,text,token,annotation
0,package main,"['package', 'main']","['KEYWORD', 'IDENTIFIER']"
1,import (,"['import', '(']","['KEYWORD', 'OPERATOR']"
2,"    ""crypto""","['""crypto""']",['STRING_LITERAL']
3,"    ""crypto/rand""","['""crypto/rand""']",['STRING_LITERAL']
4,"    ""crypto/rsa""","['""crypto/rsa""']",['STRING_LITERAL']
5,"    ""crypto/sha256""","['""crypto/sha256""']",['STRING_LITERAL']
6,"    ""crypto/x509""","['""crypto/x509""']",['STRING_LITERAL']
7,"    ""encoding/base64""","['""encoding/base64""']",['STRING_LITERAL']
8,"    ""encoding/pem""","['""encoding/pem""']",['STRING_LITERAL']
9,"    ""errors""","['""errors""']",['STRING_LITERAL']
10,"    ""fmt""","['""fmt""']",['STRING_LITERAL']
11,"    ""io/ioutil""","['""io/ioutil""']",['STRING_LITERAL']
12,),[')'],['OPERATOR']
13,func main() {,"['func', 'main', '()', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'OPERATOR']"
14,"    signer, err := loadPrivateKey(""private.pem"");","['signer', ',', 'err', ':=', 'loadPrivateKey', '(', '""private.pem""', ');']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'STRING_LITERAL', 'OPERATOR']"
15,    if err != nil {,"['if', 'err', '!=', 'nil', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
16,"        fmt.Errorf(""signer is damaged: %v"", err)","['fmt', '.', 'Errorf', '(', '""signer is damaged: %v""', ',', 'err', ')']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'STRING_LITERAL', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
17,    },['}'],['OPERATOR']
18,"    toSign := ""date: Thu, 05 Jan 2012 21:31:40 GMT"";","['toSign', ':=', '""date: Thu, 05 Jan 2012 21:31:40 GMT""', ';']","['IDENTIFIER', 'OPERATOR', 'STRING_LITERAL', 'OPERATOR']"
19,"    signed, err := signer.Sign([]byte(toSign))","['signed', ',', 'err', ':=', 'signer', '.', 'Sign', '([]', 'byte', '(', 'toSign', '))']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
20,    if err != nil {,"['if', 'err', '!=', 'nil', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
21,"        fmt.Errorf(""could not sign request: %v"", err)","['fmt', '.', 'Errorf', '(', '""could not sign request: %v""', ',', 'err', ')']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'STRING_LITERAL', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
22,    },['}'],['OPERATOR']
23,    sig := base64.StdEncoding.EncodeToString(signed),"['sig', ':=', 'base64', '.', 'StdEncoding', '.', 'EncodeToString', '(', 'signed', ')']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
24,"    fmt.Printf(""Encoded: %v\n"", sig)","['fmt', '.', 'Printf', '(', '""Encoded: %v\\n""', ',', 'sig', ')']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'STRING_LITERAL', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
25,"    parser, perr := loadPublicKey(""public.pem"");","['parser', ',', 'perr', ':=', 'loadPublicKey', '(', '""public.pem""', ');']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'STRING_LITERAL', 'OPERATOR']"
26,    if perr != nil {,"['if', 'perr', '!=', 'nil', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
27,"        fmt.Errorf(""could not sign request: %v"", err)","['fmt', '.', 'Errorf', '(', '""could not sign request: %v""', ',', 'err', ')']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'STRING_LITERAL', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
28,    },['}'],['OPERATOR']
29,"    unsigned, err := parser.Unsign(signed);","['unsigned', ',', 'err', ':=', 'parser', '.', 'Unsign', '(', 'signed', ');']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
30,     if err != nil {,"['if', 'err', '!=', 'nil', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
31,"        fmt.Errorf(""could not sign request: %v"", err)","['fmt', '.', 'Errorf', '(', '""could not sign request: %v""', ',', 'err', ')']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'STRING_LITERAL', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
32,    },['}'],['OPERATOR']
33,"    fmt.Printf(""Decrypted: %v\n"", base64.StdEncoding.EncodeToString(unsigned))    ","['fmt', '.', 'Printf', '(', '""Decrypted: %v\\n""', ',', 'base64', '.', 'StdEncoding', '.', 'EncodeToString', '(', 'unsigned', '))']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'STRING_LITERAL', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
34,},['}'],['OPERATOR']
35,// loadPrivateKey loads an parses a PEM encoded private key file.,['// loadPrivateKey loads an parses a PEM encoded private key file.'],"['COMMENT', 'NN', 'VBZ', 'DT', 'VBZ', 'DT', 'NNP', 'VBD', 'JJ', 'NN', 'NN', '.']"
36,"func loadPublicKey(path string) (Unsigner, error) {","['func', 'loadPublicKey', '(', 'path', 'string', ')', '(', 'Unsigner', ',', 'error', ')', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'IDENTIFIER', 'OPERATOR', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'OPERATOR']"
37,"        data, err := ioutil.ReadFile(path)","['data', ',', 'err', ':=', 'ioutil', '.', 'ReadFile', '(', 'path', ')']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
38,        if err != nil {,"['if', 'err', '!=', 'nil', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
39,"                return nil, err","['return', 'nil', ',', 'err']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER']"
40,        },['}'],['OPERATOR']
41,        return parsePublicKey(data),"['return', 'parsePublicKey', '(', 'data', ')']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
42,},['}'],['OPERATOR']
43,// parsePublicKey parses a PEM encoded private key.,['// parsePublicKey parses a PEM encoded private key.'],"['COMMENT', 'NN', 'VBZ', 'DT', 'NNP', 'VBD', 'JJ', 'NN', '.']"
44,"func parsePublicKey(pemBytes []byte) (Unsigner, error) {","['func', 'parsePublicKey', '(', 'pemBytes', '[]', 'byte', ')', '(', 'Unsigner', ',', 'error', ')', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'OPERATOR']"
45,"        block, _ := pem.Decode(pemBytes)","['block', ',', '_', ':=', 'pem', '.', 'Decode', '(', 'pemBytes', ')']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
46,        if block == nil {,"['if', 'block', '==', 'nil', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
47,"                return nil, errors.New(""ssh: no key found"")","['return', 'nil', ',', 'errors', '.', 'New', '(', '""ssh: no key found""', ')']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'STRING_LITERAL', 'OPERATOR']"
48,        },['}'],['OPERATOR']
49,        var rawkey interface{},"['var', 'rawkey', 'interface', '{}']","['KEYWORD', 'IDENTIFIER', 'KEYWORD', 'OPERATOR']"
50,        switch block.Type {,"['switch', 'block', '.', 'Type', '{']","['IDENTIFIER', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
51,"        case ""PUBLIC KEY"":","['case', '""PUBLIC KEY""', ':']","['KEYWORD', 'STRING_LITERAL', 'OPERATOR']"
52,"                rsa, err := x509.ParsePKIXPublicKey(block.Bytes)","['rsa', ',', 'err', ':=', 'x509', '.', 'ParsePKIXPublicKey', '(', 'block', '.', 'Bytes', ')']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
53,                if err != nil {,"['if', 'err', '!=', 'nil', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
54,"                        return nil, err","['return', 'nil', ',', 'err']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER']"
55,                },['}'],['OPERATOR']
56,                rawkey = rsa,"['rawkey', '=', 'rsa']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER']"
57,        default:,"['default', ':']","['KEYWORD', 'OPERATOR']"
58,"                return nil, fmt.Errorf(""ssh: unsupported key type %q"", block.Type)","['return', 'nil', ',', 'fmt', '.', 'Errorf', '(', '""ssh: unsupported key type %q""', ',', 'block', '.', 'Type', ')']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'STRING_LITERAL', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
59,        },['}'],['OPERATOR']
60,        return newUnsignerFromKey(rawkey),"['return', 'newUnsignerFromKey', '(', 'rawkey', ')']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
61,},['}'],['OPERATOR']
62,// loadPrivateKey loads an parses a PEM encoded private key file.,['// loadPrivateKey loads an parses a PEM encoded private key file.'],"['COMMENT', 'NN', 'VBZ', 'DT', 'VBZ', 'DT', 'NNP', 'VBD', 'JJ', 'NN', 'NN', '.']"
63,"func loadPrivateKey(path string) (Signer, error) {","['func', 'loadPrivateKey', '(', 'path', 'string', ')', '(', 'Signer', ',', 'error', ')', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'IDENTIFIER', 'OPERATOR', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'OPERATOR']"
64,"        data, err := ioutil.ReadFile(path)","['data', ',', 'err', ':=', 'ioutil', '.', 'ReadFile', '(', 'path', ')']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
65,        if err != nil {,"['if', 'err', '!=', 'nil', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
66,"                return nil, err","['return', 'nil', ',', 'err']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER']"
67,        },['}'],['OPERATOR']
68,        return parsePrivateKey(data),"['return', 'parsePrivateKey', '(', 'data', ')']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
69,},['}'],['OPERATOR']
70,// parsePublicKey parses a PEM encoded private key.,['// parsePublicKey parses a PEM encoded private key.'],"['COMMENT', 'NN', 'VBZ', 'DT', 'NNP', 'VBD', 'JJ', 'NN', '.']"
71,"func parsePrivateKey(pemBytes []byte) (Signer, error) {","['func', 'parsePrivateKey', '(', 'pemBytes', '[]', 'byte', ')', '(', 'Signer', ',', 'error', ')', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'OPERATOR']"
72,"        block, _ := pem.Decode(pemBytes)","['block', ',', '_', ':=', 'pem', '.', 'Decode', '(', 'pemBytes', ')']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
73,        if block == nil {,"['if', 'block', '==', 'nil', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
74,"                return nil, errors.New(""ssh: no key found"")","['return', 'nil', ',', 'errors', '.', 'New', '(', '""ssh: no key found""', ')']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'STRING_LITERAL', 'OPERATOR']"
75,        },['}'],['OPERATOR']
76,        var rawkey interface{},"['var', 'rawkey', 'interface', '{}']","['KEYWORD', 'IDENTIFIER', 'KEYWORD', 'OPERATOR']"
77,        switch block.Type {,"['switch', 'block', '.', 'Type', '{']","['IDENTIFIER', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
78,"        case ""RSA PRIVATE KEY"":","['case', '""RSA PRIVATE KEY""', ':']","['KEYWORD', 'STRING_LITERAL', 'OPERATOR']"
79,"                rsa, err := x509.ParsePKCS1PrivateKey(block.Bytes)","['rsa', ',', 'err', ':=', 'x509', '.', 'ParsePKCS1PrivateKey', '(', 'block', '.', 'Bytes', ')']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
80,                if err != nil {,"['if', 'err', '!=', 'nil', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
81,"                        return nil, err","['return', 'nil', ',', 'err']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER']"
82,                },['}'],['OPERATOR']
83,                rawkey = rsa,"['rawkey', '=', 'rsa']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER']"
84,        default:,"['default', ':']","['KEYWORD', 'OPERATOR']"
85,"                return nil, fmt.Errorf(""ssh: unsupported key type %q"", block.Type)","['return', 'nil', ',', 'fmt', '.', 'Errorf', '(', '""ssh: unsupported key type %q""', ',', 'block', '.', 'Type', ')']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'STRING_LITERAL', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
86,        },['}'],['OPERATOR']
87,        return newSignerFromKey(rawkey),"['return', 'newSignerFromKey', '(', 'rawkey', ')']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
88,},['}'],['OPERATOR']
89,// A Signer is can create signatures that verify against a public key.,['// A Signer is can create signatures that verify against a public key.'],"['COMMENT', 'DT', 'NNP', 'VBZ', 'MD', 'VB', 'NNS', 'WDT', 'VBP', 'IN', 'DT', 'JJ', 'NN', '.']"
90,type Signer interface {,"['type', 'Signer', 'interface', '{']","['KEYWORD', 'IDENTIFIER', 'KEYWORD', 'OPERATOR']"
91,        // Sign returns raw signature for the given data. This method,['// Sign returns raw signature for the given data. This method'],"['COMMENT', 'NNP', 'VBZ', 'JJ', 'NN', 'IN', 'DT', 'VBN', 'NNS', '.', 'DT', 'NN']"
92,        // will apply the hash specified for the keytype to the data.,['// will apply the hash specified for the keytype to the data.'],"['COMMENT', 'MD', 'VB', 'DT', 'NN', 'VBD', 'IN', 'DT', 'NN', 'TO', 'DT', 'NNS', '.']"
93,"        Sign(data []byte) ([]byte, error)","['Sign', '(', 'data', '[]', 'byte', ')', '([]', 'byte', ',', 'error', ')']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
94,},['}'],['OPERATOR']
95,// A Signer is can create signatures that verify against a public key.,['// A Signer is can create signatures that verify against a public key.'],"['COMMENT', 'DT', 'NNP', 'VBZ', 'MD', 'VB', 'NNS', 'WDT', 'VBP', 'IN', 'DT', 'JJ', 'NN', '.']"
96,type Unsigner interface {,"['type', 'Unsigner', 'interface', '{']","['KEYWORD', 'IDENTIFIER', 'KEYWORD', 'OPERATOR']"
97,        // Sign returns raw signature for the given data. This method,['// Sign returns raw signature for the given data. This method'],"['COMMENT', 'NNP', 'VBZ', 'JJ', 'NN', 'IN', 'DT', 'VBN', 'NNS', '.', 'DT', 'NN']"
98,        // will apply the hash specified for the keytype to the data.,['// will apply the hash specified for the keytype to the data.'],"['COMMENT', 'MD', 'VB', 'DT', 'NN', 'VBD', 'IN', 'DT', 'NN', 'TO', 'DT', 'NNS', '.']"
99,"        Unsign(data []byte) ([]byte, error)","['Unsign', '(', 'data', '[]', 'byte', ')', '([]', 'byte', ',', 'error', ')']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
100,},['}'],['OPERATOR']
101,"func newSignerFromKey(k interface{}) (Signer, error) {","['func', 'newSignerFromKey', '(', 'k', 'interface', '{})', '(', 'Signer', ',', 'error', ')', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'KEYWORD', 'OPERATOR', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'OPERATOR']"
102,        var sshKey Signer,"['var', 'sshKey', 'Signer']","['KEYWORD', 'IDENTIFIER', 'IDENTIFIER']"
103,        switch t := k.(type) {,"['switch', 't', ':=', 'k', '.(', 'type', ')', '{']","['IDENTIFIER', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'KEYWORD', 'OPERATOR', 'OPERATOR']"
104,        case *rsa.PrivateKey:,"['case', '*', 'rsa', '.', 'PrivateKey', ':']","['KEYWORD', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
105,                sshKey = &rsaPrivateKey{t},"['sshKey', '=', '&', 'rsaPrivateKey', '{', 't', '}']","['IDENTIFIER', 'OPERATOR', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
106,        default: ,"['default', ':']","['KEYWORD', 'OPERATOR']"
107,"                return nil, fmt.Errorf(""ssh: unsupported key type %T"", k)","['return', 'nil', ',', 'fmt', '.', 'Errorf', '(', '""ssh: unsupported key type %T""', ',', 'k', ')']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'STRING_LITERAL', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
108,        },['}'],['OPERATOR']
109,"        return sshKey, nil","['return', 'sshKey', ',', 'nil']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER']"
110,},['}'],['OPERATOR']
111,"func newUnsignerFromKey(k interface{}) (Unsigner, error) {","['func', 'newUnsignerFromKey', '(', 'k', 'interface', '{})', '(', 'Unsigner', ',', 'error', ')', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'KEYWORD', 'OPERATOR', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'OPERATOR']"
112,        var sshKey Unsigner,"['var', 'sshKey', 'Unsigner']","['KEYWORD', 'IDENTIFIER', 'IDENTIFIER']"
113,        switch t := k.(type) {,"['switch', 't', ':=', 'k', '.(', 'type', ')', '{']","['IDENTIFIER', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'KEYWORD', 'OPERATOR', 'OPERATOR']"
114,        case *rsa.PublicKey:,"['case', '*', 'rsa', '.', 'PublicKey', ':']","['KEYWORD', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
115,                sshKey = &rsaPublicKey{t},"['sshKey', '=', '&', 'rsaPublicKey', '{', 't', '}']","['IDENTIFIER', 'OPERATOR', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
116,        default:,"['default', ':']","['KEYWORD', 'OPERATOR']"
117,"                return nil, fmt.Errorf(""ssh: unsupported key type %T"", k)","['return', 'nil', ',', 'fmt', '.', 'Errorf', '(', '""ssh: unsupported key type %T""', ',', 'k', ')']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'STRING_LITERAL', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
118,        },['}'],['OPERATOR']
119,"        return sshKey, nil","['return', 'sshKey', ',', 'nil']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER']"
120,},['}'],['OPERATOR']
121,type rsaPublicKey struct {,"['type', 'rsaPublicKey', 'struct', '{']","['KEYWORD', 'IDENTIFIER', 'KEYWORD', 'OPERATOR']"
122,    *rsa.PublicKey,"['*', 'rsa', '.', 'PublicKey']","['OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER']"
123,},['}'],['OPERATOR']
124,type rsaPrivateKey struct {,"['type', 'rsaPrivateKey', 'struct', '{']","['KEYWORD', 'IDENTIFIER', 'KEYWORD', 'OPERATOR']"
125,        *rsa.PrivateKey,"['*', 'rsa', '.', 'PrivateKey']","['OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER']"
126,},['}'],['OPERATOR']
127,// Sign signs data with rsa-sha256,['// Sign signs data with rsa-sha256'],"['COMMENT', 'NNP', 'NNS', 'NNS', 'IN', 'NN']"
128,"func (r *rsaPrivateKey) Sign(data []byte) ([]byte, error) {","['func', '(', 'r', '*', 'rsaPrivateKey', ')', 'Sign', '(', 'data', '[]', 'byte', ')', '([]', 'byte', ',', 'error', ')', '{']","['KEYWORD', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'OPERATOR']"
129,        h := sha256.New(),"['h', ':=', 'sha256', '.', 'New', '()']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
130,        h.Write(data),"['h', '.', 'Write', '(', 'data', ')']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
131,        d := h.Sum(nil),"['d', ':=', 'h', '.', 'Sum', '(', 'nil', ')']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
132,"        return rsa.SignPKCS1v15(rand.Reader, r.PrivateKey, crypto.SHA256, d)","['return', 'rsa', '.', 'SignPKCS1v15', '(', 'rand', '.', 'Reader', ',', 'r', '.', 'PrivateKey', ',', 'crypto', '.', 'SHA256', ',', 'd', ')']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
133,},['}'],['OPERATOR']
134,// Unsign encrypts data with rsa-sha256,['// Unsign encrypts data with rsa-sha256'],"['COMMENT', 'NNP', 'VBZ', 'NNS', 'IN', 'NN']"
135,"func (r *rsaPublicKey) Unsign(message []byte) ([]byte, error) {  ","['func', '(', 'r', '*', 'rsaPublicKey', ')', 'Unsign', '(', 'message', '[]', 'byte', ')', '([]', 'byte', ',', 'error', ')', '{']","['KEYWORD', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'OPERATOR']"
136,"        return rsa.EncryptPKCS1v15(rand.Reader, r.PublicKey, message)        ","['return', 'rsa', '.', 'EncryptPKCS1v15', '(', 'rand', '.', 'Reader', ',', 'r', '.', 'PublicKey', ',', 'message', ')']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
137,},['}'],['OPERATOR']
