,text,token,annotation
0,// Copyright 2012 Stefan Nilsson,['// Copyright 2012 Stefan Nilsson'],"['COMMENT', 'JJ', 'CD', 'NNP', 'NNP']"
1,//,['//'],['COMMENT']
2,"// Licensed under the Apache License, Version 2.0 (the ""License"");","['// Licensed under the Apache License, Version 2.0 (the ""License"");']","['COMMENT', 'VBN', 'IN', 'DT', 'NNP', 'NNP', ',', 'NNP', 'CD', '(', 'DT', '``', 'NNP', ""''"", ')', ':']"
3,// you may not use this file except in compliance with the License.,['// you may not use this file except in compliance with the License.'],"['COMMENT', 'PRP', 'MD', 'RB', 'VB', 'DT', 'NN', 'IN', 'IN', 'NN', 'IN', 'DT', 'NNP', '.']"
4,// You may obtain a copy of the License at,['// You may obtain a copy of the License at'],"['COMMENT', 'PRP', 'MD', 'VB', 'DT', 'NN', 'IN', 'DT', 'NNP', 'IN']"
5,//,['//'],['COMMENT']
6,//     http://www.apache.org/licenses/LICENSE-2.0,['//     http://www.apache.org/licenses/LICENSE-2.0'],"['COMMENT', 'NN', ':', 'NN']"
7,//,['//'],['COMMENT']
8,"// Unless required by applicable law or agreed to in writing, software","['// Unless required by applicable law or agreed to in writing, software']","['COMMENT', 'IN', 'VBN', 'IN', 'JJ', 'NN', 'CC', 'VBN', 'TO', 'IN', 'NN', ',', 'NN']"
9,"// distributed under the License is distributed on an ""AS IS"" BASIS,","['// distributed under the License is distributed on an ""AS IS"" BASIS,']","['COMMENT', 'VBN', 'IN', 'DT', 'NNP', 'VBZ', 'VBN', 'IN', 'DT', '``', 'NNP', 'NNP', ""''"", 'NNP', ',']"
10,"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","['// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.']","['COMMENT', 'JJ', 'NNP', 'NNP', 'NNP', 'IN', 'NNP', 'NNP', ',', 'RB', 'NN', 'CC', 'VBN', '.']"
11,// See the License for the specific language governing permissions and,['// See the License for the specific language governing permissions and'],"['COMMENT', 'VB', 'DT', 'NNP', 'IN', 'DT', 'JJ', 'NN', 'NN', 'NNS', 'CC']"
12,// limitations under the License.,['// limitations under the License.'],"['COMMENT', 'NNS', 'IN', 'DT', 'NNP', '.']"
13,// Package prio provides a priority queue.,['// Package prio provides a priority queue.'],"['COMMENT', 'NN', 'NN', 'VBZ', 'DT', 'NN', 'NN', '.']"
14,// The queue can hold elements that implement the two methods of prio.Interface.,['// The queue can hold elements that implement the two methods of prio.Interface.'],"['COMMENT', 'DT', 'NN', 'MD', 'VB', 'NNS', 'WDT', 'VBP', 'DT', 'CD', 'NNS', 'IN', 'NN', '.']"
15,package prio,"['package', 'prio']","['KEYWORD', 'IDENTIFIER']"
16,/*,['*'],['OPERATOR']
17,A type that implements prio.Interface can be inserted into a priority queue.,"['A', 'type', 'that', 'implements', 'prio', '.', 'Interface', 'can', 'be', 'inserted', 'into', 'a', 'priority', 'queue', '.']","['IDENTIFIER', 'KEYWORD', 'IDENTIFIER', 'IDENTIFIER', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'IDENTIFIER', 'IDENTIFIER', 'IDENTIFIER', 'IDENTIFIER', 'IDENTIFIER', 'IDENTIFIER', 'IDENTIFIER', 'OPERATOR']"
18,The simplest use case looks like this:,"['The', 'simplest', 'use', 'case', 'looks', 'like', 'this', ':']","['IDENTIFIER', 'IDENTIFIER', 'IDENTIFIER', 'KEYWORD', 'IDENTIFIER', 'IDENTIFIER', 'IDENTIFIER', 'OPERATOR']"
19,        type myInt int,"['type', 'myInt', 'int']","['KEYWORD', 'IDENTIFIER', 'IDENTIFIER']"
20,        func (x myInt) Less(y prio.Interface) bool { return x < y.(myInt) },"['func', '(', 'x', 'myInt', ')', 'Less', '(', 'y', 'prio', '.', 'Interface', ')', 'bool', '{', 'return', 'x', '<', 'y', '.(', 'myInt', ')', '}']","['KEYWORD', 'OPERATOR', 'IDENTIFIER', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'OPERATOR']"
21,        func (x myInt) Index(i int)                {},"['func', '(', 'x', 'myInt', ')', 'Index', '(', 'i', 'int', ')', '{}']","['KEYWORD', 'OPERATOR', 'IDENTIFIER', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'IDENTIFIER', 'OPERATOR', 'OPERATOR']"
22,To use the Remove method you need to keep track of the index of elements,"['To', 'use', 'the', 'Remove', 'method', 'you', 'need', 'to', 'keep', 'track', 'of', 'the', 'index', 'of', 'elements']","['IDENTIFIER', 'IDENTIFIER', 'IDENTIFIER', 'IDENTIFIER', 'IDENTIFIER', 'IDENTIFIER', 'IDENTIFIER', 'IDENTIFIER', 'IDENTIFIER', 'IDENTIFIER', 'IDENTIFIER', 'IDENTIFIER', 'IDENTIFIER', 'IDENTIFIER', 'IDENTIFIER']"
23,"in the heap, e.g. like this:","['in', 'the', 'heap', ',', 'e', '.', 'g', '.', 'like', 'this', ':']","['IDENTIFIER', 'IDENTIFIER', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'IDENTIFIER', 'OPERATOR']"
24,        type myType struct {,"['type', 'myType', 'struct', '{']","['KEYWORD', 'IDENTIFIER', 'KEYWORD', 'OPERATOR']"
25,                value int,"['value', 'int']","['IDENTIFIER', 'IDENTIFIER']"
26,                index int // index in heap,"['index', 'int', '// index in heap']","['IDENTIFIER', 'IDENTIFIER', 'COMMENT', 'NN', 'IN', 'NN']"
27,        },['}'],['OPERATOR']
28,        func (x *myType) Less(y prio.Interface) bool { return x.value < y.(*myType).value },"['func', '(', 'x', '*', 'myType', ')', 'Less', '(', 'y', 'prio', '.', 'Interface', ')', 'bool', '{', 'return', 'x', '.', 'value', '<', 'y', '.(*', 'myType', ').', 'value', '}']","['KEYWORD', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
29,        func (x *myType) Index(i int)                { x.index = i },"['func', '(', 'x', '*', 'myType', ')', 'Index', '(', 'i', 'int', ')', '{', 'x', '.', 'index', '=', 'i', '}']","['KEYWORD', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'IDENTIFIER', 'OPERATOR', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
30,*/,['*'],['OPERATOR']
31,type Interface interface {,"['type', 'Interface', 'interface', '{']","['KEYWORD', 'IDENTIFIER', 'KEYWORD', 'OPERATOR']"
32,        // Less returns whether this element should sort before element x.,['// Less returns whether this element should sort before element x.'],"['COMMENT', 'NNP', 'VBZ', 'IN', 'DT', 'NN', 'MD', 'VB', 'IN', 'JJ', 'NN', '.']"
33,        Less(x Interface) bool,"['Less', '(', 'x', 'Interface', ')', 'bool']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER']"
34,        // Index is called by the priority queue when this element is moved to index i.,['// Index is called by the priority queue when this element is moved to index i.'],"['COMMENT', 'NN', 'VBZ', 'VBN', 'IN', 'DT', 'NN', 'NN', 'WRB', 'DT', 'NN', 'VBZ', 'VBN', 'TO', 'NN', 'NN', '.']"
35,        Index(i int),"['Index', '(', 'i', 'int', ')']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'IDENTIFIER', 'OPERATOR']"
36,},['}'],['OPERATOR']
37,// Queue represents a priority queue.,['// Queue represents a priority queue.'],"['COMMENT', 'NNP', 'VBZ', 'DT', 'NN', 'NN', '.']"
38,// The zero value for Queue is an empty queue ready to use.,['// The zero value for Queue is an empty queue ready to use.'],"['COMMENT', 'DT', 'CD', 'NN', 'IN', 'NNP', 'VBZ', 'DT', 'JJ', 'NN', 'NN', 'TO', 'VB', '.']"
39,type Queue struct {,"['type', 'Queue', 'struct', '{']","['KEYWORD', 'IDENTIFIER', 'KEYWORD', 'OPERATOR']"
40,        h []Interface,"['h', '[]', 'Interface']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER']"
41,},['}'],['OPERATOR']
42,// New returns an initialized priority queue with the given elements.,['// New returns an initialized priority queue with the given elements.'],"['COMMENT', 'NNP', 'NNS', 'DT', 'JJ', 'NN', 'NN', 'IN', 'DT', 'VBN', 'NNS', '.']"
43,// A call of the form New(x...) uses the underlying array of x to implement,['// A call of the form New(x...) uses the underlying array of x to implement'],"['COMMENT', 'DT', 'NN', 'IN', 'DT', 'NN', 'NNP', '(', 'NNP', ':', ')', 'VBZ', 'DT', 'JJ', 'NN', 'IN', 'NN', 'TO', 'VB']"
44,// the queue and hence might change the elements of x.,['// the queue and hence might change the elements of x.'],"['COMMENT', 'DT', 'NN', 'CC', 'NN', 'MD', 'VB', 'DT', 'NNS', 'IN', 'NN', '.']"
45,"// The complexity is O(n), where n = len(x).","['// The complexity is O(n), where n = len(x).']","['COMMENT', 'DT', 'NN', 'VBZ', 'NNP', '(', 'NN', ')', ',', 'WRB', 'JJ', 'NN', 'NN', '(', 'NNP', ')', '.']"
46,func New(x ...Interface) Queue {,"['func', 'New', '(', 'x', '...', 'Interface', ')', 'Queue', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
47,        q := Queue{x},"['q', ':=', 'Queue', '{', 'x', '}']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
48,        heapify(q.h),"['heapify', '(', 'q', '.', 'h', ')']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
49,        return q,"['return', 'q']","['KEYWORD', 'IDENTIFIER']"
50,},['}'],['OPERATOR']
51,// Push pushes the element x onto the queue.,['// Push pushes the element x onto the queue.'],"['COMMENT', 'NN', 'VBZ', 'DT', 'NN', 'NNP', 'IN', 'DT', 'NN', '.']"
52,// The complexity is O(log(n)) where n = q.Len().,['// The complexity is O(log(n)) where n = q.Len().'],"['COMMENT', 'DT', 'NN', 'VBZ', 'NNP', '(', 'NN', '(', 'JJ', ')', ')', 'WRB', 'JJ', 'NN', 'NN', '(', ')', '.']"
53,func (q *Queue) Push(x Interface) {,"['func', '(', 'q', '*', 'Queue', ')', 'Push', '(', 'x', 'Interface', ')', '{']","['KEYWORD', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'IDENTIFIER', 'OPERATOR', 'OPERATOR']"
54,        n := len(q.h),"['n', ':=', 'len', '(', 'q', '.', 'h', ')']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
55,"        q.h = append(q.h, x)","['q', '.', 'h', '=', 'append', '(', 'q', '.', 'h', ',', 'x', ')']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
56,"        up(q.h, n) // x.Index(n) is done by up.","['up', '(', 'q', '.', 'h', ',', 'n', ')', '// x.Index(n) is done by up.']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'COMMENT', 'NN', '(', 'JJ', ')', 'VBZ', 'VBN', 'IN', 'IN', '.']"
57,},['}'],['OPERATOR']
58,// Pop removes a minimum element (according to Less) from the queue and returns it.,['// Pop removes a minimum element (according to Less) from the queue and returns it.'],"['COMMENT', 'NNP', 'VBZ', 'DT', 'JJ', 'NN', '(', 'VBG', 'TO', 'NNP', ')', 'IN', 'DT', 'NN', 'CC', 'VBZ', 'PRP', '.']"
59,"// The complexity is O(log(n)), where n = q.Len().","['// The complexity is O(log(n)), where n = q.Len().']","['COMMENT', 'DT', 'NN', 'VBZ', 'NNP', '(', 'NN', '(', 'JJ', ')', ')', ',', 'WRB', 'JJ', 'NN', 'NN', '(', ')', '.']"
60,func (q *Queue) Pop() Interface {,"['func', '(', 'q', '*', 'Queue', ')', 'Pop', '()', 'Interface', '{']","['KEYWORD', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
61,        h := q.h,"['h', ':=', 'q', '.', 'h']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER']"
62,        n := len(h) - 1,"['n', ':=', 'len', '(', 'h', ')', '-', '1']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'OPERATOR', 'DECIMAL_LITERAL']"
63,        x := h[0],"['x', ':=', 'h', '[', '0', ']']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'DECIMAL_LITERAL', 'OPERATOR']"
64,"        h[0], h[n] = h[n], nil","['h', '[', '0', '],', 'h', '[', 'n', ']', '=', 'h', '[', 'n', '],', 'nil']","['IDENTIFIER', 'OPERATOR', 'DECIMAL_LITERAL', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER']"
65,        h = h[:n],"['h', '=', 'h', '[:', 'n', ']']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
66,        if n > 0 {,"['if', 'n', '>', '0', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'DECIMAL_LITERAL', 'OPERATOR']"
67,"                down(h, 0) // h[0].Index(0) is done by down.","['down', '(', 'h', ',', '0', ')', '// h[0].Index(0) is done by down.']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'DECIMAL_LITERAL', 'OPERATOR', 'COMMENT', 'NN', 'VBZ', 'CD', 'NN', 'NN', '(', 'CD', ')', 'VBZ', 'VBN', 'IN', 'RB', '.']"
68,        },['}'],['OPERATOR']
69,        q.h = h,"['q', '.', 'h', '=', 'h']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER']"
70,        x.Index(-1) // for safety,"['x', '.', 'Index', '(-', '1', ')', '// for safety']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'DECIMAL_LITERAL', 'OPERATOR', 'COMMENT', 'IN', 'NN']"
71,        return x,"['return', 'x']","['KEYWORD', 'IDENTIFIER']"
72,},['}'],['OPERATOR']
73,"// Peek returns, but does not remove, a minimum element (according to Less) of the queue.","['// Peek returns, but does not remove, a minimum element (according to Less) of the queue.']","['COMMENT', 'NNP', 'NNS', ',', 'CC', 'VBZ', 'RB', 'VB', ',', 'DT', 'JJ', 'NN', '(', 'VBG', 'TO', 'NNP', ')', 'IN', 'DT', 'NN', '.']"
74,func (q *Queue) Peek() Interface {,"['func', '(', 'q', '*', 'Queue', ')', 'Peek', '()', 'Interface', '{']","['KEYWORD', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
75,        return q.h[0],"['return', 'q', '.', 'h', '[', '0', ']']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'DECIMAL_LITERAL', 'OPERATOR']"
76,},['}'],['OPERATOR']
77,// Remove removes the element at index i from the queue and returns it.,['// Remove removes the element at index i from the queue and returns it.'],"['COMMENT', 'NNP', 'VBZ', 'DT', 'NN', 'IN', 'NN', 'NN', 'IN', 'DT', 'NN', 'CC', 'VBZ', 'PRP', '.']"
78,"// The complexity is O(log(n)), where n = q.Len().","['// The complexity is O(log(n)), where n = q.Len().']","['COMMENT', 'DT', 'NN', 'VBZ', 'NNP', '(', 'NN', '(', 'JJ', ')', ')', ',', 'WRB', 'JJ', 'NN', 'NN', '(', ')', '.']"
79,func (q *Queue) Remove(i int) Interface {,"['func', '(', 'q', '*', 'Queue', ')', 'Remove', '(', 'i', 'int', ')', 'Interface', '{']","['KEYWORD', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
80,        h := q.h,"['h', ':=', 'q', '.', 'h']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER']"
81,        n := len(h) - 1,"['n', ':=', 'len', '(', 'h', ')', '-', '1']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'OPERATOR', 'DECIMAL_LITERAL']"
82,        x := h[i],"['x', ':=', 'h', '[', 'i', ']']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
83,"        h[i], h[n] = h[n], nil","['h', '[', 'i', '],', 'h', '[', 'n', ']', '=', 'h', '[', 'n', '],', 'nil']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER']"
84,        h = h[:n],"['h', '=', 'h', '[:', 'n', ']']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
85,        if i < n {,"['if', 'i', '<', 'n', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
86,"                down(h, i) // h[i].Index(i) is done by down.","['down', '(', 'h', ',', 'i', ')', '// h[i].Index(i) is done by down.']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'COMMENT', 'NN', 'NN', 'NN', 'VBP', 'NN', '(', 'NN', ')', 'VBZ', 'VBN', 'IN', 'RB', '.']"
87,"                up(h, i)","['up', '(', 'h', ',', 'i', ')']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
88,        },['}'],['OPERATOR']
89,        q.h = h,"['q', '.', 'h', '=', 'h']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER']"
90,        x.Index(-1) // for safety,"['x', '.', 'Index', '(-', '1', ')', '// for safety']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'DECIMAL_LITERAL', 'OPERATOR', 'COMMENT', 'IN', 'NN']"
91,        return x,"['return', 'x']","['KEYWORD', 'IDENTIFIER']"
92,},['}'],['OPERATOR']
93,// Len returns the number of elements in the queue.,['// Len returns the number of elements in the queue.'],"['COMMENT', 'NNP', 'VBZ', 'DT', 'NN', 'IN', 'NNS', 'IN', 'DT', 'NN', '.']"
94,func (q *Queue) Len() int {,"['func', '(', 'q', '*', 'Queue', ')', 'Len', '()', 'int', '{']","['KEYWORD', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
95,        return len(q.h),"['return', 'len', '(', 'q', '.', 'h', ')']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
96,},['}'],['OPERATOR']
97,// Establishes the heap invariant in O(n) time.,['// Establishes the heap invariant in O(n) time.'],"['COMMENT', 'NNS', 'DT', 'NN', 'NN', 'IN', 'NNP', '(', 'RB', ')', 'NN', '.']"
98,func heapify(h []Interface) {,"['func', 'heapify', '(', 'h', '[]', 'Interface', ')', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'OPERATOR']"
99,        n := len(h),"['n', ':=', 'len', '(', 'h', ')']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
100,        for i := n - 1; i >= n/2; i-- {,"['for', 'i', ':=', 'n', '-', '1', ';', 'i', '>=', 'n', '2', ';', 'i', '--', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'DECIMAL_LITERAL', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'DECIMAL_LITERAL', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'OPERATOR']"
101,                h[i].Index(i),"['h', '[', 'i', '].', 'Index', '(', 'i', ')']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
102,        },['}'],['OPERATOR']
103,        for i := n/2 - 1; i >= 0; i-- { // h[i].Index(i) is done by down.,"['for', 'i', ':=', 'n', '2', '-', '1', ';', 'i', '>=', '0', ';', 'i', '--', '{', '// h[i].Index(i) is done by down.']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'DECIMAL_LITERAL', 'OPERATOR', 'DECIMAL_LITERAL', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'DECIMAL_LITERAL', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'OPERATOR', 'COMMENT', 'NN', 'NN', 'NN', 'VBP', 'NN', '(', 'NN', ')', 'VBZ', 'VBN', 'IN', 'RB', '.']"
104,"                down(h, i)","['down', '(', 'h', ',', 'i', ')']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
105,        },['}'],['OPERATOR']
106,},['}'],['OPERATOR']
107,// Moves element at position i towards top of heap to restore invariant.,['// Moves element at position i towards top of heap to restore invariant.'],"['COMMENT', 'NNS', 'VBP', 'IN', 'NN', 'NN', 'VBP', 'NN', 'IN', 'NN', 'TO', 'VB', 'NN', '.']"
108,"func up(h []Interface, i int) {","['func', 'up', '(', 'h', '[]', 'Interface', ',', 'i', 'int', ')', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'IDENTIFIER', 'OPERATOR', 'OPERATOR']"
109,        for {,"['for', '{']","['KEYWORD', 'OPERATOR']"
110,                parent := (i - 1) / 2,"['parent', ':=', '(', 'i', '-', '1', ')', '2']","['IDENTIFIER', 'OPERATOR', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'DECIMAL_LITERAL', 'OPERATOR', 'DECIMAL_LITERAL']"
111,                if i == 0 || h[parent].Less(h[i]) {,"['if', 'i', '==', '0', '||', 'h', '[', 'parent', '].', 'Less', '(', 'h', '[', 'i', '])', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'DECIMAL_LITERAL', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'OPERATOR']"
112,                        h[i].Index(i),"['h', '[', 'i', '].', 'Index', '(', 'i', ')']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
113,                        break,['break'],['KEYWORD']
114,                },['}'],['OPERATOR']
115,"                h[parent], h[i] = h[i], h[parent]","['h', '[', 'parent', '],', 'h', '[', 'i', ']', '=', 'h', '[', 'i', '],', 'h', '[', 'parent', ']']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
116,                h[i].Index(i),"['h', '[', 'i', '].', 'Index', '(', 'i', ')']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
117,                i = parent,"['i', '=', 'parent']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER']"
118,        },['}'],['OPERATOR']
119,},['}'],['OPERATOR']
120,// Moves element at position i towards bottom of heap to restore invariant.,['// Moves element at position i towards bottom of heap to restore invariant.'],"['COMMENT', 'NNS', 'VBP', 'IN', 'NN', 'NN', 'VBP', 'NN', 'IN', 'NN', 'TO', 'VB', 'NN', '.']"
121,"func down(h []Interface, i int) {","['func', 'down', '(', 'h', '[]', 'Interface', ',', 'i', 'int', ')', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'IDENTIFIER', 'OPERATOR', 'OPERATOR']"
122,        for {,"['for', '{']","['KEYWORD', 'OPERATOR']"
123,                n := len(h),"['n', ':=', 'len', '(', 'h', ')']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
124,                left := 2*i + 1,"['left', ':=', '2', '*', 'i', '+', '1']","['IDENTIFIER', 'OPERATOR', 'DECIMAL_LITERAL', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'DECIMAL_LITERAL']"
125,                if left >= n {,"['if', 'left', '>=', 'n', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
126,                        h[i].Index(i),"['h', '[', 'i', '].', 'Index', '(', 'i', ')']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
127,                        break,['break'],['KEYWORD']
128,                },['}'],['OPERATOR']
129,                j := left,"['j', ':=', 'left']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER']"
130,                if right := left + 1; right < n && h[right].Less(h[left]) {,"['if', 'right', ':=', 'left', '+', '1', ';', 'right', '<', 'n', '&&', 'h', '[', 'right', '].', 'Less', '(', 'h', '[', 'left', '])', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'DECIMAL_LITERAL', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'OPERATOR']"
131,                        j = right,"['j', '=', 'right']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER']"
132,                },['}'],['OPERATOR']
133,                if h[i].Less(h[j]) {,"['if', 'h', '[', 'i', '].', 'Less', '(', 'h', '[', 'j', '])', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'OPERATOR']"
134,                        h[i].Index(i),"['h', '[', 'i', '].', 'Index', '(', 'i', ')']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
135,                        break,['break'],['KEYWORD']
136,                },['}'],['OPERATOR']
137,"                h[i], h[j] = h[j], h[i]","['h', '[', 'i', '],', 'h', '[', 'j', ']', '=', 'h', '[', 'j', '],', 'h', '[', 'i', ']']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
138,                h[i].Index(i),"['h', '[', 'i', '].', 'Index', '(', 'i', ')']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
139,                i = j,"['i', '=', 'j']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER']"
140,        },['}'],['OPERATOR']
141,},['}'],['OPERATOR']
