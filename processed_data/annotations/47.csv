,text,token,annotation
0,"I have a new TCP server written in Go that has 100+ clients attached to it.  Each client streams in data that needs to be looked at centrally as they are looking at radio packets over the air waves from various locations which then get analysed.  The code works but I am seeing a lot of contention and increased CPU around the locking and was after some thoughts on how to avoid the locking (if possible) or optimise around it.

As the TCP server spins up a GoRoutine for each packet received the addMessage function needs a level of synchronisation.  These packets also get analysed in another function later on that does a RLock() on the map.

It is the cullMessages() function that gets called once per second that really gets caught up in itself and can really slow down, sometimes taking 2-3 seconds to run which compounds the issue as the next 2-3 operations are queued waiting to unlock and run straight away!

Any ideas/thoughts would be appreciated!

","['I', 'have', 'a', 'new', 'TCP', 'server', 'written', 'in', 'Go', 'that', 'has', '100+', 'clients', 'attached', 'to', 'it.', 'Each', 'client', 'streams', 'in', 'data', 'that', 'needs', 'to', 'be', 'looked', 'at', 'centrally', 'as', 'they', 'are', 'looking', 'at', 'radio', 'packets', 'over', 'the', 'air', 'waves', 'from', 'various', 'locations', 'which', 'then', 'get', 'analysed.', 'The', 'code', 'works', 'but', 'I', 'am', 'seeing', 'a', 'lot', 'of', 'contention', 'and', 'increased', 'CPU', 'around', 'the', 'locking', 'and', 'was', 'after', 'some', 'thoughts', 'on', 'how', 'to', 'avoid', 'the', 'locking', '(if', 'possible)', 'or', 'optimise', 'around', 'it.', 'As', 'the', 'TCP', 'server', 'spins', 'up', 'a', 'GoRoutine', 'for', 'each', 'packet', 'received', 'the', 'addMessage', 'function', 'needs', 'a', 'level', 'of', 'synchronisation.', 'These', 'packets', 'also', 'get', 'analysed', 'in', 'another', 'function', 'later', 'on', 'that', 'does', 'a', 'RLock()', 'on', 'the', 'map.', 'It', 'is', 'the', 'cullMessages()', 'function', 'that', 'gets', 'called', 'once', 'per', 'second', 'that', 'really', 'gets', 'caught', 'up', 'in', 'itself', 'and', 'can', 'really', 'slow', 'down,', 'sometimes', 'taking', '2-3', 'seconds', 'to', 'run', 'which', 'compounds', 'the', 'issue', 'as', 'the', 'next', '2-3', 'operations', 'are', 'queued', 'waiting', 'to', 'unlock', 'and', 'run', 'straight', 'away!', 'Any', 'ideas/thoughts', 'would', 'be', 'appreciated!']","['PRP', 'VBP', 'DT', 'JJ', 'NNP', 'NN', 'VBN', 'IN', 'NNP', 'WDT', 'VBZ', 'CD', 'NNS', 'VBN', 'TO', 'VB', 'DT', 'NN', 'NNS', 'IN', 'NNS', 'WDT', 'VBZ', 'TO', 'VB', 'VBN', 'IN', 'RB', 'IN', 'PRP', 'VBP', 'VBG', 'IN', 'NN', 'NNS', 'IN', 'DT', 'NN', 'VBZ', 'IN', 'JJ', 'NNS', 'WDT', 'RB', 'VBP', 'IN', 'DT', 'NN', 'VBZ', 'CC', 'PRP', 'VBP', 'VBG', 'DT', 'NN', 'IN', 'NN', 'CC', 'VBD', 'NNP', 'IN', 'DT', 'NN', 'CC', 'VBD', 'IN', 'DT', 'NNS', 'IN', 'WRB', 'TO', 'VB', 'DT', 'NN', 'JJ', 'NN', 'CC', 'NN', 'RB', 'RB', 'IN', 'DT', 'NNP', 'NN', 'VBZ', 'RP', 'DT', 'NNP', 'IN', 'DT', 'NN', 'VBD', 'DT', 'NN', 'NN', 'VBZ', 'DT', 'NN', 'IN', 'JJ', 'DT', 'NNS', 'RB', 'VBP', 'VBN', 'IN', 'DT', 'NN', 'RB', 'IN', 'DT', 'VBZ', 'DT', 'NNP', 'IN', 'DT', 'NN', 'PRP', 'VBZ', 'DT', 'NN', 'NN', 'WDT', 'VBZ', 'VBN', 'RB', 'IN', 'NN', 'WDT', 'RB', 'VBZ', 'VBN', 'RP', 'IN', 'PRP', 'CC', 'MD', 'RB', 'VB', 'NN', 'RB', 'VBG', 'JJ', 'NNS', 'TO', 'VB', 'WDT', 'VBZ', 'DT', 'NN', 'IN', 'DT', 'JJ', 'JJ', 'NNS', 'VBP', 'VBN', 'VBG', 'TO', 'VB', 'CC', 'VB', 'RB', 'RB', 'NNP', 'NNS', 'MD', 'VB', 'JJ']"
1,var dataMessagesMutex sync.RWMutex,"['var', 'dataMessagesMutex', 'sync', '.', 'RWMutex']","['KEYWORD', 'IDENTIFIER', 'IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER']"
2,var dataMessages map[string][]*trackingPacket_v1,"['var', 'dataMessages', 'map', '[', 'string', '][]*', 'trackingPacket_v1']","['KEYWORD', 'IDENTIFIER', 'KEYWORD', 'PUNCTUATION', 'IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER']"
3,// Function is called from each TCP client who need to share this data,"['//', 'Function', 'is', 'called', 'from', 'each', 'TCP', 'client', 'who', 'need', 'to', 'share', 'this', 'data']","['COMMENT', 'NN', 'VBZ', 'VBN', 'IN', 'DT', 'NNP', 'NN', 'WP', 'VBP', 'TO', 'NN', 'DT', 'NN']"
4,func addMessage(trackingPacket *trackingPacket_v1) {,"['func', 'addMessage', '(', 'trackingPacket', '*', 'trackingPacket_v1', ')', '{']","['KEYWORD', 'IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'ARITHMETIC_OPERATOR', 'IDENTIFIER', 'PUNCTUATION', 'PUNCTUATION']"
5,    dataMessagesMutex.Lock(),['dataMessagesMutex.Lock()'],['FUNCTION_CALL']
6,"    dataMessages[trackingPacket.packetID] = append(dataMessages[trackingPacket.packetID], trackingPacket)","['dataMessages', '[', 'trackingPacket', '.', 'packetID', ']', '=', 'append', '(', 'dataMessages', '[', 'trackingPacket', '.', 'packetID', '],', 'trackingPacket', ')']","['IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'PUNCTUATION', 'ASSIGNMENT_OPERATOR', 'IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'PUNCTUATION']"
7,    dataMessagesMutex.Unlock(),['dataMessagesMutex.Unlock()'],['FUNCTION_CALL']
8,},['}'],['PUNCTUATION']
9,"// Function called on a loop, need to delete based on age here","['//', 'Function', 'called', 'on', 'a', 'loop,', 'need', 'to', 'delete', 'based', 'on', 'age', 'here']","['COMMENT', 'NN', 'VBN', 'IN', 'DT', 'JJ', 'NN', 'TO', 'VB', 'VBN', 'IN', 'NN', 'RB']"
10,func cullMessages() {,"['func', 'cullMessages', '()', '{']","['KEYWORD', 'IDENTIFIER', 'PUNCTUATION', 'PUNCTUATION']"
11,    cullTS := time.Now().Add(-time.Second * MODES_MAX_MESSAGE_AGE),"['cullTS', ':=', 'time.Now().Add(-time.Second * MODES_MAX_MESSAGE_AGE)']","['IDENTIFIER', 'ASSIGNMENT_OPERATOR', 'FUNCTION_CALL']"
12,    dataMessagesMutex.Lock(),['dataMessagesMutex.Lock()'],['FUNCTION_CALL']
13,    defer dataMessagesMutex.Unlock(),"['defer', 'dataMessagesMutex.Unlock()']","['IDENTIFIER', 'FUNCTION_CALL']"
14,"    for avr, data := range dataMessages {","['for', 'avr', ',', 'data', ':=', 'range', 'dataMessages', '{']","['KEYWORD', 'IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'ASSIGNMENT_OPERATOR', 'KEYWORD', 'IDENTIFIER', 'PUNCTUATION']"
15,        sort.Sort(PacketSorter(data)),['sort.Sort(PacketSorter(data))'],['FUNCTION_CALL']
16,        highestIndex := 0,"['highestIndex', ':=', '0']","['IDENTIFIER', 'ASSIGNMENT_OPERATOR', 'OCTAL_LITERAL']"
17,"        for i, messages := range data {","['for', 'i', ',', 'messages', ':=', 'range', 'data', '{']","['KEYWORD', 'IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'ASSIGNMENT_OPERATOR', 'KEYWORD', 'IDENTIFIER', 'PUNCTUATION']"
18,            if cullTS.Sub(messages.ProcessedTime) > 0 {,"['if', 'cullTS.Sub(messages.ProcessedTime)', '>', '0', '{']","['KEYWORD', 'FUNCTION_CALL', 'RELATION_OPERATOR', 'OCTAL_LITERAL', 'PUNCTUATION']"
19,                // Need to delete the message here,"['//', 'Need', 'to', 'delete', 'the', 'message', 'here']","['COMMENT', 'NN', 'TO', 'VB', 'DT', 'NN', 'RB']"
20,                messages = nil,"['messages', '=', 'nil']","['IDENTIFIER', 'ASSIGNMENT_OPERATOR', 'IDENTIFIER']"
21,                highestIndex = i,"['highestIndex', '=', 'i']","['IDENTIFIER', 'ASSIGNMENT_OPERATOR', 'IDENTIFIER']"
22,            },['}'],['PUNCTUATION']
23,        },['}'],['PUNCTUATION']
24,        // Copy the new slice into the data variable,"['//', 'Copy', 'the', 'new', 'slice', 'into', 'the', 'data', 'variable']","['COMMENT', 'VB', 'DT', 'JJ', 'NN', 'IN', 'DT', 'NNS', 'NN']"
25,        data = data[highestIndex+1:],"['data', '=', 'data', '[', 'highestIndex', '+', '1', ':]']","['IDENTIFIER', 'ASSIGNMENT_OPERATOR', 'IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'ARITHMETIC_OPERATOR', 'DECIMAL_LITERAL', 'PUNCTUATION']"
26,        if len(data) == 0 {,"['if', 'len', '(', 'data', ')', '==', '0', '{']","['KEYWORD', 'IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'PUNCTUATION', 'RELATION_OPERATOR', 'OCTAL_LITERAL', 'PUNCTUATION']"
27,"            // Empty Messages, delete","['//', 'Empty', 'Messages,', 'delete']","['COMMENT', 'NNP', 'NNP', 'NN']"
28,"            delete(dataMessages, avr)","['delete', '(', 'dataMessages', ',', 'avr', ')']","['IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'PUNCTUATION']"
29,        },['}'],['PUNCTUATION']
30,    },['}'],['PUNCTUATION']
31,},['}'],['PUNCTUATION']
32,"

UPDATE: 
Added analysis function 

","['UPDATE:', 'Added', 'analysis', 'function']","['NNP', 'NNP', 'NN', 'NN']"
33,func processCandidates() {,"['func', 'processCandidates', '()', '{']","['KEYWORD', 'IDENTIFIER', 'PUNCTUATION', 'PUNCTUATION']"
34,    mlatMessagesMutex.RLock(),['mlatMessagesMutex.RLock()'],['FUNCTION_CALL']
35,    defer dataMessagesMutex.RUnlock(),"['defer', 'dataMessagesMutex.RUnlock()']","['IDENTIFIER', 'FUNCTION_CALL']"
36,"    for _, data := range dataMessages {","['for', '_', ',', 'data', ':=', 'range', 'dataMessages', '{']","['KEYWORD', 'IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'ASSIGNMENT_OPERATOR', 'KEYWORD', 'IDENTIFIER', 'PUNCTUATION']"
37,        numberOfMessages := len(data),"['numberOfMessages', ':=', 'len', '(', 'data', ')']","['IDENTIFIER', 'ASSIGNMENT_OPERATOR', 'IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'PUNCTUATION']"
38,        for a := 0; a < numberOfMessages; a++ {,"['for', 'a', ':=', '0', ';', 'a', '<', 'numberOfMessages', ';', 'a', '++', '{']","['KEYWORD', 'IDENTIFIER', 'ASSIGNMENT_OPERATOR', 'OCTAL_LITERAL', 'PUNCTUATION', 'IDENTIFIER', 'RELATION_OPERATOR', 'IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'ARITHMETIC_OPERATOR', 'PUNCTUATION']"
39,            packetA := data[a],"['packetA', ':=', 'data', '[', 'a', ']']","['IDENTIFIER', 'ASSIGNMENT_OPERATOR', 'IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'PUNCTUATION']"
40,            applicablePackets := []*trackingPacket_v1{packetA},"['applicablePackets', ':=', '[]*', 'trackingPacket_v1', '{', 'packetA', '}']","['IDENTIFIER', 'ASSIGNMENT_OPERATOR', 'PUNCTUATION', 'IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'PUNCTUATION']"
41,            for b := 0; b < numberOfMessages; b++ {,"['for', 'b', ':=', '0', ';', 'b', '<', 'numberOfMessages', ';', 'b', '++', '{']","['KEYWORD', 'IDENTIFIER', 'ASSIGNMENT_OPERATOR', 'OCTAL_LITERAL', 'PUNCTUATION', 'IDENTIFIER', 'RELATION_OPERATOR', 'IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'ARITHMETIC_OPERATOR', 'PUNCTUATION']"
42,                // Don't compare identical packets,"['//', ""Don't"", 'compare', 'identical', 'packets']","['COMMENT', 'NNP', 'VB', 'JJ', 'NNS']"
43,                if b == a {,"['if', 'b', '==', 'a', '{']","['KEYWORD', 'IDENTIFIER', 'RELATION_OPERATOR', 'IDENTIFIER', 'PUNCTUATION']"
44,                    continue,['continue'],['KEYWORD']
45,                },['}'],['PUNCTUATION']
46,                packetB := data[b],"['packetB', ':=', 'data', '[', 'b', ']']","['IDENTIFIER', 'ASSIGNMENT_OPERATOR', 'IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'PUNCTUATION']"
47,                // Only consider this packet if it's within an acceptable,"['//', 'Only', 'consider', 'this', 'packet', 'if', ""it's"", 'within', 'an', 'acceptable']","['COMMENT', 'RB', 'VB', 'DT', 'NN', 'IN', 'NN', 'IN', 'DT', 'JJ']"
48,                // timestamp threshold,"['//', 'timestamp', 'threshold']","['COMMENT', 'NN', 'NN']"
49,                tsDelta := math.Abs(packetA.NormalisedTS - packetB.NormalisedTS),"['tsDelta', ':=', 'math.Abs(packetA.NormalisedTS - packetB.NormalisedTS)']","['IDENTIFIER', 'ASSIGNMENT_OPERATOR', 'FUNCTION_CALL']"
50,                if tsDelta < MAX_MESSAGE_TS_DIFF {,"['if', 'tsDelta', '<', 'MAX_MESSAGE_TS_DIFF', '{']","['KEYWORD', 'IDENTIFIER', 'RELATION_OPERATOR', 'IDENTIFIER', 'PUNCTUATION']"
51,"                    // Finally, we need to make sure that only one message per","['//', 'Finally,', 'we', 'need', 'to', 'make', 'sure', 'that', 'only', 'one', 'message', 'per']","['COMMENT', 'IN', 'PRP', 'VBP', 'TO', 'VB', 'JJ', 'IN', 'RB', 'CD', 'NN', 'IN']"
52,                    // station is included in our batch,"['//', 'station', 'is', 'included', 'in', 'our', 'batch']","['COMMENT', 'NN', 'VBZ', 'VBN', 'IN', 'PRP$', 'NN']"
53,                    stationAlreadyRepresented := false,"['stationAlreadyRepresented', ':=', 'false']","['IDENTIFIER', 'ASSIGNMENT_OPERATOR', 'BOOLEAN_LITERAL']"
54,                    for i := 0; i < len(applicablePackets); i++ {,"['for', 'i', ':=', '0', ';', 'i', '<', 'len', '(', 'applicablePackets', ');', 'i', '++', '{']","['KEYWORD', 'IDENTIFIER', 'ASSIGNMENT_OPERATOR', 'OCTAL_LITERAL', 'PUNCTUATION', 'IDENTIFIER', 'RELATION_OPERATOR', 'IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'ARITHMETIC_OPERATOR', 'PUNCTUATION']"
55,                        if applicablePackets[i].Sharecode == packetB.Sharecode {,"['if', 'applicablePackets', '[', 'i', '].', 'Sharecode', '==', 'packetB', '.', 'Sharecode', '{']","['KEYWORD', 'IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'RELATION_OPERATOR', 'IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'PUNCTUATION']"
56,                            stationAlreadyRepresented = true,"['stationAlreadyRepresented', '=', 'true']","['IDENTIFIER', 'ASSIGNMENT_OPERATOR', 'BOOLEAN_LITERAL']"
57,                        },['}'],['PUNCTUATION']
58,                    },['}'],['PUNCTUATION']
59,                    if stationAlreadyRepresented == false {,"['if', 'stationAlreadyRepresented', '==', 'false', '{']","['KEYWORD', 'IDENTIFIER', 'RELATION_OPERATOR', 'BOOLEAN_LITERAL', 'PUNCTUATION']"
60,"                        applicablePackets = append(applicablePackets, packetB)","['applicablePackets', '=', 'append', '(', 'applicablePackets', ',', 'packetB', ')']","['IDENTIFIER', 'ASSIGNMENT_OPERATOR', 'IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'PUNCTUATION']"
61,                    },['}'],['PUNCTUATION']
62,                },['}'],['PUNCTUATION']
63,            },['}'],['PUNCTUATION']
64,            // Remove any stations which are deemed too close to one another,"['//', 'Remove', 'any', 'stations', 'which', 'are', 'deemed', 'too', 'close', 'to', 'one', 'another']","['COMMENT', 'NNP', 'DT', 'NNS', 'WDT', 'VBP', 'VBN', 'RB', 'JJ', 'TO', 'CD', 'DT']"
65,            if len(applicablePackets) >= MIN_STATIONS_NEEDED {,"['if', 'len', '(', 'applicablePackets', ')', '>=', 'MIN_STATIONS_NEEDED', '{']","['KEYWORD', 'IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'PUNCTUATION', 'RELATION_OPERATOR', 'IDENTIFIER', 'PUNCTUATION']"
66,                applicablePackets = cullPackets(applicablePackets),"['applicablePackets', '=', 'cullPackets', '(', 'applicablePackets', ')']","['IDENTIFIER', 'ASSIGNMENT_OPERATOR', 'IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'PUNCTUATION']"
67,            },['}'],['PUNCTUATION']
68,            // Provided we still have enough packets....,"['//', 'Provided', 'we', 'still', 'have', 'enough', 'packets....']","['COMMENT', 'VBN', 'PRP', 'RB', 'VBP', 'JJ', 'NN']"
69,            if len(applicablePackets) >= MIN_STATIONS_NEEDED {,"['if', 'len', '(', 'applicablePackets', ')', '>=', 'MIN_STATIONS_NEEDED', '{']","['KEYWORD', 'IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'PUNCTUATION', 'RELATION_OPERATOR', 'IDENTIFIER', 'PUNCTUATION']"
70,                // Generate a hash for this batch...,"['//', 'Generate', 'a', 'hash', 'for', 'this', 'batch...']","['COMMENT', 'VB', 'DT', 'NN', 'IN', 'DT', 'NN']"
71,                hash := generateHashForPackets(applicablePackets),"['hash', ':=', 'generateHashForPackets', '(', 'applicablePackets', ')']","['IDENTIFIER', 'ASSIGNMENT_OPERATOR', 'IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'PUNCTUATION']"
72,                batchIsUnique := true,"['batchIsUnique', ':=', 'true']","['IDENTIFIER', 'ASSIGNMENT_OPERATOR', 'BOOLEAN_LITERAL']"
73,"                for _, packet := range applicablePackets {","['for', '_', ',', 'packet', ':=', 'range', 'applicablePackets', '{']","['KEYWORD', 'IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'ASSIGNMENT_OPERATOR', 'KEYWORD', 'IDENTIFIER', 'PUNCTUATION']"
74,                    if packet.containsHash(hash) {,"['if', 'packet.containsHash(hash)', '{']","['KEYWORD', 'FUNCTION_CALL', 'PUNCTUATION']"
75,                        batchIsUnique = false,"['batchIsUnique', '=', 'false']","['IDENTIFIER', 'ASSIGNMENT_OPERATOR', 'BOOLEAN_LITERAL']"
76,                        break,['break'],['KEYWORD']
77,                    },['}'],['PUNCTUATION']
78,                },['}'],['PUNCTUATION']
79,                if batchIsUnique == true {,"['if', 'batchIsUnique', '==', 'true', '{']","['KEYWORD', 'IDENTIFIER', 'RELATION_OPERATOR', 'BOOLEAN_LITERAL', 'PUNCTUATION']"
80,"                    for _, packet := range applicablePackets {","['for', '_', ',', 'packet', ':=', 'range', 'applicablePackets', '{']","['KEYWORD', 'IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'ASSIGNMENT_OPERATOR', 'KEYWORD', 'IDENTIFIER', 'PUNCTUATION']"
81,                        packet.addHash(hash),['packet.addHash(hash)'],['FUNCTION_CALL']
82,                    },['}'],['PUNCTUATION']
83,                    go sendOfDataForWork(applicablePackets),"['go', 'sendOfDataForWork', '(', 'applicablePackets', ')']","['KEYWORD', 'IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'PUNCTUATION']"
84,                },['}'],['PUNCTUATION']
85,            },['}'],['PUNCTUATION']
86,        },['}'],['PUNCTUATION']
87,    },['}'],['PUNCTUATION']
88,},['}'],['PUNCTUATION']
