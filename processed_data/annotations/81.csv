,text,token,annotation
0,"Go Code:

","['Go', 'Code:']","['NNP', 'NNP']"
1,package main,"['package', 'main']","['KEYWORD', 'IDENTIFIER']"
2,import (,"['import', '(']","['KEYWORD', 'PUNCTUATION']"
3,"    ""bufio""","['""bufio""']",['STRING_LITERAL']
4,"    _ ""bytes""","['_', '""bytes""']","['IDENTIFIER', 'STRING_LITERAL']"
5,"    ""fmt""","['""fmt""']",['STRING_LITERAL']
6,"    _ ""io""","['_', '""io""']","['IDENTIFIER', 'STRING_LITERAL']"
7,"    ""log""","['""log""']",['STRING_LITERAL']
8,"    ""os""","['""os""']",['STRING_LITERAL']
9,"    ""os/user""","['""os/user""']",['STRING_LITERAL']
10,"    ""path/filepath""","['""path/filepath""']",['STRING_LITERAL']
11,"    _ ""reflect""","['_', '""reflect""']","['IDENTIFIER', 'STRING_LITERAL']"
12,"    ""regexp""","['""regexp""']",['STRING_LITERAL']
13,"    ""runtime""","['""runtime""']",['STRING_LITERAL']
14,"    ""strconv""","['""strconv""']",['STRING_LITERAL']
15,"    ""strings""","['""strings""']",['STRING_LITERAL']
16,"    ""sync""","['""sync""']",['STRING_LITERAL']
17,"    ""time""","['""time""']",['STRING_LITERAL']
18,"    ""github.com/aws/aws-sdk-go/aws""","['""github.com/aws/aws-sdk-go/aws""']",['STRING_LITERAL']
19,"    ""github.com/aws/aws-sdk-go/aws/session""","['""github.com/aws/aws-sdk-go/aws/session""']",['STRING_LITERAL']
20,"    ""github.com/aws/aws-sdk-go/service/s3""","['""github.com/aws/aws-sdk-go/service/s3""']",['STRING_LITERAL']
21,"    ""github.com/aws/aws-sdk-go/service/s3/s3manager""","['""github.com/aws/aws-sdk-go/service/s3/s3manager""']",['STRING_LITERAL']
22,),[')'],['PUNCTUATION']
23,var (,"['var', '(']","['KEYWORD', 'PUNCTUATION']"
24,"    LocalDirectory   = ""s3logs"" // Into this directory","['LocalDirectory', '=', '""s3logs""', '//', 'Into', 'this', 'directory']","['IDENTIFIER', 'ASSIGNMENT_OPERATOR', 'STRING_LITERAL', 'COMMENT', 'IN', 'DT', 'NN']"
25,    Lock             sync.Mutex,"['Lock', 'sync', '.', 'Mutex']","['IDENTIFIER', 'IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER']"
26,    totalImpressions int,"['totalImpressions', 'int']","['IDENTIFIER', 'IDENTIFIER']"
27,),[')'],['PUNCTUATION']
28,var data = make(map[string]map[string]int),"['var', 'data', '=', 'make', '(', 'map', '[', 'string', ']', 'map', '[', 'string', ']', 'int', ')']","['KEYWORD', 'IDENTIFIER', 'ASSIGNMENT_OPERATOR', 'IDENTIFIER', 'PUNCTUATION', 'KEYWORD', 'PUNCTUATION', 'IDENTIFIER', 'PUNCTUATION', 'KEYWORD', 'PUNCTUATION', 'IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'PUNCTUATION']"
29,func main() {,"['func', 'main', '()', '{']","['KEYWORD', 'IDENTIFIER', 'PUNCTUATION', 'PUNCTUATION']"
30,    start := time.Now(),"['start', ':=', 'time.Now()']","['IDENTIFIER', 'ASSIGNMENT_OPERATOR', 'FUNCTION_CALL']"
31,"    // by adding this line i'm telling the program to run the threads on 4 different cores at the same time, Parallelism!!","['//', 'by', 'adding', 'this', 'line', ""i'm"", 'telling', 'the', 'program', 'to', 'run', 'the', 'threads', 'on', '4', 'different', 'cores', 'at', 'the', 'same', 'time,', 'Parallelism!!']","['COMMENT', 'IN', 'VBG', 'DT', 'NN', 'NN', 'VBG', 'DT', 'NN', 'TO', 'VB', 'DT', 'NNS', 'IN', 'CD', 'JJ', 'NNS', 'IN', 'DT', 'JJ', 'NN', 'NNP']"
32,    //REMEMBER TO ADD BLOCKS TO STOP RACE CONDITIONS,"['//', 'REMEMBER', 'TO', 'ADD', 'BLOCKS', 'TO', 'STOP', 'RACE', 'CONDITIONS']","['COMMENT', 'VB', 'NNP', 'NNP', 'NNP', 'NNP', 'NNP', 'NNP', 'NNP']"
33,    runtime.GOMAXPROCS(4),['runtime.GOMAXPROCS(4)'],['FUNCTION_CALL']
34,    var wg sync.WaitGroup,"['var', 'wg', 'sync', '.', 'WaitGroup']","['KEYWORD', 'IDENTIFIER', 'IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER']"
35,"    var year, month, day = time.Now().Date()","['var', 'year', ',', 'month', ',', 'day', '=', 'time.Now().Date()']","['KEYWORD', 'IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'ASSIGNMENT_OPERATOR', 'FUNCTION_CALL']"
36,    str_year := strconv.Itoa(year),"['str_year', ':=', 'strconv.Itoa(year)']","['IDENTIFIER', 'ASSIGNMENT_OPERATOR', 'FUNCTION_CALL']"
37,    str_month := strconv.Itoa(int(month)),"['str_month', ':=', 'strconv.Itoa(int(month))']","['IDENTIFIER', 'ASSIGNMENT_OPERATOR', 'FUNCTION_CALL']"
38,    str_day := strconv.Itoa(day),"['str_day', ':=', 'strconv.Itoa(day)']","['IDENTIFIER', 'ASSIGNMENT_OPERATOR', 'FUNCTION_CALL']"
39,    if int(month) < 10 {,"['if', 'int', '(', 'month', ')', '<', '10', '{']","['KEYWORD', 'IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'PUNCTUATION', 'RELATION_OPERATOR', 'DECIMAL_LITERAL', 'PUNCTUATION']"
40,"        str_month = ""0"" + strconv.Itoa(int(month))","['str_month', '=', '""0""', '+', 'strconv.Itoa(int(month))']","['IDENTIFIER', 'ASSIGNMENT_OPERATOR', 'STRING_LITERAL', 'ARITHMETIC_OPERATOR', 'FUNCTION_CALL']"
41,    },['}'],['PUNCTUATION']
42,    if day < 10 {,"['if', 'day', '<', '10', '{']","['KEYWORD', 'IDENTIFIER', 'RELATION_OPERATOR', 'DECIMAL_LITERAL', 'PUNCTUATION']"
43,"        str_day = ""0"" + strconv.Itoa(day)","['str_day', '=', '""0""', '+', 'strconv.Itoa(day)']","['IDENTIFIER', 'ASSIGNMENT_OPERATOR', 'STRING_LITERAL', 'ARITHMETIC_OPERATOR', 'FUNCTION_CALL']"
44,    },['}'],['PUNCTUATION']
45,    regBuckets := map[string]string{,"['regBuckets', ':=', 'map', '[', 'string', ']', 'string', '{']","['IDENTIFIER', 'ASSIGNMENT_OPERATOR', 'KEYWORD', 'PUNCTUATION', 'IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'PUNCTUATION']"
46,"        ""us-west-1"": ""pubgears-ca"",","['""us-west-1""', ':', '""pubgears-ca""', ',']","['STRING_LITERAL', 'PUNCTUATION', 'STRING_LITERAL', 'PUNCTUATION']"
47,"        ""test"":      ""test"",","['""test""', ':', '""test""', ',']","['STRING_LITERAL', 'PUNCTUATION', 'STRING_LITERAL', 'PUNCTUATION']"
48,    },['}'],['PUNCTUATION']
49,"    for region, bucket := range regBuckets {","['for', 'region', ',', 'bucket', ':=', 'range', 'regBuckets', '{']","['KEYWORD', 'IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'ASSIGNMENT_OPERATOR', 'KEYWORD', 'IDENTIFIER', 'PUNCTUATION']"
50,"        prefix := fmt.Sprintf(""tagserver/logs/AWSLogs/978380792767/elasticloadbalancing/%s/%s/%s/%s/"", region, str_year, str_month, str_day)","['prefix', ':=', 'fmt.Sprintf(""tagserver/logs/AWSLogs/978380792767/elasticloadbalancing/%s/%s/%s/%s/"", region, str_year, str_month, str_day)']","['IDENTIFIER', 'ASSIGNMENT_OPERATOR', 'FUNCTION_CALL']"
51,        wg.Add(1),['wg.Add(1)'],['FUNCTION_CALL']
52,"        go getLogs(region, bucket, LocalDirectory+bucket, &prefix, &wg)","['go', 'getLogs', '(', 'region', ',', 'bucket', ',', 'LocalDirectory', '+', 'bucket', ',', '&', 'prefix', ',', '&', 'wg', ')']","['KEYWORD', 'IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'ARITHMETIC_OPERATOR', 'IDENTIFIER', 'PUNCTUATION', 'POINTER_OPERATOR', 'IDENTIFIER', 'PUNCTUATION', 'POINTER_OPERATOR', 'IDENTIFIER', 'PUNCTUATION']"
53,    },['}'],['PUNCTUATION']
54,    wg.Wait(),['wg.Wait()'],['FUNCTION_CALL']
55,    //salon/t1/728x90/index,"['//', 'salon/t1/728x90/index']","['COMMENT', 'NN']"
56,    //totalImpressions := 0,"['//', 'totalImpressions', ':=', '0']","['COMMENT', 'NNS', 'VBP', 'CD']"
57,    // var provider = make(map[string]int),"['//', 'var', 'provider', '=', 'make(map[string]int)']","['COMMENT', 'NN', 'NN', 'NNP', 'NN']"
58,"    // for key, value := range data {","['//', 'for', 'key,', 'value', ':=', 'range', 'data', '{']","['COMMENT', 'IN', 'JJ', 'NN', 'NNP', 'NN', 'NNS', '(']"
59,    //   key = strings.TrimSpace(key),"['//', 'key', '=', 'strings.TrimSpace(key)']","['COMMENT', 'JJ', 'NNP', 'NN']"
60,"    //   pro := strings.Split(key, ""_"")[3]","['//', 'pro', ':=', 'strings.Split(key,', '""_"")[3]']","['COMMENT', 'JJ', 'FW', 'NN', 'NN']"
61,    //,['//'],['COMMENT']
62,"    //   if strings.Contains(pro, ""pp"") == true || (pro == ""pulsepoint"") || (pro == ""cweb"") {","['//', 'if', 'strings.Contains(pro,', '""pp"")', '==', 'true', '||', '(pro', '==', '""pulsepoint"")', '||', '(pro', '==', '""cweb"")', '{']","['COMMENT', 'IN', 'VBN', 'NNP', 'NNP', 'JJ', 'NNP', 'NNP', 'NNP', 'NNP', 'NNP', 'NNP', 'NNP', 'NNP', '(']"
63,"    //     provider[""pulsepoint""] += value","['//', 'provider[""pulsepoint""]', '+=', 'value']","['COMMENT', 'NN', 'CD', 'NN']"
64,"    //   } else if (pro == ""openx"") || (pro == ""openx3"") {","['//', '}', 'else', 'if', '(pro', '==', '""openx"")', '||', '(pro', '==', '""openx3"")', '{']","['COMMENT', ')', 'RB', 'IN', 'JJ', 'FW', 'FW', 'FW', 'FW', 'FW', 'FW', '(']"
65,"    //     provider[""openx""] += value","['//', 'provider[""openx""]', '+=', 'value']","['COMMENT', 'NN', 'CD', 'NN']"
66,"    //   } else if key == "" "" {","['//', '}', 'else', 'if', 'key', '==', '""', '""', '{']","['COMMENT', ')', 'RB', 'IN', 'JJ', 'NNP', 'NNP', 'NNP', '(']"
67,    //     continue,"['//', 'continue']","['COMMENT', 'NN']"
68,    //   } else {,"['//', '}', 'else', '{']","['COMMENT', ')', 'RB', '(']"
69,    //     provider[pro] += value,"['//', 'provider[pro]', '+=', 'value']","['COMMENT', 'NN', 'CD', 'NN']"
70,    //   },"['//', '}']","['COMMENT', ')']"
71,    //   totalImpressions += value,"['//', 'totalImpressions', '+=', 'value']","['COMMENT', 'NNS', 'VBP', 'NN']"
72,    // },"['//', '}']","['COMMENT', ')']"
73,"    for tag, value := range data {","['for', 'tag', ',', 'value', ':=', 'range', 'data', '{']","['KEYWORD', 'IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'ASSIGNMENT_OPERATOR', 'KEYWORD', 'IDENTIFIER', 'PUNCTUATION']"
74,"        for hour, imp := range value {","['for', 'hour', ',', 'imp', ':=', 'range', 'value', '{']","['KEYWORD', 'IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'ASSIGNMENT_OPERATOR', 'KEYWORD', 'IDENTIFIER', 'PUNCTUATION']"
75,"            fmt.Printf(""tag: %s  \n hour: %s impression %s\n"", tag, hour, imp)","['fmt.Printf(""tag: %s  \\n hour: %s impression %s\\n"", tag, hour, imp)']",['FUNCTION_CALL']
76,        },['}'],['PUNCTUATION']
77,    },['}'],['PUNCTUATION']
78,    //sl = sl[:len(sl)-1],"['//', 'sl', '=', 'sl[:len(sl)-1]']","['COMMENT', 'JJ', 'CD', 'NN']"
79,    elapsed := time.Since(start),"['elapsed', ':=', 'time.Since(start)']","['IDENTIFIER', 'ASSIGNMENT_OPERATOR', 'FUNCTION_CALL']"
80,"    fmt.Printf(""\nTime took %s\n"", elapsed)","['fmt.Printf(""\\nTime took %s\\n"", elapsed)']",['FUNCTION_CALL']
81,},['}'],['PUNCTUATION']
82,"func getLogs(region string, bucket string, directory string, prefix *string, wg *sync.WaitGroup) {","['func', 'getLogs', '(', 'region', 'string', ',', 'bucket', 'string', ',', 'directory', 'string', ',', 'prefix', '*', 'string', ',', 'wg', '*', 'sync', '.', 'WaitGroup', ')', '{']","['KEYWORD', 'IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'ARITHMETIC_OPERATOR', 'IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'ARITHMETIC_OPERATOR', 'IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'PUNCTUATION', 'PUNCTUATION']"
83,    sess := session.New(),"['sess', ':=', 'session.New()']","['IDENTIFIER', 'ASSIGNMENT_OPERATOR', 'FUNCTION_CALL']"
84,"    client := s3.New(sess, &aws.Config{Region: aws.String(region)})","['client', ':=', 's3.New(sess, &aws.Config{Region: aws.String(region)})']","['IDENTIFIER', 'ASSIGNMENT_OPERATOR', 'FUNCTION_CALL']"
85,"    params := &s3.ListObjectsInput{Bucket: &bucket, Prefix: prefix}","['params', ':=', '&', 's3', '.', 'ListObjectsInput', '{', 'Bucket', ':', '&', 'bucket', ',', 'Prefix', ':', 'prefix', '}']","['IDENTIFIER', 'ASSIGNMENT_OPERATOR', 'POINTER_OPERATOR', 'IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'PUNCTUATION', 'POINTER_OPERATOR', 'IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'PUNCTUATION']"
86,"    manager := s3manager.NewDownloaderWithClient(client, func(d *s3manager.Downloader) {","['manager', ':=', 's3manager.NewDownloaderWithClient(client, func(d *s3manager.Downloader)', '{']","['IDENTIFIER', 'ASSIGNMENT_OPERATOR', 'FUNCTION_CALL', 'PUNCTUATION']"
87,        d.PartSize = 5 * 1024 * 1024 // 6MB per part,"['d', '.', 'PartSize', '=', '5', '*', '1024', '*', '1024', '//', '6MB', 'per', 'part']","['IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'ASSIGNMENT_OPERATOR', 'DECIMAL_LITERAL', 'ARITHMETIC_OPERATOR', 'DECIMAL_LITERAL', 'ARITHMETIC_OPERATOR', 'DECIMAL_LITERAL', 'COMMENT', 'CD', 'IN', 'NN']"
88,        d.Concurrency = 4,"['d', '.', 'Concurrency', '=', '4']","['IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'ASSIGNMENT_OPERATOR', 'DECIMAL_LITERAL']"
89,    }),['})'],['PUNCTUATION']
90,"    d := downloader{bucket: bucket, dir: directory, Downloader: manager}","['d', ':=', 'downloader', '{', 'bucket', ':', 'bucket', ',', 'dir', ':', 'directory', ',', 'Downloader', ':', 'manager', '}']","['IDENTIFIER', 'ASSIGNMENT_OPERATOR', 'IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'PUNCTUATION']"
91,"    client.ListObjectsPages(params, d.eachPage)","['client.ListObjectsPages(params, d.eachPage)']",['FUNCTION_CALL']
92,    wg.Done(),['wg.Done()'],['FUNCTION_CALL']
93,},['}'],['PUNCTUATION']
94,// downloader object and methods,"['//', 'downloader', 'object', 'and', 'methods']","['COMMENT', 'NN', 'NN', 'CC', 'NNS']"
95,type downloader struct {,"['type', 'downloader', 'struct', '{']","['KEYWORD', 'IDENTIFIER', 'KEYWORD', 'PUNCTUATION']"
96,    *s3manager.Downloader,"['*', 's3manager', '.', 'Downloader']","['POINTER_OPERATOR', 'IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER']"
97,"    bucket, dir string","['bucket', ',', 'dir', 'string']","['IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'IDENTIFIER']"
98,},['}'],['PUNCTUATION']
99,"func (d *downloader) eachPage(page *s3.ListObjectsOutput, more bool) bool {","['func', '(', 'd', '*', 'downloader', ')', 'eachPage', '(', 'page', '*', 's3', '.', 'ListObjectsOutput', ',', 'more', 'bool', ')', 'bool', '{']","['KEYWORD', 'PUNCTUATION', 'IDENTIFIER', 'ARITHMETIC_OPERATOR', 'IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'ARITHMETIC_OPERATOR', 'IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'PUNCTUATION']"
100,"    for _, obj := range page.Contents {","['for', '_', ',', 'obj', ':=', 'range', 'page', '.', 'Contents', '{']","['KEYWORD', 'IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'ASSIGNMENT_OPERATOR', 'KEYWORD', 'IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'PUNCTUATION']"
101,        // fmt.Println(obj),"['//', 'fmt.Println(obj)']","['COMMENT', 'NN']"
102,        //     return true,"['//', 'return', 'true']","['COMMENT', 'NN', 'JJ']"
103,        d.downloadToFile(*obj.Key),['d.downloadToFile(*obj.Key)'],['FUNCTION_CALL']
104,    },['}'],['PUNCTUATION']
105,    return true,"['return', 'true']","['KEYWORD', 'BOOLEAN_LITERAL']"
106,},['}'],['PUNCTUATION']
107,func (d *downloader) downloadToFile(key string) {,"['func', '(', 'd', '*', 'downloader', ')', 'downloadToFile', '(', 'key', 'string', ')', '{']","['KEYWORD', 'PUNCTUATION', 'IDENTIFIER', 'ARITHMETIC_OPERATOR', 'IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'IDENTIFIER', 'PUNCTUATION', 'PUNCTUATION']"
108,    // Create the directories in the path,"['//', 'Create', 'the', 'directories', 'in', 'the', 'path']","['COMMENT', 'VB', 'DT', 'NNS', 'IN', 'DT', 'NN']"
109,    // desktop path,"['//', 'desktop', 'path']","['COMMENT', 'JJ', 'NN']"
110,"    user, errs := user.Current()","['user', ',', 'errs', ':=', 'user.Current()']","['IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'ASSIGNMENT_OPERATOR', 'FUNCTION_CALL']"
111,    if errs != nil {,"['if', 'errs', '!=', 'nil', '{']","['KEYWORD', 'IDENTIFIER', 'RELATION_OPERATOR', 'IDENTIFIER', 'PUNCTUATION']"
112,        panic(errs),"['panic', '(', 'errs', ')']","['IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'PUNCTUATION']"
113,    },['}'],['PUNCTUATION']
114,    homedir := user.HomeDir,"['homedir', ':=', 'user', '.', 'HomeDir']","['IDENTIFIER', 'ASSIGNMENT_OPERATOR', 'IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER']"
115,"    desktop := homedir + ""/Desktop/"" + d.dir","['desktop', ':=', 'homedir', '+', '""/Desktop/""', '+', 'd', '.', 'dir']","['IDENTIFIER', 'ASSIGNMENT_OPERATOR', 'IDENTIFIER', 'ARITHMETIC_OPERATOR', 'STRING_LITERAL', 'ARITHMETIC_OPERATOR', 'IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER']"
116,"    file := filepath.Join(desktop, key)","['file', ':=', 'filepath.Join(desktop, key)']","['IDENTIFIER', 'ASSIGNMENT_OPERATOR', 'FUNCTION_CALL']"
117,"    if err := os.MkdirAll(filepath.Dir(file), 0775); err != nil {","['if', 'err', ':=', 'os.MkdirAll(filepath.Dir(file), 0775)', ';', 'err', '!=', 'nil', '{']","['KEYWORD', 'IDENTIFIER', 'ASSIGNMENT_OPERATOR', 'FUNCTION_CALL', 'PUNCTUATION', 'IDENTIFIER', 'RELATION_OPERATOR', 'IDENTIFIER', 'PUNCTUATION']"
118,        panic(err),"['panic', '(', 'err', ')']","['IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'PUNCTUATION']"
119,    },['}'],['PUNCTUATION']
120,    // Setup the local file,"['//', 'Setup', 'the', 'local', 'file']","['COMMENT', 'NNP', 'DT', 'JJ', 'NN']"
121,"    fd, err := os.Create(file)","['fd', ',', 'err', ':=', 'os.Create(file)']","['IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'ASSIGNMENT_OPERATOR', 'FUNCTION_CALL']"
122,    if err != nil {,"['if', 'err', '!=', 'nil', '{']","['KEYWORD', 'IDENTIFIER', 'RELATION_OPERATOR', 'IDENTIFIER', 'PUNCTUATION']"
123,        panic(err),"['panic', '(', 'err', ')']","['IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'PUNCTUATION']"
124,    },['}'],['PUNCTUATION']
125,    defer fd.Close(),"['defer', 'fd.Close()']","['IDENTIFIER', 'FUNCTION_CALL']"
126,    // Download the file using the AWS SDK,"['//', 'Download', 'the', 'file', 'using', 'the', 'AWS', 'SDK']","['COMMENT', 'NNP', 'DT', 'NN', 'VBG', 'DT', 'NNP', 'NNP']"
127,"    //fmt.Printf(""Downloading s3://%s/%s to %s...\n"", d.bucket, key, file)","['//', 'fmt.Printf(""Downloading', 's3:%s/%s', 'to', '%s...\\n"",', 'd.bucket,', 'key,', 'file)']","['COMMENT', 'VBG', 'NN', 'TO', 'VB', 'JJ', 'NNS', 'VBP']"
128,"    params := &s3.GetObjectInput{Bucket: &d.bucket, Key: &key}","['params', ':=', '&', 's3', '.', 'GetObjectInput', '{', 'Bucket', ':', '&', 'd', '.', 'bucket', ',', 'Key', ':', '&', 'key', '}']","['IDENTIFIER', 'ASSIGNMENT_OPERATOR', 'POINTER_OPERATOR', 'IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'PUNCTUATION', 'POINTER_OPERATOR', 'IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'PUNCTUATION', 'POINTER_OPERATOR', 'IDENTIFIER', 'PUNCTUATION']"
129,"    d.Download(fd, params)","['d.Download(fd, params)']",['FUNCTION_CALL']
130,"    _, e := d.Download(fd, params)","['_', ',', 'e', ':=', 'd.Download(fd, params)']","['IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'ASSIGNMENT_OPERATOR', 'FUNCTION_CALL']"
131,    if e != nil {,"['if', 'e', '!=', 'nil', '{']","['KEYWORD', 'IDENTIFIER', 'RELATION_OPERATOR', 'IDENTIFIER', 'PUNCTUATION']"
132,        panic(e),"['panic', '(', 'e', ')']","['IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'PUNCTUATION']"
133,    },['}'],['PUNCTUATION']
134,"    f, err := os.Open(file)","['f', ',', 'err', ':=', 'os.Open(file)']","['IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'ASSIGNMENT_OPERATOR', 'FUNCTION_CALL']"
135,    if err != nil {,"['if', 'err', '!=', 'nil', '{']","['KEYWORD', 'IDENTIFIER', 'RELATION_OPERATOR', 'IDENTIFIER', 'PUNCTUATION']"
136,        log.Fatal(err),['log.Fatal(err)'],['FUNCTION_CALL']
137,    },['}'],['PUNCTUATION']
138,    defer f.Close(),"['defer', 'f.Close()']","['IDENTIFIER', 'FUNCTION_CALL']"
139,"    tag := regexp.MustCompile(""/([a-zA-Z0-9_]+/{1}[a-zA-Z0-9_]+/{1}[a-zA-Z0-9_]+/{1}[a-zA-Z0-9_]+)"")","['tag', ':=', 'regexp.MustCompile(""/([a-zA-Z0-9_]+/{1}[a-zA-Z0-9_]+/{1}[a-zA-Z0-9_]+/{1}[a-zA-Z0-9_]+)"")']","['IDENTIFIER', 'ASSIGNMENT_OPERATOR', 'FUNCTION_CALL']"
140,"    date := regexp.MustCompile(""T([^:]+)"")","['date', ':=', 'regexp.MustCompile(""T([^:]+)"")']","['IDENTIFIER', 'ASSIGNMENT_OPERATOR', 'FUNCTION_CALL']"
141,    scanner := bufio.NewScanner(f),"['scanner', ':=', 'bufio.NewScanner(f)']","['IDENTIFIER', 'ASSIGNMENT_OPERATOR', 'FUNCTION_CALL']"
142,    // HAVING TROUBLE HERE,"['//', 'HAVING', 'TROUBLE', 'HERE']","['COMMENT', 'NN', 'NNP', 'NNP']"
143,    for scanner.Scan() {,"['for', 'scanner.Scan()', '{']","['KEYWORD', 'FUNCTION_CALL', 'PUNCTUATION']"
144,        //dateCollection := make(map[string]int),"['//', 'dateCollection', ':=', 'make(map[string]int)']","['COMMENT', 'NN', 'CD', 'NN']"
145,        m := tag.FindString(scanner.Text()),"['m', ':=', 'tag.FindString(scanner.Text())']","['IDENTIFIER', 'ASSIGNMENT_OPERATOR', 'FUNCTION_CALL']"
146,"        if m != """" {","['if', 'm', '!=', '""""', '{']","['KEYWORD', 'IDENTIFIER', 'RELATION_OPERATOR', 'STRING_LITERAL', 'PUNCTUATION']"
147,            // stop races,"['//', 'stop', 'races']","['COMMENT', 'NN', 'NNS']"
148,            Lock.Lock(),['Lock.Lock()'],['FUNCTION_CALL']
149,"            arr := strings.Split(m, ""/"")","['arr', ':=', 'strings.Split(m, ""/"")']","['IDENTIFIER', 'ASSIGNMENT_OPERATOR', 'FUNCTION_CALL']"
150,"            taghash := strings.Join(arr, ""_"")","['taghash', ':=', 'strings.Join(arr, ""_"")']","['IDENTIFIER', 'ASSIGNMENT_OPERATOR', 'FUNCTION_CALL']"
151,"            taghash = strings.TrimLeft(taghash, ""_"")","['taghash', '=', 'strings.TrimLeft(taghash, ""_"")']","['IDENTIFIER', 'ASSIGNMENT_OPERATOR', 'FUNCTION_CALL']"
152,            //data[taghash]++,"['//', 'data[taghash]++']","['COMMENT', 'NN']"
153,            m = date.FindString(scanner.Text()),"['m', '=', 'date.FindString(scanner.Text())']","['IDENTIFIER', 'ASSIGNMENT_OPERATOR', 'FUNCTION_CALL']"
154,"            if m != """" {","['if', 'm', '!=', '""""', '{']","['KEYWORD', 'IDENTIFIER', 'RELATION_OPERATOR', 'STRING_LITERAL', 'PUNCTUATION']"
155,                hour := m,"['hour', ':=', 'm']","['IDENTIFIER', 'ASSIGNMENT_OPERATOR', 'IDENTIFIER']"
156,                data[taghash] = make(map[string]int),"['data', '[', 'taghash', ']', '=', 'make', '(', 'map', '[', 'string', ']', 'int', ')']","['IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'PUNCTUATION', 'ASSIGNMENT_OPERATOR', 'IDENTIFIER', 'PUNCTUATION', 'KEYWORD', 'PUNCTUATION', 'IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'PUNCTUATION']"
157,                data[taghash][hour]++,"['data', '[', 'taghash', '][', 'hour', ']++']","['IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'PUNCTUATION']"
158,            },['}'],['PUNCTUATION']
159,            Lock.Unlock(),['Lock.Unlock()'],['FUNCTION_CALL']
160,        },['}'],['PUNCTUATION']
161,    },['}'],['PUNCTUATION']
162,    fmt.Println(file),['fmt.Println(file)'],['FUNCTION_CALL']
163,    os.Remove(file),['os.Remove(file)'],['FUNCTION_CALL']
164,    if err := scanner.Err(); err != nil {,"['if', 'err', ':=', 'scanner.Err()', ';', 'err', '!=', 'nil', '{']","['KEYWORD', 'IDENTIFIER', 'ASSIGNMENT_OPERATOR', 'FUNCTION_CALL', 'PUNCTUATION', 'IDENTIFIER', 'RELATION_OPERATOR', 'IDENTIFIER', 'PUNCTUATION']"
165,        log.Fatal(err),['log.Fatal(err)'],['FUNCTION_CALL']
166,    },['}'],['PUNCTUATION']
167,},['}'],['PUNCTUATION']
168,"

The area i'm having trouble at starts on line 167 section below:

for scanner.Scan() {
        //dateCollection := make(map[string]int)
        m := tag.FindString(scanner.Text())
        if m != """" {
            // stop races
            Lock.Lock()
            arr := strings.Split(m, ""/"")
            taghash := strings.Join(arr, ""_"")
            taghash = strings.TrimLeft(taghash, ""_"")
            //data[taghash]++
            m = date.FindString(scanner.Text())
            if m != """" {
                hour := m
                data[taghash] = make(map[string]int)
                data[taghash][hour]++
            }
            Lock.Unlock()
        }
    }
    fmt.Println(file)
    os.Remove(file)
    if err := scanner.Err(); err != nil {
        log.Fatal(err)
    }


The output i'm getting when I print the values in the main func

fstvt1_ros_300x600_pp8_1 T07 1


I'm expecting an output that looks something like this:

fstvt1_ros_300x600_pp8_1
T00 213434
T01 23432
T02 3324
T03 324
T04 324
T05 0 ...
(this isn't real data)


What I'm trying to do:
I have a map of data ","['The', 'area', ""i'm"", 'having', 'trouble', 'at', 'starts', 'on', 'line', '167', 'section', 'below:', 'for', 'scanner.Scan()', '{', '//dateCollection', ':=', 'make(map[string]int)', 'm', ':=', 'tag.FindString(scanner.Text())', 'if', 'm', '!=', '""""', '{', '//', 'stop', 'races', 'Lock.Lock()', 'arr', ':=', 'strings.Split(m,', '""/"")', 'taghash', ':=', 'strings.Join(arr,', '""_"")', 'taghash', '=', 'strings.TrimLeft(taghash,', '""_"")', '//data[taghash]++', 'm', '=', 'date.FindString(scanner.Text())', 'if', 'm', '!=', '""""', '{', 'hour', ':=', 'm', 'data[taghash]', '=', 'make(map[string]int)', 'data[taghash][hour]++', '}', 'Lock.Unlock()', '}', '}', 'fmt.Println(file)', 'os.Remove(file)', 'if', 'err', ':=', 'scanner.Err();', 'err', '!=', 'nil', '{', 'log.Fatal(err)', '}', 'The', 'output', ""i'm"", 'getting', 'when', 'I', 'print', 'the', 'values', 'in', 'the', 'main', 'func', 'fstvt1_ros_300x600_pp8_1', 'T07', '1', ""I'm"", 'expecting', 'an', 'output', 'that', 'looks', 'something', 'like', 'this:', 'fstvt1_ros_300x600_pp8_1', 'T00', '213434', 'T01', '23432', 'T02', '3324', 'T03', '324', 'T04', '324', 'T05', '0', '...', '(this', ""isn't"", 'real', 'data)', 'What', ""I'm"", 'trying', 'to', 'do:', 'I', 'have', 'a', 'map', 'of', 'data']","['DT', 'NN', 'NN', 'VBG', 'NN', 'IN', 'NNS', 'IN', 'NN', 'CD', 'NN', 'NN', 'IN', 'NN', '(', 'NN', 'NNP', 'NN', 'NN', 'NNP', 'NN', 'IN', 'JJ', 'NNP', 'NNP', '(', 'JJ', 'NN', 'NNS', 'NNP', 'VBP', 'NNP', 'NN', 'NNP', 'NN', 'NNP', 'NN', 'NNP', 'NN', 'NNP', 'NN', 'NNP', 'NNP', 'NN', 'NNP', 'NN', 'IN', 'JJ', 'NNP', 'NNP', '(', 'NN', 'NNP', 'NN', 'NN', 'NNP', 'NN', 'NN', ')', 'NNP', ')', ')', 'JJ', 'JJ', 'IN', 'JJ', 'NNP', 'NN', 'NN', 'NNP', 'RB', '(', 'NN', ')', 'DT', 'NN', 'NN', 'VBG', 'WRB', 'PRP', 'VBP', 'DT', 'NNS', 'IN', 'DT', 'JJ', 'NN', 'NN', 'NNP', 'CD', 'NNP', 'VBG', 'DT', 'NN', 'WDT', 'VBZ', 'NN', 'IN', 'JJ', 'NN', 'NNP', 'CD', 'NNP', 'CD', 'NNP', 'CD', 'NNP', 'CD', 'NNP', 'CD', 'NNP', 'CD', ':', 'VBP', 'JJ', 'JJ', 'NN', 'WP', 'NNP', 'VBG', 'TO', 'VB', 'PRP', 'VBP', 'DT', 'NN', 'IN', 'NNS']"
169,var data = make(map[string]map[string]int),"['var', 'data', '=', 'make', '(', 'map', '[', 'string', ']', 'map', '[', 'string', ']', 'int', ')']","['KEYWORD', 'IDENTIFIER', 'ASSIGNMENT_OPERATOR', 'IDENTIFIER', 'PUNCTUATION', 'KEYWORD', 'PUNCTUATION', 'IDENTIFIER', 'PUNCTUATION', 'KEYWORD', 'PUNCTUATION', 'IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'PUNCTUATION']"
170," whose key is equal to a taghash, e.g. fstvt1_ros_300x600_pp8_1. The value is a map of data.  The key value of that map is expected to be a string and an integer. I want multiple maps.  One for each key... T01, T02..  What is currently outputted is the last item in the last of items i'm iterating on instead of a collection of keys and values for each taghash.  How do i make is so that instead of overwriting the data, it adds the new key Value T01, T02.. and if the taghash and hour are the some to increment that particular object.

Line of code i'm currently using:

T01, T02..

data[taghash][hour]++


Where the if the taghash and hour exist then it should increment.  If the taghash and hour doesn't exist then create the taghash and add the new key and increment.
","['whose', 'key', 'is', 'equal', 'to', 'a', 'taghash,', 'e.g.', 'fstvt1_ros_300x600_pp8_1.', 'The', 'value', 'is', 'a', 'map', 'of', 'data.', 'The', 'key', 'value', 'of', 'that', 'map', 'is', 'expected', 'to', 'be', 'a', 'string', 'and', 'an', 'integer.', 'I', 'want', 'multiple', 'maps.', 'One', 'for', 'each', 'key...', 'T01,', 'T02..', 'What', 'is', 'currently', 'outputted', 'is', 'the', 'last', 'item', 'in', 'the', 'last', 'of', 'items', ""i'm"", 'iterating', 'on', 'instead', 'of', 'a', 'collection', 'of', 'keys', 'and', 'values', 'for', 'each', 'taghash.', 'How', 'do', 'i', 'make', 'is', 'so', 'that', 'instead', 'of', 'overwriting', 'the', 'data,', 'it', 'adds', 'the', 'new', 'key', 'Value', 'T01,', 'T02..', 'and', 'if', 'the', 'taghash', 'and', 'hour', 'are', 'the', 'some', 'to', 'increment', 'that', 'particular', 'object.', 'Line', 'of', 'code', ""i'm"", 'currently', 'using:', 'T01,', 'T02..', 'data[taghash][hour]++', 'Where', 'the', 'if', 'the', 'taghash', 'and', 'hour', 'exist', 'then', 'it', 'should', 'increment.', 'If', 'the', 'taghash', 'and', 'hour', ""doesn't"", 'exist', 'then', 'create', 'the', 'taghash', 'and', 'add', 'the', 'new', 'key', 'and', 'increment.']","['WP$', 'NN', 'VBZ', 'JJ', 'TO', 'DT', 'NN', 'NN', 'VBD', 'DT', 'NN', 'VBZ', 'DT', 'NN', 'IN', 'NN', 'DT', 'JJ', 'NN', 'IN', 'DT', 'NN', 'VBZ', 'VBN', 'TO', 'VB', 'DT', 'NN', 'CC', 'DT', 'NN', 'PRP', 'VBP', 'JJ', 'VBP', 'CD', 'IN', 'DT', 'NN', 'NNP', 'NNP', 'WP', 'VBZ', 'RB', 'VBN', 'VBZ', 'DT', 'JJ', 'NN', 'IN', 'DT', 'JJ', 'IN', 'NNS', 'JJ', 'VBG', 'IN', 'RB', 'IN', 'DT', 'NN', 'IN', 'NNS', 'CC', 'NNS', 'IN', 'DT', 'NN', 'WRB', 'VBP', 'VB', 'VB', 'VBZ', 'RB', 'IN', 'RB', 'IN', 'VBG', 'DT', 'NN', 'PRP', 'VBZ', 'DT', 'JJ', 'JJ', 'NNP', 'NNP', 'NNP', 'CC', 'IN', 'DT', 'NN', 'CC', 'NN', 'VBP', 'DT', 'DT', 'TO', 'VB', 'IN', 'JJ', 'JJ', 'NNP', 'IN', 'NN', 'NN', 'RB', 'JJ', 'NNP', 'NNP', 'NN', 'WRB', 'DT', 'IN', 'DT', 'NN', 'CC', 'NN', 'VBP', 'RB', 'PRP', 'MD', 'VB', 'IN', 'DT', 'NN', 'CC', 'NN', 'NNS', 'VBP', 'RB', 'VB', 'DT', 'NN', 'CC', 'VB', 'DT', 'JJ', 'NN', 'CC', 'NN']"
171,for scanner.Scan() {,"['for', 'scanner.Scan()', '{']","['KEYWORD', 'FUNCTION_CALL', 'PUNCTUATION']"
172,        //dateCollection := make(map[string]int),"['//', 'dateCollection', ':=', 'make(map[string]int)']","['COMMENT', 'NN', 'CD', 'NN']"
173,        m := tag.FindString(scanner.Text()),"['m', ':=', 'tag.FindString(scanner.Text())']","['IDENTIFIER', 'ASSIGNMENT_OPERATOR', 'FUNCTION_CALL']"
174,"        if m != """" {","['if', 'm', '!=', '""""', '{']","['KEYWORD', 'IDENTIFIER', 'RELATION_OPERATOR', 'STRING_LITERAL', 'PUNCTUATION']"
175,            // stop races,"['//', 'stop', 'races']","['COMMENT', 'NN', 'NNS']"
176,            Lock.Lock(),['Lock.Lock()'],['FUNCTION_CALL']
177,"            arr := strings.Split(m, ""/"")","['arr', ':=', 'strings.Split(m, ""/"")']","['IDENTIFIER', 'ASSIGNMENT_OPERATOR', 'FUNCTION_CALL']"
178,"            taghash := strings.Join(arr, ""_"")","['taghash', ':=', 'strings.Join(arr, ""_"")']","['IDENTIFIER', 'ASSIGNMENT_OPERATOR', 'FUNCTION_CALL']"
179,"            taghash = strings.TrimLeft(taghash, ""_"")","['taghash', '=', 'strings.TrimLeft(taghash, ""_"")']","['IDENTIFIER', 'ASSIGNMENT_OPERATOR', 'FUNCTION_CALL']"
180,            //data[taghash]++,"['//', 'data[taghash]++']","['COMMENT', 'NN']"
181,            m = date.FindString(scanner.Text()),"['m', '=', 'date.FindString(scanner.Text())']","['IDENTIFIER', 'ASSIGNMENT_OPERATOR', 'FUNCTION_CALL']"
182,"            if m != """" {","['if', 'm', '!=', '""""', '{']","['KEYWORD', 'IDENTIFIER', 'RELATION_OPERATOR', 'STRING_LITERAL', 'PUNCTUATION']"
183,                hour := m,"['hour', ':=', 'm']","['IDENTIFIER', 'ASSIGNMENT_OPERATOR', 'IDENTIFIER']"
184,                data[taghash] = make(map[string]int),"['data', '[', 'taghash', ']', '=', 'make', '(', 'map', '[', 'string', ']', 'int', ')']","['IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'PUNCTUATION', 'ASSIGNMENT_OPERATOR', 'IDENTIFIER', 'PUNCTUATION', 'KEYWORD', 'PUNCTUATION', 'IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'PUNCTUATION']"
185,                data[taghash][hour]++,"['data', '[', 'taghash', '][', 'hour', ']++']","['IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'PUNCTUATION']"
186,            },['}'],['PUNCTUATION']
187,            Lock.Unlock(),['Lock.Unlock()'],['FUNCTION_CALL']
188,        },['}'],['PUNCTUATION']
189,    },['}'],['PUNCTUATION']
190,    fmt.Println(file),['fmt.Println(file)'],['FUNCTION_CALL']
191,    os.Remove(file),['os.Remove(file)'],['FUNCTION_CALL']
192,    if err := scanner.Err(); err != nil {,"['if', 'err', ':=', 'scanner.Err()', ';', 'err', '!=', 'nil', '{']","['KEYWORD', 'IDENTIFIER', 'ASSIGNMENT_OPERATOR', 'FUNCTION_CALL', 'PUNCTUATION', 'IDENTIFIER', 'RELATION_OPERATOR', 'IDENTIFIER', 'PUNCTUATION']"
193,        log.Fatal(err),['log.Fatal(err)'],['FUNCTION_CALL']
194,    },['}'],['PUNCTUATION']
195," whose key is equal to a taghash, e.g. fstvt1_ros_300x600_pp8_1. The value is a map of data.  The key value of that map is expected to be a string and an integer. I want multiple maps.  One for each key... T01, T02..  What is currently outputted is the last item in the last of items i'm iterating on instead of a collection of keys and values for each taghash.  How do i make is so that instead of overwriting the data, it adds the new key Value T01, T02.. and if the taghash and hour are the some to increment that particular object.

Line of code i'm currently using:

T01, T02..

","['whose', 'key', 'is', 'equal', 'to', 'a', 'taghash,', 'e.g.', 'fstvt1_ros_300x600_pp8_1.', 'The', 'value', 'is', 'a', 'map', 'of', 'data.', 'The', 'key', 'value', 'of', 'that', 'map', 'is', 'expected', 'to', 'be', 'a', 'string', 'and', 'an', 'integer.', 'I', 'want', 'multiple', 'maps.', 'One', 'for', 'each', 'key...', 'T01,', 'T02..', 'What', 'is', 'currently', 'outputted', 'is', 'the', 'last', 'item', 'in', 'the', 'last', 'of', 'items', ""i'm"", 'iterating', 'on', 'instead', 'of', 'a', 'collection', 'of', 'keys', 'and', 'values', 'for', 'each', 'taghash.', 'How', 'do', 'i', 'make', 'is', 'so', 'that', 'instead', 'of', 'overwriting', 'the', 'data,', 'it', 'adds', 'the', 'new', 'key', 'Value', 'T01,', 'T02..', 'and', 'if', 'the', 'taghash', 'and', 'hour', 'are', 'the', 'some', 'to', 'increment', 'that', 'particular', 'object.', 'Line', 'of', 'code', ""i'm"", 'currently', 'using:', 'T01,', 'T02..']","['WP$', 'NN', 'VBZ', 'JJ', 'TO', 'DT', 'NN', 'NN', 'VBD', 'DT', 'NN', 'VBZ', 'DT', 'NN', 'IN', 'NN', 'DT', 'JJ', 'NN', 'IN', 'DT', 'NN', 'VBZ', 'VBN', 'TO', 'VB', 'DT', 'NN', 'CC', 'DT', 'NN', 'PRP', 'VBP', 'JJ', 'VBP', 'CD', 'IN', 'DT', 'NN', 'NNP', 'NNP', 'WP', 'VBZ', 'RB', 'VBN', 'VBZ', 'DT', 'JJ', 'NN', 'IN', 'DT', 'JJ', 'IN', 'NNS', 'JJ', 'VBG', 'IN', 'RB', 'IN', 'DT', 'NN', 'IN', 'NNS', 'CC', 'NNS', 'IN', 'DT', 'NN', 'WRB', 'VBP', 'VB', 'VB', 'VBZ', 'RB', 'IN', 'RB', 'IN', 'VBG', 'DT', 'NN', 'PRP', 'VBZ', 'DT', 'JJ', 'JJ', 'NNP', 'NNP', 'NNP', 'CC', 'IN', 'DT', 'NN', 'CC', 'NN', 'VBP', 'DT', 'DT', 'TO', 'VB', 'IN', 'JJ', 'JJ', 'NNP', 'IN', 'NN', 'NN', 'RB', 'JJ', 'NNP', 'NNP']"
196,data[taghash][hour]++,"['data', '[', 'taghash', '][', 'hour', ']++']","['IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'PUNCTUATION']"
197,"

Where the if the taghash and hour exist then it should increment.  If the taghash and hour doesn't exist then create the taghash and add the new key and increment.
","['Where', 'the', 'if', 'the', 'taghash', 'and', 'hour', 'exist', 'then', 'it', 'should', 'increment.', 'If', 'the', 'taghash', 'and', 'hour', ""doesn't"", 'exist', 'then', 'create', 'the', 'taghash', 'and', 'add', 'the', 'new', 'key', 'and', 'increment.']","['WRB', 'DT', 'IN', 'DT', 'NN', 'CC', 'NN', 'VBP', 'RB', 'PRP', 'MD', 'VB', 'IN', 'DT', 'NN', 'CC', 'NN', 'NNS', 'VBP', 'RB', 'VB', 'DT', 'NN', 'CC', 'VB', 'DT', 'JJ', 'NN', 'CC', 'NN']"
198,fstvt1_ros_300x600_pp8_1,['fstvt1_ros_300x600_pp8_1'],['IDENTIFIER']
199,"

Where the if the taghash and hour exist then it should increment.  If the taghash and hour doesn't exist then create the taghash and add the new key and increment.
","['Where', 'the', 'if', 'the', 'taghash', 'and', 'hour', 'exist', 'then', 'it', 'should', 'increment.', 'If', 'the', 'taghash', 'and', 'hour', ""doesn't"", 'exist', 'then', 'create', 'the', 'taghash', 'and', 'add', 'the', 'new', 'key', 'and', 'increment.']","['WRB', 'DT', 'IN', 'DT', 'NN', 'CC', 'NN', 'VBP', 'RB', 'PRP', 'MD', 'VB', 'IN', 'DT', 'NN', 'CC', 'NN', 'NNS', 'VBP', 'RB', 'VB', 'DT', 'NN', 'CC', 'VB', 'DT', 'JJ', 'NN', 'CC', 'NN']"
200,fstvt1_ros_300x600_pp8_1,['fstvt1_ros_300x600_pp8_1'],['IDENTIFIER']
201,T00 213434,"['T00', '213434']","['IDENTIFIER', 'DECIMAL_LITERAL']"
202,T01 23432,"['T01', '23432']","['IDENTIFIER', 'DECIMAL_LITERAL']"
203,T02 3324,"['T02', '3324']","['IDENTIFIER', 'DECIMAL_LITERAL']"
204,T03 324,"['T03', '324']","['IDENTIFIER', 'DECIMAL_LITERAL']"
205,T04 324,"['T04', '324']","['IDENTIFIER', 'DECIMAL_LITERAL']"
206,T05 0 ...,"['T05', '0', '...']","['IDENTIFIER', 'OCTAL_LITERAL', 'PUNCTUATION']"
207,(this isn't real data),"['(', 'this', 'isn', 't', 'real', 'data', ')']","['PUNCTUATION', 'IDENTIFIER', 'IDENTIFIER', 'IDENTIFIER', 'IDENTIFIER', 'IDENTIFIER', 'PUNCTUATION']"
