,text,token,annotation
0,"The function Scanner.Bytes may return the same slice used internally by the scanner.


","['The', 'function', 'Scanner.Bytes', 'may', 'return', 'the', 'same', 'slice', 'used', 'internally', 'by', 'the', 'scanner.']","['DT', 'NN', 'NNP', 'MD', 'VB', 'DT', 'JJ', 'NN', 'VBN', 'RB', 'IN', 'DT', 'NN']"
1,func (s *Scanner) Bytes() []byte,"['func', '(', 's', '*', 'Scanner', ')', 'Bytes', '()', '[]', 'byte']","['KEYWORD', 'PUNCTUATION', 'IDENTIFIER', 'ARITHMETIC_OPERATOR', 'IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'PUNCTUATION', 'PUNCTUATION', 'IDENTIFIER']"
2,"
  
  Bytes returns the most recent token generated by a call to Scan. The underlying array may point to data that will be overwritten by a subsequent call to Scan. It does no allocation.


As per documentation, this slice may be overwritten by subsequent calls to Scanner.Scan. Since your code does not ensure that this slice is not used after the next call to Scanner.Scan (and in fact your code produces lines and consumes them asynchonously), it may contain garbage at the point where you're trying to use it.

Explicitly copy the slice to make sure that the data is not being overwritten by subsequent calls to Scanner.Scan.

","['Bytes', 'returns', 'the', 'most', 'recent', 'token', 'generated', 'by', 'a', 'call', 'to', 'Scan.', 'The', 'underlying', 'array', 'may', 'point', 'to', 'data', 'that', 'will', 'be', 'overwritten', 'by', 'a', 'subsequent', 'call', 'to', 'Scan.', 'It', 'does', 'no', 'allocation.', 'As', 'per', 'documentation,', 'this', 'slice', 'may', 'be', 'overwritten', 'by', 'subsequent', 'calls', 'to', 'Scanner.Scan.', 'Since', 'your', 'code', 'does', 'not', 'ensure', 'that', 'this', 'slice', 'is', 'not', 'used', 'after', 'the', 'next', 'call', 'to', 'Scanner.Scan', '(and', 'in', 'fact', 'your', 'code', 'produces', 'lines', 'and', 'consumes', 'them', 'asynchonously),', 'it', 'may', 'contain', 'garbage', 'at', 'the', 'point', 'where', ""you're"", 'trying', 'to', 'use', 'it.', 'Explicitly', 'copy', 'the', 'slice', 'to', 'make', 'sure', 'that', 'the', 'data', 'is', 'not', 'being', 'overwritten', 'by', 'subsequent', 'calls', 'to', 'Scanner.Scan.']","['NNS', 'VBP', 'DT', 'RBS', 'JJ', 'NN', 'VBN', 'IN', 'DT', 'NN', 'TO', 'VB', 'DT', 'JJ', 'NN', 'MD', 'VB', 'TO', 'VB', 'DT', 'MD', 'VB', 'VBN', 'IN', 'DT', 'JJ', 'NN', 'TO', 'VB', 'PRP', 'VBZ', 'DT', 'NN', 'IN', 'IN', 'NN', 'DT', 'NN', 'MD', 'VB', 'VBN', 'IN', 'JJ', 'NNS', 'TO', 'NNP', 'IN', 'PRP$', 'NN', 'VBZ', 'RB', 'VB', 'IN', 'DT', 'NN', 'VBZ', 'RB', 'VBN', 'IN', 'DT', 'JJ', 'NN', 'TO', 'NNP', 'NNP', 'IN', 'NN', 'PRP$', 'NN', 'VBZ', 'NNS', 'CC', 'VBZ', 'PRP', 'IN', 'PRP', 'MD', 'VB', 'NN', 'IN', 'DT', 'NN', 'WRB', 'NN', 'VBG', 'TO', 'VB', 'JJ', 'RB', 'VBP', 'DT', 'NN', 'TO', 'VB', 'JJ', 'IN', 'DT', 'NN', 'VBZ', 'RB', 'VBG', 'VBN', 'IN', 'JJ', 'NNS', 'TO', 'VB']"
3,"input <- append(nil, newestBytes...)","['input', '<-', 'append', '(', 'nil', ',', 'newestBytes', '...)']","['IDENTIFIER', 'CHANNEL_OPERATOR', 'IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'PUNCTUATION']"
