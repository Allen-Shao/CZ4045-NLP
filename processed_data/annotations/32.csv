,text,token,annotation
0,"I am very, very memory careful as I have to write programs that need to cope with massive datasets.

Currently my application quickly reaches 32GB of memory, starts swapping, and then gets killed by the system.

I do not understand how this can be since all variables are collectable (in functions and quickly released) except TokensStruct and TokensCount in the Trainer struct. TokensCount is just a uint. TokensStruct is a 1,000,000 row slice of [5]uint32 and string, so that means 20 bytes + string, which we could call a maximum of 50 bytes per record. 50*1000000 = 50MB of memory required. So this script should therefore not use much more than 50MB + overhead + temporary collectable variables in the functions (maybe another 50MB max.) The maximum potential size of TokensStruct is 5,000,000, as this is the size of dictionary, but even then it would be only 250MB of memory. dictionary is a map and apparently uses around 600MB of memory, as that is how the app starts, but this is not an issue because dictionary is only loaded once and never written to again.

Instead it uses 32GB of memory then dies. By the speed that it does this I expect it would happily get to 1TB of memory if it could. The memory appears to increase in a linear fashion with the size of the files being loaded, meaning that it appears to never clear any memory at all. Everything that enters the app is allocated more memory and memory is never freed.

I tried implementing runtime.GC() in case the garbage collection wasn't running often enough, but this made no difference.

Since the memory usage increases in a linear fashion then this would imply that there is a memory leak in GetTokens() or LoadZip(). I don't know how this could be, since they are both functions and only do one task and then close. Or it could be that the tokens variable in Start() is the cause of the leak. Basically it looks like every file that is loaded and parsed is never released from memory, as that is the only way that the memory could fill up in a linear fashion and keep on rising up to 32GB++.

Absolute nightmare! What's wrong with Go? Any way to fix this?

","['I', 'am', 'very,', 'very', 'memory', 'careful', 'as', 'I', 'have', 'to', 'write', 'programs', 'that', 'need', 'to', 'cope', 'with', 'massive', 'datasets.', 'Currently', 'my', 'application', 'quickly', 'reaches', '32GB', 'of', 'memory,', 'starts', 'swapping,', 'and', 'then', 'gets', 'killed', 'by', 'the', 'system.', 'I', 'do', 'not', 'understand', 'how', 'this', 'can', 'be', 'since', 'all', 'variables', 'are', 'collectable', '(in', 'functions', 'and', 'quickly', 'released)', 'except', 'TokensStruct', 'and', 'TokensCount', 'in', 'the', 'Trainer', 'struct.', 'TokensCount', 'is', 'just', 'a', 'uint.', 'TokensStruct', 'is', 'a', '1,000,000', 'row', 'slice', 'of', '[5]uint32', 'and', 'string,', 'so', 'that', 'means', '20', 'bytes', '+', 'string,', 'which', 'we', 'could', 'call', 'a', 'maximum', 'of', '50', 'bytes', 'per', 'record.', '50*1000000', '=', '50MB', 'of', 'memory', 'required.', 'So', 'this', 'script', 'should', 'therefore', 'not', 'use', 'much', 'more', 'than', '50MB', '+', 'overhead', '+', 'temporary', 'collectable', 'variables', 'in', 'the', 'functions', '(maybe', 'another', '50MB', 'max.)', 'The', 'maximum', 'potential', 'size', 'of', 'TokensStruct', 'is', '5,000,000,', 'as', 'this', 'is', 'the', 'size', 'of', 'dictionary,', 'but', 'even', 'then', 'it', 'would', 'be', 'only', '250MB', 'of', 'memory.', 'dictionary', 'is', 'a', 'map', 'and', 'apparently', 'uses', 'around', '600MB', 'of', 'memory,', 'as', 'that', 'is', 'how', 'the', 'app', 'starts,', 'but', 'this', 'is', 'not', 'an', 'issue', 'because', 'dictionary', 'is', 'only', 'loaded', 'once', 'and', 'never', 'written', 'to', 'again.', 'Instead', 'it', 'uses', '32GB', 'of', 'memory', 'then', 'dies.', 'By', 'the', 'speed', 'that', 'it', 'does', 'this', 'I', 'expect', 'it', 'would', 'happily', 'get', 'to', '1TB', 'of', 'memory', 'if', 'it', 'could.', 'The', 'memory', 'appears', 'to', 'increase', 'in', 'a', 'linear', 'fashion', 'with', 'the', 'size', 'of', 'the', 'files', 'being', 'loaded,', 'meaning', 'that', 'it', 'appears', 'to', 'never', 'clear', 'any', 'memory', 'at', 'all.', 'Everything', 'that', 'enters', 'the', 'app', 'is', 'allocated', 'more', 'memory', 'and', 'memory', 'is', 'never', 'freed.', 'I', 'tried', 'implementing', 'runtime.GC()', 'in', 'case', 'the', 'garbage', 'collection', ""wasn't"", 'running', 'often', 'enough,', 'but', 'this', 'made', 'no', 'difference.', 'Since', 'the', 'memory', 'usage', 'increases', 'in', 'a', 'linear', 'fashion', 'then', 'this', 'would', 'imply', 'that', 'there', 'is', 'a', 'memory', 'leak', 'in', 'GetTokens()', 'or', 'LoadZip().', 'I', ""don't"", 'know', 'how', 'this', 'could', 'be,', 'since', 'they', 'are', 'both', 'functions', 'and', 'only', 'do', 'one', 'task', 'and', 'then', 'close.', 'Or', 'it', 'could', 'be', 'that', 'the', 'tokens', 'variable', 'in', 'Start()', 'is', 'the', 'cause', 'of', 'the', 'leak.', 'Basically', 'it', 'looks', 'like', 'every', 'file', 'that', 'is', 'loaded', 'and', 'parsed', 'is', 'never', 'released', 'from', 'memory,', 'as', 'that', 'is', 'the', 'only', 'way', 'that', 'the', 'memory', 'could', 'fill', 'up', 'in', 'a', 'linear', 'fashion', 'and', 'keep', 'on', 'rising', 'up', 'to', '32GB++.', 'Absolute', 'nightmare!', ""What's"", 'wrong', 'with', 'Go?', 'Any', 'way', 'to', 'fix', 'this?']","['PRP', 'VBP', 'JJ', 'RB', 'RB', 'JJ', 'IN', 'PRP', 'VBP', 'TO', 'VB', 'NNS', 'WDT', 'VBP', 'TO', 'VB', 'IN', 'JJ', 'NN', 'NNP', 'PRP$', 'NN', 'RB', 'VBZ', 'CD', 'IN', 'NN', 'NNS', 'NN', 'CC', 'RB', 'VBZ', 'VBN', 'IN', 'DT', 'NN', 'PRP', 'VBP', 'RB', 'VB', 'WRB', 'DT', 'MD', 'VB', 'IN', 'DT', 'NNS', 'VBP', 'JJ', 'JJ', 'NNS', 'CC', 'RB', 'VB', 'IN', 'NNP', 'CC', 'NNP', 'IN', 'DT', 'NNP', 'NN', 'NNP', 'VBZ', 'RB', 'DT', 'JJ', 'NN', 'VBZ', 'DT', 'CD', 'NN', 'NN', 'IN', 'NN', 'CC', 'NN', 'RB', 'IN', 'VBZ', 'CD', 'NNS', 'VBP', 'NN', 'WDT', 'PRP', 'MD', 'VB', 'DT', 'NN', 'IN', 'CD', 'NNS', 'IN', 'NN', 'CD', 'JJ', 'CD', 'IN', 'NN', 'NN', 'IN', 'DT', 'NN', 'MD', 'VB', 'RB', 'RB', 'RB', 'JJR', 'IN', 'CD', 'JJ', 'JJ', 'NN', 'JJ', 'JJ', 'NNS', 'IN', 'DT', 'NNS', 'VBP', 'DT', 'CD', 'NN', 'DT', 'JJ', 'JJ', 'NN', 'IN', 'NNP', 'VBZ', 'CD', 'IN', 'DT', 'VBZ', 'DT', 'NN', 'IN', 'NN', 'CC', 'RB', 'RB', 'PRP', 'MD', 'VB', 'RB', 'CD', 'IN', 'NN', 'NN', 'VBZ', 'DT', 'NN', 'CC', 'RB', 'VBZ', 'IN', 'CD', 'IN', 'NN', 'IN', 'DT', 'VBZ', 'WRB', 'DT', 'JJ', 'NN', 'CC', 'DT', 'VBZ', 'RB', 'DT', 'NN', 'IN', 'NN', 'VBZ', 'RB', 'JJ', 'RB', 'CC', 'RB', 'VBN', 'TO', 'VB', 'RB', 'PRP', 'VBZ', 'CD', 'IN', 'NN', 'RB', 'VBN', 'IN', 'DT', 'NN', 'IN', 'PRP', 'VBZ', 'DT', 'PRP', 'VBP', 'PRP', 'MD', 'RB', 'VB', 'TO', 'CD', 'IN', 'NN', 'IN', 'PRP', 'VBZ', 'DT', 'NN', 'VBZ', 'TO', 'VB', 'IN', 'DT', 'JJ', 'NN', 'IN', 'DT', 'NN', 'IN', 'DT', 'NNS', 'VBG', 'JJ', 'NN', 'IN', 'PRP', 'VBZ', 'TO', 'RB', 'JJ', 'DT', 'NN', 'IN', 'NN', 'NN', 'WDT', 'VBZ', 'DT', 'NN', 'VBZ', 'VBN', 'JJR', 'NN', 'CC', 'NN', 'VBZ', 'RB', 'VBN', 'PRP', 'VBD', 'VBG', 'NN', 'IN', 'NN', 'DT', 'NN', 'NN', 'IN', 'VBG', 'RB', 'RB', 'CC', 'DT', 'VBD', 'DT', 'NN', 'IN', 'DT', 'NN', 'NN', 'NNS', 'IN', 'DT', 'JJ', 'NN', 'RB', 'DT', 'MD', 'VB', 'IN', 'EX', 'VBZ', 'DT', 'NN', 'NN', 'IN', 'NNP', 'CC', 'NNP', 'PRP', 'VBP', 'VB', 'WRB', 'DT', 'MD', 'VB', 'IN', 'PRP', 'VBP', 'DT', 'NNS', 'CC', 'RB', 'VBP', 'CD', 'NN', 'CC', 'RB', 'NN', 'CC', 'PRP', 'MD', 'VB', 'IN', 'DT', 'NNS', 'JJ', 'IN', 'NNP', 'VBZ', 'DT', 'NN', 'IN', 'DT', 'NN', 'NNP', 'PRP', 'VBZ', 'IN', 'DT', 'NN', 'WDT', 'VBZ', 'VBN', 'CC', 'VBN', 'VBZ', 'RB', 'VBN', 'IN', 'NN', 'IN', 'DT', 'VBZ', 'DT', 'JJ', 'NN', 'IN', 'DT', 'NN', 'MD', 'VB', 'RP', 'IN', 'DT', 'JJ', 'NN', 'CC', 'VB', 'IN', 'VBG', 'RP', 'TO', 'CD', 'NNP', 'NN', 'NNP', 'JJ', 'IN', 'NNP', 'NNP', 'NN', 'TO', 'VB', 'NN']"
1,package main,"['package', 'main']","['KEYWORD', 'IDENTIFIER']"
2,import (,"['import', '(']","['KEYWORD', 'OPERATOR']"
3,"    ""bytes""","['""bytes""']",['STRING_LITERAL']
4,"    ""code.google.com/p/go.text/transform""","['""code.google.com/p/go.text/transform""']",['STRING_LITERAL']
5,"    ""code.google.com/p/go.text/unicode/norm""","['""code.google.com/p/go.text/unicode/norm""']",['STRING_LITERAL']
6,"    ""compress/zlib""","['""compress/zlib""']",['STRING_LITERAL']
7,"    ""encoding/gob""","['""encoding/gob""']",['STRING_LITERAL']
8,"    ""fmt""","['""fmt""']",['STRING_LITERAL']
9,"    ""github.com/AlasdairF/BinSearch""","['""github.com/AlasdairF/BinSearch""']",['STRING_LITERAL']
10,"    ""io/ioutil""","['""io/ioutil""']",['STRING_LITERAL']
11,"    ""os""","['""os""']",['STRING_LITERAL']
12,"    ""regexp""","['""regexp""']",['STRING_LITERAL']
13,"    ""runtime""","['""runtime""']",['STRING_LITERAL']
14,"    ""strings""","['""strings""']",['STRING_LITERAL']
15,"    ""unicode""","['""unicode""']",['STRING_LITERAL']
16,"    ""unicode/utf8""","['""unicode/utf8""']",['STRING_LITERAL']
17,),[')'],['OPERATOR']
18,type TokensStruct struct {,"['type', 'TokensStruct', 'struct', '{']","['KEYWORD', 'IDENTIFIER', 'KEYWORD', 'OPERATOR']"
19,    binsearch.Key_string,"['binsearch', '.', 'Key_string']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER']"
20,    Value [][5]uint32,"['Value', '[][', '5', ']', 'uint32']","['IDENTIFIER', 'OPERATOR', 'DECIMAL_LITERAL', 'OPERATOR', 'IDENTIFIER']"
21,},['}'],['OPERATOR']
22,type Trainer struct {,"['type', 'Trainer', 'struct', '{']","['KEYWORD', 'IDENTIFIER', 'KEYWORD', 'OPERATOR']"
23,    Tokens      TokensStruct,"['Tokens', 'TokensStruct']","['IDENTIFIER', 'IDENTIFIER']"
24,    TokensCount uint,"['TokensCount', 'uint']","['IDENTIFIER', 'IDENTIFIER']"
25,},['}'],['OPERATOR']
26,func checkErr(err error) {,"['func', 'checkErr', '(', 'err', 'error', ')', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'IDENTIFIER', 'OPERATOR', 'OPERATOR']"
27,    if err == nil {,"['if', 'err', '==', 'nil', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
28,        return,['return'],['KEYWORD']
29,    },['}'],['OPERATOR']
30,"    fmt.Println(`Some Error:`, err)","['fmt', '.', 'Println', '(', 'Some', 'Error', ':', ',', 'err', ')']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'IDENTIFIER', 'OPERATOR', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
31,    panic(err),"['panic', '(', 'err', ')']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
32,},['}'],['OPERATOR']
33,// Local helper function for normalization of UTF8 strings.,"['//', 'Local', 'helper', 'function', 'for', 'normalization', 'of', 'UTF8', 'strings.']","['COMMENT', 'JJ', 'NN', 'NN', 'IN', 'NN', 'IN', 'NNP', 'NN']"
34,func isMn(r rune) bool {,"['func', 'isMn', '(', 'r', 'rune', ')', 'bool', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
35,"    return unicode.Is(unicode.Mn, r) // Mn: nonspacing marks","['//', 'Mn:', 'nonspacing', 'marks']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'COMMENT', 'NNP', 'NN', 'NNS']"
36,},['}'],['OPERATOR']
37,// This map is used by RemoveAccents function to convert non-accented characters.,"['//', 'This', 'map', 'is', 'used', 'by', 'RemoveAccents', 'function', 'to', 'convert', 'non-accented', 'characters.']","['COMMENT', 'DT', 'NN', 'VBZ', 'VBN', 'IN', 'NNP', 'NN', 'TO', 'VB', 'JJ', 'NN']"
38,"var transliterations = map[rune]string{'Æ': ""E"", 'Ð': ""D"", 'Ł': ""L"", 'Ø': ""OE"", 'Þ': ""Th"", 'ß': ""ss"", 'æ': ""e"", 'ð': ""d"", 'ł': ""l"", 'ø': ""oe"", 'þ': ""th"", 'Œ': ""OE"", 'œ': ""oe""}","['var', 'transliterations', '=', 'map', '[', 'rune', ']', 'string', '{', ':', '""E"", \'Ð\': ""D"", \'Ł\': ""L"", \'Ø\': ""OE"", \'Þ\': ""Th"", \'ß\': ""ss"", \'æ\': ""e"", \'ð\': ""d"", \'ł\': ""l"", \'ø\': ""oe"", \'þ\': ""th"", \'Œ\': ""OE"", \'œ\': ""oe""', '}']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'KEYWORD', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'OPERATOR', 'STRING_LITERAL', 'OPERATOR']"
39,"//  removeAccentsBytes converts accented UTF8 characters into their non-accented equivalents, from a []byte.","['//', 'removeAccentsBytes', 'converts', 'accented', 'UTF8', 'characters', 'into', 'their', 'non-accented', 'equivalents,', 'from', 'a', '[]byte.']","['COMMENT', 'NNS', 'NNS', 'VBD', 'NNP', 'NNS', 'IN', 'PRP$', 'JJ', 'NN', 'IN', 'DT', 'NN']"
40,"func removeAccentsBytesDashes(b []byte) ([]byte, error) {","['func', 'removeAccentsBytesDashes', '(', 'b', '[]', 'byte', ')', '([]', 'byte', ',', 'error', ')', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'OPERATOR']"
41,"    mnBuf := make([]byte, len(b))","['mnBuf', ':=', 'make', '([]', 'byte', ',', 'len', '(', 'b', '))']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
42,"    t := transform.Chain(norm.NFD, transform.RemoveFunc(isMn), norm.NFC)","['t', ':=', 'transform', '.', 'Chain', '(', 'norm', '.', 'NFD', ',', 'transform', '.', 'RemoveFunc', '(', 'isMn', '),', 'norm', '.', 'NFC', ')']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
43,"    n, _, err := t.Transform(mnBuf, b, true)","['n', ',', '_', ',', 'err', ':=', 't', '.', 'Transform', '(', 'mnBuf', ',', 'b', ',', 'true', ')']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
44,    if err != nil {,"['if', 'err', '!=', 'nil', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
45,"        return nil, err","['return', 'nil', ',', 'err']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER']"
46,    },['}'],['OPERATOR']
47,    mnBuf = mnBuf[:n],"['mnBuf', '=', 'mnBuf', '[:', 'n', ']']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
48,"    tlBuf := bytes.NewBuffer(make([]byte, 0, len(mnBuf)*2))","['tlBuf', ':=', 'bytes', '.', 'NewBuffer', '(', 'make', '([]', 'byte', ',', '0', ',', 'len', '(', 'mnBuf', ')*', '2', '))']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'DECIMAL_LITERAL', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'DECIMAL_LITERAL', 'OPERATOR']"
49,"    for i, w := 0, 0; i < len(mnBuf); i += w {","['for', 'i', ',', 'w', ':=', '0', ',', '0', ';', 'i', '<', 'len', '(', 'mnBuf', ');', 'i', '+=', 'w', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'DECIMAL_LITERAL', 'OPERATOR', 'DECIMAL_LITERAL', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
50,"        r, width := utf8.DecodeRune(mnBuf[i:])","['r', ',', 'width', ':=', 'utf8', '.', 'DecodeRune', '(', 'mnBuf', '[', 'i', ':])']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
51,        if r == '-' {,"['if', 'r', '==', '-', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'OPERATOR', 'OPERATOR']"
52,            tlBuf.WriteByte(' '),"['tlBuf', '.', 'WriteByte', '(', ')']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'OPERATOR']"
53,        } else {,"['}', 'else', '{']","['OPERATOR', 'KEYWORD', 'OPERATOR']"
54,"            if d, ok := transliterations[r]; ok {","['if', 'd', ',', 'ok', ':=', 'transliterations', '[', 'r', '];', 'ok', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
55,                tlBuf.WriteString(d),"['tlBuf', '.', 'WriteString', '(', 'd', ')']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
56,            } else {,"['}', 'else', '{']","['OPERATOR', 'KEYWORD', 'OPERATOR']"
57,                tlBuf.WriteRune(r),"['tlBuf', '.', 'WriteRune', '(', 'r', ')']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
58,            },['}'],['OPERATOR']
59,        },['}'],['OPERATOR']
60,        w = width,"['w', '=', 'width']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER']"
61,    },['}'],['OPERATOR']
62,"    return tlBuf.Bytes(), nil","['return', 'tlBuf', '.', 'Bytes', '(),', 'nil']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER']"
63,},['}'],['OPERATOR']
64,"func LoadZip(filename string) ([]byte, error) {","['func', 'LoadZip', '(', 'filename', 'string', ')', '([]', 'byte', ',', 'error', ')', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'IDENTIFIER', 'OPERATOR', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'OPERATOR']"
65,    // Open file for reading,"['//', 'Open', 'file', 'for', 'reading']","['COMMENT', 'NNP', 'NN', 'IN', 'NN']"
66,"    fi, err := os.Open(filename)","['fi', ',', 'err', ':=', 'os', '.', 'Open', '(', 'filename', ')']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
67,    if err != nil {,"['if', 'err', '!=', 'nil', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
68,"        return nil, err","['return', 'nil', ',', 'err']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER']"
69,    },['}'],['OPERATOR']
70,    defer fi.Close(),"['defer', 'fi', '.', 'Close', '()']","['IDENTIFIER', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
71,    // Attach ZIP reader,"['//', 'Attach', 'ZIP', 'reader']","['COMMENT', 'NNP', 'NNP', 'NN']"
72,"    fz, err := zlib.NewReader(fi)","['fz', ',', 'err', ':=', 'zlib', '.', 'NewReader', '(', 'fi', ')']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
73,    if err != nil {,"['if', 'err', '!=', 'nil', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
74,"        return nil, err","['return', 'nil', ',', 'err']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER']"
75,    },['}'],['OPERATOR']
76,    defer fz.Close(),"['defer', 'fz', '.', 'Close', '()']","['IDENTIFIER', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
77,    // Pull,"['//', 'Pull']","['COMMENT', 'NN']"
78,"    data, err := ioutil.ReadAll(fz)","['data', ',', 'err', ':=', 'ioutil', '.', 'ReadAll', '(', 'fz', ')']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
79,    if err != nil {,"['if', 'err', '!=', 'nil', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
80,"        return nil, err","['return', 'nil', ',', 'err']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER']"
81,    },['}'],['OPERATOR']
82,"    return norm.NFC.Bytes(data), nil // return normalized","['//', 'return', 'normalized']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'COMMENT', 'NN', 'VBD']"
83,},['}'],['OPERATOR']
84,func getTokens(pibn string) []string {,"['func', 'getTokens', '(', 'pibn', 'string', ')', '[]', 'string', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'IDENTIFIER', 'OPERATOR', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
85,    var data []byte,"['var', 'data', '[]', 'byte']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER']"
86,    var err error,"['var', 'err', 'error']","['KEYWORD', 'IDENTIFIER', 'IDENTIFIER']"
87,"    data, err = LoadZip(`/storedir/` + pibn + `/text.zip`)","['data', ',', 'err', '=', 'LoadZip', '(', 'storedir', '+', 'pibn', '+', 'text', '.', 'zip', ')']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
88,    checkErr(err),"['checkErr', '(', 'err', ')']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
89,"    data, err = removeAccentsBytesDashes(data)","['data', ',', 'err', '=', 'removeAccentsBytesDashes', '(', 'data', ')']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
90,    checkErr(err),"['checkErr', '(', 'err', ')']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
91,    data = bytes.ToLower(data),"['data', '=', 'bytes', '.', 'ToLower', '(', 'data', ')']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
92,"    data = reg2.ReplaceAll(data, []byte(""$2"")) // remove contractions","['//', 'remove', 'contractions']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'STRING_LITERAL', 'OPERATOR', 'COMMENT', 'VB', 'NNS']"
93,"    data = reg.ReplaceAllLiteral(data, nil)","['data', '=', 'reg', '.', 'ReplaceAllLiteral', '(', 'data', ',', 'nil', ')']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
94,    tokens := strings.Fields(string(data)),"['tokens', ':=', 'strings', '.', 'Fields', '(', 'string', '(', 'data', '))']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
95,    return tokens,"['return', 'tokens']","['KEYWORD', 'IDENTIFIER']"
96,},['}'],['OPERATOR']
97,func (t *Trainer) Start() {,"['func', '(', 't', '*', 'Trainer', ')', 'Start', '()', '{']","['KEYWORD', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'OPERATOR']"
98,"    data, err := ioutil.ReadFile(`list.txt`)","['data', ',', 'err', ':=', 'ioutil', '.', 'ReadFile', '(', 'list', '.', 'txt', ')']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
99,    checkErr(err),"['checkErr', '(', 'err', ')']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
100,    pibns := bytes.Fields(data),"['pibns', ':=', 'bytes', '.', 'Fields', '(', 'data', ')']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
101,"    for i, pibn := range pibns {","['for', 'i', ',', 'pibn', ':=', 'range', 'pibns', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'KEYWORD', 'IDENTIFIER', 'OPERATOR']"
102,        tokens := getTokens(string(pibn)),"['tokens', ':=', 'getTokens', '(', 'string', '(', 'pibn', '))']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
103,        t.addTokens(tokens),"['t', '.', 'addTokens', '(', 'tokens', ')']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
104,        if i%100 == 0 {,"['if', 'i', '100', '==', '0', '{']","['KEYWORD', 'IDENTIFIER', 'DECIMAL_LITERAL', 'OPERATOR', 'DECIMAL_LITERAL', 'OPERATOR']"
105,"            runtime.GC() // I added this just to try to stop the memory craziness, but it makes no difference","['//', 'I', 'added', 'this', 'just', 'to', 'try', 'to', 'stop', 'the', 'memory', 'craziness,', 'but', 'it', 'makes', 'no', 'difference']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'COMMENT', 'PRP', 'VBD', 'DT', 'RB', 'TO', 'VB', 'TO', 'VB', 'DT', 'NN', 'NN', 'CC', 'PRP', 'VBZ', 'DT', 'NN']"
106,        },['}'],['OPERATOR']
107,    },['}'],['OPERATOR']
108,},['}'],['OPERATOR']
109,func (t *Trainer) addTokens(tokens []string) {,"['func', '(', 't', '*', 'Trainer', ')', 'addTokens', '(', 'tokens', '[]', 'string', ')', '{']","['KEYWORD', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'OPERATOR']"
110,"    for _, tok := range tokens {","['for', '_', ',', 'tok', ':=', 'range', 'tokens', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'KEYWORD', 'IDENTIFIER', 'OPERATOR']"
111,"        if _, ok := dictionary[tok]; ok {","['if', '_', ',', 'ok', ':=', 'dictionary', '[', 'tok', '];', 'ok', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
112,"            if indx, ok2 := t.Tokens.Find(tok); ok2 {","['if', 'indx', ',', 'ok2', ':=', 't', '.', 'Tokens', '.', 'Find', '(', 'tok', ');', 'ok2', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
113,                ar := t.Tokens.Value[indx],"['ar', ':=', 't', '.', 'Tokens', '.', 'Value', '[', 'indx', ']']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
114,                ar[0]++,"['ar', '[', '0', ']++']","['IDENTIFIER', 'OPERATOR', 'DECIMAL_LITERAL', 'OPERATOR']"
115,                t.Tokens.Value[indx] = ar,"['t', '.', 'Tokens', '.', 'Value', '[', 'indx', ']', '=', 'ar']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'OPERATOR', 'IDENTIFIER']"
116,                t.TokensCount++,"['t', '.', 'TokensCount', '++']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
117,            } else {,"['}', 'else', '{']","['OPERATOR', 'KEYWORD', 'OPERATOR']"
118,"                t.Tokens.AddKeyAt(tok, indx)","['t', '.', 'Tokens', '.', 'AddKeyAt', '(', 'tok', ',', 'indx', ')']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
119,"                t.Tokens.Value = append(t.Tokens.Value, [5]uint32{0, 0, 0, 0, 0})","['t', '.', 'Tokens', '.', 'Value', '=', 'append', '(', 't', '.', 'Tokens', '.', 'Value', ',', '[', '5', ']', 'uint32', '{', '0', ',', '0', ',', '0', ',', '0', ',', '0', '})']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'OPERATOR', 'DECIMAL_LITERAL', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'DECIMAL_LITERAL', 'OPERATOR', 'DECIMAL_LITERAL', 'OPERATOR', 'DECIMAL_LITERAL', 'OPERATOR', 'DECIMAL_LITERAL', 'OPERATOR', 'DECIMAL_LITERAL', 'OPERATOR']"
120,"                copy(t.Tokens.Value[indx+1:], t.Tokens.Value[indx:])","['copy', '(', 't', '.', 'Tokens', '.', 'Value', '[', 'indx', '+', '1', ':],', 't', '.', 'Tokens', '.', 'Value', '[', 'indx', ':])']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'DECIMAL_LITERAL', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
121,"                t.Tokens.Value[indx] = [5]uint32{1, 0, 0, 0, 0}","['t', '.', 'Tokens', '.', 'Value', '[', 'indx', ']', '=', '[', '5', ']', 'uint32', '{', '1', ',', '0', ',', '0', ',', '0', ',', '0', '}']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'OPERATOR', 'OPERATOR', 'DECIMAL_LITERAL', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'DECIMAL_LITERAL', 'OPERATOR', 'DECIMAL_LITERAL', 'OPERATOR', 'DECIMAL_LITERAL', 'OPERATOR', 'DECIMAL_LITERAL', 'OPERATOR', 'DECIMAL_LITERAL', 'OPERATOR']"
122,                t.TokensCount++,"['t', '.', 'TokensCount', '++']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
123,            },['}'],['OPERATOR']
124,        },['}'],['OPERATOR']
125,    },['}'],['OPERATOR']
126,    return,['return'],['KEYWORD']
127,},['}'],['OPERATOR']
128,func LoadDictionary() {,"['func', 'LoadDictionary', '()', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'OPERATOR']"
129,    dictionary = make(map[string]bool),"['dictionary', '=', 'make', '(', 'map', '[', 'string', ']', 'bool', ')']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'KEYWORD', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
130,"    data, err := ioutil.ReadFile(`dictionary`)","['data', ',', 'err', ':=', 'ioutil', '.', 'ReadFile', '(', 'dictionary', ')']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
131,    checkErr(err),"['checkErr', '(', 'err', ')']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
132,    words := bytes.Fields(data),"['words', ':=', 'bytes', '.', 'Fields', '(', 'data', ')']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
133,"    for _, word := range words {","['for', '_', ',', 'word', ':=', 'range', 'words', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'KEYWORD', 'IDENTIFIER', 'OPERATOR']"
134,        strword := string(word),"['strword', ':=', 'string', '(', 'word', ')']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
135,        dictionary[strword] = false,"['dictionary', '[', 'strword', ']', '=', 'false']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'OPERATOR', 'IDENTIFIER']"
136,    },['}'],['OPERATOR']
137,},['}'],['OPERATOR']
138,var reg = regexp.MustCompile(`[^a-z0-9\s]`),"['var', 'reg', '=', 'regexp', '.', 'MustCompile', '(', '[^', 'a', '-', 'z0', '-', '9', 's', ']', ')']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'DECIMAL_LITERAL', 'IDENTIFIER', 'OPERATOR', 'OPERATOR']"
139,var reg2 = regexp.MustCompile(`\b(c|l|all|dall|dell|nell|sull|coll|pell|gl|agl|dagl|degl|negl|sugl|un|m|t|s|v|d|qu|n|j)'([a-z])`) //contractions,"['//', 'contractions']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'OPERATOR', 'COMMENT', 'NNS']"
140,var dictionary map[string]bool,"['var', 'dictionary', 'map', '[', 'string', ']', 'bool']","['KEYWORD', 'IDENTIFIER', 'KEYWORD', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER']"
141,func main() {,"['func', 'main', '()', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'OPERATOR']"
142,    trainer := new(Trainer),"['trainer', ':=', 'new', '(', 'Trainer', ')']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
143,    LoadDictionary(),"['LoadDictionary', '()']","['IDENTIFIER', 'OPERATOR']"
144,    trainer.Start(),"['trainer', '.', 'Start', '()']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
145,},['}'],['OPERATOR']
