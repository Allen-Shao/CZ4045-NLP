,text,token
0,"In the big picture, I'm trying to implement Dijkstra's algorithm using a priority queue. 

According to members of golang-nuts, the idiomatic way to do this in Go is to use the heap interface with a custom underlying data structure. So I have created Node.go and PQueue.go like so:

","['In', 'the', 'big', 'picture,', ""I'm"", 'trying', 'to', 'implement', ""Dijkstra's"", 'algorithm', 'using', 'a', 'priority', 'queue.', 'According', 'to', 'members', 'of', 'golang-nuts,', 'the', 'idiomatic', 'way', 'to', 'do', 'this', 'in', 'Go', 'is', 'to', 'use', 'the', 'heap', 'interface', 'with', 'a', 'custom', 'underlying', 'data', 'structure.', 'So', 'I', 'have', 'created', 'Node.go', 'and', 'PQueue.go', 'like', 'so:']"
1,//Node.go,"['//', 'Node.go']"
2,package pqueue,"['package', 'pqueue']"
3,type Node struct {,"['type', 'Node', 'struct', '{']"
4,    row    int,"['row', 'int']"
5,    col    int,"['col', 'int']"
6,    myVal  int,"['myVal', 'int']"
7,    sumVal int,"['sumVal', 'int']"
8,},['}']
9,"func (n *Node) Init(r, c, mv, sv int) {","['func', '(', 'n', '*', 'Node', ')', 'Init', '(', 'r', ',', 'c', ',', 'mv', ',', 'sv', 'int', ')', '{']"
10,    n.row = r,"['n', '.', 'row', '=', 'r']"
11,    n.col = c,"['n', '.', 'col', '=', 'c']"
12,    n.myVal = mv,"['n', '.', 'myVal', '=', 'mv']"
13,    n.sumVal = sv,"['n', '.', 'sumVal', '=', 'sv']"
14,},['}']
15,func (n *Node) Equals(o *Node) bool {,"['func', '(', 'n', '*', 'Node', ')', 'Equals', '(', 'o', '*', 'Node', ')', 'bool', '{']"
16,    return n.row == o.row && n.col == o.col,"['return', 'n', '.', 'row', '==', 'o', '.', 'row', '&&', 'n', '.', 'col', '==', 'o', '.', 'col']"
17,},['}']
18,"

And PQueue.go: 

","['And', 'PQueue.go:']"
19,// PQueue.go,"['//', 'PQueue.go']"
20,package pqueue,"['package', 'pqueue']"
21,"import ""container/vector""","['import', '""container/vector""']"
22,"import ""container/heap""","['import', '""container/heap""']"
23,type PQueue struct {,"['type', 'PQueue', 'struct', '{']"
24,    data vector.Vector,"['data', 'vector', '.', 'Vector']"
25,    size int,"['size', 'int']"
26,},['}']
27,func (pq *PQueue) Init() {,"['func', '(', 'pq', '*', 'PQueue', ')', 'Init', '()', '{']"
28,    heap.Init(pq),['heap.Init(pq)']
29,},['}']
30,func (pq *PQueue) IsEmpty() bool {,"['func', '(', 'pq', '*', 'PQueue', ')', 'IsEmpty', '()', 'bool', '{']"
31,    return pq.size == 0,"['return', 'pq', '.', 'size', '==', '0']"
32,},['}']
33,func (pq *PQueue) Push(i interface{}) {,"['func', '(', 'pq', '*', 'PQueue', ')', 'Push', '(', 'i', 'interface', '{})', '{']"
34,"    heap.Push(pq, i)","['heap.Push(pq, i)']"
35,    pq.size++,"['pq', '.', 'size', '++']"
36,},['}']
37,func (pq *PQueue) Pop() interface{} {,"['func', '(', 'pq', '*', 'PQueue', ')', 'Pop', '()', 'interface', '{}', '{']"
38,    pq.size--,"['pq', '.', 'size', '--']"
39,    return heap.Pop(pq),"['return', 'heap.Pop(pq)']"
40,},['}']
41,func (pq *PQueue) Len() int {,"['func', '(', 'pq', '*', 'PQueue', ')', 'Len', '()', 'int', '{']"
42,    return pq.size,"['return', 'pq', '.', 'size']"
43,},['}']
44,"func (pq *PQueue) Less(i, j int) bool {","['func', '(', 'pq', '*', 'PQueue', ')', 'Less', '(', 'i', ',', 'j', 'int', ')', 'bool', '{']"
45,    I := pq.data.At(i).(Node),"['I', ':=', 'pq', '.', 'data.At(i).(Node)']"
46,    J := pq.data.At(j).(Node),"['J', ':=', 'pq', '.', 'data.At(j).(Node)']"
47,    return (I.sumVal + I.myVal) < (J.sumVal + J.myVal),"['return', '(', 'I', '.', 'sumVal', '+', 'I', '.', 'myVal', ')', '<', '(', 'J', '.', 'sumVal', '+', 'J', '.', 'myVal', ')']"
48,},['}']
49,"func (pq *PQueue) Swap(i, j int) {","['func', '(', 'pq', '*', 'PQueue', ')', 'Swap', '(', 'i', ',', 'j', 'int', ')', '{']"
50,    temp := pq.data.At(i).(Node),"['temp', ':=', 'pq', '.', 'data.At(i).(Node)']"
51,"    pq.data.Set(i, pq.data.At(j).(Node))","['pq', '.', 'data.Set(i, pq.data.At(j).(Node))']"
52,"    pq.data.Set(j, temp)","['pq', '.', 'data.Set(j, temp)']"
53,},['}']
54,"

And main.go: (the action is in SolveMatrix)

","['And', 'main.go:', '(the', 'action', 'is', 'in', 'SolveMatrix)']"
55,// Euler 81,"['//', 'Euler', '81']"
56,package main,"['package', 'main']"
57,"import ""fmt""","['import', '""fmt""']"
58,"import ""io/ioutil""","['import', '""io/ioutil""']"
59,"import ""strings""","['import', '""strings""']"
60,"import ""strconv""","['import', '""strconv""']"
61,"import ""./pqueue""","['import', '""./pqueue""']"
62,const MATSIZE = 5,"['const', 'MATSIZE', '=', '5']"
63,"const MATNAME = ""matrix_small.txt""","['const', 'MATNAME', '=', '""matrix_small.txt""']"
64,func main() {,"['func', 'main', '()', '{']"
65,    var matrix [MATSIZE][MATSIZE]int,"['var', 'matrix', '[', 'MATSIZE', '][', 'MATSIZE', ']', 'int']"
66,"    contents, err := ioutil.ReadFile(MATNAME)","['contents', ',', 'err', ':=', 'ioutil.ReadFile(MATNAME)']"
67,    if err != nil {,"['if', 'err', '!=', 'nil', '{']"
68,"        panic(""FILE IO ERROR!"")","['panic', '(', '""FILE IO ERROR!""', ')']"
69,    },['}']
70,    inFileStr := string(contents),"['inFileStr', ':=', 'string', '(', 'contents', ')']"
71,"    byrows := strings.Split(inFileStr, ""\n"", -1)","['byrows', ':=', 'strings.Split(inFileStr, ""\\n"", -1)']"
72,    for row := 0; row < MATSIZE; row++ {,"['for', 'row', ':=', '0', ';', 'row', '<', 'MATSIZE', ';', 'row', '++', '{']"
73,        byrows[row] = (byrows[row])[0 : len(byrows[row])-1],"['byrows', '[', 'row', ']', '=', '(', 'byrows', '[', 'row', '])[', '0', ':', 'len', '(', 'byrows', '[', 'row', '])-', '1', ']']"
74,"        bycols := strings.Split(byrows[row], "","", -1)","['bycols', ':=', 'strings.Split(byrows[row], "","", -1)']"
75,        for col := 0; col < MATSIZE; col++ {,"['for', 'col', ':=', '0', ';', 'col', '<', 'MATSIZE', ';', 'col', '++', '{']"
76,"            matrix[row][col], _ = strconv.Atoi(bycols[col])","['matrix', '[', 'row', '][', 'col', '],', '_', '=', 'strconv.Atoi(bycols[col])']"
77,        },['}']
78,    },['}']
79,    PrintMatrix(matrix),"['PrintMatrix', '(', 'matrix', ')']"
80,"    sum, len := SolveMatrix(matrix)","['sum', ',', 'len', ':=', 'SolveMatrix', '(', 'matrix', ')']"
81,"    fmt.Printf(""len: %d, sum: %d\n"", len, sum)","['fmt.Printf(""len: %d, sum: %d\\n"", len, sum)']"
82,},['}']
83,func PrintMatrix(mat [MATSIZE][MATSIZE]int) {,"['func', 'PrintMatrix', '(', 'mat', '[', 'MATSIZE', '][', 'MATSIZE', ']', 'int', ')', '{']"
84,    for r := 0; r < MATSIZE; r++ {,"['for', 'r', ':=', '0', ';', 'r', '<', 'MATSIZE', ';', 'r', '++', '{']"
85,        for c := 0; c < MATSIZE; c++ {,"['for', 'c', ':=', '0', ';', 'c', '<', 'MATSIZE', ';', 'c', '++', '{']"
86,"            fmt.Printf(""%d "", mat[r][c])","['fmt.Printf(""%d "", mat[r][c])']"
87,        },['}']
88,"        fmt.Print(""\n"")","['fmt.Print(""\\n"")']"
89,    },['}']
90,},['}']
91,"func SolveMatrix(mat [MATSIZE][MATSIZE]int) (int, int) {","['func', 'SolveMatrix', '(', 'mat', '[', 'MATSIZE', '][', 'MATSIZE', ']', 'int', ')', '(', 'int', ',', 'int', ')', '{']"
92,    var PQ pqueue.PQueue,"['var', 'PQ', 'pqueue', '.', 'PQueue']"
93,    var firstNode pqueue.Node,"['var', 'firstNode', 'pqueue', '.', 'Node']"
94,    var endNode pqueue.Node,"['var', 'endNode', 'pqueue', '.', 'Node']"
95,    msm1 := MATSIZE - 1,"['msm1', ':=', 'MATSIZE', '-', '1']"
96,"    firstNode.Init(0, 0, mat[0][0], 0)","['firstNode.Init(0, 0, mat[0][0], 0)']"
97,"    endNode.Init(msm1, msm1, mat[msm1][msm1], 0)","['endNode.Init(msm1, msm1, mat[msm1][msm1], 0)']"
98,    if PQ.IsEmpty() { // make compiler stfu about unused variable,"['if', 'PQ.IsEmpty()', '{', '// make compiler stfu about unused variable']"
99,"        fmt.Print(""empty"")","['fmt.Print(""empty"")']"
100,    },['}']
101,    PQ.Push(firstNode) // problem,"['PQ.Push(firstNode)', '// problem']"
102,"    return 0, 0","['return', '0', ',', '0']"
103,},['}']
104,"

The problem is, upon compiling i get the error message:

","['The', 'problem', 'is,', 'upon', 'compiling', 'i', 'get', 'the', 'error', 'message:']"
105,[~/Code/Euler/81] $ make,"['[', 'Code', 'Euler', '81', ']', '$', 'make']"
106,6g -o pqueue.6 Node.go PQueue.go,"['6', 'g', '-', 'o', 'pqueue', '.', '6', 'Node', '.', 'go', 'PQueue', '.', 'go']"
107,6g main.go,"['6', 'g', 'main', '.', 'go']"
108,main.go:58: implicit assignment of unexported field 'row' of pqueue.Node in function argument,"['main', '.', 'go', ':', '58', ':', 'implicit', 'assignment', 'of', 'unexported', 'field', 'row', 'of', 'pqueue', '.', 'Node', 'in', 'func', 'tion', 'argument']"
109,make: *** [all] Error 1,"['make', ':', '***', '[', 'all', ']', 'Error', '1']"
110,"

And commenting out the line PQ.Push(firstNode) does satisfy the compiler. But I don't understand why I'm getting the error message in the first place. Push doesn't modify the argument in any way. 



UPDATE:
For the sake of those who come across this in searches in the future, the code above is chock full of gross misconceptions. Take a look below for a much more useful template to work off of:
Node.go:

","['And', 'commenting', 'out', 'the', 'line', 'PQ.Push(firstNode)', 'does', 'satisfy', 'the', 'compiler.', 'But', 'I', ""don't"", 'understand', 'why', ""I'm"", 'getting', 'the', 'error', 'message', 'in', 'the', 'first', 'place.', 'Push', ""doesn't"", 'modify', 'the', 'argument', 'in', 'any', 'way.', 'UPDATE:', 'For', 'the', 'sake', 'of', 'those', 'who', 'come', 'across', 'this', 'in', 'searches', 'in', 'the', 'future,', 'the', 'code', 'above', 'is', 'chock', 'full', 'of', 'gross', 'misconceptions.', 'Take', 'a', 'look', 'below', 'for', 'a', 'much', 'more', 'useful', 'template', 'to', 'work', 'off', 'of:', 'Node.go:']"
111,// Node.go,"['//', 'Node.go']"
112,package pqueue,"['package', 'pqueue']"
113,"import ""fmt""","['import', '""fmt""']"
114,type Node struct {,"['type', 'Node', 'struct', '{']"
115,    row    int,"['row', 'int']"
116,    col    int,"['col', 'int']"
117,    myVal  int,"['myVal', 'int']"
118,    sumVal int,"['sumVal', 'int']"
119,    parent *Node,"['parent', '*', 'Node']"
120,},['}']
121,"func NewNode(r, c, mv, sv int, n *Node) *Node {","['func', 'NewNode', '(', 'r', ',', 'c', ',', 'mv', ',', 'sv', 'int', ',', 'n', '*', 'Node', ')', '*', 'Node', '{']"
122,"    return &Node{r, c, mv, sv, n}","['return', '&', 'Node', '{', 'r', ',', 'c', ',', 'mv', ',', 'sv', ',', 'n', '}']"
123,},['}']
124,func (n *Node) Eq(o *Node) bool {,"['func', '(', 'n', '*', 'Node', ')', 'Eq', '(', 'o', '*', 'Node', ')', 'bool', '{']"
125,    return n.row == o.row && n.col == o.col,"['return', 'n', '.', 'row', '==', 'o', '.', 'row', '&&', 'n', '.', 'col', '==', 'o', '.', 'col']"
126,},['}']
127,func (n *Node) String() string {,"['func', '(', 'n', '*', 'Node', ')', 'String', '()', 'string', '{']"
128,"    return fmt.Sprintf(""{%d, %d, %d, %d}"", n.row, n.col, n.myVal, n.sumVal)","['return', 'fmt.Sprintf(""{%d, %d, %d, %d}"", n.row, n.col, n.myVal, n.sumVal)']"
129,},['}']
130,func (n *Node) Row() int {,"['func', '(', 'n', '*', 'Node', ')', 'Row', '()', 'int', '{']"
131,    return n.row,"['return', 'n', '.', 'row']"
132,},['}']
133,func (n *Node) Col() int {,"['func', '(', 'n', '*', 'Node', ')', 'Col', '()', 'int', '{']"
134,    return n.col,"['return', 'n', '.', 'col']"
135,},['}']
136,func (n *Node) SetParent(p *Node) {,"['func', '(', 'n', '*', 'Node', ')', 'SetParent', '(', 'p', '*', 'Node', ')', '{']"
137,    n.parent = p,"['n', '.', 'parent', '=', 'p']"
138,},['}']
139,func (n *Node) Parent() *Node {,"['func', '(', 'n', '*', 'Node', ')', 'Parent', '()', '*', 'Node', '{']"
140,    return n.parent,"['return', 'n', '.', 'parent']"
141,},['}']
142,func (n *Node) MyVal() int {,"['func', '(', 'n', '*', 'Node', ')', 'MyVal', '()', 'int', '{']"
143,    return n.myVal,"['return', 'n', '.', 'myVal']"
144,},['}']
145,func (n *Node) SumVal() int {,"['func', '(', 'n', '*', 'Node', ')', 'SumVal', '()', 'int', '{']"
146,    return n.sumVal,"['return', 'n', '.', 'sumVal']"
147,},['}']
148,func (n *Node) SetSumVal(sv int) {,"['func', '(', 'n', '*', 'Node', ')', 'SetSumVal', '(', 'sv', 'int', ')', '{']"
149,    n.sumVal = sv,"['n', '.', 'sumVal', '=', 'sv']"
150,},['}']
151,"

PQueue.go:

",['PQueue.go:']
152,// PQueue.go,"['//', 'PQueue.go']"
153,package pqueue,"['package', 'pqueue']"
154,type PQueue []*Node,"['type', 'PQueue', '[]*', 'Node']"
155,func (pq *PQueue) IsEmpty() bool {,"['func', '(', 'pq', '*', 'PQueue', ')', 'IsEmpty', '()', 'bool', '{']"
156,    return len(*pq) == 0,"['return', 'len', '(*', 'pq', ')', '==', '0']"
157,},['}']
158,func (pq *PQueue) Push(i interface{}) {,"['func', '(', 'pq', '*', 'PQueue', ')', 'Push', '(', 'i', 'interface', '{})', '{']"
159,    a := *pq,"['a', ':=', '*', 'pq']"
160,    n := len(a),"['n', ':=', 'len', '(', 'a', ')']"
161,    a = a[0 : n+1],"['a', '=', 'a', '[', '0', ':', 'n', '+', '1', ']']"
162,    r := i.(*Node),"['r', ':=', 'i', '.(*', 'Node', ')']"
163,    a[n] = r,"['a', '[', 'n', ']', '=', 'r']"
164,    *pq = a,"['*', 'pq', '=', 'a']"
165,},['}']
166,func (pq *PQueue) Pop() interface{} {,"['func', '(', 'pq', '*', 'PQueue', ')', 'Pop', '()', 'interface', '{}', '{']"
167,    a := *pq,"['a', ':=', '*', 'pq']"
168,    *pq = a[0 : len(a)-1],"['*', 'pq', '=', 'a', '[', '0', ':', 'len', '(', 'a', ')-', '1', ']']"
169,    r := a[len(a)-1],"['r', ':=', 'a', '[', 'len', '(', 'a', ')-', '1', ']']"
170,    return r,"['return', 'r']"
171,},['}']
172,func (pq *PQueue) Len() int {,"['func', '(', 'pq', '*', 'PQueue', ')', 'Len', '()', 'int', '{']"
173,    return len(*pq),"['return', 'len', '(*', 'pq', ')']"
174,},['}']
175,// post: true iff is i less than j,"['//', 'post:', 'true', 'iff', 'is', 'i', 'less', 'than', 'j']"
176,"func (pq *PQueue) Less(i, j int) bool {","['func', '(', 'pq', '*', 'PQueue', ')', 'Less', '(', 'i', ',', 'j', 'int', ')', 'bool', '{']"
177,    I := (*pq)[i],"['I', ':=', '(*', 'pq', ')[', 'i', ']']"
178,    J := (*pq)[j],"['J', ':=', '(*', 'pq', ')[', 'j', ']']"
179,    return (I.sumVal + I.myVal) < (J.sumVal + J.myVal),"['return', '(', 'I', '.', 'sumVal', '+', 'I', '.', 'myVal', ')', '<', '(', 'J', '.', 'sumVal', '+', 'J', '.', 'myVal', ')']"
180,},['}']
181,"func (pq *PQueue) Swap(i, j int) {","['func', '(', 'pq', '*', 'PQueue', ')', 'Swap', '(', 'i', ',', 'j', 'int', ')', '{']"
182,"    (*pq)[i], (*pq)[j] = (*pq)[j], (*pq)[i]","['(*', 'pq', ')[', 'i', '],', '(*', 'pq', ')[', 'j', ']', '=', '(*', 'pq', ')[', 'j', '],', '(*', 'pq', ')[', 'i', ']']"
183,},['}']
184,func (pq *PQueue) String() string {,"['func', '(', 'pq', '*', 'PQueue', ')', 'String', '()', 'string', '{']"
185,"    var build string = ""{""","['var', 'build', 'string', '=', '""{""']"
186,"    for _, v := range *pq {","['for', '_', ',', 'v', ':=', 'range', '*', 'pq', '{']"
187,        build += v.String(),"['build', '+=', 'v.String()']"
188,    },['}']
189,"    build += ""}""","['build', '+=', '""}""']"
190,    return build,"['return', 'build']"
191,},['}']
