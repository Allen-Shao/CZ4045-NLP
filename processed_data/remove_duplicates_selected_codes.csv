PostId,Unnamed: 0,Code,CodeLength
8272760,1,"package main

import ""rand""

func Routine1(command12 chan int, response12 chan int, command13 chan int, response13 chan int) {

    // z12 is a variable which stores the value comming from channel 2 and z13 is a variable which stores the value comming from channel 3.

    z12 := 200
    z13 := 200
    m12 := false
    m13 := false
    y := 0

    for i := 0; i < 20; i++ {
        y = rand.Intn(100)

        // If y's value is not 0 then the value will be sent to routine 2 or 3 according to   prime or not.
        // If y's value is 0 then process state (the varibles used by it means z12, z13) and channel state will be saved.[routine 1 is initiator]

        if y == 0 {
            print(z12, ""    z12 STATE SAVED\n"")
            print(z13, ""    z13 STATE SAVED\n"")

            // Routine 1 is initiator,  it sends 0 to make other process to save the state.

            y = 0
            command12 <- y
            command13 <- y

            // Untill routine 2 and 3 does not send 0, process 1 is on channel saving state (it's process state is already saved).
            // When routine 1 recives 0 from both other processes, channel is saved and routine 1 retuns to it's common routine procedure.
            // When routine 1 recives 0 from any other processes, saving channel bettwen them is stopped.
            // m12, m13 is used to mark whether 0 recived or not.

            for m12 != true || m13 != true {
                select {
                case cmd1 := <-response12:
                    {
                        z12 = cmd1
                        if z12 != 0 {
                            print(z12, ""    z12  Channel Saving.... \n"")
                            y = rand.Intn(100)
                            command12 <- y
                        }
                        if z12 == 0 {
                            m12 = true
                            print("" z12  Channel Saving Stopped \n"")
                        }
                    }

                case cmd2 := <-response13:
                    {
                        z13 = cmd2
                        if z13 != 0 {
                            print(z13, ""    z13  Channel Saving.... \n"")
                            y = rand.Intn(100)
                            command13 <- y
                        }
                        if z13 == 0 {
                            m13 = true
                            print(""    z13  Channel Saving Stopped \n"")
                        }
                    }
                }

            }

            // After saving process state it retuns to it's normal behaviour.

            m12 = false
            m13 = false
        }

        if y != 0 {

            // If y value is not 0, routine 1 just sends int to other process according to prime or not and recives int accordingly.

            if y%2 == 0 {
                command12 <- y
            }

            if y%2 != 0 {
                command13 <- y
            }
            select {
            case cmd1 := <-response12:
                {
                    z12 = cmd1
                    print(z12, ""    z12\n"")
                }
            case cmd2 := <-response13:
                {
                    z13 = cmd2
                    print(z13, ""   z13\n"")
                }
            }
        }
    }
    close(command12)
    close(command13)
}


//Routine 2 (or 3) is not an initiator (means it can't send 0). When it recives 0 (from routine 1 or 3) it save the state of process and the state of the channel from which it recived).
// When it recives 0 from both other two routine, it saves all channel state and returns to it's common behaviour. [same in routine 3]

func Routine2(command12 chan int, response12 chan int, command23 chan int, response23 chan int) {
    z21 := 200
    z23 := 200
    m21 := false
    m23 := false

    for i := 0; i < 20; i++ {
        select {
        case x, open := <-command12:
            {
                if !open {
                    return
                }
                if x != 0 && m23 != true {
                    z21 = x
                    print(z21, ""   z21\n"")
                }
                if x != 0 && m23 == true {
                    z21 = x
                    print(z21, ""   z21 Channel Saving \n"")
                }
                if x == 0 {
                    m21 = true
                    if m21 == true && m23 == true {
                        print("" z21 and z23 Channel Saving Stopped \n"")
                        m23 = false
                        m21 = false
                    }
                    if m21 == true && m23 != true {
                        z21 = x
                        print(z21, ""   z21  Channel Saved \n"")

                    }

                }
            }

        case x, open := <-response23:
            {
                if !open {
                    return
                }
                if x != 0 && m21 != true {
                    z23 = x
                    print(z23, ""   z21\n"")
                }
                if x != 0 && m21 == true {
                    z23 = x
                    print(z23, ""   z23 Channel Saving \n"")
                }
                if x == 0 {
                    m23 = true
                    if m21 == true && m23 == true {
                        print("" z23 Channel Saving Stopped \n"")
                        m23 = false
                        m21 = false
                    }
                    if m23 == true && m21 != true {
                        z23 = x
                        print(z23, ""   z23  Channel Saved \n"")
                    }

                }
            }
        }

        if m23 == false && m21 == false {
            y := rand.Intn(100)
            if y%2 == 0 {
                if y == 0 {
                    y = 10
                    response12 <- y
                }
            }

            if y%2 != 0 {
                if y == 0 {
                    y = 10
                    response23 <- y
                }
            }
        }

        if m23 == true && m21 != true {
            y := rand.Intn(100)
            response12 <- y
        }

        if m23 != true && m21 == true {
            y := rand.Intn(100)
            command23 <- y
        }

    }
    close(response12)
    close(command23)
}

func Routine3(command13 chan int, response13 chan int, command23 chan int, response23 chan int) {
    z31 := 200
    z32 := 200
    m31 := false
    m32 := false

    for i := 0; i < 20; i++ {
        select {
        case x, open := <-command13:
            {
                if !open {
                    return
                }
                if x != 0 && m32 != true {
                    z31 = x
                    print(z31, ""   z21\n"")
                }
                if x != 0 && m32 == true {
                    z31 = x
                    print(z31, ""   z31 Channel Saving \n"")
                }
                if x == 0 {
                    m31 = true
                    if m31 == true && m32 == true {
                        print("" z21 Channel Saving Stopped \n"")
                        m31 = false
                        m32 = false
                    }
                    if m31 == true && m32 != true {
                        z31 = x
                        print(z31, ""   z31  Channel Saved \n"")

                    }

                }
            }

        case x, open := <-command23:
            {
                if !open {
                    return
                }
                if x != 0 && m31 != true {
                    z32 = x
                    print(z32, ""   z32\n"")
                }
                if x != 0 && m31 == true {
                    z32 = x
                    print(z32, ""   z32 Channel Saving \n"")
                }
                if x == 0 {
                    m32 = true
                    if m31 == true && m32 == true {
                        print("" z32 Channel Saving Stopped \n"")
                        m31 = false
                        m32 = false
                    }
                    if m32 == true && m31 != true {
                        z32 = x
                        print(z32, ""   z32  Channel Saved \n"")

                    }

                }
            }
        }
        if m31 == false && m32 == false {
            y := rand.Intn(100)
            if y%2 == 0 {
                response13 <- y
            }

            if y%2 != 0 {
                response23 <- y
            }
        }

        if m31 == true && m32 != true {
            y := rand.Intn(100)
            response13 <- y
        }

        if m31 != true && m32 == true {
            y := rand.Intn(100)
            response23 <- y
        }

    }
    close(response13)
    close(response23)
}


func main() {

    // Three concurrent channels are created to pass integers to each other.
    // command 12 used to send int and response12 is used to receive int from routine 1 to routine 2.
    // response 12 used to send int and command 12 is used to receive int from routine 2 to routine 1. {so as for others}

    command12 := make(chan int)
    response12 := make(chan int)
    command13 := make(chan int)
    response13 := make(chan int)
    command23 := make(chan int)
    response23 := make(chan int)

    go Routine1(command12, response12, command13, response13)
    go Routine2(command12, response12, command23, response23)
    Routine3(command13, response13, command23, response23)
}",9500
12482910,8,"package main

func parseFile(name string, finished chan int) {
    var Verts []*Vertex
    var Texs []*TexCoord
    var Faces []*Face

    var objFile, mtlFile, jsonFile *os.File
    var parseMaterial bool

    // Set up files and i/o
    inName := name
    outName := strings.Replace(inName, "".obj"", "".json3d"", -1)
    parseMaterial = false

    fmt.Printf(""--""+FgGreen+""Creating""+Reset+"" %s from %s\n"", outName, inName)

    var err error
    var part []byte
    var prefix bool

    if objFile, err = os.Open(inName); err != nil {
        fmt.Println(FgRed+""!!Failed to open input file!!""+Reset)
        return
    }

    if jsonFile, err = os.Create(outName); err != nil {
        fmt.Println(FgRed+""!!Failed to create output file!!""+Reset)
        return
    }

    reader := bufio.NewReader(objFile)
    writer := bufio.NewWriter(jsonFile)
    buffer := bytes.NewBuffer(make([]byte, 1024))

    // Read the file in and parse out what we need
    for {
        if part, prefix, err = reader.ReadLine(); err != nil {
            break
        }

        buffer.Write(part)
        if !prefix {
            line := buffer.String()
            if(strings.Contains(line, ""v "")) {
                Verts = append(Verts, parseVertex(line))
            } else if(strings.Contains(line, ""vt "")) {
                Texs = append(Texs, parseTexCoord(line))
            } else if(strings.Contains(line, ""f "")) {
                Faces = append(Faces, parseFace(line, Verts, Texs))
            } else if(strings.Contains(line, ""mtllib "")) {
                mtlName := strings.Split(line, "" "")[1]
                if mtlFile, err = os.Open(mtlName); err != nil {
                    fmt.Printf(""--""+FgRed+""Failed to find material file: %s\n""+Reset, mtlName)
                    parseMaterial = false
                } else {
                    parseMaterial = true
                }
            }
            buffer.Reset()
        }
    }

    if err == io.EOF {
        err = nil
    }

    objFile.Close()

    // Write out the data
    writer.WriteString(""{\""obj\"":[\n"");

    // Write out the verts
    writer.WriteString(""{\""vrt\"":[\n"");
    for i, vert := range Verts {
        writer.WriteString(vert.String())
        if i < len(Verts) - 1 { writer.WriteString("","") }
        writer.WriteString(""\n"")
    }

    // Write out the faces
    writer.WriteString(""],\""fac\"":[\n"")
    for i, face := range Faces {
        writer.WriteString(face.String(true))
        if i < len(Faces) - 1 { writer.WriteString("","") }
        writer.WriteString(""\n"")
    }

    // Write out the normals
    writer.WriteString(""],\""nrm\"":["")
    for i, face := range Faces {


        writer.WriteString(""["")
        for j, vert := range face.verts {
            length := math.Sqrt((vert.X * vert.X) + (vert.Y * vert.Y) + (vert.Z * vert.Z))
            x := vert.X / length
            y := vert.Y / length
            z := vert.Z / length
            normal := fmt.Sprintf(""[%f,%f,%f]"", x, y, z)
            writer.WriteString(normal)
            if(j < len(face.verts)-1) { writer.WriteString("","") }
        }
        writer.WriteString(""]"")




        //writer.WriteString(""[0, 1, 0]"")
        if i < len(Faces) - 1 { writer.WriteString("","") }
        writer.WriteString(""\n"")
    }

    // Write out the tex coords
    writer.WriteString(""],\""tex\"":["")
    for i, face := range Faces {
        writer.WriteString(""["")
        writer.WriteString(face.tex[0].String())
        writer.WriteString("","")
        writer.WriteString(face.tex[1].String())
        writer.WriteString("","")
        writer.WriteString(face.tex[2].String())
        writer.WriteString(""]"")
        if i < len(Faces) - 1 { writer.WriteString("","") }
        writer.WriteString(""\n"")
    }

    // Close obj block
    writer.WriteString(""]}]"");

    if parseMaterial {
        writer.WriteString("",mat:[{"");
        reader := bufio.NewReader(mtlFile)

        // Read the file in and parse out what we need
        for {
            if part, prefix, err = reader.ReadLine(); err != nil {
                break
            }

            buffer.Write(part)
            if !prefix {
                line := buffer.String()
                if(strings.Contains(line, ""map_Kd "")) {
                    parts := strings.Split(line, "" "")
                    entry := fmt.Sprintf(""\""t\"":\""%s\"","", parts[1])
                    writer.WriteString(entry)

                    width, height := 256, 256
                    var imageFile *os.File
                    if imageFile, err = os.Open(parts[1]); err != nil {
                        fmt.Printf(""--""+FgRed+""Failed to find %s, defaulting to 256x256""+Reset+""\n"", parts[1])
                        return
                    } else {
                        var config image.Config
                        imageReader := bufio.NewReader(imageFile)
                        config, err = jpeg.DecodeConfig(imageReader)
                        width, height = config.Width, config.Height
                        fmt.Printf(""--""+FgGreen+""Verifing""+Reset+"" that %s is %dpx x %dpx\n"", parts[1], width, height)
                    }

                    size := fmt.Sprintf(""\""w\"":%d,\""h\"":%d,"", width, height)
                    writer.WriteString(size)

                } else if(strings.Contains(line, ""Kd "")) {
                    parts := strings.Split(line, "" "")
                    entry := fmt.Sprintf(""\""r\"":%s, \""g\"":%s, \""b\"":%s,"", parts[1], parts[2], parts[3])
                    writer.WriteString(entry)
                }
                buffer.Reset()
            }
        }

        if err == io.EOF {
            err = nil
        }

        writer.WriteString(""\""res\"":100,\""uv\"":true}]"");
    }

    // Close json
    writer.WriteString(""}"");
    writer.Flush()
    jsonFile.Close()

    fmt.Printf(""--""+FgGreen+""Exported""+Reset+"" %d faces with %d verticies\n"", len(Faces), len(Verts))

    finished <- -1
}

func main(){
    // Verify we were called correctly
    if len(os.Args) < 2 {
        fmt.Println(""Usage: go run objParser.go "");
        return
    }

    files := len(os.Args)
    finished := make(chan int)

    now := time.Now()

    for i := 1; i < files; i++ {
        go parseFile(os.Args[i], finished)
    }

    for i := 1; i < files; i++ {
        <- finished
    }

    fmt.Printf(""Parsed %d files in %s\n"", files-1, time.Since(now))
}",6363
12885235,9,"package hello

import (
    ""fmt""
    ""net/http""
)

func init() {
    http.HandleFunc(""/"", handler)
}

func handler(w http.ResponseWriter, r *http.Request) {
    fmt.Fprint(w, ""Hello, world!"")
}
",195
13777298,18,"// Copyright 2012 Stefan Nilsson
//
// Licensed under the Apache License, Version 2.0 (the ""License"");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an ""AS IS"" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package prio provides a priority queue.
// The queue can hold elements that implement the two methods of prio.Interface.
package prio

/*
A type that implements prio.Interface can be inserted into a priority queue.

The simplest use case looks like this:

        type myInt int

        func (x myInt) Less(y prio.Interface) bool { return x < y.(myInt) }
        func (x myInt) Index(i int)                {}

To use the Remove method you need to keep track of the index of elements
in the heap, e.g. like this:

        type myType struct {
                value int
                index int // index in heap
        }

        func (x *myType) Less(y prio.Interface) bool { return x.value < y.(*myType).value }
        func (x *myType) Index(i int)                { x.index = i }
*/
type Interface interface {
        // Less returns whether this element should sort before element x.
        Less(x Interface) bool
        // Index is called by the priority queue when this element is moved to index i.
        Index(i int)
}

// Queue represents a priority queue.
// The zero value for Queue is an empty queue ready to use.
type Queue struct {
        h []Interface
}

// New returns an initialized priority queue with the given elements.
// A call of the form New(x...) uses the underlying array of x to implement
// the queue and hence might change the elements of x.
// The complexity is O(n), where n = len(x).
func New(x ...Interface) Queue {
        q := Queue{x}
        heapify(q.h)
        return q
}

// Push pushes the element x onto the queue.
// The complexity is O(log(n)) where n = q.Len().
func (q *Queue) Push(x Interface) {
        n := len(q.h)
        q.h = append(q.h, x)
        up(q.h, n) // x.Index(n) is done by up.
}

// Pop removes a minimum element (according to Less) from the queue and returns it.
// The complexity is O(log(n)), where n = q.Len().
func (q *Queue) Pop() Interface {
        h := q.h
        n := len(h) - 1
        x := h[0]
        h[0], h[n] = h[n], nil
        h = h[:n]
        if n > 0 {
                down(h, 0) // h[0].Index(0) is done by down.
        }
        q.h = h
        x.Index(-1) // for safety
        return x
}

// Peek returns, but does not remove, a minimum element (according to Less) of the queue.
func (q *Queue) Peek() Interface {
        return q.h[0]
}

// Remove removes the element at index i from the queue and returns it.
// The complexity is O(log(n)), where n = q.Len().
func (q *Queue) Remove(i int) Interface {
        h := q.h
        n := len(h) - 1
        x := h[i]
        h[i], h[n] = h[n], nil
        h = h[:n]
        if i < n {
                down(h, i) // h[i].Index(i) is done by down.
                up(h, i)
        }
        q.h = h
        x.Index(-1) // for safety
        return x
}

// Len returns the number of elements in the queue.
func (q *Queue) Len() int {
        return len(q.h)
}

// Establishes the heap invariant in O(n) time.
func heapify(h []Interface) {
        n := len(h)
        for i := n - 1; i >= n/2; i-- {
                h[i].Index(i)
        }
        for i := n/2 - 1; i >= 0; i-- { // h[i].Index(i) is done by down.
                down(h, i)
        }
}

// Moves element at position i towards top of heap to restore invariant.
func up(h []Interface, i int) {
        for {
                parent := (i - 1) / 2
                if i == 0 || h[parent].Less(h[i]) {
                        h[i].Index(i)
                        break
                }
                h[parent], h[i] = h[i], h[parent]
                h[i].Index(i)
                i = parent
        }
}

// Moves element at position i towards bottom of heap to restore invariant.
func down(h []Interface, i int) {
        for {
                n := len(h)
                left := 2*i + 1
                if left >= n {
                        h[i].Index(i)
                        break
                }
                j := left
                if right := left + 1; right < n && h[right].Less(h[left]) {
                        j = right
                }
                if h[i].Less(h[j]) {
                        h[i].Index(i)
                        break
                }
                h[i], h[j] = h[j], h[i]
                h[i].Index(i)
                i = j
        }
}",4886
14080024,19,"// Handle the reads
  var tbuf [81920]byte

  for {

    n, err := c.rwc.Read(tbuf[0:])

    // Was there an error in reading ?
    if err != nil {
        log.Printf(""Could not read packet : %s"", err.Error())
        break
    }

    log.Println(n)

}

return",263
14298523,21,"package main

import (
    ""fmt""
    ""math/rand""
    ""time""
)

const (
    NUMBER_OF_SIMULATIONS = 1000
    NUMBER_OF_INTERACTIONS = 1000000
    DROP_RATE = 0.0003
)

/**
 * Simulates a single interaction with a monster
 *
 * Returns 1 if the monster dropped an item and 0 otherwise
 */
func interaction() int {
    if rand.Float64() <= DROP_RATE {
        return 1
    }
    return 0
}

/**
 * Runs several interactions and retuns a slice representing the results
 */
func simulation(n int) []int {
    interactions := make([]int, n)
    for i := range interactions {
        interactions[i] = interaction()
    }
    return interactions
}

/**
 * Runs several simulations and returns the results
 */
func test(n int) []int {
    simulations := make([]int, n)
    for i := range simulations {
        successes := 0
        for _, v := range simulation(NUMBER_OF_INTERACTIONS) {
            successes += v
        }
        simulations[i] = successes
    }
    return simulations
}

func main() {
    rand.Seed(time.Now().UnixNano())
    fmt.Println(""Successful interactions: "", test(NUMBER_OF_SIMULATIONS))
}",1111
14732354,39,"package main

import (
    ""fmt""
    ""github.com/0xe2-0x9a-0x9b/Go-SDL/sdl""
    gl ""github.com/chsc/gogl/gl33""
    ""math""
    ""time""
    ""unsafe""
)

const DEG_TO_RAD = math.Pi / 180

type GoMatrix [16]float64
type GlMatrix [16]gl.Float

var good_frames, bad_frames, sdl_events int

func main() {

    //=================================================================
    // Just opening a window, skip to the next part.

    if status := sdl.Init(sdl.INIT_VIDEO); status != 0 {
        panic(""Could not initialize SDL: "" + sdl.GetError())
    }
    defer sdl.Quit()

    sdl.GL_SetAttribute(sdl.GL_DOUBLEBUFFER, 1)
    const FLAGS = sdl.OPENGL
    if screen := sdl.SetVideoMode(640, 480, 32, FLAGS); screen == nil {
        panic(""Could not open SDL window: "" + sdl.GetError())
    }

    if err := gl.Init(); err != nil {
        panic(err)
    }

    gl.Viewport(0, 0, 640, 480)
    gl.ClearColor(.5, .5, .5, 1)

    //=================================================================
    // Simplest shaders ever.

    // A matrix to move the model, nothing else.
    vertex_code := gl.GLString(`
    #version 330 core
    in vec3 vpos;
    uniform mat4 MVP;
    void main() { 
        gl_Position = MVP * vec4(vpos, 1);
    }   
    `)
    // Everything is red.
    fragment_code := gl.GLString(`
    #version 330 core
    void main(){
        gl_FragColor = vec4(1,0,0,1);
    }
    `)
    vs := gl.CreateShader(gl.VERTEX_SHADER)
    fs := gl.CreateShader(gl.FRAGMENT_SHADER)
    gl.ShaderSource(vs, 1, &vertex_code, nil)
    gl.ShaderSource(fs, 1, &fragment_code, nil)
    gl.CompileShader(vs)
    gl.CompileShader(fs)
    prog := gl.CreateProgram()
    gl.AttachShader(prog, vs)
    gl.AttachShader(prog, fs)
    gl.LinkProgram(prog)
    // Did it compile?
    var link_status gl.Int
    gl.GetProgramiv(prog, gl.LINK_STATUS, &link_status)
    if link_status == gl.FALSE {
        var info_log_length gl.Int
        gl.GetProgramiv(prog, gl.INFO_LOG_LENGTH, &info_log_length)
        if info_log_length == 0 {
            panic(""Program linking failed but OpenGL has no log about it."")
        } else {
            info_log_gl := gl.GLStringAlloc(gl.Sizei(info_log_length))
            defer gl.GLStringFree(info_log_gl)
            gl.GetProgramInfoLog(prog, gl.Sizei(info_log_length), nil, info_log_gl)
            info_log := gl.GoString(info_log_gl)
            panic(info_log)
        }
    }
    gl.UseProgram(prog)
    attrib_vpos := gl.Uint(gl.GetAttribLocation(prog, gl.GLString(""vpos"")))

    //=================================================================
    // One triangle.

    positions := [...]gl.Float{-.5, -.5, 0, .5, -.5, 0, 0, .5, 0}

    var vao gl.Uint
    gl.GenVertexArrays(1, &vao)
    gl.BindVertexArray(vao)

    var vbo gl.Uint
    gl.GenBuffers(1, &vbo)
    gl.BindBuffer(gl.ARRAY_BUFFER, vbo)
    gl.BufferData(gl.ARRAY_BUFFER,
        gl.Sizeiptr(unsafe.Sizeof(positions)),
        gl.Pointer(&positions[0]),
        gl.STATIC_DRAW)

    gl.EnableVertexAttribArray(attrib_vpos)
    gl.VertexAttribPointer(attrib_vpos, 3, gl.FLOAT, gl.FALSE, 0, gl.Pointer(nil))

    //=================================================================

    Loop(prog)
    fmt.Println(""Good frames"", good_frames)
    fmt.Println(""Bad frames "", bad_frames)
    fmt.Println(""SDL events "", sdl_events)
}

func Loop(program gl.Uint) {
    start_time := time.Now()
    ticker := time.NewTicker(100 * time.Millisecond)
    defer ticker.Stop()
    running := true
    for running {
        select {
        case tick_time := <-ticker.C:
            OnTick(start_time, tick_time, program)
        case event := <-sdl.Events:
            running = OnSdlEvent(event)
        }
    }
}

func OnSdlEvent(event interface{}) bool {
    sdl_events++
    switch event.(type) {
    case sdl.QuitEvent:
        return false // Stop the main loop.
    }
    return true // Do not stop the main loop.
}

func OnTick(start_time, tick_time time.Time, program gl.Uint) {
    duration := tick_time.Sub(start_time).Seconds()
    speed := 10.
    angle := math.Mod(duration*speed, 360)
    gom := RotZ(angle)
    MVP := ToGlMatrix(gom)

    /* HERE, SOMETHING FISHY HAPPENS.

    Problem: sometimes, actually often, OpenGl returns 0 instead of -1 for
    the dummy parameter.  This is entirely correlated to the stuttering.

    With my implementation of OpenGl, swap buffer does a real swap.
    That means I get to see the last two pictures rendered.
    Thing is, I can see the swap, that means the pictures are different.
    That means that the call to DrawArrays is ignored.

    OpenGl is just crapping its pants.
    */
    matrix_loc := gl.GetUniformLocation(program, gl.GLString(""MVP""))
    dummy_matrix_loc := gl.GetUniformLocation(program, gl.GLString(""dummy""))
    if gl.GetError() != gl.NO_ERROR {
        fmt.Println(""Error get location"") // Never happens.
    }
    if dummy_matrix_loc == -1 {
        good_frames++ // Because is SHOULD fail.
    } else {
        bad_frames++ // That's not normal.
    }
    gl.UniformMatrix4fv(matrix_loc, 16, gl.TRUE, &MVP[0])
    if gl.GetError() != gl.NO_ERROR {
        fmt.Println(""Error send matrix"") // Never happens.
    }
    gl.Clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT)
    if gl.GetError() != gl.NO_ERROR {
        fmt.Println(""Error clearing"") // Never happens.
    }
    gl.DrawArrays(gl.TRIANGLES, 0, 3)
    if gl.GetError() != gl.NO_ERROR {
        fmt.Println(""Error drawing"") // Never happens.
    }
    gl.Finish() // Does not seem to make anything work better.
    sdl.GL_SwapBuffers()
}

func RotZ(angle float64) GoMatrix {
    var gom GoMatrix
    a := angle * DEG_TO_RAD
    c := math.Cos(a)
    s := math.Sin(a)
    gom[0] = c
    gom[1] = s
    gom[4] = -s
    gom[5] = c
    gom[10] = 1
    gom[15] = 1
    return gom
}

func ToGlMatrix(gom GoMatrix) GlMatrix {
    var glm GlMatrix
    glm[0] = gl.Float(gom[0])
    glm[1] = gl.Float(gom[1])
    glm[2] = gl.Float(gom[2])
    glm[3] = gl.Float(gom[3])
    glm[4] = gl.Float(gom[4])
    glm[5] = gl.Float(gom[5])
    glm[6] = gl.Float(gom[6])
    glm[7] = gl.Float(gom[7])
    glm[8] = gl.Float(gom[8])
    glm[9] = gl.Float(gom[9])
    glm[10] = gl.Float(gom[10])
    glm[11] = gl.Float(gom[11])
    glm[12] = gl.Float(gom[12])
    glm[13] = gl.Float(gom[13])
    glm[14] = gl.Float(gom[14])
    glm[15] = gl.Float(gom[15])
    return glm
}",6375
15067286,43,"package main

import (
    ""net""
    ""os""
    ""bufio""
    ""fmt""
    ""time""
)

func AcceptConnections(listener net.Listener, console <- chan string) {

    msg := """"

    for {

        conn, err := listener.Accept()

        if err != nil {
            panic(err)
        }

        fmt.Printf(""client connected\n"")

        for {

            if msg == """" {
                msg = <- console
                fmt.Printf(""read from console: %s"", msg)
            }

            err = conn.SetWriteDeadline(time.Now().Add(time.Second))

            if err != nil {
                fmt.Printf(""SetWriteDeadline failed: %v\n"", err)
            }

            _, err = conn.Write([]byte(msg))

            if err != nil {
                // expecting an error after sending a message
                // to a non-existing client endpoint
                fmt.Printf(""failed sending a message to network: %v\n"", err)
                break
            } else {
                fmt.Printf(""msg sent: %s"", msg)
                msg = """"
            }
        }
    }
}

func ReadConsole(network chan <- string) {

    console := bufio.NewReader(os.Stdin)

    for {

        line, err := console.ReadString('\n')

        if err != nil {

            panic(err)

        } else {

            network <- line
        }
    }
}

func main() {

    listener, err := net.Listen(""tcp"", ""localhost:6666"")

    if err != nil {
        panic(err)
    }

    println(""listening on "" + listener.Addr().String())

    consoleToNetwork := make(chan string)

    go AcceptConnections(listener, consoleToNetwork)

    ReadConsole(consoleToNetwork)
}",1624
15314845,48,"package main

import (
        ""fmt""
        ""runtime""
        ""unsafe""
)

func Alloc() uint64 {
        var stats runtime.MemStats
        runtime.GC()
        runtime.ReadMemStats(&stats)
        return stats.Alloc - uint64(unsafe.Sizeof(hs[0]))*uint64(cap(hs))
}

var hs = []*map[int16]byte{}

func main() {
        hs := []*map[int16]byte{}
        n := 1000
        before := Alloc()
        for i := 0; i < n; i++ {
                h := map[int16]byte{}
                hs = append(hs, &h)
        }
        after := Alloc()
        emptyPerMap := float64(after-before) / float64(n)
        fmt.Printf(""Bytes used for %d empty maps: %d, bytes/map %.1f\n"", n, after-before, emptyPerMap)
        hs = nil

        k := 1
        for p := 1; p < 16; p++ {
                before = Alloc()
                for i := 0; i < n; i++ {
                        h := map[int16]byte{}
                        for j := 0; j < k; j++ {
                                h[int16(j)] = byte(j)
                        }
                        hs = append(hs, &h)
                }
                after = Alloc()
                fullPerMap := float64(after-before) / float64(n)
                fmt.Printf(""Bytes used for %d maps with %d entries: %d, bytes/map %.1f\n"", n, k, after-before, fullPerMap)
                fmt.Printf(""Bytes per entry %.1f\n"", (fullPerMap-emptyPerMap)/float64(k))
                k *= 2
        }

}",1416
15674709,52,"package main

import (
    ""bytes""
    ""database/sql""
    ""flag""
    ""fmt""
    _ ""github.com/Go-SQL-Driver/MySQL""
    ""ijinshan.com/cfg""
    ""log""
    ""net""
    ""net/http""
    ""net/smtp""
    ""os""
    ""strconv""
    ""strings""
    ""sync""
    ""time""
)

var (
    Log           *log.Logger
    Conf          cfg.KVConfig
    Debug         bool
    CpuCore       int
    HttpTransport = &http.Transport{
        Dial: func(netw, addr string) (net.Conn, error) {
            deadline := time.Now().Add(30 * time.Second)
            c, err := net.DialTimeout(netw, addr, 20*time.Second)
            if err != nil {
                return nil, err
            }

            c.SetDeadline(deadline)
            return c, nil
        },
        DisableKeepAlives: true,
    }
    HttpClient = &http.Client{
        Transport: HttpTransport,
    }
    WG            sync.WaitGroup
)

const (
    LogFileFlag   = os.O_WRONLY | os.O_CREATE | os.O_APPEND
    LogFileMode   = 0644
    LogFlag       = log.LstdFlags | log.Lshortfile
    GET_VIDEO_SQL = `SELECT B.Name, A.TSID, A.Chapter, A.ChapterNum, 
    IFNULL(A.Website, ''), IFNULL(A.Descr, ''), 
    IFNULL(A.VideoId, ''), IFNULL(AndroidWebURL, ''), IFNULL(IOSWebURL, ''), 
    IFNULL(AndroidURL, ''), IFNULL(AndroidURL2, ''), IFNULL(IOSURL, '')
    FROM Video A INNER JOIN TVS B ON A.TSID = B.ID LIMIT 200`

    HtmlHead = `节目名
    tsid章节章节号描述
    videoid网站地址`
    HtmlTail = """"
)

type videoInfo struct {
    name          string
    tsid          uint
    chapter       string
    chapterNum    uint
    descr         string
    videoId       string
    website       string
    androidWebUrl string
    iosWebUrl     string
    androidUrl    string
    androidUrl2   string
    iosUrl        string
}

func init() {
    var (
        confFile string
        err      error
    )

    // parse command argument:w
    flag.StringVar(&confFile, ""c"", ""./vsmonitor.conf"", "" set config file path"")
    flag.Parse()
    // read config
    if Conf, err = cfg.Read(confFile); err != nil {
        panic(fmt.Sprintf(""Read config file \""%s\"" failed (%s)"",
            confFile, err.Error()))
    }
    // open log file
    file, err := os.OpenFile(Conf[""log.file""], LogFileFlag, LogFileMode)
    if err != nil {
        panic(fmt.Sprintf(""OpenFile \""%s\"" failed (%s)"", Conf[""log.file""],
            err.Error()))
    }
    // init LOG
    Log = log.New(file, """", LogFlag)
    Debug = false
    i, err := strconv.ParseInt(Conf[""cpucore.num""], 10, 32)
    if err != nil {
        panic(fmt.Sprintf(""ParseInt \""%s\"" failed (%s)"", Conf[""cpucore.num""],
            err.Error()))
    }

    CpuCore = int(i)
}

func getHttpStatusCode(url string) int {
    if url == """" {
        return 200
    }

    req, err := http.NewRequest(""GET"", url, nil)
    if err != nil {
        return 0
    }

    req.Header.Add(""User-Agent"", ""Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_3) AppleWebKit/537.17 (KHTML, like Gecko) Chrome/24.0.1312.57 Safari/537.17"")
    req.Header.Add(""Connection"", ""close"")
    resp, err := HttpClient.Do(req)
    if err != nil {
        return 0
    }

    defer resp.Body.Close()
    return resp.StatusCode
}

func sendMail(host, user, pwd, from, to, subject, body, mailType string) error {
    auth := smtp.PlainAuth("""", user, pwd, strings.Split(host, "":"")[0])
    cntType := fmt.Sprintf(""Content-Type: text/%s;charset=UTF-8"", mailType)
    msg := fmt.Sprintf(""To: %s\r\nFrom: %s\r\nSubject: %s\r\n%s\r\n\r\n%s"",
        to, from, user, subject, cntType, body)

    return smtp.SendMail(host, auth, user, strings.Split(to, "",""), []byte(msg))
}

func getVideos(videoChan chan *videoInfo, htmlBuf *bytes.Buffer) error {
    defer HttpTransport.CloseIdleConnections()
    db, err := sql.Open(""mysql"", Conf[""weikan.mysql""])
    if err != nil {
        return err
    }

    rows, err := db.Query(GET_VIDEO_SQL)
    if err != nil {
        db.Close()
        return err
    }

    for rows.Next() {
        video := &videoInfo{}
        err = rows.Scan(&video.name, &video.tsid, &video.chapter,
            &video.chapterNum,
            &video.website, &video.descr, &video.videoId, &video.androidWebUrl,
            &video.iosWebUrl, &video.androidUrl, &video.androidUrl2,
            &video.iosUrl)
        if err != nil {
            db.Close()
            return err
        }

        videoChan <- video
        WG.Add(1)
    }

    db.Close()
    // wait check url finish
    WG.Wait()
    // send mail
    for {
        if htmlBuf.Len() == 0 {
            Log.Print(""no error found!!!!!!!!"")
            break
        }

        Log.Print(""found error !!!!!!!!"")
        /*
        err := sendMail(""smtp.gmail.com:587"", ""xxxx"",
            ""xxx"", ""xxx "",
            Conf[""mail.to""], ""xxxxx"",
            HtmlHead+htmlBuf.String()+HtmlTail, ""html"")
        if err != nil {
            Log.Printf(""sendMail failed (%s)"", err.Error())
            time.Sleep(10 * time.Second)
            continue
        }
        */

        Log.Print(""send mail"")
        break
    }

    Log.Print(""reset buf"")
    htmlBuf.Reset()
    return nil
}

func checkUrl(videoChan chan *videoInfo, errChan chan string) {
    defer func() {
        if err := recover(); err != nil {
            Log.Print(""rouintes failed : "", err)
        }
    }()

    for {
        video := <-videoChan
        ok := true
        errUrl := """"

        if code := getHttpStatusCode(video.androidWebUrl); code >= 400 {
            errUrl += fmt.Sprintf(""%s (%d)"",
                video.androidWebUrl, code)
            ok = false
        }

        if code := getHttpStatusCode(video.iosWebUrl); code >= 400 {
            errUrl += fmt.Sprintf(""%s (%d)"",
                video.iosWebUrl, code)
            ok = false
        }

        if code := getHttpStatusCode(video.androidUrl); code >= 400 {
            errUrl += fmt.Sprintf(""%s (%d)"",
                video.androidUrl, code)
            ok = false
        }

        if code := getHttpStatusCode(video.androidUrl2); code >= 400 {
            errUrl += fmt.Sprintf(""%s (%d)"",
                video.androidUrl2, code)
            ok = false
        }

        if code := getHttpStatusCode(video.iosUrl); code >= 400 {
            errUrl += fmt.Sprintf(""%s (%d)"",
                video.iosUrl, code)
            ok = false
        }

        if !ok {
            errChan %s%d%s
            %d%s%s%s%s`,
                video.name, video.tsid, video.chapter, video.chapterNum,
                video.descr, video.videoId,
                video.website, errUrl)
            Log.Printf(""\""%s\"" (%s) —— \""%s\"" checkurl err"", video.name,
                video.chapter, video.descr)
        } else {
            Log.Printf(""\""%s\"" (%s) —— \""%s\"" checkurl ok"", video.name,
                video.chapter, video.descr)
            WG.Done()
        }
    }
}

func mergeErr(errChan chan string, htmlBuf *bytes.Buffer) {
    defer func() {
        if err := recover(); err != nil {
            Log.Print(""rouintes failed : "", err)
        }
    }()

    for {
        html := <-errChan
        _, err := htmlBuf.WriteString(html)
        if err != nil {
            Log.Printf(""htmlBuf WriteString \""%s\"" failed (%s)"", html,
                err.Error())
            panic(err)
        }

        WG.Done()
    }
}

func main() {
    videoChan := make(chan *videoInfo, 100000)
    errChan := make(chan string, 100000)
    htmlBuf := &bytes.Buffer{}
    defer func() {
        if err := recover(); err != nil {
            Log.Print(""rouintes failed : "", err)
        }
    }()

    // check url
    for i := 0; i < CpuCore; i++ {
        go checkUrl(videoChan, errChan)
    }
    // merge error string then send mail
    go mergeErr(errChan, htmlBuf)

    for {
        // get Video and LiveSrc video source
        if err := getVideos(videoChan, htmlBuf); err != nil {
            Log.Printf(""getVideos failed (%s)"", err.Error())
            time.Sleep(10 * time.Second)
            continue
        }

        // time.Sleep(1 * time.Hour)
    }

    Log.Print(""exit..."")
}",8062
15794113,57,"package main

import (
    ""bufio""
    ""bytes""
    ""encoding/binary""
    ""fmt""
    ""os""
    ""runtime""
    ""unicode/utf16""
    ""unicode/utf8""
)

// UTF16BytesToString converts UTF-16 encoded bytes, in big or little endian byte order,
// to a UTF-8 encoded string.
func UTF16BytesToString(b []byte, o binary.ByteOrder) string {
    utf := make([]uint16, (len(b)+(2-1))/2)
    for i := 0; i+(2-1) < len(b); i += 2 {
        utf[i/2] = o.Uint16(b[i:])
    }
    if len(b)/2 < len(utf) {
        utf[len(utf)-1] = utf8.RuneError
    }
    return string(utf16.Decode(utf))
}

// UTF-16 endian byte order
const (
    unknownEndian = iota
    bigEndian
    littleEndian
)

// dropCREndian drops a terminal \r from the endian data.
func dropCREndian(data []byte, t1, t2 byte) []byte {
    if len(data) > 1 {
        if data[len(data)-2] == t1 && data[len(data)-1] == t2 {
            return data[0 : len(data)-2]
        }
    }
    return data
}

// dropCRBE drops a terminal \r from the big endian data.
func dropCRBE(data []byte) []byte {
    return dropCREndian(data, '\x00', '\r')
}

// dropCRLE drops a terminal \r from the little endian data.
func dropCRLE(data []byte) []byte {
    return dropCREndian(data, '\r', '\x00')
}

// dropCR drops a terminal \r from the data.
func dropCR(data []byte) ([]byte, int) {
    var endian = unknownEndian
    switch ld := len(data); {
    case ld != len(dropCRLE(data)):
        endian = littleEndian
    case ld != len(dropCRBE(data)):
        endian = bigEndian
    }
    return data, endian
}

// SplitFunc is a split function for a Scanner that returns each line of
// text, stripped of any trailing end-of-line marker. The returned line may
// be empty. The end-of-line marker is one optional carriage return followed
// by one mandatory newline. In regular expression notation, it is `\r?\n`.
// The last non-empty line of input will be returned even if it has no
// newline.
func ScanUTF16LinesFunc(byteOrder binary.ByteOrder) (bufio.SplitFunc, func() binary.ByteOrder) {

    // Function closure variables
    var endian = unknownEndian
    switch byteOrder {
    case binary.BigEndian:
        endian = bigEndian
    case binary.LittleEndian:
        endian = littleEndian
    }
    const bom = 0xFEFF
    var checkBOM bool = endian == unknownEndian

    // Scanner split function
    splitFunc := func(data []byte, atEOF bool) (advance int, token []byte, err error) {

        if atEOF && len(data) == 0 {
            return 0, nil, nil
        }

        if checkBOM {
            checkBOM = false
            if len(data) > 1 {
                switch uint16(bom) {
                case uint16(data[0])<<8 | uint16(data[1]):
                    endian = bigEndian
                    return 2, nil, nil
                case uint16(data[1])<<8 | uint16(data[0]):
                    endian = littleEndian
                    return 2, nil, nil
                }
            }
        }

        // Scan for newline-terminated lines.
        i := 0
        for {
            j := bytes.IndexByte(data[i:], '\n')
            if j < 0 {
                break
            }
            i += j
            switch e := i % 2; e {
            case 1: // UTF-16BE
                if endian != littleEndian {
                    if i > 1 {
                        if data[i-1] == '\x00' {
                            endian = bigEndian
                            // We have a full newline-terminated line.
                            return i + 1, dropCRBE(data[0 : i-1]), nil
                        }
                    }
                }
            case 0: // UTF-16LE
                if endian != bigEndian {
                    if i+1 < len(data) {
                        i++
                        if data[i] == '\x00' {
                            endian = littleEndian
                            // We have a full newline-terminated line.
                            return i + 1, dropCRLE(data[0 : i-1]), nil
                        }
                    }
                }
            }
            i++
        }

        // If we're at EOF, we have a final, non-terminated line. Return it.
        if atEOF {
            // drop CR.
            advance = len(data)
            switch endian {
            case bigEndian:
                data = dropCRBE(data)
            case littleEndian:
                data = dropCRLE(data)
            default:
                data, endian = dropCR(data)
            }
            if endian == unknownEndian {
                if runtime.GOOS == ""windows"" {
                    endian = littleEndian
                } else {
                    endian = bigEndian
                }
            }
            return advance, data, nil
        }

        // Request more data.
        return 0, nil, nil
    }

    // Endian byte order function
    orderFunc := func() (byteOrder binary.ByteOrder) {
        switch endian {
        case bigEndian:
            byteOrder = binary.BigEndian
        case littleEndian:
            byteOrder = binary.LittleEndian
        }
        return byteOrder
    }

    return splitFunc, orderFunc
}

func main() {
    file, err := os.Open(""utf16.le.txt"")
    if err != nil {
        fmt.Println(err)
        os.Exit(1)
    }
    defer file.Close()
    fmt.Println(file.Name())

    rdr := bufio.NewReader(file)
    scanner := bufio.NewScanner(rdr)
    var bo binary.ByteOrder // unknown, infer from data
    // bo = binary.LittleEndian // windows
    splitFunc, orderFunc := ScanUTF16LinesFunc(bo)
    scanner.Split(splitFunc)

    for scanner.Scan() {
        b := scanner.Bytes()
        s := UTF16BytesToString(b, orderFunc())
        fmt.Println(len(s), s)
        fmt.Println(len(b), b)
    }
    fmt.Println(orderFunc())

    if err := scanner.Err(); err != nil {
        fmt.Println(err)
    }
}",5831
16280176,60,"package main

/*
Fido fetches the list of public images from the Glance server, captures the IDs of images with 'status': 'active' and then queues the images for pre-fetching with the Glance CLI utility `glance-cache-manage`. Once the images are added to the queue, `glance-cache-prefetcher` is called to actively fetch the queued images into the local compute nodes' image cache.

See http://docs.openstack.org/developer/glance/cache.html for further details on the Glance image cache.
*/

import (
    ""bytes""
    ""encoding/json""
    ""fmt""
    ""io/ioutil""
    /*
        ""log""
        ""log/syslog""
    */
    ""net/http""
    ""os""
    ""os/exec""
)

func prefetchImages() error {

    cmd := exec.Command(""glance-cache-prefetcher"")
    err := cmd.Run()

    if err != nil {
        return fmt.Errorf(""glance-cache-prefetcher failed to execute properly: %v"", err)
    }

    return nil
}

func queueImages(hostname string, imageList []string) error {

    for _, image := range imageList {
        cmd := exec.Command(""glance-cache-manage"", ""--host="", hostname, ""queue-image"", image)
        err := cmd.Run()

        if err != nil {
            return fmt.Errorf(""glance-cache-manage failed to execute properly: %v"", err)
        } else {
            fmt.Printf(""Image %s queued"", image)
        }
    }

    return nil
}

func getBody(method string, url string, headers map[string]string, body []byte) ([]byte, error) {

    client := &http.Client{}
    req, err := http.NewRequest(method, url, bytes.NewReader(body))

    if err != nil {
        return nil, err
    }

    for key, value := range headers {
        req.Header.Add(key, value)
    }

    res, err := client.Do(req)
    defer res.Body.Close()

    if err != nil {
        return nil, err
    }

    var bodyBytes []byte

    if res.StatusCode == 200 {
        bodyBytes, err = ioutil.ReadAll(res.Body)
    } else if err != nil {
        return nil, err
    } else {
        return nil, fmt.Errorf(""The remote end did not return a HTTP 200 (OK) response."")
    }

    return bodyBytes, nil

}

func getImages(authToken string) ([]string, error) {

    type GlanceDetailResponse struct {
        Images []struct {
            Name   string `json:""name""`
            Status string `json:""status""`
            ID     string `json:""id""`
        }
    }

    method := ""GET""
    url := ""http://192.168.1.2:9292/v1.1/images/detail""
    headers := map[string]string{""X-Auth-Token"": authToken}

    bodyBytes, err := getBody(method, url, headers, nil)

    if err != nil {
        return nil, fmt.Errorf(""unable to retrieve the response body from the Glance API server: %v"", err)
    }

    var glance GlanceDetailResponse
    err = json.Unmarshal(bodyBytes, &glance)

    if err != nil {
        return nil, fmt.Errorf(""unable to parse the JSON response:"", err)
    }

    imageList := make([]string, 10)

    for _, image := range glance.Images {
        if image.Status == ""active"" {
            imageList = append(imageList, image.ID)
        }
    }

    return imageList, nil

}

func getToken() (string, error) {

    type TokenResponse struct {
        Auth []struct {
            Token struct {
                Expires string `json:""expires""`
                ID      string `json:""id""`
            }
        }
    }

    method := ""POST""
    url := ""http://192.168.1.2:5000/v2.0/tokens""
    headers := map[string]string{""Content-type"": ""application/json""}
    creds := []byte(`{""auth"":{""passwordCredentials"":{""username"": ""glance"", ""password"":""""}, ""tenantId"":""""}}`)

    bodyBytes, err := getBody(method, url, headers, creds)

    if err != nil {
        return """", err
    }

    var keystone TokenResponse
    err = json.Unmarshal(bodyBytes, &keystone)

    if err != nil {
        return """", err
    }

    authToken := string((keystone.Auth[0].Token.ID))

    return authToken, nil
}

func main() {

    /*
        slog, err := syslog.New(syslog.LOG_ERR, ""[fido]"")

        if err != nil {
            log.Fatalf(""unable to connect to syslog: %v"", err)
            os.Exit(1)
        } else {
            defer slog.Close()
        }
    */

    hostname, err := os.Hostname()

    if err != nil {
        // slog.Err(""Hostname not captured"")
        os.Exit(1)
    }

    authToken, err := getToken()

    if err != nil {
        // slog.Err(""The authentication token from the Glance API server was not retrieved"")
        os.Exit(1)
    }

    imageList, err := getImages(authToken)

    err = queueImages(hostname, imageList)

    if err != nil {
        // slog.Err(""Could not queue the images for pre-fetching"")
        os.Exit(1)
    }

    err = prefetchImages()

    if err != nil {
        // slog.Err(""Could not queue the images for pre-fetching"")
        os.Exit(1)
    }

    return
}",4764
17477311,82,"package main

/*
#include 
#include ""wrapper.h""
*/
import ""C""

import (
    ""fmt""
)

//export HandleXPCEvent
func HandleXPCEvent(event C.xpc_object_t) {
    fmt.Println(""Event was handled"")
}

func main() {
    name := C.CString(""com.example.xpc"")
    queue := C.dispatch_queue_create(name, nil)
    conn := C.xpc_connection_create(name, queue)
    C.set_event_handler(conn)

    //C.xpc_connection_resume(conn)
}
",414
18817336,92,"package client                                                                                                                                                                                              
import (                                                                                                                                                                                                    
    ""encoding/base64""                                                                                                                                                                                       
    ""crypto/aes""                                                                                                                                                                                            
    ""crypto/cipher""                                                                                                                                                                                         
    ""fmt""                                                                                                                                                                                                   
) 

var iv = []byte{34, 35, 35, 57, 68, 4, 35, 36, 7, 8, 35, 23, 35, 86, 35, 23}

func encodeBase64(b []byte) string {                                                                                                                                                                        
    return base64.StdEncoding.EncodeToString(b)                                                                                                                                                             
}                                                                                                                                                                                                           

func decodeBase64(s string) []byte {                                                                                                                                                                        
    data, err := base64.StdEncoding.DecodeString(s)                                                                                                                                                         
    if err != nil { panic(err) }                                                                                                                                                                            
    return data                                                                                                                                                                                             
}                                                                                                                                                                                                           

func Encrypt(key, text string) string {                                                                                                                                                                     
    block, err := aes.NewCipher([]byte(key))                                                                                                                                                                
    if err != nil { panic(err) }                                                                                                                                                                            
    plaintext := []byte(text)                                                                                                                                                                               
    cfb := cipher.NewCFBEncrypter(block, iv)                                                                                                                                                                
    ciphertext := make([]byte, len(plaintext))                                                                                                                                                              
    cfb.XORKeyStream(ciphertext, plaintext)                                                                                                                                                                 
    return encodeBase64(ciphertext)                                                                                                                                                                         
}                                                                                                                                                                                                           

func Decrypt(key, text string) string {                                                                                                                                                                     
    block, err := aes.NewCipher([]byte(key))                                                                                                                                                                
    if err != nil { panic(err) }                                                                                                                                                                            
    ciphertext := decodeBase64(text)                                                                                                                                                                        
    cfb := cipher.NewCFBEncrypter(block, iv)                                                                                                                                                                
    plaintext := make([]byte, len(ciphertext))                                                                                                                                                              
    cfb.XORKeyStream(plaintext, ciphertext)                                                                                                                                                                 
}",6263
19802242,96,"package main

import (
    ""bytes""
    ""errors""
    ""flag""
    ""fmt""
    ""log""
    ""net""
    ""net/http""
    ""net/url""
    ""runtime""
    ""strconv""
    ""time""
)

const DEFAULT_IDLE_TIMEOUT = 5 * time.Second

var (
    listen       string
    logOn        bool
    localhost, _ = url.Parse(""http://localhost:8080/"")
    client       = &http.Client{
        Transport: &http.Transport{
            Proxy: NoProxyAllowed,
            Dial: func(network, addr string) (net.Conn, error) {
                return NewTimeoutConnDial(network, addr, DEFAULT_IDLE_TIMEOUT)
            },
        },
    }
)

func main() {
    runtime.GOMAXPROCS(runtime.NumCPU())
    flag.StringVar(&listen, ""listen"", ""0.0.0.0:9000"", ""listen on address"")
    flag.BoolVar(&logOn, ""log"", true, ""enable logging"")
    flag.Parse()
    server := getTimeoutServer(listen, http.HandlerFunc(proxyHandlerFunc))
    log.Printf(""Starting router-server on %s\n"", listen)
    log.Fatal(server.ListenAndServe())
}

func proxyHandlerFunc(w http.ResponseWriter, req *http.Request) {
    if logOn {
        log.Printf(""%+v\n"", req)
    }
    // Setup request URL
    origURL := req.URL
    req.URL = new(url.URL)
    *req.URL = *localhost
    req.URL.Path, req.URL.RawQuery, req.URL.Fragment = origURL.Path, origURL.RawQuery, origURL.Fragment
    req.RequestURI, req.Host = """", req.URL.Host
    // Perform request
    resp, err := client.Do(req)
    if err != nil {
        w.WriteHeader(http.StatusBadGateway)
        w.Write([]byte(fmt.Sprintf(""%d - StatusBadGateway: %s"", http.StatusBadGateway, err)))
        return
    }
    defer resp.Body.Close()
    var respBuffer *bytes.Buffer
    if resp.ContentLength != -1 {
        respBuffer = bytes.NewBuffer(make([]byte, 0, resp.ContentLength))
    } else {
        respBuffer = new(bytes.Buffer)
    }
    if _, err = respBuffer.ReadFrom(resp.Body); err != nil {
        w.WriteHeader(http.StatusBadGateway)
        w.Write([]byte(fmt.Sprintf(""%d - StatusBadGateway: %s"", http.StatusBadGateway, err)))
        return
    }
    // Write result of request
    headers := w.Header()
    var key string
    var val []string
    for key, val = range resp.Header {
        headers[key] = val
    }
    headers.Set(""Content-Length"", strconv.Itoa(respBuffer.Len()))
    w.WriteHeader(resp.StatusCode)
    w.Write(respBuffer.Bytes())
}

func getTimeoutServer(addr string, handler http.Handler) *http.Server {
    //keeps people who are slow or are sending keep-alives from eating all our sockets
    const (
        HTTP_READ_TO  = DEFAULT_IDLE_TIMEOUT
        HTTP_WRITE_TO = DEFAULT_IDLE_TIMEOUT
    )
    return &http.Server{
        Addr:         addr,
        Handler:      handler,
        ReadTimeout:  HTTP_READ_TO,
        WriteTimeout: HTTP_WRITE_TO,
    }
}

func NoProxyAllowed(request *http.Request) (*url.URL, error) {
    return nil, nil
}

//TimeoutConn-------------------------
//Put me in my own TimeoutConn.go ?

type TimeoutConn struct {
    net.Conn
    readTimeout, writeTimeout time.Duration
}

var invalidOperationError = errors.New(""TimeoutConn does not support or allow .SetDeadline operations"")

func NewTimeoutConn(conn net.Conn, ioTimeout time.Duration) (*TimeoutConn, error) {
    return NewTimeoutConnReadWriteTO(conn, ioTimeout, ioTimeout)
}

func NewTimeoutConnReadWriteTO(conn net.Conn, readTimeout, writeTimeout time.Duration) (*TimeoutConn, error) {
    this := &TimeoutConn{
        Conn:         conn,
        readTimeout:  readTimeout,
        writeTimeout: writeTimeout,
    }
    now := time.Now()
    err := this.Conn.SetReadDeadline(now.Add(this.readTimeout))
    if err != nil {
        return nil, err
    }
    err = this.Conn.SetWriteDeadline(now.Add(this.writeTimeout))
    if err != nil {
        return nil, err
    }
    return this, nil
}

func NewTimeoutConnDial(network, addr string, ioTimeout time.Duration) (net.Conn, error) {
    conn, err := net.DialTimeout(network, addr, ioTimeout)
    if err != nil {
        return nil, err
    }
    if conn, err = NewTimeoutConn(conn, ioTimeout); err != nil {
        return nil, err
    }
    return conn, nil
}

func (this *TimeoutConn) Read(data []byte) (int, error) {
    this.Conn.SetReadDeadline(time.Now().Add(this.readTimeout))
    return this.Conn.Read(data)
}

func (this *TimeoutConn) Write(data []byte) (int, error) {
    this.Conn.SetWriteDeadline(time.Now().Add(this.writeTimeout))
    return this.Conn.Write(data)
}

func (this *TimeoutConn) SetDeadline(time time.Time) error {
    return invalidOperationError
}

func (this *TimeoutConn) SetReadDeadline(time time.Time) error {
    return invalidOperationError
}

func (this *TimeoutConn) SetWriteDeadline(time time.Time) error {
    return invalidOperationError
}",4725
20655702,108,"package main

import (
    ""crypto""
    ""crypto/rand""
    ""crypto/rsa""
    ""crypto/sha256""
    ""crypto/x509""
    ""encoding/base64""
    ""encoding/pem""
    ""errors""
    ""fmt""
    ""io/ioutil""
)

func main() {
    signer, err := loadPrivateKey(""private.pem"");
    if err != nil {
        fmt.Errorf(""signer is damaged: %v"", err)
    }

    toSign := ""date: Thu, 05 Jan 2012 21:31:40 GMT"";

    signed, err := signer.Sign([]byte(toSign))
    if err != nil {
        fmt.Errorf(""could not sign request: %v"", err)
    }
    sig := base64.StdEncoding.EncodeToString(signed)
    fmt.Printf(""Encoded: %v\n"", sig)


    parser, perr := loadPublicKey(""public.pem"");
    if perr != nil {
        fmt.Errorf(""could not sign request: %v"", err)
    }
    unsigned, err := parser.Unsign(signed);
     if err != nil {
        fmt.Errorf(""could not sign request: %v"", err)
    }

    fmt.Printf(""Decrypted: %v\n"", base64.StdEncoding.EncodeToString(unsigned))    
}


// loadPrivateKey loads an parses a PEM encoded private key file.
func loadPublicKey(path string) (Unsigner, error) {
        data, err := ioutil.ReadFile(path)

        if err != nil {
                return nil, err
        }
        return parsePublicKey(data)
}

// parsePublicKey parses a PEM encoded private key.
func parsePublicKey(pemBytes []byte) (Unsigner, error) {
        block, _ := pem.Decode(pemBytes)
        if block == nil {
                return nil, errors.New(""ssh: no key found"")
        }

        var rawkey interface{}
        switch block.Type {
        case ""PUBLIC KEY"":
                rsa, err := x509.ParsePKIXPublicKey(block.Bytes)
                if err != nil {
                        return nil, err
                }
                rawkey = rsa
        default:
                return nil, fmt.Errorf(""ssh: unsupported key type %q"", block.Type)
        }

        return newUnsignerFromKey(rawkey)
}


// loadPrivateKey loads an parses a PEM encoded private key file.
func loadPrivateKey(path string) (Signer, error) {
        data, err := ioutil.ReadFile(path)
        if err != nil {
                return nil, err
        }
        return parsePrivateKey(data)
}

// parsePublicKey parses a PEM encoded private key.
func parsePrivateKey(pemBytes []byte) (Signer, error) {
        block, _ := pem.Decode(pemBytes)
        if block == nil {
                return nil, errors.New(""ssh: no key found"")
        }

        var rawkey interface{}
        switch block.Type {
        case ""RSA PRIVATE KEY"":
                rsa, err := x509.ParsePKCS1PrivateKey(block.Bytes)
                if err != nil {
                        return nil, err
                }
                rawkey = rsa
        default:
                return nil, fmt.Errorf(""ssh: unsupported key type %q"", block.Type)
        }
        return newSignerFromKey(rawkey)
}

// A Signer is can create signatures that verify against a public key.
type Signer interface {
        // Sign returns raw signature for the given data. This method
        // will apply the hash specified for the keytype to the data.
        Sign(data []byte) ([]byte, error)
}

// A Signer is can create signatures that verify against a public key.
type Unsigner interface {
        // Sign returns raw signature for the given data. This method
        // will apply the hash specified for the keytype to the data.
        Unsign(data []byte) ([]byte, error)
}

func newSignerFromKey(k interface{}) (Signer, error) {
        var sshKey Signer
        switch t := k.(type) {
        case *rsa.PrivateKey:
                sshKey = &rsaPrivateKey{t}
        default: 
                return nil, fmt.Errorf(""ssh: unsupported key type %T"", k)
        }
        return sshKey, nil
}

func newUnsignerFromKey(k interface{}) (Unsigner, error) {
        var sshKey Unsigner
        switch t := k.(type) {
        case *rsa.PublicKey:
                sshKey = &rsaPublicKey{t}
        default:
                return nil, fmt.Errorf(""ssh: unsupported key type %T"", k)
        }
        return sshKey, nil
}

type rsaPublicKey struct {
    *rsa.PublicKey
}

type rsaPrivateKey struct {
        *rsa.PrivateKey
}

// Sign signs data with rsa-sha256
func (r *rsaPrivateKey) Sign(data []byte) ([]byte, error) {
        h := sha256.New()
        h.Write(data)
        d := h.Sum(nil)
        return rsa.SignPKCS1v15(rand.Reader, r.PrivateKey, crypto.SHA256, d)
}

// Unsign encrypts data with rsa-sha256
func (r *rsaPublicKey) Unsign(message []byte) ([]byte, error) {  
        return rsa.EncryptPKCS1v15(rand.Reader, r.PublicKey, message)        
}",4573
20768452,114,"type ModelB struct {
    MessageID          string   `datastore:""msg_id,noindex""`
    CategoryIDs        []string `datastore:""cat_ids,noindex""`
    ListIDs            []string `datastore:""list_ids,noindex""`
    DefaultListIDIndex int      `datastore:""default_list_id_index,noindex""`
}

type ModelA struct {
    DateJoin          time.Time `datastore:""date_join,""`
    Name              string    `datastore:""name,""`
    OwnerSalutation   string    `datastore:""owner_salutation,noindex""`
    OwnerEmailAddress string    `datastore:""owner_email_address,""`
    LogoURL           string    `datastore:""logo_url,noindex""`
    Messages          []ModelB  `datastore:""-""`
}

// Load is implemented for the PropertyLoaderSaver interface.
func (s *ModelA) Load(c <-chan datastore.Property) (err error) {
    f := make(chan datastore.Property, 32)
    errc := make(chan error, 1)
    defer func() {
        if err == nil {
            err = <-errc
        }
    }()
    go func() {
        defer close(f)
        for p := range c {
            if p.Name == ""bm"" {
                var b ModelB
                err := loadLocalStructuredProperty(&b, []byte(p.Value.(string)))
                if err != nil {
                    errc <- err
                    return
                }
                s.Messages = append(s.Messages, b)
            } else {
                f <- p
            }
        }
        errc <- nil
    }()
    return datastore.LoadStruct(s, f)
}",1460
21010854,121,gl.Clear(),10
21154561,139,"package main

import ""fmt""

func main() {
    a := []int{0, 1, 2, 3}
    for i := 0; i < len(a); {
        v := a[i]
        fmt.Printf(""i: %d v: %d\n"", i, v)
        fmt.Println(""before"", a)
        if v%2 == 0 {
            // delete a[i]
            a = append(a[:i], a[i+1:]...)
        } else {
            i++
        }
        fmt.Println(""after"", a, ""\n"")
    }
    fmt.Println(""final"", a)

}",401
21696845,147,"package main                                                                                                                                                                                      

import (                                                                                                                                                                                          
    ""io/ioutil""                                                                                                                                                                                   
    //""unicode/utf8""                                                                                                                                                                              
    //""fmt""                                                                                                                                                                                       

    ""gopkg.in/yaml.v1""                                                                                                                                                                        
)                                                                                                                                                                                                 

type Subtitle struct {                                                                                                                                                                            
    Line string                                                                                                                                                                                   
}                                                                                                                                                                                                 

func main() {                                                                                                                                                                                     
    filename := ""subtitle.yaml""                                                                                                                                                                   
    in, _ := ioutil.ReadFile(filename)                                                                                                                                                            
    var subtitle Subtitle                                                                                                                                                                         
    _ = goyaml.Unmarshal(in, &subtitle)                                                                                                                                                           
    out, _ := goyaml.Marshal(&subtitle)                                                                                                                                                           

    //for len(out) > 0 { // For debugging, see what the runes are                                                                                                                                                                         
    //  r, size := utf8.DecodeRune(out)                                                                                                                                                             
    //  fmt.Printf(""%c "", r)                                                                                                                                                              
    //  out = out[size:]                                                                                                                                                                            
    //}                                                                                                                                                                                           

    _ = ioutil.WriteFile(filename, out, 0644)                                                                                                                                                     
}",4330
21730796,160,"package main

import (
    ""flag""
    ""fmt""
    ""github.com/fitstar/falcore""
    ""github.com/fitstar/falcore/filter""
    ""net/http""
    ""os""
    ""os/signal""
    ""syscall""
)

// Command line options
var (
    port = flag.Int(""port"", 8000, ""the port to listen on"")
    path = flag.String(""base"", ""./www"", ""the path to serve files from"")
)

// very simple request filter
func Filter(req *falcore.Request) *http.Response {
    pid := syscall.Getpid()
    fmt.Println(pid, ""GET"", req.HttpRequest.URL.Path)

    // return falcore.StringResponse(request.HttpRequest, 200, nil, ""OK\n"")
    if req.HttpRequest.URL.Path == ""/"" {
        req.HttpRequest.URL.Path = ""AppNexus-Interesting.txt"" //""/summary.xml""
    }
    return nil
}

// flag to accept a socket file descriptor
var socketFd = flag.Int(""socket"", -1, ""Socket file descriptor"")

func main() {
    pid := syscall.Getpid()
    flag.Parse()
    fmt.Println(""Falcore hot restart running with pid:"", pid, ""to hot restart, issue the kill -1"", pid, ""command"")

    // create the pipeline
    pipeline := falcore.NewPipeline()

    // upstream filters
    pipeline.Upstream.PushBack(falcore.NewRequestFilter(Filter))

    // Serve files
    pipeline.Upstream.PushBack(&filter.FileFilter{
        BasePath: *path,
    })

    // downstream filters
    pipeline.Downstream.PushBack(filter.NewCompressionFilter(nil))

    // create the server with the pipeline
    srv := falcore.NewServer(*port, pipeline)

    // if passed the socket file descriptor, setup the listener that way
    // if you don't have it, the default is to create the socket listener
    // with the data passed to falcore.NewServer above (happens in ListenAndServer())
    if *socketFd != -1 {
        // I know I'm a child process if I get here so I can signal the parent when I'm ready to take over
        go childReady(srv)
        fmt.Printf(""%v Got socket FD: %v\n"", pid, *socketFd)
        srv.FdListen(*socketFd)
    }

    // using signals to manage the restart lifecycle
    go handleSignals(srv)

    // start the server
    // this is normally blocking forever unless you send lifecycle commands
    if err := srv.ListenAndServe(); err != nil {
        fmt.Printf(""%v Could not start server: %v"", pid, err)
    }
    fmt.Printf(""%v Exiting now\n"", pid)
}

// blocks on the server ready and when ready, it sends
// a signal to the parent so that it knows it cna now exit
func childReady(srv *falcore.Server) {
    pid := syscall.Getpid()
    // wait for the ready signal
    <-srv.AcceptReady
    // grab the parent and send a signal that the child is ready
    parent := syscall.Getppid()
    fmt.Printf(""%v Kill parent %v with SIGUSR1\n"", pid, parent)
    syscall.Kill(parent, syscall.SIGUSR1)
}

// setup and fork/exec myself. Make sure to keep open important FD's that won't get re-created by the child
// specifically, std* and your listen socket
func forker(srv *falcore.Server) (pid int, err error) {
    fmt.Printf(""Forking now with socket: %v\n"", srv.SocketFd())
    mypath := os.Args[0]
    args := []string{mypath, ""-socket"", fmt.Sprintf(""%v"", srv.SocketFd())}
    attr := new(syscall.ProcAttr)
    attr.Files = append([]uintptr(nil), 0, 1, 2, uintptr(srv.SocketFd()))
    pid, err = syscall.ForkExec(mypath, args, attr)
    return
}

// Handle lifecycle events
func handleSignals(srv *falcore.Server) {
    var sig os.Signal
    var sigChan = make(chan os.Signal)
    signal.Notify(sigChan, syscall.SIGHUP, syscall.SIGUSR1, syscall.SIGINT, syscall.SIGTERM, syscall.SIGTSTP)
    pid := syscall.Getpid()
    for {
        sig = <-sigChan
        switch sig {
        case syscall.SIGHUP:
            // send this to the paraent process to initiate the restart
            fmt.Println(pid, ""Received SIGHUP.  forking."")
            cpid, err := forker(srv)
            fmt.Println(pid, ""Forked pid:"", cpid, ""errno:"", err)
        case syscall.SIGUSR1:
            // child sends this back to the parent when it's ready to Accept
            fmt.Println(pid, ""Received SIGUSR1.  Stopping accept."")
            srv.StopAccepting()
        case syscall.SIGINT:
            fmt.Println(pid, ""Received SIGINT.  Shutting down."")
            os.Exit(0)
        case syscall.SIGTERM:
            fmt.Println(pid, ""Received SIGTERM.  Terminating."")
            os.Exit(0)
        case syscall.SIGTSTP:
            fmt.Println(pid, ""Received SIGTSTP.  Stopping."")
            syscall.Kill(pid, syscall.SIGSTOP)
        default:
            fmt.Println(pid, ""Received"", sig, "": ignoring"")
        }
    }
}",4528
21830447,161,"package main

    import (
        ""encoding/json""

    )

    type LocationReadable struct {
        District string
        City     string
        State    string
    }

    type Locale struct {
        Location         string
        CountryCode      string
        CurrencyId       string
        CurrencySymbol   string
        LocationReadable LocationReadable
    }

    type Media struct {
        Image string
        Video string
    }

    type Variations struct {
        FixedPrice float64
        Media      Media
        Quantity   int
    }

    type PaymentData struct {
        PaymentName    string
        PaymentService string
    }

    type Payment struct {
        Online  PaymentData
        Offline PaymentData
    }

    type Shipping struct {
        ShippingService        string
        ShippingName           string
        ShippingCost           float64
        HandlingTimeMax        int
        DispatchTimeMin        int
        DispatchTimeMax        int
        ShippingAdditionalCost int
    }
    type Item []struct {
        _version    string
        CategoryId  string
        Title       string
        Media       Media
        SellerId    string
        Locale      Locale
        ListingType string
        Payment     Payment
        StartTime   string
        EndTime     string
        Shipping    Shipping
        TitleSlug   string
        Variations  Variations
        _fpaiStatus string
    }
    func main(){
     itemInfoR := `{""locale"":{""location"":""51.51121389999999,-0.11982439999997041"",""countryCode"":""GB"",""currencyId"":""GBP"",""currencySymbol"":""Â£"",""locationReadable"":{""district"":""City of Westminster"",""city"":""London"",""state"":""Greater London""}},""_version"":""serving"",""categoryId"":[""Root"",""Cameras \u0026 Photo"",""Digital Cameras""],""title"":""many pictures"",""media"":{""image"":[""//lh5.ggpht.com/O_o_N6CFkClY5AV0-LqntpyFjor7Of4u23ZcK7lYwc2uY1ea7GWi61VDJZCB7UCb79svkjKPHIenqwEUhjHi0jdIQnnl6z_p03yktPUB1FBHezIQ"",""//lh6.ggpht.com/ih3q2d7CenGLPyupH9FpfsoJQWQpw1i8wWA2Kd26bFnSF2fbnKyGU9WePIhCgEeqw5p6YMVmFi1c9oS0Ag93aF_oZ3ZiwK7fQuSYIrZ9VhgXbrTHkw"",""//lh6.ggpht.com/7RJRsapsnwWL3_KiLIjMz4QojDzUvsztXtvKTFvIfde_AHccDnOibAvXRN73tTB4SeHzlj8S1LWxbYwwWFGn9elfCKdSb8BUIU5QJY1LO791HutQ"",""//lh6.ggpht.com/qAtjgyHAB734Ox_4NC_fa-ZRqrCjCmJu0Tp8bo-HMO88duv8l4hhuv2REBkB--yneFzOL7annecVlGty-YsKouondiOFVnAZWzjpdrfsGfbL6wh2"",""//lh3.ggpht.com/dWUbASepwHF4lHaXIPnpv4BNm2pCml9MlJt7s86s1cpu-PsYNmS0yQmKFKTM38q_oMLW_YJMJ19civ2gVViKAGYcZylRW7jN3w77AJvhzS6JE2g"",""//lh6.ggpht.com/9aXLmPRVeZnxkwvNb3mWTF8kvfEY_lho_lOVVc9AbNqLb8GQmiS_XXVZ3OKqMv2pxgYSayMYPPRh6ACYyh0H8KtS8mPD6MKUkEajwxkTtp5Q4Lo"",""//lh3.ggpht.com/FG_QXZPHJ2tTYwI_t5Fg1KqivglVg9RlJn0JRsu9Ox8vJ7IcBirb2IV_I1LL_WVOMxfTuBBSDLMlrw9v0MCAdmnPCR29sCbRGjhm6zEfIH-3q2QSdw"",""//lh4.ggpht.com/Y23DqORrVkM2m55f-rq5_BBrlkvQg4uX7AsAt-ixhMobjK_SFgFaDfktgLhkNsyKwSr9HcF8iiGY3Nw0xOKXG1sn6wyAWg_qsolmKjVOrM5V5mIR"",""//lh6.ggpht.com/mQ62Ly-DjMKPMzU1OcSPJ7SLBqym0uBjawlkTHfmb-HOKaD56dnitk1duwPFJVdbi0GUpd63RQvr2VMpHp6S1OQ3di-hq4-JPeRoS5FJzksXSvW_"",""//lh3.ggpht.com/dqWjWPcNsvlR1tMC_agizX19f9MDiNGWFYTYVn4kjJxzIIkEe0mLzNcvS62zVJxAOaitT-IgaUfZ-Ze23BgzbqYY-l600i_LbVe35Uinz6sXIyoB"",""//lh6.ggpht.com/xhSdFc9uHgghs_6gf3seUWYM-PG2oLmjTrpF7ptEEMqaIrQIa8VPfC6tXE7f3M13eZvDXYqMW_k0AHO5vwCEPNp-iObixskd_lBaKNfz3MH3SNQ"",""//lh5.ggpht.com/kYeoKPoZGJCow-G1FhnD8kzVjNjbQA8-Kyj8eAh0HL-fMZX9tTeFPQikTZdSU0kks4-5Ui54cZF2CjGut9vfMJAVDKIq3T-bAQewCxvfl2120tH5zQ"",""//lh5.ggpht.com/4qUl3d-G9EPBzcYKrimNsWhQw7CmONV0jgfVhxFgB9mEU_QLRCyNJTWs2A3xf6wc7AUF2DXrKEkoX-SNLMZ6s-O4aXXV9WOjOPcWdAYreMRBld0E"",""//lh5.ggpht.com/z-0C4G6EWYkelAF1LjPfl_UQcsp92H4joIPt8NfsOl0nPJ2VpzZYahWadKqTLfl6kq3C6aDBcwfGQyMWSozYoZIAOAW0yRvZrwxia321PlsKTxbZ"",""//lh4.ggpht.com/U7I12JrDYmMC_pUXpw8DVBjBilU67BvbM8qT8gJE0bQfkhHo7FOdMttiz3syP5IR-LyO4J1WBlfmZjvMjRr4GIBt4o3Vqp-hKz7q2_OGwGtsN5s"",""//lh3.ggpht.com/fF2XWEtqG23ybhzClhC_p8gvKJalf1vg7k3H7UkuAaIVubil7EgOvJUCwAZk2KiCtlPYp1E5Ep2xaxZjJRmg5EFSEAjqlMHJS_Wd1Bcje6xre4s"",""//lh3.ggpht.com/jgOebMihBoIZvHE4EOklJvZ_k-9egjNIlUKfKFcLkvXJs8g2FXjPvdFUbwqGrkHrMtyis8uOvgt-E51Vm11hq4bieh7h0cegca0VI4vFtFaAemU"",""//lh3.ggpht.com/MOrI-zKNMNrQE_aHj5hzbojP3T0hEMJKK6K8UO3e1NBC-nkcQeIM1QnvtJdT_G-W4e7-qv4BiqwdWcNHBpZXOmmX3tcuYEV8u_ANEoa9_aUIfeyg"",""//lh6.ggpht.com/SyIS5sGOkTG7k_jFF14wzH9Evrblv6o4pHBI6z6X070-xhAeyut_kRO6xHtDID4KLcWFvItjQy-plPcJ6K1T9tlFOrtaryEPvuAYdMVx8e0TTw"",""//lh6.ggpht.com/2Pp9kLYFhDT3USwHinU5OxnzcWWOLI0nOWe29gOD5KMzyEcXoHkTN-AutJV9M8F_9eqAP379XB9O1d0BWPanhr-MguzKxfHeUvYTs6yHzDkxyfe0NA"",""//lh4.ggpht.com/7aofqklSkF3AMDfF19yqsA9J3EfEiKy1NdOelEGKNnW0Cv5tGEpq2PF_jZO1MVoBbrrmVVRv0Tdq7I8KyZbIlyHdbTs1jMl7dEFqVMvsPcyaORyHlQ"",""//lh4.ggpht.com/anYJHqkMCkuhmIHQTBspLtWcDTyx1ZRe84_q5pAgVEOVmsKkaKhS725N4YFoj2zpJrBP7iTC2vf1GUtrp6H7kkm8c1k6zkW6I_Gf5f9A3re_I8Ex"",""//lh3.ggpht.com/OtSw0rU-DvfoXgoWrQdkln6Kz7O14TF9qrPNJSGJnZLeDqUEctOn1DT09pdwwVpNQV-cXmVYQL-PX4XPhpZLWH1ciSkVT6WHNmTz1D9pHphBwJUv"",""//lh3.ggpht.com/cTCZnXPIjI-EO2bvQdLgeoSLOSlMFcv805n347Zyci9XDYUdcVDC_5H7SFVYDr4pC5HtQDYnrOHL6AinLW7hWtfSCLlvVhVUNQ-DlDn0NwZ-1iCO-g"",""//lh4.ggpht.com/i-mL_JcF9rwjQq6HnuKzuAHU41_UGxQ62IOPZvaDrATXaPFbhe-EbT7ZIpboyNA5PXRCsxNsZ9hu58edRvNs5ScgKN8Lg-00J2LhlwMAbdEsv7b0nw"",""//lh6.ggpht.com/D_YV2BG1WWwl67xNloP3sxzRkqhcVTgJi58L-A8nLrOcMR_tBqLz4fHEGQ-qiNcG_-32MNy3dlSPWrTBKzBcweJxgMnRVet5yuGfelUlwehDtXX_3w""],""video"":[]},""sellerId"":""mihai"",""listingType"":""fixedPrice"",""payment"":{""online"":[{""paymentName"":""PayPal"",""paymentService"":""paypal""}],""offline"":[{""paymentName"":""Pay on Pick-up"",""paymentService"":""payOnPickup""}]},""startTime"":""2014-01-04T10:02:18+00:00"",""endTime"":""2014-04-04T10:02:18+00:00"",""shipping"":[{""shippingService"":""economy"",""shippingName"":""Economy"",""shippingCost"":1.0,""handlingTimeMax"":4,""dispatchTimeMin"":1,""dispatchTimeMax"":10,""shippingAdditionalCost"":""2""},{""shippingService"":""localPickup"",""shippingName"":""Local Pick-Up"",""shippingCost"":0.0,""handlingTimeMax"":2,""dispatchTimeMin"":0,""dispatchTimeMax"":0,""shippingAdditionalCost"":""0""}],""titleSlug"":""many-pictures"",""variations"":[{""fixedPrice"":222999.0,""media"":{""image"":[""//lh6.ggpht.com/ih3q2d7CenGLPyupH9FpfsoJQWQpw1i8wWA2Kd26bFnSF2fbnKyGU9WePIhCgEeqw5p6YMVmFi1c9oS0Ag93aF_oZ3ZiwK7fQuSYIrZ9VhgXbrTHkw"",""//lh6.ggpht.com/9aXLmPRVeZnxkwvNb3mWTF8kvfEY_lho_lOVVc9AbNqLb8GQmiS_XXVZ3OKqMv2pxgYSayMYPPRh6ACYyh0H8KtS8mPD6MKUkEajwxkTtp5Q4Lo"",""//lh3.ggpht.com/FG_QXZPHJ2tTYwI_t5Fg1KqivglVg9RlJn0JRsu9Ox8vJ7IcBirb2IV_I1LL_WVOMxfTuBBSDLMlrw9v0MCAdmnPCR29sCbRGjhm6zEfIH-3q2QSdw""],""video"":[]},""quantity"":1121,""Brand"":""Bell \u0026 Howell""},{""fixedPrice"":211.0,""media"":{""image"":[""//lh6.ggpht.com/qAtjgyHAB734Ox_4NC_fa-ZRqrCjCmJu0Tp8bo-HMO88duv8l4hhuv2REBkB--yneFzOL7annecVlGty-YsKouondiOFVnAZWzjpdrfsGfbL6wh2"",""//lh3.ggpht.com/FG_QXZPHJ2tTYwI_t5Fg1KqivglVg9RlJn0JRsu9Ox8vJ7IcBirb2IV_I1LL_WVOMxfTuBBSDLMlrw9v0MCAdmnPCR29sCbRGjhm6zEfIH-3q2QSdw"",""//lh6.ggpht.com/9aXLmPRVeZnxkwvNb3mWTF8kvfEY_lho_lOVVc9AbNqLb8GQmiS_XXVZ3OKqMv2pxgYSayMYPPRh6ACYyh0H8KtS8mPD6MKUkEajwxkTtp5Q4Lo"",""//lh3.ggpht.com/MOrI-zKNMNrQE_aHj5hzbojP3T0hEMJKK6K8UO3e1NBC-nkcQeIM1QnvtJdT_G-W4e7-qv4BiqwdWcNHBpZXOmmX3tcuYEV8u_ANEoa9_aUIfeyg""],""video"":[]},""quantity"":2,""Brand"":""Fujifilm""},{""fixedPrice"":22.0,""media"":{""image"":[""//lh3.ggpht.com/jgOebMihBoIZvHE4EOklJvZ_k-9egjNIlUKfKFcLkvXJs8g2FXjPvdFUbwqGrkHrMtyis8uOvgt-E51Vm11hq4bieh7h0cegca0VI4vFtFaAemU"",""//lh3.ggpht.com/MOrI-zKNMNrQE_aHj5hzbojP3T0hEMJKK6K8UO3e1NBC-nkcQeIM1QnvtJdT_G-W4e7-qv4BiqwdWcNHBpZXOmmX3tcuYEV8u_ANEoa9_aUIfeyg"",""//lh4.ggpht.com/anYJHqkMCkuhmIHQTBspLtWcDTyx1ZRe84_q5pAgVEOVmsKkaKhS725N4YFoj2zpJrBP7iTC2vf1GUtrp6H7kkm8c1k6zkW6I_Gf5f9A3re_I8Ex""],""video"":[]},""quantity"":12,""Brand"":""Gateway""}],""_fpaiStatus"":""published""}`
    itemInfoBytes := []byte(itemInfoR)
var ItemInfo Item
        er := json.Unmarshal(itemInfoBytes, &ItemInfo)
            if er != nil {
                panic(er)
            }

        }",7727
21865681,162,"package main

import (
    ""crypto/md5""
    ""encoding/hex""
    ""fmt""
    ""github.com/gocql/gocql""
    ""github.com/gorilla/mux""
    ""github.com/gorilla/sessions""
    ""net/http""
    ""time""
)

var store = sessions.NewCookieStore([]byte(""something-very-secret""))

var router = mux.NewRouter()

func init() {

    store.Options = &sessions.Options{
        Domain:   ""localhost"",
        Path:     ""/"",
        MaxAge:   3600 * 1, // 1 hour
        HttpOnly: true,
    }
}
func main() {
    //session handling
    router.HandleFunc(""/"", SessionHandler)
    router.HandleFunc(""/signIn"", SignInHandler)
    router.HandleFunc(""/signUp"", SignUpHandler)
    router.HandleFunc(""/logOut"", LogOutHandler)
    http.Handle(""/"", router)
    http.ListenAndServe("":8100"", nil)
}

//handler for signIn
func SignInHandler(res http.ResponseWriter, req *http.Request) {

    email := req.FormValue(""email"")
    password := req.FormValue(""password"")

    //Generate hash of password
    hasher := md5.New()
    hasher.Write([]byte(password))
    encrypted_password := hex.EncodeToString(hasher.Sum(nil))

    //cassandra connection
    cluster := gocql.NewCluster(""localhost"")
    cluster.Keyspace = ""gbuy""
    cluster.DefaultPort = 9042
    cluster.Consistency = gocql.Quorum
    session, _ := cluster.CreateSession()
    defer session.Close()

    //select query
    var firstname string
    stmt := ""SELECT firstname FROM USER WHERE email= '"" + email + ""' and password ='"" + encrypted_password + ""';""
    err := session.Query(stmt).Scan(&firstname)
    if err != nil {
        fmt.Fprintf(res, ""failed"")
    } else {
        if firstname == """" {
            fmt.Fprintf(res, ""failed"")
        } else {
            fmt.Fprintf(res, firstname)
        }
    }

    //store in session variable
    sessionNew, _ := store.Get(req, ""loginSession"")

    // Set some session values.
    sessionNew.Values[""email""] = email
    sessionNew.Values[""name""] = firstname

    // Save it.
    sessionNew.Save(req, res)
    //store.Save(req,res,sessionNew)

    fmt.Println(""Session after logging:"")
    fmt.Println(sessionNew)

}

//handler for signUp
func SignUpHandler(res http.ResponseWriter, req *http.Request) {

    fName := req.FormValue(""fName"")
    lName := req.FormValue(""lName"")
    email := req.FormValue(""email"")
    password := req.FormValue(""passwd"")
    birthdate := req.FormValue(""date"")
    city := req.FormValue(""city"")
    gender := req.FormValue(""gender"")

    //Get current timestamp and format it.
    sysdate := time.Now().Format(""2006-01-02 15:04:05-0700"")

    //Generate hash of password
    hasher := md5.New()
    hasher.Write([]byte(password))
    encrypted_password := hex.EncodeToString(hasher.Sum(nil))

    //cassandra connection
    cluster := gocql.NewCluster(""localhost"")
    cluster.Keyspace = ""gbuy""
    cluster.DefaultPort = 9042
    cluster.Consistency = gocql.Quorum
    session, _ := cluster.CreateSession()
    defer session.Close()

    //Insert the data into the Table
    stmt := ""INSERT INTO USER (email,firstname,lastname,birthdate,city,gender,password,creation_date) VALUES ('"" + email + ""','"" + fName + ""','"" + lName + ""','"" + birthdate + ""','"" + city + ""','"" + gender + ""','"" + encrypted_password + ""','"" + sysdate + ""');""
    fmt.Println(stmt)
    err := session.Query(stmt).Exec()
    if err != nil {
        fmt.Fprintf(res, ""failed"")
    } else {
        fmt.Fprintf(res, fName)
    }
}

//handler for logOut
func LogOutHandler(res http.ResponseWriter, req *http.Request) {
    sessionOld, err := store.Get(req, ""loginSession"")

    fmt.Println(""Session in logout"")
    fmt.Println(sessionOld)
    if err = sessionOld.Save(req, res); err != nil {
        fmt.Println(""Error saving session: %v"", err)
    }
}

//handler for Session
func SessionHandler(res http.ResponseWriter, req *http.Request) {

    router.PathPrefix(""/"").Handler(http.FileServer(http.Dir(""../static/"")))
    session, _ := store.Get(req, ""loginSession"")

    fmt.Println(""Session in SessionHandler"")
    fmt.Println(session)


    if val, ok := session.Values[""email""].(string); ok {
        // if val is a string
        switch val {
        case """": {
            http.Redirect(res, req, ""html/login.html"", http.StatusFound) }
        default:
            http.Redirect(res, req, ""html/home.html"", http.StatusFound)
        }
    } else {
        // if val is not a string type
        http.Redirect(res, req, ""html/login.html"", http.StatusFound)
    }
}",4451
22124192,170,"package main

import (
    ""crypto/rsa""
    ""crypto/tls""
    ""encoding/hex""
    ""fmt""
    ""log""
    ""math/big""
    ""net""
    ""net/smtp""
)

func main() {

    var (
        host     = ""smtp.myexchange.com""
        port     = 587
        from     = ""sender@example.org""
        password = ""password""
        to       = []string{""recipient@example.org""}
        msg      = []byte(""This is my message"")
        auth     = smtp.PlainAuth("""", from, password, ""smtp.myexchange.com"")
    )

    conf := new(tls.Config)
    conf.Certificates = make([]tls.Certificate, 1)
    conf.Certificates[0].Certificate = [][]byte{testRSACertificate}
    conf.Certificates[0].PrivateKey = testRSAPrivateKey
    conf.CipherSuites = []uint16{tls.TLS_RSA_WITH_RC4_128_SHA}
    conf.InsecureSkipVerify = true
    conf.MinVersion = tls.VersionSSL30
    conf.MaxVersion = tls.VersionTLS10
    serverAddr := fmt.Sprintf(""%s:%d"", host, port)

    conn, err := net.Dial(""tcp"", serverAddr)
    if err != nil {
        log.Printf(""Error Dialing %s\n"", err)
        return
    }

    client, err := smtp.NewClient(conn, host)
    if err != nil {
        log.Printf(""Error SMTP connection: %s\n"", err)
        return
    }

    if err = client.StartTLS(conf); err != nil {
        log.Printf(""Error performing StartTLS: %s\n"", err)
        return
    }

    if ok, _ := client.Extension(""AUTH""); ok {
        if err := client.Auth(auth); err != nil {
            log.Printf(""Error during AUTH %s\n"", err)
            return
        }
    }

    if err := client.Mail(from); err != nil {
        log.Printf(""Error: %s\n"", err)
        return
    }

    for _, addr := range to {
        if err := client.Rcpt(addr); err != nil {
            log.Printf(""Error: %s\n"", err)
            return
        }
    }

    w, err := client.Data()
    if err != nil {
        log.Printf(""Error: %s\n"", err)
        return
    }

    _, err = w.Write(msg)
    if err != nil {
        log.Printf(""Error: %s\n"", err)
        return

    }

    err = w.Close()
    if err != nil {
        log.Printf(""Error: %s\n"", err)
        return

    }

    client.Quit()
}

// Code below from http://golang.org/src/pkg/crypto/tls/handshake_server_test.go

func bigFromString(s string) *big.Int {
    ret := new(big.Int)
    ret.SetString(s, 10)
    return ret
}

func fromHex(s string) []byte {
    b, _ := hex.DecodeString(s)
    return b
}

var testRSACertificate = fromHex(""308202b030820219a00302010202090085b0bba48a7fb8ca300d06092a864886f70d01010505003045310b3009060355040613024155311330110603550408130a536f6d652d53746174653121301f060355040a1318496e7465726e6574205769646769747320507479204c7464301e170d3130303432343039303933385a170d3131303432343039303933385a3045310b3009060355040613024155311330110603550408130a536f6d652d53746174653121301f060355040a1318496e7465726e6574205769646769747320507479204c746430819f300d06092a864886f70d010101050003818d0030818902818100bb79d6f517b5e5bf4610d0dc69bee62b07435ad0032d8a7a4385b71452e7a5654c2c78b8238cb5b482e5de1f953b7e62a52ca533d6fe125c7a56fcf506bffa587b263fb5cd04d3d0c921964ac7f4549f5abfef427100fe1899077f7e887d7df10439c4a22edb51c97ce3c04c3b326601cfafb11db8719a1ddbdb896baeda2d790203010001a381a73081a4301d0603551d0e04160414b1ade2855acfcb28db69ce2369ded3268e18883930750603551d23046e306c8014b1ade2855acfcb28db69ce2369ded3268e188839a149a4473045310b3009060355040613024155311330110603550408130a536f6d652d53746174653121301f060355040a1318496e7465726e6574205769646769747320507479204c746482090085b0bba48a7fb8ca300c0603551d13040530030101ff300d06092a864886f70d010105050003818100086c4524c76bb159ab0c52ccf2b014d7879d7a6475b55a9566e4c52b8eae12661feb4f38b36e60d392fdf74108b52513b1187a24fb301dbaed98b917ece7d73159db95d31d78ea50565cd5825a2d5a5f33c4b6d8c97590968c0f5298b5cd981f89205ff2a01ca31b9694dda9fd57e970e8266d71999b266e3850296c90a7bdd9"")

var testRSAPrivateKey = &rsa.PrivateKey{
    PublicKey: rsa.PublicKey{
        N: bigFromString(""131650079503776001033793877885499001334664249354723305978524647182322416328664556247316495448366990052837680518067798333412266673813370895702118944398081598789828837447552603077848001020611640547221687072142537202428102790818451901395596882588063427854225330436740647715202971973145151161964464812406232198521""),
        E: 65537,
    },
    D: bigFromString(""29354450337804273969007277378287027274721892607543397931919078829901848876371746653677097639302788129485893852488285045793268732234230875671682624082413996177431586734171663258657462237320300610850244186316880055243099640544518318093544057213190320837094958164973959123058337475052510833916491060913053867729""),
    Primes: []*big.Int{
        bigFromString(""11969277782311800166562047708379380720136961987713178380670422671426759650127150688426177829077494755200794297055316163155755835813760102405344560929062149""),
        bigFromString(""10998999429884441391899182616418192492905073053684657075974935218461686523870125521822756579792315215543092255516093840728890783887287417039645833477273829""),
    },
}",4970
22430354,175,"type service_config struct {
    Services []struct {
        Name    string
        Command string
        Request map[string]interface{}
    }
}

var ServiceConf = service_config{}

err_json := json.Unmarshal(file_content, &ServiceConf)

for _, s := range ServiceConf.Services {
  log.Println(s)
}
",299
23268356,182,"package main
import ""fmt""
import ""time""
import ""code.google.com/p/go-sqlite/go1/sqlite3""
import ""crypto/rand""
import ""encoding/base64"" 

func getrandomtext() (string) {
    b := make([]byte, 12)
    rand.Read(b)
    en := base64.StdEncoding // or URLEncoding
    enclen := en.EncodedLen(len(b))
    d := make([]byte, enclen)
    en.Encode(d, b)
    returntext := string(d[:enclen])
    //fmt.Printf(""getrandomtext() : '""+returntext+""'\n"")
    return returntext
}

func main() {
    dbname := ""multitasking.db""
    tablename := ""multiwrite""
    defer time.Sleep(5000 * time.Millisecond)
    db, err := sqlite3.Open(""file:""+dbname+""?file:locked.sqlite?cache=shared&mode=rwc"")
    defer db.Close()
    if err != nil {
        fmt.Printf(""failed to open database, error: "" + err.Error() + ""\n"") 
        return
    } 
    err = db.Exec(""DROP TABLE IF EXISTS ""+tablename+"";"")
    if err != nil {
        fmt.Printf(""error dropping table ""+tablename+"": ""+err.Error()+""\n"")
    }
    err = db.Exec(""CREATE TABLE ""+tablename+"" (id INTEGER PRIMARY KEY AUTOINCREMENT, text VARCHAR(200));"")
    if err != nil {
        fmt.Printf(""error creating table ""+tablename+"": ""+err.Error()+""\n"") 
        return
    } else {
        fmt.Printf(""successfully created table ""+tablename+""!\n"") 
    }
    var insertcount int = 128
    fmt.Printf(""inserting %d random text rows ...\n"", insertcount) 
    var counter int = 0
    insertloop:
    if counter < insertcount {
        counter++
        go func(count int) {
            if db.Exec(""INSERT INTO ""+tablename+""(text) VALUES(\""""+getrandomtext()+""\"");"") !=nil {
                fmt.Printf("" -%d"", count)
            } else {
                fmt.Printf("" +%d"", count)
            }
        }(counter)
        goto insertloop
    }
    fmt.Printf(""\nExecuted! Waiting some seconds...\n"")
    time.Sleep(3000 * time.Millisecond)         
    fmt.Printf(""\nRequesting...\n"")
    ReadTable, err := db.Prepare(""SELECT id, text FROM ""+tablename+"";"")
    err = ReadTable.Query()
    if err != nil {
        fmt.Printf(""failed to read '""+tablename+""' table, error: "" + err.Error() + ""\n"")
        return
    } 
    Readloop:
    var RowId int
    var RowText string
    err = ReadTable.Scan(&RowId, &RowText)
    if err == nil {
        fmt.Printf(""> %d | %s\n"", RowId, RowText)
        ReadTable.Next() 
        goto Readloop
    }
    fmt.Printf(""Sqlite3 test done! :)\n"")
}",2399
24004951,198,"// Direct port of R code from nmath/{phyper,dbinom,stirlerr}.c and {dpq,nmath}.h.
// Code licensed under GPL for that reason (c) Dan Kortschak.
package main

import (
    ""errors""
    ""fmt""
    ""math""
)

func main() {
    // Example values come from:
    // http://stackoverflow.com/questions/8382806/r-hypergeometric-test-phyper
    fmt.Println(Phyper(62, 1998, 5260-1998, 131, true, false))

    for x := 0.; x < 10; x++ {
        fmt.Println(Phyper(x, 10, 7, 8, true, false))
    }
    fmt.Println()
    for x := 0.; x < 10; x++ {
        fmt.Println(Dhyper(x, 10, 7, 8, false))
    }
    fmt.Println()
    for x := 0.; x < 10; x++ {
        fmt.Println(Qhyper(x, 10, 7, 8, true, false))
    }
}

var ErrDomain = errors.New(""hyper: argument out of domain"")

const (
    epsilon = 2.2204460492503131e-16
    min     = 2.2250738585072014e-308
)

// Sample of n balls from r red and b black ones; x are red
func Phyper(x, r, b, n float64, lowerTail, logP bool) (float64, error) {
    x = math.Floor(x + 1e-7)
    r = round(r)
    b = round(b)
    n = round(n)

    if r  r+b {
        return math.NaN(), ErrDomain
    }

    if x*(r+b) > n*r {
        b, r = r, b
        x = n - x - 1
        lowerTail = !lowerTail
    }

    if x < 0 {
        return dt0(lowerTail, logP), nil
    }
    if x >= r || x >= n {
        return dt1(lowerTail, logP), nil
    }

    d, err := Dhyper(x, r, b, n, logP)
    if err != nil {
        return d, err
    }
    pd := pdhyper(x, r, b, n, logP)

    if logP {
        return log(d+pd, lowerTail), nil
    }
    res := d * pd
    if lowerTail {
        return res, nil
    }
    // Use 0.5 - p + 0.5 to perhaps gain 1 bit of accuracy
    res = 0.5 - res
    return res + 0.5, nil
}

func Dhyper(x, r, b, n float64, giveLog bool) (float64, error) {
    if negativeOrNotInteger(r) || negativeOrNotInteger(b) || negativeOrNotInteger(n) || n > r+b {
        return math.NaN(), ErrDomain
    }
    if x < 0 {
        return 0, nil
    }
    if x != math.Floor(x) {
        return 0, fmt.Errorf(""non-integer x = %f"", x)
    }

    x = round(x)
    r = round(r)
    b = round(b)
    n = round(n)

    if n  b {
        return 0, nil
    }
    if n == 0 {
        if x == 0 {
            return 1, nil
        }
        return 0, nil
    }

    p := n / (r + b)
    q := (r + b - n) / (r + b)

    p1, err := dbinom(x, r, p, q, giveLog)
    if err != nil {
        return math.NaN(), err
    }
    p2, err := dbinom(n-x, b, p, q, giveLog)
    if err != nil {
        return math.NaN(), err
    }
    p3, err := dbinom(n, r+b, p, q, giveLog)
    if err != nil {
        return math.NaN(), err
    }

    if giveLog {
        return p1 + p2 - p3, nil
    }
    return p1 * p2 / p3, nil
}

func Qhyper(p, NR, NB, n float64, lowerTail, logP bool) (float64, error) {
    if notFinite(p) || notFinite(NR) || notFinite(NB) || notFinite(n) {
        return math.NaN(), ErrDomain
    }

    NR = round(NR)
    NB = round(NB)
    N := NR + NB
    n = round(n)
    if NR  N {
        return math.NaN(), ErrDomain
    }

    /* Goal: Find xr (= #{red balls in sample}) such that
    * phyper(xr, NR,NB, n) >= p > phyper(xr - 1, NR,NB, n)
     */

    xstart := math.Max(0, n-NB)
    xend := math.Min(n, NR)

    if logP {
        if p > 0 {
            return math.NaN(), ErrDomain
        }
        if p == 0 { /* upper bound*/
            if lowerTail {
                return xend, nil
            }
            return xstart, nil
        }
        if math.IsInf(p, -1) {
            if lowerTail {
                return xstart, nil
            }
            return xend, nil
        }
    } else { /* !logP */
        if p  1 {
            return math.NaN(), ErrDomain
        }
        if p == 0 {
            if lowerTail {
                return xstart, nil
            }
            return xend, nil
        }
        if p == 1 {
            if lowerTail {
                return xend, nil
            }
            return xstart, nil
        }
    }

    xr := xstart
    xb := n - xr /* always ( = #{black balls in sample} ) */

    smallN := N < 1000 /* won't have underflow in product below */
    /* if N is small, term := product.ratio( bin.coef );
    otherwise work with its logarithm to protect against underflow */
    t1, err := lfastchoose(NR, xr)
    if err != nil {
        return 0, err
    }
    t2, err := lfastchoose(NB, xb)
    if err != nil {
        return 0, err
    }
    t3, err := lfastchoose(N, n)
    if err != nil {
        return 0, err
    }
    term := t1 + t2 - t3
    if smallN {
        term = math.Exp(term)
    }
    NR -= xr
    NB -= xb

    if !lowerTail || logP {
        p = qIv(p, lowerTail, logP)
    }
    p *= 1 - 1000*epsilon /* was 64, but failed on FreeBSD sometimes */
    var sum float64
    if smallN {
        sum = term
    } else {
        sum = math.Exp(term)
    }

    for sum < p && xr < xend {
        xr++
        NB++
        if smallN {
            term *= (NR / xr) * (xb / NB)
        } else {
            term += math.Log((NR / xr) * (xb / NB))
        }
        if smallN {
            sum += term
        } else {
            sum += math.Exp(term)
        }
        xb--
        NR--
    }
    return xr, nil
}

func lfastchoose(n, k float64) (float64, error) {
    lb, err := lbeta(n-k+1, k+1)
    if err != nil {
        return math.NaN(), err
    }
    return -math.Log(n+1) - lb, nil
}

func lbeta(a, b float64) (float64, error) {
    p := a
    q := a
    if b < p {
        p = b
    } /* := min(a,b) */
    if b > q {
        q = b
    } /* := max(a,b) */

    /* both arguments must be >= 0 */
    if p < 0 {
        return math.NaN(), ErrDomain
    } else if p == 0 {
        return math.Inf(1), nil
    } else if notFinite(q) { /* q == +Inf */
        return math.Inf(1), nil
    }

    if p >= 10 {
        /* p and q are big. */
        corr := stirlerr(p) + stirlerr(q) - stirlerr(p+q)
        return math.Log(q)*-0.5 + logSqrt2Pi + corr + (p-0.5)*math.Log(p/(p+q)) + q*math.Log1p(-p/(p+q)), nil
    } else if q >= 10 {
        /* p is small, but q is big. */
        corr := stirlerr(q) - stirlerr(p+q)
        return math.Gamma(p) + corr + p - p*math.Log(p+q) + (q-0.5)*math.Log1p(-p/(p+q)), nil
    } else {
        /* p and q are small: p <= q < 10. */
        /* R change for very small args */
        if p < min {
            return lgamma(p) + (lgamma(q) - lgamma(p+q)), nil
        }
    }
    return math.Log(math.Gamma(p) * (math.Gamma(q) / math.Gamma(p+q))), nil
}

func lgamma(p float64) float64 {
    r, _ := math.Lgamma(p)
    return r
}

func qIv(p float64, lowerTail, logP bool) float64 {
    if logP {
        if lowerTail {
            return math.Exp(p)
        }
        return -math.Expm1(p)
    }
    if lowerTail {
        return p
    }
    p = 0.5 - p
    return p + 0.5
}

// Calculate
//
// phyper (x, r, b, n, TRUE, FALSE)
// [log] ----------------------------------
// dhyper (x, r, b, n, FALSE)
//
// without actually calling phyper. This assumes that
//
// x * (r + b) <= n * r
func pdhyper(x, r, b, n float64, logP bool) float64 {

    sum := 0.
    term := 1.

    for x > 0 && term >= epsilon*sum {
        term *= x * (b - n + x) / (n + 1 - x) / (r + 1 - x)
        sum += term
        x--
    }

    if logP {
        return math.Log1p(sum)
    }
    return 1 + sum
}

var (
    ln2   = math.Log(2)
    ln2Pi = math.Log(2 * math.Pi)
)

func log(x float64, lowerTail bool) float64 {
    if lowerTail {
        return math.Log(x)
    }
    if x > -ln2 {
        return math.Log(-math.Expm1(x))
    }
    return math.Log1p(-math.Exp(x))
}

func dbinom(x, n, p, q float64, giveLog bool) (float64, error) {
    if p == 0 {
        if x == 0 {
            return 1, nil
        }
        return 0, nil
    }
    if q == 0 {
        if x == n {
            return 1, nil
        }
        return 0, nil
    }

    if x == 0 {
        if n == 0 {
            return 1, nil
        }
        if p < 0.1 {
            t, err := bd0(n, n*q)
            if err != nil {
                return math.NaN(), err
            }
            return exp(-t-n*p, giveLog), nil
        }
        return exp(n*math.Log(q), giveLog), nil
    }
    if x == n {
        if q < 0.1 {
            t, err := bd0(n, n*p)
            if err != nil {
                return math.NaN(), err
            }
            return exp(-t-n*q, giveLog), nil
        }
        return exp(n*math.Log(p), giveLog), nil
    }
    if x  n {
        return 0, nil
    }

    // n*p or n*q can underflow to zero if n and p or q are small. This
    // used to occur in dbeta, and gives NaN as from R 2.3.0.
    t1, err := bd0(x, n*p)
    if err != nil {
        return math.NaN(), err
    }
    t2, err := bd0(n-x, n*q)
    if err != nil {
        return math.NaN(), err
    }
    lc := stirlerr(n) - stirlerr(x) - stirlerr(n-x) - t1 - t2

    // f = (M_2PI*x*(n-x))/n; could overflow or underflow
    // Upto R 2.7.1:
    // lf = log(M_2PI) + log(x) + log(n-x) - log(n);
    // -- following is much better for x << n :
    lf := ln2Pi + math.Log(x) + math.Log1p(-x/n)

    return exp(lc-0.5*lf, giveLog), nil
}

func negativeOrNotInteger(x float64) bool {
    return x < 0 || x != math.Floor(x)
}

func notFinite(x float64) bool {
    return math.IsNaN(x) || math.IsInf(x, 0)
}

func round(x float64) float64 {
    if _, frac := math.Modf(x); frac >= 0.5 {
        return math.Ceil(x)
    }
    return math.Floor(x)
}

func exp(x float64, giveLog bool) float64 {
    if giveLog {
        return x
    }
    return math.Exp(x)
}

func dt0(lowerTail, logP bool) float64 {
    if lowerTail {
        return d0(logP)
    }
    return d1(logP)
}

func dt1(lowerTail, logP bool) float64 {
    if lowerTail {
        return d1(logP)
    }
    return d0(logP)
}

func d0(logP bool) float64 {
    if logP {
        return math.Inf(-1)
    }
    return 0
}

func d1(logP bool) float64 {
    if logP {
        return 0
    }
    return 1
}

// bd0(x,M) :=  M * D0(x/M) = M*[ x/M * log(x/M) + 1 - (x/M) ] =
//       =  x * log(x/M) + M - x
// where M = E[X] = n*p (or = lambda), for   x, M > 0
//
// in a manner that should be stable (with small relative error)
// for all x and M=np. In particular for x/np close to 1, direct
// evaluation fails, and evaluation is based on the Taylor series
// of log((1+v)/(1-v)) with v = (x-M)/(x+M) = (x-np)/(x+np).
//
func bd0(x, np float64) (float64, error) {
    if notFinite(x) || notFinite(np) || np == 0 {
        return math.NaN(), ErrDomain
    }

    if math.Abs(x-np) < 0.1*(x+np) {
        v := (x - np) / (x + np) // might underflow to 0
        s := (x - np) * v        // s using v -- change by MM
        if math.Abs(s) < min {
            return s, nil
        }
        ej := 2 * x * v
        v = v * v
        for j := 1; j < 1000; j++ {
            // Taylor series; 1000: no infinite loop
            // as |v| < .1,  v^2000 is ""zero""
            ej *= v // = v^(2j+1)
            s1 := s + ej/float64((j<<1)+1)
            if s1 == s { // last term was effectively 0
                return s1, nil
            }
            s = s1
        }
    }
    /* else:  | x - np |  is not too small */
    return x*math.Log(x/np) + np - x, nil
}

var (
    // error for 0, 0.5, 1.0, 1.5, ..., 14.5, 15.0.
    sfErrHalves = [31]float64{
        0.0, // n=0 - wrong, place holder only
        0.1534264097200273452913848,   // 0.5
        0.0810614667953272582196702,   // 1.0
        0.0548141210519176538961390,   // 1.5
        0.0413406959554092940938221,   // 2.0
        0.03316287351993628748511048,  // 2.5
        0.02767792568499833914878929,  // 3.0
        0.02374616365629749597132920,  // 3.5
        0.02079067210376509311152277,  // 4.0
        0.01848845053267318523077934,  // 4.5
        0.01664469118982119216319487,  // 5.0
        0.01513497322191737887351255,  // 5.5
        0.01387612882307074799874573,  // 6.0
        0.01281046524292022692424986,  // 6.5
        0.01189670994589177009505572,  // 7.0
        0.01110455975820691732662991,  // 7.5
        0.010411265261972096497478567, // 8.0
        0.009799416126158803298389475, // 8.5
        0.009255462182712732917728637, // 9.0
        0.008768700134139385462952823, // 9.5
        0.008330563433362871256469318, // 10.0
        0.007934114564314020547248100, // 10.5
        0.007573675487951840794972024, // 11.0
        0.007244554301320383179543912, // 11.5
        0.006942840107209529865664152, // 12.0
        0.006665247032707682442354394, // 12.5
        0.006408994188004207068439631, // 13.0
        0.006171712263039457647532867, // 13.5
        0.005951370112758847735624416, // 14.0
        0.005746216513010115682023589, // 14.5
        0.005554733551962801371038690, // 15.0
    }

    logSqrt2Pi = math.Log(math.Sqrt(2 * math.Pi))
)

// stirlerr(n) = log(n!) - log( sqrt(2*pi*n)*(n/e)^n )
//             = log Gamma(n+1) - 1/2 * [log(2*pi) + log(n)] - n*[log(n) - 1]
//             = log Gamma(n+1) - (n + 1/2) * log(n) + n - log(2*pi)/2
func stirlerr(n float64) float64 {
    const (
        S0 = 1. / 12.
        S1 = 1. / 360.
        S2 = 1. / 1260.
        S3 = 1. / 1680.
        S4 = 1. / 1188.
    )

    var nn float64

    if n <= 15.0 {
        nn = n + n
        if nn == math.Floor(nn) {
            return sfErrHalves[int(nn)]
        }
        lg, _ := math.Lgamma(n + 1)
        return lg - (n+0.5)*math.Log(n) + n - logSqrt2Pi
    }

    nn = n * n
    switch {
    case n > 500:
        return ((S0 - S1/nn) / n)
    case n > 80:
        return ((S0 - (S1-S2/nn)/nn) / n)
    case n > 35:
        return ((S0 - (S1-(S2-S3/nn)/nn)/nn) / n)
    default: // 15 < n <= 35
        return (S0 - (S1-(S2-(S3-S4/nn)/nn)/nn)/nn) / n
    }
}",13684
24316030,199,"// web1 project main.go
package main

import (
    ""errors""
    ""fmt""
    ""github.com/jmcvetta/neoism""
    ""html/template""
    ""io/ioutil""
    ""net/http""
    ""regexp""
)

type Page struct {
    Title string
    Body  string
}

func (p *Page) save() error {
    db, err := neoism.Connect(""http://localhost:7474/db/data"")
    if err != nil {
        return err
    }
    res := []struct {
        N neoism.Node
    }{}
    cq := neoism.CypherQuery{
        Statement:  ""MERGE (n:Page {title: {title}}) ON MATCH SET n.body = {body} RETURN n"",
        Parameters: neoism.Props{""title"": p.Title, ""body"": p.Body},
        Result:     &res,
    }
    db.Cypher(&cq)
    return nil
}

func loadPage(title string) (*Page, error) {
    db, err := neoism.Connect(""http://localhost:7474/db/data"")
    if err != nil {
        return nil, err
    }
    res := []struct {
        Title string `json:""a.title""` // `json` tag matches column name in query
        Body  string `json:""a.body""`
    }{}
    cq := neoism.CypherQuery{
        Statement: `
            MATCH (a:Page)
            WHERE a.title = {name}
            RETURN a.title, a.body
        `,
        Parameters: neoism.Props{""name"": title},
        Result:     &res,
    }
    db.Cypher(&cq)
    r := res[0]
    if r.Title == """" || r.Body == """" {
        return nil, errors.New(""Page doesn't exist"")
    }
    return &Page{Title: r.Title, Body: r.Body}, nil
}

func viewHandler(w http.ResponseWriter, r *http.Request, title string) {
    p, err := loadPage(title)
    if err != nil {
        http.Redirect(w, r, ""/edit/""+title, http.StatusFound)
        return
    }
    renderTemplate(w, ""view"", p)
}

func editHandler(w http.ResponseWriter, r *http.Request, title string) {
    p, err := loadPage(title)
    if err != nil {
        p = &Page{Title: title}
    }
    renderTemplate(w, ""edit"", p)
}

func saveHandler(w http.ResponseWriter, r *http.Request, title string) {
    body := r.FormValue(""body"")
    p := &Page{Title: title, Body: body}
    err := p.save()
    if err != nil {
        http.Error(w, err.Error(), http.StatusInternalServerError)
        return
    }
    http.Redirect(w, r, ""/view/""+title, http.StatusFound)
}

func homeHandler(w http.ResponseWriter, r *http.Request) {
    body, err := ioutil.ReadFile(""home.html"")
    if err != nil {
        http.Error(w, err.Error(), http.StatusInternalServerError)
        return
    }
    fmt.Fprintf(w, ""%s"", body)
}

func rootHandler(w http.ResponseWriter, r *http.Request) {
    http.Redirect(w, r, ""/home"", http.StatusFound)
}

var templates = template.Must(template.ParseFiles(""edit.html"", ""view.html""))

func renderTemplate(w http.ResponseWriter, tmpl string, p *Page) {
    err := templates.ExecuteTemplate(w, tmpl+"".html"", p)
    if err != nil {
        http.Error(w, err.Error(), http.StatusInternalServerError)
    }
}

var validPath = regexp.MustCompile(""^/(edit|save|view)/([a-zA-Z0-9]+)$"")

func makeHandler(fn func(http.ResponseWriter, *http.Request, string)) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        m := validPath.FindStringSubmatch(r.URL.Path)
        if m == nil {
            http.NotFound(w, r)
            return
        }
        fn(w, r, m[2])
    }
}

func main() {
    http.HandleFunc(""/view/"", makeHandler(viewHandler))
    http.HandleFunc(""/edit/"", makeHandler(editHandler))
    http.HandleFunc(""/save/"", makeHandler(saveHandler))
    http.HandleFunc(""/home"", homeHandler)
    http.HandleFunc(""/"", rootHandler)
    http.ListenAndServe("":8082"", nil)
}",3534
24456511,206,"package main

import (
    ""errors""
    ""fmt""
    ""os""
    ""os/exec""
    ""regexp""
    ""strings""

    ""github.com/codegangsta/cli""
    ""github.com/puerkitobio/goquery""
)

const (
    MainSite        = ""https://parahumans.wordpress.com/""
    TableOfContents = ""https://parahumans.wordpress.com/table-of-contents/""
)

type Arc struct {
    Identifier string
    Title      string
    Chapters   []Chapter
}

type Chapter struct {
    Title      string
    Url        string
    Tags       []string
    Paragraphs []Paragraph
    Retries    int
    DatePosted string
}

type Paragraph string

// Format the paragraph
func (p *Paragraph) Format() {
    s := string(*p)

    // Handle emphasis
    s = strings.Replace(s, """", ""*"", -1)
    s = strings.Replace(s, """", ""*"", -1)
    s = strings.Replace(s, """", ""*"", -1)
    s = strings.Replace(s, """", ""*"", -1)

    // Handle bold
    s = strings.Replace(s, """", ""**"", -1)
    s = strings.Replace(s, """", ""**"", -1)
    s = strings.Replace(s, """", ""**"", -1)
    s = strings.Replace(s, """", ""**"", -1)

    // Remove new lines
    s = strings.Replace(s, ""\n"", """", -1)

    // And random double spaces
    s = strings.Replace(s, "".  "", "". "", -1)

    *p = Paragraph(s)
}

// Return the Arc that the given chapter belongs to
func (ch *Chapter) WhichArc(arcList []*Arc) (*Arc, error) {
    for _, arc := range arcList {
        if strings.Replace(ch.Title[:2], ""."", """", -1) == arc.Identifier {
            return arc, nil
        }
    }
    return &Arc{}, errors.New(""chapter '"" + ch.Title + ""' did not match any Arcs"")
}

// Parse a chapter and return it
func (ch *Chapter) Parse(done chan bool) {
    if ch.Retries > 3 {
        panic(""Chapter url '"" + ch.Url + ""' has timed out too many times"")
    }
    // Get the chapter
    if strings.HasPrefix(ch.Url, ""http"") == false {
        // Make sure it begins with http so goquery can use it
        ch.Url = ""https://"" + ch.Url
    }
    doc, err := goquery.NewDocument(ch.Url)
    if err != nil {
        // Try again
        ch.Retries++
        go ch.Parse(done)
        return
    }

    // Set the new chapter title
    ch.Title = doc.Find(""h1.entry-title"").Text()

    // Set the tags
    doc.Find("".entry-meta a[rel=tag]"").Each(func(_ int, s *goquery.Selection) {
        ch.Tags = append(ch.Tags, s.Text())
        if len(ch.Tags) == 0 {
            ch.Tags = append(ch.Tags, ""NONE"")
        }
    })

    // Get the date it was posted
    ch.DatePosted = doc.Find(""time.entry-date"").Text()

    // Now we'll get all the paragraphs
    doc.Find("".entry-content > p"").Each(func(_ int, s *goquery.Selection) {
        // Check for the previous/next links
        if len(s.Find(""a"").Nodes) > 0 {
            return
        }

        // Get the paragraph HTML
        st, _ := s.Html()
        para := Paragraph("""")

        // Get the actual paragraph
        if val, exists := s.Attr(""padding-left""); exists && val == ""30px"" {
            // Check to see if the paragraph is special (indented) block
            para = Paragraph(""    "" + st)
        } else if val, exists := s.Attr(""text-align""); exists && val == ""center"" {
            // Otherwise check to see if it's a separator paragraph
            para = Paragraph(""----------"")
        } else {
            // It's just a normal paragraph in this case
            para = Paragraph(st)
        }

        // And add the paragraph to the chapter
        para.Format()
        ch.Paragraphs = append(ch.Paragraphs, para)
    })

    // Finally, let's signal a success
    done <- true
}

// Return a slice of Arcs extracted from the table of contents
func ParseArcs(s string) []*Arc {
    arcs := []*Arc{}
    r, _ := regexp.Compile(`[0-9]+`)
    for _, line := range strings.Split(s, ""\n"") {
        line = strings.TrimSpace(line)
        if strings.HasPrefix(line, ""Arc"") {
            arcs = append(arcs, &Arc{
                Identifier: r.FindString(line),
                Title:      line,
            })
        } else if strings.HasPrefix(line, ""Epilogue"") {
            arcs = append(arcs, &Arc{
                Identifier: ""E"",
                Title:      line,
            })
        }
    }
    return arcs
}

func main() {
    // Define the app
    app := cli.NewApp()
    app.Name = ""Worm Scraper""
    app.Usage = ""A tool to let you get an updated EPUB copy of the serial web novel Worm, by Wildbow""
    app.Version = ""1.0""
    app.Author = ""Benjamin Harris""

    // Define the application flags
    app.Flags = []cli.Flag{
        cli.BoolFlag{""pdf"", ""Save the book as a PDF instead of an EPUB, if possible""},
        cli.BoolFlag{""with-link"", ""Include a link to the chapter online""},
        cli.BoolFlag{""with-tags"", ""Include the tags each chapter was posted under""},
        cli.BoolFlag{""with-date"", ""Include the date each chapter was posted""},
    }

    // The heart of the application
    app.Action = func(context *cli.Context) {
        // Starting the program
        fmt.Println(""Starting to scrape Worm"")

        // Get the list of arcs from the table of contents
        fmt.Println(""Gathering links from table of contents..."")
        contents, err := goquery.NewDocument(TableOfContents)
        if err != nil {
            panic(""Failed to get the table of contents! "" + err.Error())
        }

        // Parse the arcs
        arcs := ParseArcs(contents.Find("".entry-content"").Text())

        // Now get the links for the arc chapters
        contents.Find("".entry-content a:not([class*=share-icon])"").Each(func(_ int, s *goquery.Selection) {
            ch := Chapter{}
            ch.Title = strings.Replace(strings.TrimSpace(s.Text()), ""\n"", """", -1)
            ch.Url, _ = s.Attr(""href"")

            if ch.Title == """" {
                return
            }

            arc, _ := ch.WhichArc(arcs)
            arc.Chapters = append(arc.Chapters, ch)
        })

        // Manually add missing chapter in Epilogue
        c := Chapter{
            Title: ""E.2"",
            Url:   ""https://parahumans.wordpress.com/2013/11/05/teneral-e-2/"",
        }
        a, _ := c.WhichArc(arcs)
        a.Chapters = append(a.Chapters, c)
        copy(a.Chapters[1+1:], a.Chapters[1:])
        a.Chapters[1] = c

        // Now start getting the chapters
        chapters := 0
        done := make(chan bool)
        for _, arc := range arcs {
            for i, _ := range arc.Chapters {
                chapters++
                go arc.Chapters[i].Parse(done)
            }
        }

        fmt.Println(""Starting to parse"", chapters, ""chapters"")
        fmt.Print(""Finished: "")

        totalChapters := chapters
        for {
            select {
            case <-done:
                chapters--
                fmt.Print(totalChapters-chapters, "","")
            }
            if chapters == 0 {
                // We're done with all the chapters
                close(done)
                fmt.Println()
                break
            }
        }

        // And let's write all this stuff to a file now
        fmt.Println(""Saving results to file..."")
        f, err := os.OpenFile(""Worm.md"", os.O_RDWR|os.O_CREATE|os.O_EXCL, 0666)
        if err != nil {
            panic(err)
        }
        defer f.Close()

        // Define pagebreak
        PageBreak := ""\n\n""

        // Write the cover
        f.WriteString(""# Worm\n\n"")
        f.WriteString(""By Wildbow\n\n"")
        f.WriteString(""Website: "" + MainSite)

        // Now loop through the Arcs
        for _, arc := range arcs {
            f.WriteString(PageBreak + ""# "" + arc.Title)
            for _, chapter := range arc.Chapters {
                f.WriteString(""\n\n"")
                f.WriteString(""## "" + chapter.Title + ""\n\n"")
                if context.Bool(""with-tags"") {
                    f.WriteString(""**Tags:** "" + strings.Join(chapter.Tags, "", "") + ""  "")
                }
                if context.Bool(""with-date"") {
                    f.WriteString(""**Date:** "" + chapter.DatePosted + ""  "")
                }
                if context.Bool(""with-link"") {
                    f.WriteString(""**Link:** "" + chapter.Url + ""  "")
                }
                f.WriteString(""\n\n"")

                // Now save the chapter's paragraphs
                for _, p := range chapter.Paragraphs {
                    f.WriteString(string(p) + ""\n\n"")
                }
            }
        }

        // Now let's try to convert the markdown file into an ebook format (epub, pdf)
        fmt.Print(""Attempting to convert Markdown file... "")
        cmdText := []string{""-S"", ""Worm.md"", ""--epub-chapter-level"", ""2"", ""-o"", ""Worm.epub""}
        if context.Bool(""pdf"") {
            cmdText = []string{""Worm.md"", ""-o"", ""Worm.pdf""}
            PageBreak = ``
        }
        cmd := exec.Command(""pandoc"", cmdText...)
        err = cmd.Run()
        if err != nil {
            fmt.Println(""Conversion failed! Make sure you've installed Pandoc (http://johnmacfarlane.net/pandoc/installing.html) if you want to convert the generated Markdown file to an ebook compatible format. In the meantime, we've left you the Markdown file."")
        } else {
            _ = os.Remove(""Worm.md"")
            fmt.Println(""Completed!"")
        }
    }

    // Run the application
    app.Run(os.Args)
}",9250
24640352,217,"package main

import (
    ""fmt""
    ""io""
    ""net/http""
    ""regexp""
    ""strconv""

    ""github.com/zenazn/goji""
    ""github.com/zenazn/goji/param""
    ""github.com/zenazn/goji/web""
)

// Note: the code below cuts a lot of corners to make the example app simple.

func main() {
    // Add routes to the global handler
    goji.Get(""/"", Root)
    // Fully backwards compatible with net/http's Handlers
    goji.Get(""/greets"", http.RedirectHandler(""/"", 301))
    // Use your favorite HTTP verbs
    goji.Post(""/greets"", NewGreet)
    // Use Sinatra-style patterns in your URLs
    goji.Get(""/users/:name"", GetUser)
    // Goji also supports regular expressions with named capture groups.
    goji.Get(regexp.MustCompile(`^/greets/(?P\d+)$`), GetGreet)

    // Middleware can be used to inject behavior into your app. The
    // middleware for this application are defined in middleware.go, but you
    // can put them wherever you like.
    goji.Use(PlainText)

    admin := web.New()
    goji.Handle(""/admin/*"", admin)
    admin.Use(SuperSecure)

    // Goji's routing, like Sinatra's, is exact: no effort is made to
    // normalize trailing slashes.
    goji.Get(""/admin"", http.RedirectHandler(""/admin/"", 301))


    admin.Get(""/admin/"", AdminRoot)
    admin.Get(""/admin/finances"", AdminFinances)

    // Use a custom 404 handler
    goji.NotFound(NotFound)

    goji.Serve()
}",1379
24937062,236,"func Listen(net, laddr string) (Listener, error) {
   la, err := resolveAddr(""listen"", net, laddr, noDeadline)
   if err != nil {
      return nil, &OpError{Op: ""listen"", Net: net, Addr: nil, Err: err}
   }
   var l Listener
   switch la := la.toAddr().(type) {
   case *TCPAddr:
      l, err = ListenTCP(net, la)
   case *UnixAddr:
      l, err = ListenUnix(net, la)
   default:
      return nil, &OpError{Op: ""listen"", Net: net, Addr: la, Err: &AddrError{Err: ""unexpected address type"", Addr: laddr}}
   }
   if err != nil {
      return nil, err // l is non-nil interface containing nil pointer
   }
   return l, nil
}
",622
25107540,253,"func main() {
    inFile, err := os.Open(*srcFile)
    if err != nil {
        log.LogErrorf(""Error opening dump: %v"", err)
        return
    }
    defer inFile.Close()

    var wg sync.WaitGroup
    input := make(chan []byte, 51)


    go func() {
        wg.Add(1)
        for line := range input {
            log.Printf(""Bytes: %s"", line)
            // process the line
        }
        wg.Done()
    }()

    scanner := bufio.NewScanner(inFile)
    count := 0
    for scanner.Scan() {
        count++
        log.Printf(""Scanned: %d"", count)
        if err := scanner.Err(); err != nil {
            log.LogErrorf(""Error scanning: %v"", err)
        }
        newestBytes := scanner.Bytes()
        log.Printf(""Bytes: %s"", newestBytes)
        input <- newestBytes
    }
    close(input)
    wg.Wait()
}",811
25175111,270,"package main

import (
    ""bytes""
    ""code.google.com/p/go.text/transform""
    ""code.google.com/p/go.text/unicode/norm""
    ""compress/zlib""
    ""encoding/gob""
    ""fmt""
    ""github.com/AlasdairF/BinSearch""
    ""io/ioutil""
    ""os""
    ""regexp""
    ""runtime""
    ""strings""
    ""unicode""
    ""unicode/utf8""
)

type TokensStruct struct {
    binsearch.Key_string
    Value [][5]uint32
}

type Trainer struct {
    Tokens      TokensStruct
    TokensCount uint
}

func checkErr(err error) {
    if err == nil {
        return
    }
    fmt.Println(`Some Error:`, err)
    panic(err)
}

// Local helper function for normalization of UTF8 strings.
func isMn(r rune) bool {
    return unicode.Is(unicode.Mn, r) // Mn: nonspacing marks
}

// This map is used by RemoveAccents function to convert non-accented characters.
var transliterations = map[rune]string{'Æ': ""E"", 'Ð': ""D"", 'Ł': ""L"", 'Ø': ""OE"", 'Þ': ""Th"", 'ß': ""ss"", 'æ': ""e"", 'ð': ""d"", 'ł': ""l"", 'ø': ""oe"", 'þ': ""th"", 'Œ': ""OE"", 'œ': ""oe""}

//  removeAccentsBytes converts accented UTF8 characters into their non-accented equivalents, from a []byte.
func removeAccentsBytesDashes(b []byte) ([]byte, error) {
    mnBuf := make([]byte, len(b))
    t := transform.Chain(norm.NFD, transform.RemoveFunc(isMn), norm.NFC)
    n, _, err := t.Transform(mnBuf, b, true)
    if err != nil {
        return nil, err
    }
    mnBuf = mnBuf[:n]
    tlBuf := bytes.NewBuffer(make([]byte, 0, len(mnBuf)*2))
    for i, w := 0, 0; i < len(mnBuf); i += w {
        r, width := utf8.DecodeRune(mnBuf[i:])
        if r == '-' {
            tlBuf.WriteByte(' ')
        } else {
            if d, ok := transliterations[r]; ok {
                tlBuf.WriteString(d)
            } else {
                tlBuf.WriteRune(r)
            }
        }
        w = width
    }
    return tlBuf.Bytes(), nil
}

func LoadZip(filename string) ([]byte, error) {
    // Open file for reading
    fi, err := os.Open(filename)
    if err != nil {
        return nil, err
    }
    defer fi.Close()
    // Attach ZIP reader
    fz, err := zlib.NewReader(fi)
    if err != nil {
        return nil, err
    }
    defer fz.Close()
    // Pull
    data, err := ioutil.ReadAll(fz)
    if err != nil {
        return nil, err
    }
    return norm.NFC.Bytes(data), nil // return normalized
}

func getTokens(pibn string) []string {
    var data []byte
    var err error
    data, err = LoadZip(`/storedir/` + pibn + `/text.zip`)
    checkErr(err)
    data, err = removeAccentsBytesDashes(data)
    checkErr(err)
    data = bytes.ToLower(data)
    data = reg2.ReplaceAll(data, []byte(""$2"")) // remove contractions
    data = reg.ReplaceAllLiteral(data, nil)
    tokens := strings.Fields(string(data))
    return tokens
}

func (t *Trainer) Start() {
    data, err := ioutil.ReadFile(`list.txt`)
    checkErr(err)
    pibns := bytes.Fields(data)
    for i, pibn := range pibns {
        tokens := getTokens(string(pibn))
        t.addTokens(tokens)
        if i%100 == 0 {
            runtime.GC() // I added this just to try to stop the memory craziness, but it makes no difference
        }
    }
}

func (t *Trainer) addTokens(tokens []string) {
    for _, tok := range tokens {
        if _, ok := dictionary[tok]; ok {
            if indx, ok2 := t.Tokens.Find(tok); ok2 {
                ar := t.Tokens.Value[indx]
                ar[0]++
                t.Tokens.Value[indx] = ar
                t.TokensCount++
            } else {
                t.Tokens.AddKeyAt(tok, indx)
                t.Tokens.Value = append(t.Tokens.Value, [5]uint32{0, 0, 0, 0, 0})
                copy(t.Tokens.Value[indx+1:], t.Tokens.Value[indx:])
                t.Tokens.Value[indx] = [5]uint32{1, 0, 0, 0, 0}
                t.TokensCount++
            }
        }
    }
    return
}

func LoadDictionary() {
    dictionary = make(map[string]bool)
    data, err := ioutil.ReadFile(`dictionary`)
    checkErr(err)
    words := bytes.Fields(data)
    for _, word := range words {
        strword := string(word)
        dictionary[strword] = false
    }
}

var reg = regexp.MustCompile(`[^a-z0-9\s]`)
var reg2 = regexp.MustCompile(`\b(c|l|all|dall|dell|nell|sull|coll|pell|gl|agl|dagl|degl|negl|sugl|un|m|t|s|v|d|qu|n|j)'([a-z])`) //contractions
var dictionary map[string]bool

func main() {
    trainer := new(Trainer)
    LoadDictionary()
    trainer.Start()
}",4373
25268071,274,"package main

import (
    ""crypto""
    ""crypto/rand""
    ""crypto/rsa""
    ""crypto/sha1""
    ""crypto/x509""
    ""encoding/base64""
    ""encoding/pem""
    ""fmt""
    ""log""
)

const (
    data = ""TEST DATA TO COMPUTE""

    privKeyPEM = `-----BEGIN RSA PRIVATE KEY-----
MIIBOgIBAAJBAK3ADijXKw72+YbC5QKK2y7IosCp7rWOhTf8Ph07ZA0KjdbKtfL/
7dmNKjSP6EkC/DJUWfZJNLIlGOtDLLA/AnsCAwEAAQJAQj9kJrZDuKT6ZyOQZfPD
tobRZ1xjo93/dWU72bF3aHDo4ILMy2Kigy5yhZU0ZGjOuPv5eUOLRe/yxYQf6B5J
AQIhANbhfZ4QJC8dLXAqcsxOXuLgztzbKixUre0gnhiVSd1hAiEAzv+sHJ4PMjKs
Iuf6/nUI9XFgQQRd+NGRovyHRZC18VsCIAX7AKQFjvxAs6MLi2ZkR//IgfljoCjb
snuHDN9iSEwBAiEAmAc1XCtGE+Mdg+GG+T3xn3pubDIN5oHcia0YmKIIzsMCIEy1
fWM5cIJ9bAUExKB6MV8PF+9EjDvXzbSk1/Ycta8z
-----END RSA PRIVATE KEY-----`
)

func main() {

    // Parse private key into rsa.PrivateKey
    PEMBlock, _ := pem.Decode([]byte(privKeyPEM))
    if PEMBlock == nil {
        log.Fatal(""Could not parse Private Key PEM"")
    }
    if PEMBlock.Type != ""RSA PRIVATE KEY"" {
        log.Fatal(""Found wrong key type"")
    }
    privkey, err := x509.ParsePKCS1PrivateKey(PEMBlock.Bytes)
    if err != nil {
        log.Fatal(err)
    }

    // Compute the sha1
    h := sha1.New()
    h.Write([]byte(data))

    // Sign the data
    signature, err := rsa.SignPKCS1v15(rand.Reader, privkey, crypto.SHA1, h.Sum(nil))
    if err != nil {
        log.Fatal(err)
    }

    // Print the results
    fmt.Print(base64.StdEncoding.EncodeToString(signature))
}",1442
25312824,279,"type Data struct {
    Next string
    Results Result
}

type Result struct {
    Results []AreaGeometry
}

type AreaGeometry struct {
    AREAGEOMETRY_ID int32
    AreaManagerId int64
    AreaId string
    EndDateArea string
    StartDateArea string
    AreaGeometryTxt string
}

// Synchronizes the AreaGeometry in our MySQL database with the AreaGeometry in the database from the RDW
func retrieveData() {
    resp, err := http.Get(""https://api.datamarket.azure.com/opendata.rdw/StatischParkeren.Open.Data/v1/AREAGEOMETRY?$format=json"")
    if err != nil {
        panic(err.Error()) // TODO: proper error handling
    }
    body, err := ioutil.ReadAll(resp.Body)
    var d Data
    json.Unmarshal(body, &d)
    fmt.Println(""Next: "" + d.Next)
}",748
25333683,280,"package main

import (
    ""bytes""
    ""compress/zlib""
    ""encoding/json""
    ""flag""
    ""fmt""
    ""gotwcc/mylib""
    ""io""
    ""net/http""
    ""os""
)

type Block struct {
    data []byte
}

type Row struct {
    offset, len uint32
    block       *Block
}

type Cache struct {
    blocks          []Block
    indexes         map[string]*Row
    enable_compress bool
    maxRowGroup     uint
}

func (this *Cache) dump() {
    for key, value := range this.indexes {
        fmt.Printf(""[%s] = \""%s\""\n"", key, value.block)
    }
}

func (this *Cache) search(item_id string) string {
    row := this.indexes[item_id]
    if row == nil {
        return ""(Not found)""
    }
    block := this.uncompress(row.block.data)
    slice := block[row.offset : row.offset+row.len]
    return string(slice)
}

func (this *Cache) compress(data []byte) []byte {
    if !this.enable_compress {
        return data
    }

    var b bytes.Buffer
    w := zlib.NewWriter(&b)
    w.Write(data)
    w.Close()
    return b.Bytes()
}

func (this *Cache) uncompress(data []byte) []byte {
    if !this.enable_compress {
        return data
    }

    var res bytes.Buffer
    b := bytes.NewReader(data)
    r, err := zlib.NewReader(b)
    if err != nil {
        panic(err)
    }
    io.Copy(&res, r)

    r.Close()
    return res.Bytes()

}

func (this *Cache) loadFile(s string) {
    type TempRowBuf struct {
        item_id     []byte
        offset, len uint32
    }

    file, err := os.Open(s)
    if err != nil {
        panic(err.Error())
    }
    defer file.Close()

    scanner := mybufio.NewScanner(file)
    scanner.Split(mybufio.ScanLines)

    var tmp_buf bytes.Buffer
    var buffer bytes.Buffer
    var tmp_list []TempRowBuf
    this.indexes = make(map[string]*Row)

    var offset uint32 = 0
    nb := this.maxRowGroup
    for scanner.Scan() {
        nb--
        tmp_buf.Reset()
        tmp_buf.Write(scanner.Bytes())
        line := tmp_buf.Bytes()
        item_id, _ := tmp_buf.ReadBytes('\t')
        item_id = item_id[0 : len(item_id)-1]
        size := uint32(len(line))
        buffer.Write(line)
        tmp_list = append(tmp_list, TempRowBuf{item_id, offset, size})
        offset += size
        if nb <= 0 {
            compressed := this.compress(buffer.Bytes())
            buff := make([]byte, len(compressed))
            copy(buff, compressed)
            var block *Block = &Block{buff}
            for _, tmp := range tmp_list {
                this.indexes[string(tmp.item_id)] = &Row{tmp.offset, tmp.len, block}
            }
            nb = this.maxRowGroup
            offset = 0
            tmp_list = nil
            buffer.Reset()
        }
    }
    if nb > 0 {
        compressed := this.compress(buffer.Bytes())
        buff := make([]byte, len(compressed))
        copy(buff, compressed)
        var block *Block = &Block{buff}
        for _, tmp := range tmp_list {
            this.indexes[string(tmp.item_id)] = &Row{tmp.offset, tmp.len, block}
        }
    }
}

func wsCacheHandler(cache *Cache, writer http.ResponseWriter, request *http.Request) {
    var value map[string]string = make(map[string]string)

    item_id := request.FormValue(""item_id"")
    value[""item_id""] = item_id
    value[""raw""] = cache.search(item_id)
    jsonResp, err := json.Marshal(value)
    if err != nil {
        fmt.Println(""error:"", err)
    } else {
        fmt.Fprintf(writer, ""%s"", string(jsonResp))
    }
}

func main() {
    filename := flag.String(""data"", ""default.txt"", ""The data filename"")
    no_http := flag.Bool(""no-http"", false, ""Do not start an http server"")
    dumpMap := flag.Bool(""dump"", false, ""If we should dump the map to stdout"")
    noCompression := flag.Bool(""no-compress"", false, ""Disable compression"")
    maxRowGroup := flag.Uint(""max-row-group"", 100, ""How much line to group when doing compression"")

    flag.Parse()
    var cache Cache
    cache.enable_compress = !*noCompression
    cache.maxRowGroup = *maxRowGroup

    cache.loadFile(*filename)

    if *dumpMap {
        cache.dump()
        fmt.Println(cache.search(""100001""))
        fmt.Println(cache.search(""100002""))
        fmt.Println(cache.search(""100003""))
        fmt.Println(cache.search(""100004""))
        fmt.Println(cache.search(""100005""))
        fmt.Println(cache.search(""100006""))
        fmt.Println(cache.search(""100007""))
        fmt.Println(cache.search(""100008""))
        fmt.Println(cache.search(""100009""))
        fmt.Println(cache.search(""100010""))

    }

    if !*no_http {
        http.HandleFunc(""/"", func(writer http.ResponseWriter, request *http.Request) {
            wsCacheHandler(&cache, writer, request)
        })
        fmt.Println(""Cache loaded, now listening on port 8585..."")
        http.ListenAndServe("":8585"", nil)
    }
}",4760
25600521,283,"package main

import (
        ""net/http""
        ""fmt""
        //""encoding/json""
        //""html""
        ""github.com/kr/pretty""
);

func main(){
        http.HandleFunc(""/"", foo)
        http.ListenAndServe("":80"", nil)
}

func foo(w http.ResponseWriter, r * http.Request){
        w.Header().Set(""Server"",""A Go WebServer"")

        w.Header().Set(""Content-Type"", ""text/html"")

        hostname := r.URL.Query()[""hostname""]
        //w.Write([]byte(hostname[0]))
        fmt.Printf(""%# v"", pretty.Formatter(hostname[0]))


        w.Write([]byte(hostname))
}",560
26030627,291,"// CLIENT ///
    package main

import (
    ""bufio""
    ""bytes""
    ""fmt""
    ""io""
    ""log""
    ""net""
    ""os""
    ""strings""
)

const BUFFER_SIZE = 1024

func main() {

    //get port and ip address to dial

    if len(os.Args) != 3 {
        fmt.Println(""useage example: tcpClient 127.0.0.1 7005"")
        return
    }

    var ip string = os.Args[1]
    var port string = os.Args[2]

    connection, err := net.Dial(""tcp"", ip+"":""+port)
    if err != nil {
        fmt.Println(""There was an error making a connection"")
    }

    //read from
    reader := bufio.NewReader(os.Stdin)
    fmt.Print(""Please enter 'get ' or 'send ' to transfer files to the server\n\n"")
    inputFromUser, _ := reader.ReadString('\n')
    arrayOfCommands := strings.Split(inputFromUser, "" "")

    if arrayOfCommands[0] == ""get"" {
        getFileFromServer(arrayOfCommands[1], connection)

    } else if arrayOfCommands[0] == ""send"" {
        sendFileToServer(arrayOfCommands[1], connection)
    } else {
        fmt.Println(""Bad Command"")
    }

}

func sendFileToServer(fileName string, connection net.Conn) {

    var currentByte int64 = 0
    fmt.Println(""send to client"")
    fileBuffer := make([]byte, BUFFER_SIZE)

    var err error

    //file to read
    file, err := os.Open(strings.TrimSpace(fileName)) // For read access.
    if err != nil {
        connection.Write([]byte(""-1""))
        log.Fatal(err)
    }
    connection.Write([]byte(""send "" + fileName))
    //read file until there is an error
    for err == nil || err != io.EOF {

        _, err = file.ReadAt(fileBuffer, currentByte)
        currentByte += BUFFER_SIZE
        fmt.Println(fileBuffer)
        connection.Write(fileBuffer)
    }

    file.Close()
    connection.Close()

}

func getFileFromServer(fileName string, connection net.Conn) {

    var currentByte int64 = 0

    fileBuffer := make([]byte, BUFFER_SIZE)

    var err error
    file, err := os.Create(strings.TrimSpace(fileName))
    if err != nil {
        log.Fatal(err)
    }
    connection.Write([]byte(""get "" + fileName))
    for {

        connection.Read(fileBuffer)
        cleanedFileBuffer := bytes.Trim(fileBuffer, ""\x00"")

        _, err = file.WriteAt(cleanedFileBuffer, currentByte)

        currentByte += BUFFER_SIZE

        if err == io.EOF {
            break
        }

    }

    file.Close()
    return

}

// END CLIENT //
// SERVER //
    package main

import (
    ""bytes""
    ""fmt""
    ""io""
    ""log""
    ""net""
    ""os""
    ""strings""
)

const BUFFER_SIZE = 1024
const PORT = ""7005""

func main() {

    fmt.Println(""start listening"")

    server, error := net.Listen(""tcp"", ""localhost:""+PORT)
    if error != nil {
        fmt.Println(""There was an error starting the server"" + error.Error())
        return
    }

    //infinate loop
    for {

        connection, error := server.Accept()
        if error != nil {
            fmt.Println(""There was am error with the connection"" + error.Error())
            return
        }
        fmt.Println(""connected"")
        //handle the connection, on it's own thread, per connection
        go connectionHandler(connection)
    }
}

func connectionHandler(connection net.Conn) {
    buffer := make([]byte, BUFFER_SIZE)

    _, error := connection.Read(buffer)
    if error != nil {
        fmt.Println(""There is an error reading from connection"", error.Error())
        return
    }
    fmt.Println(""command recieved: "" + string(buffer))

    //loop until disconntect

    cleanedBuffer := bytes.Trim(buffer, ""\x00"")
    cleanedInputCommandString := strings.TrimSpace(string(cleanedBuffer))
    arrayOfCommands := strings.Split(cleanedInputCommandString, "" "")

    fmt.Println(arrayOfCommands[0])
    if arrayOfCommands[0] == ""get"" {
        sendFileToClient(arrayOfCommands[1], connection)
    } else if arrayOfCommands[0] == ""send"" {
        fmt.Println(""getting a file"")

        getFileFromClient(arrayOfCommands[1], connection)

    } else {
        _, error = connection.Write([]byte(""bad command""))
    }

}

func sendFileToClient(fileName string, connection net.Conn) {
    var currentByte int64 = 0
    fmt.Println(""send to client"")
    fileBuffer := make([]byte, BUFFER_SIZE)

    //file to read
    file, err := os.Open(strings.TrimSpace(fileName)) // For read access.
    if err != nil {

        log.Fatal(err)
    }
    var err2 error

    //read file until there is an error
    for {

        _, err2 = file.ReadAt(fileBuffer, currentByte)
        currentByte += BUFFER_SIZE
        fmt.Println(fileBuffer)
        connection.Write(fileBuffer)

        if err2 == io.EOF {
            break
        }
    }

    file.Close()
    return

}

func getFileFromClient(fileName string, connection net.Conn) {

    var currentByte int64 = 0

    fileBuffer := make([]byte, BUFFER_SIZE)

    var err error
    file, err := os.Create(strings.TrimSpace(fileName))
    if err != nil {
        log.Fatal(err)
    }
    connection.Write([]byte(""get "" + fileName))
    for err == nil || err != io.EOF {

        connection.Read(fileBuffer)

        cleanedFileBuffer := bytes.Trim(fileBuffer, ""\x00"")

        _, err = file.WriteAt(cleanedFileBuffer, currentByte)
        if len(string(fileBuffer)) != len(string(cleanedFileBuffer)) {
            break
        }
        currentByte += BUFFER_SIZE

    }

    connection.Close()
    file.Close()
    return

}

// END SERVER //",5375
26159658,296,"func ValidateIDToken(auth_token string) (err error){    
    res, err := http.Get(""https://www.googleapis.com/oauth2/v2/certs"")
    if err != nil {
        log.Fatal(err)
        return err
    }

    certs, err := ioutil.ReadAll(res.Body)
    res.Body.Close()
    if err != nil {
        log.Fatal(err)
        return err
    }

    //get modulus and exponent from the cert
    var goCertificate interface{}

    err = json.Unmarshal(certs, &goCertificate)    
    k := goCertificate.(map[string]interface{})[""keys""]
    j := k.([]interface{})
    x := j[1]
    h := x.(map[string]interface{})[""n""]
    g := x.(map[string]interface{})[""e""]
    e64 := base64.StdEncoding
    //build the google pub key
    nStr := h.(string)
    decN, err := base64.StdEncoding.DecodeString(nStr)
    if err != nil {
        log.Println(err)
        return
    }

    n := big.NewInt(0)
    n.SetBytes(decN)
    eStr := g.(string)
    decE, err := base64.StdEncoding.DecodeString(eStr)
    if err != nil {
        log.Println(err)
        return
    }

    var eBytes []byte
    if len(decE) < 8 {
        eBytes = make([]byte, 8-len(decE), 8)
        eBytes = append(eBytes, decE...)
    } else {
        eBytes = decE
    }

    eReader := bytes.NewReader(eBytes)
    var e uint64
    err = binary.Read(eReader, binary.BigEndian, &e)
    if err != nil {
        log.Println(err)
        return
    }

    pKey := rsa.PublicKey{N: n, E: int(e)}
    w := strings.SplitAfter(auth_token, ""."")    
    for i, val := range w {
        w[i] = strings.Trim(val, ""."")
    }
    y := w[0:2]

    //Join just the first two parts, the header and the payload without the signature
    o := strings.Join(y, ""."")   
    headerOauth := DecodeB64(nil,[]byte(w[0]),e64)
    inblockOauth := DecodeB64(nil,[]byte(w[1]),e64)
    toHash := string(headerOauth) + ""}."" + string(inblockOauth)
    digestOauth := DecodeB64(nil, []byte(w[2]),e64)

    hasherOauth := sha256.New()
    hasherOauth.Write([]byte(toHash))

    // validation here fails
    err = rsa.VerifyPKCS1v15(&pKey,crypto.SHA256,hasherOauth.Sum(nil),digestOauth)

    if err != nil {
        log.Printf(""Error verifying key %s"",err.Error())
        return err
    }
    return err
}",2209
26353365,318,"package main

import (
    ""bufio""
    ""bytes""
    ""errors""
    ""fmt""
    ""os""
    ""runtime""
    ""sort""
    ""strconv""
)

type Edge struct {
    U, V uint32
}

func (e Edge) String() string {
    return fmt.Sprintf(""%d,%d"", e.U, e.V)
}

type ByKey []Edge

func (a ByKey) Len() int      { return len(a) }
func (a ByKey) Swap(i, j int) { a[i], a[j] = a[j], a[i] }
func (a ByKey) Less(i, j int) bool {
    if a[i].U < a[j].U {
        return true
    }
    if a[i].U == a[j].U && a[i].V < a[j].V {
        return true
    }
    return false
}

func countEdges(scanner *bufio.Scanner) int {
    var nNodes, nEdges int
    for scanner.Scan() {
        line := scanner.Bytes()
        if !(len(line) > 0 && line[0] == '#') {
            nEdges++
            continue
        }
        n, err := fmt.Sscanf(string(line), ""# Nodes: %d Edges: %d"", &nNodes, &nEdges)
        if err != nil || n != 2 {
            n, err = fmt.Sscanf(string(line), ""# %d,%d"", &nNodes, &nEdges)
            if err != nil || n != 2 {
                continue
            }
        }
        fmt.Println(string(line))
        break
    }
    if err := scanner.Err(); err != nil {
        panic(err.Error())
    }
    fmt.Println(nEdges)
    return nEdges
}

func loadEdges(filename string) []Edge {
    file, err := os.Open(filename)
    if err != nil {
        panic(err.Error())
    }
    defer file.Close()

    scanner := bufio.NewScanner(file)
    nEdges := countEdges(scanner)
    edges := make([]Edge, 0, nEdges)
    offset, err := file.Seek(0, os.SEEK_SET)
    if err != nil || offset != 0 {
        panic(err.Error())
    }

    var sep byte = '\t'
    scanner = bufio.NewScanner(file)
    for scanner.Scan() {
        line := scanner.Bytes()
        if len(line) > 0 && line[0] == '#' {
            continue
        }
        i := bytes.IndexByte(line, sep)
        if i = len(line) {
            sep = ','
            i = bytes.IndexByte(line, sep)
            if i = len(line) {
                err := errors.New(""Invalid line format: "" + string(line))
                panic(err.Error())
            }
        }
        u, err := ParseUint(line[:i], 10, 32)
        if err != nil {
            panic(err.Error())
        }
        v, err := ParseUint(line[i+1:], 10, 32)
        if err != nil {
            panic(err.Error())
        }
        if u > v {
            u, v = v, u
        }
        edges = append(edges, Edge{uint32(u), uint32(v)})
    }
    if err := scanner.Err(); err != nil {
        panic(err.Error())
    }

    if len(edges) <= 1 {
        return edges
    }
    sort.Sort(ByKey(edges))
    j := 0
    i := j + 1
    for ; i < len(edges); i, j = i+1, j+1 {
        if edges[i] == edges[j] {
            break
        }
    }
    for ; i < len(edges); i++ {
        if edges[i] != edges[j] {
            j++
            edges[j] = edges[i]
        }
    }
    edges = edges[:j+1]
    return edges
}

func main() {
    if len(os.Args) <= 1 {
        err := errors.New(""Missing file name"")
        panic(err.Error())
    }
    filename := os.Args[1]
    fmt.Println(filename)
    edges := loadEdges(filename)

    var ms runtime.MemStats
    runtime.ReadMemStats(&ms)
    fmt.Println(ms.Alloc, ms.TotalAlloc, ms.Sys, ms.Mallocs, ms.Frees)
    fmt.Println(len(edges), cap(edges))
    for i, e := range edges {
        fmt.Println(e)
        if i >= 10 {
            break
        }
    }
}

// bytconv from strconv

// Return the first number n such that n*base >= 1<<64.
func cutoff64(base int) uint64 {
    if base < 2 {
        return 0
    }
    return (1<<64-1)/uint64(base) + 1
}

// ParseUint is like ParseInt but for unsigned numbers.
func ParseUint(s []byte, base int, bitSize int) (n uint64, err error) {
    var cutoff, maxVal uint64

    if bitSize == 0 {
        bitSize = int(strconv.IntSize)
    }

    s0 := s
    switch {
    case len(s) < 1:
        err = strconv.ErrSyntax
        goto Error

    case 2 <= base && base <= 36:
        // valid base; nothing to do

    case base == 0:
        // Look for octal, hex prefix.
        switch {
        case s[0] == '0' && len(s) > 1 && (s[1] == 'x' || s[1] == 'X'):
            base = 16
            s = s[2:]
            if len(s) < 1 {
                err = strconv.ErrSyntax
                goto Error
            }
        case s[0] == '0':
            base = 8
        default:
            base = 10
        }

    default:
        err = errors.New(""invalid base "" + strconv.Itoa(base))
        goto Error
    }

    n = 0
    cutoff = cutoff64(base)
    maxVal = 1<<uint(bitSize) - 1

    for i := 0; i < len(s); i++ {
        var v byte
        d := s[i]
        switch {
        case '0' <= d && d <= '9':
            v = d - '0'
        case 'a' <= d && d <= 'z':
            v = d - 'a' + 10
        case 'A' <= d && d <= 'Z':
            v = d - 'A' + 10
        default:
            n = 0
            err = strconv.ErrSyntax
            goto Error
        }
        if int(v) >= base {
            n = 0
            err = strconv.ErrSyntax
            goto Error
        }

        if n >= cutoff {
            // n*base overflows
            n = 1<<64 - 1
            err = strconv.ErrRange
            goto Error
        }
        n *= uint64(base)

        n1 := n + uint64(v)
        if n1  maxVal {
            // n+v overflows
            n = 1<<64 - 1
            err = strconv.ErrRange
            goto Error
        }
        n = n1
    }

    return n, nil

Error:
    return n, &strconv.NumError{""ParseUint"", string(s0), err}
}",5515
26754076,323,"type appHandler func(http.ResponseWriter, *http.Request, context.Context) *appError

func (fn appHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
        if e := fn(w, r, nil); e != nil { // e is *appError, not os.Error.
                http.Error(w, e.Message, e.Code)
        }
}
",294
27449673,337,"// Make a bridge between dstNet which is
// usually behind NAT and srcNet which is usually a client
// which wants to route the traffic though the NAT machine.
package main

import (
    log ""github.com/golang/glog""
    ""io""
    ""net""
)

// listen on the dstNet so that we can
// create a connection with the NAT client
var dstNet *net.TCPAddr = &net.TCPAddr{IP: net.ParseIP(""0.0.0.0""), Port: 9000}

// listen on srcNet so that we can get traffic
// to forward to dstNet
var srcNet *net.TCPAddr = &net.TCPAddr{IP: net.ParseIP(""0.0.0.0""), Port: 9001}

var errCh = make(chan error, 1)

// make a channel to send the reverse connections
var lrCh = make(chan *net.TCPConn, 1)
var lrNewCh = make(chan int, 1)

func listenDst() {
    // Listen on the dstNet
    lr, err := net.ListenTCP(""tcp"", dstNet)
    if err != nil {
        log.Error(err)
        errCh <- err
        return
    }
    // accept the connection
    for {
        lrConn, err := lr.AcceptTCP()
        if err != nil {
                log.Error(err)
                //errCh <- err
                //return
        }
        status := <-lrNewCh
            log.Errorf(""status request is %v"", status)
            if status == 1{
                log.Errorf(""we close and restart the listener and the connection"")
                if err =  lrConn.Close(); err !=nil{
                    log.Error(err)
                }
                if err =  lr.Close(); err !=nil{
                    log.Error(err)
                }
                    lr, err = net.ListenTCP(""tcp"", dstNet)
                    if err != nil {
                        log.Error(err)
                        errCh <- err
                        return
                    }
                lrConn, err = lr.AcceptTCP()
                if err !=nil{
                    log.Error(err)
                    errCh <- err
                }
            }else{
                log.Errorf(""new connection on its way"")
                lrCh <- lrConn
            }
    //  default:
            // log.Errorf(""accepting new connections"")


    }

}

func main() {

    go func() {
        for err := range errCh {
            if err != nil {
                panic(err)
            }
        }
    }()
    // listen for the nat server
    go listenDst()

    // listen for clients to connect
    l, err := net.ListenTCP(""tcp"", srcNet)
    if err != nil {
        log.Error(err)
        panic(err)
    }
    // accept the connection
    for {
        conn, err := l.AcceptTCP()
        if err != nil {
            log.Error(err)
            panic(err)
        }
        // serve the connection
        go func(conn *net.TCPConn) {
            defer conn.Close()
            lrNewCh <- 0
            dst := <-lrCh
            defer dst.Close()
            proxy(dst, conn)
        }(conn)

    }
}

func proxy(srvConn, cliConn *net.TCPConn) {
    // channels to wait on the close event for each connection
    serverClosed := make(chan struct{}, 1)
    clientClosed := make(chan struct{}, 1)

    go broker(srvConn, cliConn, clientClosed)
    go broker(cliConn, srvConn, serverClosed)

    // wait for one half of the proxy to exit, then trigger a shutdown of the
    // other half by calling CloseRead(). This will break the read loop in the
    // broker and allow us to fully close the connection cleanly without a
    // ""use of closed network connection"" error.
    var waitFor chan struct{}
    select {
    case <-clientClosed:
        // the client closed first and any more packets from the server aren't
        // useful, so we can optionally SetLinger(0) here to recycle the port
        // faster.
        srvConn.SetLinger(0)
        srvConn.CloseRead()
        waitFor = serverClosed
    case <-serverClosed:
        cliConn.CloseRead()
        waitFor = clientClosed
    }

    // Wait for the other connection to close.
    // This ""waitFor"" pattern isn't required, but gives us a way to track the
    // connection and ensure all copies terminate correctly; we can trigger
    // stats on entry and deferred exit of this function.
    <-waitFor
}

// This does the actual data transfer.
// The broker only closes the Read side.
func broker(dst, src net.Conn, srcClosed chan struct{}) {
    // We can handle errors in a finer-grained manner by inlining io.Copy (it's
    // simple, and we drop the ReaderFrom or WriterTo checks for
    // net.Conn->net.Conn transfers, which aren't needed). This would also let
    // us adjust buffersize.
    n, err := io.Copy(dst, src)
    log.Errorf("" %v bytes copied"", n)
    if err != nil {
        log.Errorf(""Copy error: %s"", err)
        // errCh <- err
    }
    if err := src.Close(); err != nil {
        log.Errorf(""Close error: %s"", err)
        errCh <- err
    }
    if n == 0 {
        lrNewCh <- 1
    }
    srcClosed <- struct{}{}

}",4820
27491738,338,"func IndexVehicle(client *elastic.Client, vehicle Vehicle) (bool, error) {
    // See if it exists already
    fetch, err := client.Get().
        Index(vehicleIndex).
        Type(""vehicle"").
        Id(vehicle.Id).
        Do()
    if err != nil || fetch.Found {
        return false, err
    }

    vehicleName := fmt.Sprintf(""%s %s (%s) %s"", vehicle.Make, vehicle.Model, vehicle.Model_year, vehicle.Primary_fuel)

    suggest := elastic.NewSuggestField()
    suggest.Input(vehicle.Make, vehicle.Model, vehicle.Primary_fuel, vehicle.Model_year).
        Output(vehicleName).
        Payload(vehicle)

    // Go forth and save
    put, err := client.Index().
        Index(vehicleIndex).
        Type(""vehicle"").
        Id(vehicle.Id).
        Debug(true).Pretty(true).
        BodyJson(indexBody{Name: vehicleName, Suggest: suggest}).
        Do()
    if err != nil {
        return false, err
    }
    return put.Created, nil
}
",934
27600587,352,"package main

import (
    ""sanguo/base/log""
    ""fmt""
    ""runtime""
    ""math/rand""
    ""time""
    ""net""
    ""os""
)

type GameServer struct {
    Host   string
}


func (server *GameServer) Start() {
    // load system data
    log.Debug(""/*************************SREVER START********************************/"")

    tcpAddr, err := net.ResolveTCPAddr(""tcp4"", server.Host)
    if err != nil {
        log.Error(err.Error())
        os.Exit(-1)
    }
    go func(){
        for{
            select {
            case <-time.After(30*time.Second):
                LookUp(""read memstats"")
            }
        }
    }()
    listener, err := net.ListenTCP(""tcp"", tcpAddr)
    if err != nil {
        log.Error(err.Error())
        os.Exit(-1)
    }
    log.Debug(""/*************************SERVER SUCC********************************/"")
    for {
        conn, err := listener.AcceptTCP()
        if err != nil {
            continue
        }
        log.Debug(""Accept a new connection "", conn.RemoteAddr())
        go handleClient(conn)
    }
}

func handleClient(conn *net.TCPConn) {
    sess := NewSession(conn)
    sess.Start()
}

func main() {
    rand.Seed(time.Now().Unix())

    runtime.GOMAXPROCS(runtime.NumCPU())

    log.SetLevel(0)

    filew := log.NewFileWriter(""log"", true)
    err := filew.StartLogger()
    if err != nil {
        fmt.Println(""Failed start log"",err)
        return
    }

    var server GameServer
    server.Host = ""127.0.0.1:9999""
    server.Start()
}",1489
28030045,363,"package main                                                                                                                                                                                                                                                                                                                                                          import (                                                                                                                                                                               ""encoding/json""                                                                                                                                                                    ""fmt""                                                                                                                                                                              ""os""                                                                                                                                                                                                                                                                                                                                                                  ""github.com/guelfey/go.dbus""                                                                                                                                                       ""github.com/guelfey/go.dbus/introspect""                                                                                                                                        
)                                                                                                                                                                                  

func main() {                                                                                                                                                                      
    os.Setenv(""OMXPLAYER_DBUS_ADDR"", ""/tmp/omxplayerdbus.pi"")                                                                                                                      
    os.Setenv(""OMXPLAYER_DBUS_PID"", ""/tmp/omxplayerdbus.pi.pid"")                                                                                                                   
    conn, err := dbus.SessionBus()                                                                                                                                                 
    if err != nil {                                                                                                                                                                
        panic(err)                                                                                                                                                                 
    }                                                                                                                                                                              
    node, err := introspect.Call(conn.Object(""org.mpris.MediaPlayer2.omxplayer"", ""/org/mpris/MediaPlayer2""))                                                                       
    if err != nil {                                                                                                                                                                
        fmt.Println(err)                                                                                                                                                           
    }                                                                                                                                                                              
    data, _ := json.MarshalIndent(node, """", ""    "")                                                                                                                                

    var s []string                                                                                                                                                                 
    err = conn.BusObject().Call(""org.freedesktop.DBus.ListNames"", 0).Store(&s)                                                                                                     
    if err != nil {                                                                                                                                                                
        fmt.Fprintln(os.Stderr, ""Failed to get list of owned names:"", err)                                                                                                         
        os.Exit(1)                                                                                                                                                                 
    }                                                                                                                                                                              

    fmt.Println(""Currently owned names on the session bus:"")                                                                                                                       
    for _, v := range s {                                                                                                                                                          
        fmt.Println(v)                                                                                                                                                             
    }                                                                                                                                                                              

    os.Stdout.Write(data)                                                                                                                                                          
}",5938
28301402,365,"func New(res http.ResponseWriter, req *http.Request, next http.HandlerFunc) {

    if err := process(security.ServeHttp(res, req), session.ServeHttp(res, req)); err != nil {
        res.WriteHeader(http.StatusInternalServerError)
        return
    }

    log.Println(""End of process middlewares"")
    next(res, req)

}

// Process all middlewares
func process(chErrs ...<-chan error) error {

    for _, chErr := range chErrs {

        // Will abort the loop, when error occurs
        if err := <-chErr; err != nil {
            return err
        }

    }
    return nil
}
",577
28353607,367,"// +build windows

/*
Package wmi provides a WQL interface for WMI on Windows.

Example code to print names of running processes:

    type Win32_Process struct {
        Name string
    }

    func main() {
        var dst []Win32_Process
        q := wmi.CreateQuery(&dst, """")
        err := wmi.Query(q, &dst)
        if err != nil {
            log.Fatal(err)
        }
        for i, v := range dst {
            println(i, v.Name)
        }
    }

*/
package wmi

import (
    ""bytes""
    ""errors""
    ""fmt""
    ""log""
    ""os""
    ""reflect""
    ""runtime""
    ""strconv""
    ""strings""
    ""sync""
    ""time""

    ""github.com/mattn/go-ole""
    ""github.com/mattn/go-ole/oleutil""
)

var l = log.New(os.Stdout, """", log.LstdFlags)

var (
    ErrInvalidEntityType = errors.New(""wmi: invalid entity type"")
    lock                 sync.Mutex
)

// QueryNamespace invokes Query with the given namespace on the local machine.
func QueryNamespace(query string, dst interface{}, namespace string) error {
    return Query(query, dst, nil, namespace)
}

// Query runs the WQL query and appends the values to dst.
//
// dst must have type *[]S or *[]*S, for some struct type S. Fields selected in
// the query must have the same name in dst. Supported types are all signed and
// unsigned integers, time.Time, string, bool, or a pointer to one of those.
// Array types are not supported.
//
// By default, the local machine and default namespace are used. These can be
// changed using connectServerArgs. See
// http://msdn.microsoft.com/en-us/library/aa393720.aspx for details.
func Query(query string, dst interface{}, connectServerArgs ...interface{}) error {
    dv := reflect.ValueOf(dst)
    if dv.Kind() != reflect.Ptr || dv.IsNil() {
        return ErrInvalidEntityType
    }
    dv = dv.Elem()
    mat, elemType := checkMultiArg(dv)
    if mat == multiArgTypeInvalid {
        return ErrInvalidEntityType
    }

    lock.Lock()
    defer lock.Unlock()
    runtime.LockOSThread()
    defer runtime.UnlockOSThread()

    err := ole.CoInitializeEx(0, ole.COINIT_MULTITHREADED)
    if err != nil {
        oleerr := err.(*ole.OleError)
        // S_FALSE           = 0x00000001 // CoInitializeEx was already called on this thread
        if oleerr.Code() != ole.S_OK && oleerr.Code() != 0x00000001 {
            return err
        }
    } else {
        // Only invoke CoUninitialize if the thread was not initizlied before.
        // This will allow other go packages based on go-ole play along
        // with this library.
        defer ole.CoUninitialize()
    }

    unknown, err := oleutil.CreateObject(""WbemScripting.SWbemLocator"")
    if err != nil {
        return err
    }
    defer unknown.Release()

    wmi, err := unknown.QueryInterface(ole.IID_IDispatch)
    if err != nil {
        return err
    }
    defer wmi.Release()

    // service is a SWbemServices
    serviceRaw, err := oleutil.CallMethod(wmi, ""ConnectServer"", connectServerArgs...)
    if err != nil {
        return err
    }
    service := serviceRaw.ToIDispatch()
    defer serviceRaw.Clear()

    // result is a SWBemObjectSet
    resultRaw, err := oleutil.CallMethod(service, ""ExecQuery"", query)
    if err != nil {
        return err
    }
    result := resultRaw.ToIDispatch()
    defer resultRaw.Clear()

    count, err := oleInt64(result, ""Count"")
    if err != nil {
        return err
    }

    // Initialize a slice with Count capacity
    dv.Set(reflect.MakeSlice(dv.Type(), 0, int(count)))

    var errFieldMismatch error
    for i := int64(0); i < count; i++ {
        err := func() error {
            // item is a SWbemObject, but really a Win32_Process
            itemRaw, err := oleutil.CallMethod(result, ""ItemIndex"", i)
            if err != nil {
                return err
            }
            item := itemRaw.ToIDispatch()
            defer itemRaw.Clear()

            ev := reflect.New(elemType)
            if err = loadEntity(ev.Interface(), item); err != nil {
                if _, ok := err.(*ErrFieldMismatch); ok {
                    // We continue loading entities even in the face of field mismatch errors.
                    // If we encounter any other error, that other error is returned. Otherwise,
                    // an ErrFieldMismatch is returned.
                    errFieldMismatch = err
                } else {
                    return err
                }
            }
            if mat != multiArgTypeStructPtr {
                ev = ev.Elem()
            }
            dv.Set(reflect.Append(dv, ev))
            return nil
        }()
        if err != nil {
            return err
        }
    }
    return errFieldMismatch
}

// ErrFieldMismatch is returned when a field is to be loaded into a different
// type than the one it was stored from, or when a field is missing or
// unexported in the destination struct.
// StructType is the type of the struct pointed to by the destination argument.
type ErrFieldMismatch struct {
    StructType reflect.Type
    FieldName  string
    Reason     string
}

func (e *ErrFieldMismatch) Error() string {
    return fmt.Sprintf(""wmi: cannot load field %q into a %q: %s"",
        e.FieldName, e.StructType, e.Reason)
}

var timeType = reflect.TypeOf(time.Time{})

// loadEntity loads a SWbemObject into a struct pointer.
func loadEntity(dst interface{}, src *ole.IDispatch) (errFieldMismatch error) {
    v := reflect.ValueOf(dst).Elem()
    for i := 0; i < v.NumField(); i++ {
        f := v.Field(i)
        isPtr := f.Kind() == reflect.Ptr
        if isPtr {
            ptr := reflect.New(f.Type().Elem())
            f.Set(ptr)
            f = f.Elem()
        }
        n := v.Type().Field(i).Name
        if !f.CanSet() {
            return &ErrFieldMismatch{
                StructType: f.Type(),
                FieldName:  n,
                Reason:     ""CanSet() is false"",
            }
        }
        prop, err := oleutil.GetProperty(src, n)
        if err != nil {
            errFieldMismatch = &ErrFieldMismatch{
                StructType: f.Type(),
                FieldName:  n,
                Reason:     ""no such struct field"",
            }
            continue
        }
        defer prop.Clear()

        switch val := prop.Value().(type) {
        case int, int64:
            var v int64
            switch val := val.(type) {
            case int:
                v = int64(val)
            case int64:
                v = val
            default:
                panic(""unexpected type"")
            }
            switch f.Kind() {
            case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
                f.SetInt(v)
            case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
                f.SetUint(uint64(v))
            default:
                return &ErrFieldMismatch{
                    StructType: f.Type(),
                    FieldName:  n,
                    Reason:     ""not an integer class"",
                }
            }
        case string:
            iv, err := strconv.ParseInt(val, 10, 64)
            switch f.Kind() {
            case reflect.String:
                f.SetString(val)
            case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
                if err != nil {
                    return err
                }
                f.SetInt(iv)
            case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
                if err != nil {
                    return err
                }
                f.SetUint(uint64(iv))
            case reflect.Struct:
                switch f.Type() {
                case timeType:
                    if len(val) == 25 {
                        mins, err := strconv.Atoi(val[22:])
                        if err != nil {
                            return err
                        }
                        val = val[:22] + fmt.Sprintf(""%02d%02d"", mins/60, mins%60)
                    }
                    t, err := time.Parse(""20060102150405.000000-0700"", val)
                    if err != nil {
                        return err
                    }
                    f.Set(reflect.ValueOf(t))
                }
            }
        case bool:
            switch f.Kind() {
            case reflect.Bool:
                f.SetBool(val)
            default:
                return &ErrFieldMismatch{
                    StructType: f.Type(),
                    FieldName:  n,
                    Reason:     ""not a bool"",
                }
            }
        default:
            typeof := reflect.TypeOf(val)
            if isPtr && typeof == nil {
                break
            }
            return &ErrFieldMismatch{
                StructType: f.Type(),
                FieldName:  n,
                Reason:     fmt.Sprintf(""unsupported type (%T)"", val),
            }
        }
    }
    return errFieldMismatch
}

type multiArgType int

const (
    multiArgTypeInvalid multiArgType = iota
    multiArgTypeStruct
    multiArgTypeStructPtr
)

// checkMultiArg checks that v has type []S, []*S for some struct type S.
//
// It returns what category the slice's elements are, and the reflect.Type
// that represents S.
func checkMultiArg(v reflect.Value) (m multiArgType, elemType reflect.Type) {
    if v.Kind() != reflect.Slice {
        return multiArgTypeInvalid, nil
    }
    elemType = v.Type().Elem()
    switch elemType.Kind() {
    case reflect.Struct:
        return multiArgTypeStruct, elemType
    case reflect.Ptr:
        elemType = elemType.Elem()
        if elemType.Kind() == reflect.Struct {
            return multiArgTypeStructPtr, elemType
        }
    }
    return multiArgTypeInvalid, nil
}

func oleInt64(item *ole.IDispatch, prop string) (int64, error) {
    v, err := oleutil.GetProperty(item, prop)
    if err != nil {
        return 0, err
    }
    defer v.Clear()

    i := int64(v.Val)
    return i, nil
}

// CreateQuery returns a WQL query string that queries all columns of src. where
// is an optional string that is appended to the query, to be used with WHERE
// clauses. In such a case, the ""WHERE"" string should appear at the beginning.
func CreateQuery(src interface{}, where string) string {
    var b bytes.Buffer
    b.WriteString(""SELECT "")
    s := reflect.Indirect(reflect.ValueOf(src))
    t := s.Type()
    if s.Kind() == reflect.Slice {
        t = t.Elem()
    }
    if t.Kind() != reflect.Struct {
        return """"
    }
    var fields []string
    for i := 0; i < t.NumField(); i++ {
        fields = append(fields, t.Field(i).Name)
    }
    b.WriteString(strings.Join(fields, "", ""))
    b.WriteString("" FROM "")
    b.WriteString(t.Name())
    b.WriteString("" "" + where)
    return b.String()
}",10800
28527673,395,"package main
import ""fmt""
func main() {
    fmt.Println(""hello world"")
}
",73
28767067,403,"type CharacterData struct {
  CharId    uint32
  Data      []byte
  Segment   uint8
  SegmentId uint16

  CreatedAt time.Time
  UpdatedAt time.Time
  DeletedAt time.Time
 }",174
29057228,413,"package main

import (
    ""fmt""
    ""log""
)

type Stmt struct {
    Name  string
    After []string
}

func main() {
    stmts := []Stmt{
        {Name: ""app"", After: []string{""app_user""}},
        {Name: ""billingplan"", After: []string{}},
        {Name: ""campaign"", After: []string{""app_user""}},
        {Name: ""campaign_app"", After: []string{""campaign"", ""app""}},
        {Name: ""campaign_ip"", After: []string{""campaign"", ""ip""}},
        {Name: ""campaign_operator"", After: []string{""campaign"", ""operator""}},
        {Name: ""campaign_sponsor"", After: []string{""campaign"", ""sponsor""}},
        {Name: ""campaign_subscriberfilter"", After: []string{""campaign"", ""subscriber_filters""}},
        {Name: ""campaign_url"", After: []string{""campaign"", ""url""}},
        {Name: ""contentpartner"", After: []string{""app_user""}},
        {Name: ""filter_criteria"", After: []string{""campaign"", ""subscriber_filters""}},
        {Name: ""ip"", After: []string{""app_user""}},
        {Name: ""mobile_registered"", After: []string{""campaign"", ""app""}},
        {Name: ""operator"", After: []string{}},
        {Name: ""passwords"", After: []string{""app_user""}},
        {Name: ""publish_package"", After: []string{}},
        {Name: ""role"", After: []string{}},
        {Name: ""passwords"", After: []string{""app_user""}},
        {Name: ""sponsor"", After: []string{""app_user""}},
        {Name: ""subscriber_dbs"", After: []string{}},
        {Name: ""subscriber_filters"", After: []string{""subscriber_dbs""}},
        {Name: ""timezone"", After: []string{}},
        {Name: ""url"", After: []string{""app_user""}},
        {Name: ""app_user"", After: []string{}},
        {Name: ""user_role"", After: []string{""app_user"", ""role""}},
    }

    g := make(graph)
    for _, s := range stmts {
        g[s.Name] = after(s.After)
    }

    sorted, err := topoSort(g)
    if err != nil {
        log.Fatalf(""could not sort: %v"", err)
    }
    for _, s := range sorted {
        fmt.Println(s)
    }
}

func topoSort(g graph) ([]string, error) {
    sccs := tarjanSCC(g)
    sorted := make([]string, len(sccs))
    for i, s := range sccs {
        if len(s) != 1 {
            return nil, fmt.Errorf(""found directed cycle: %q"", s)
        }
        sorted[i] = s[0]
    }
    return sorted, nil
}

// graph is an edge list representation of a directed graph.
type graph map[string]set

// set is an string set.
type set map[string]struct{}

func after(i []string) set {
    if len(i) == 0 {
        return nil
    }
    s := make(set)
    for _, v := range i {
        s[v] = struct{}{}
    }
    return s
}

// tarjanSCC returns a the strongly connected components of the
// directed graph g.
func tarjanSCC(g graph) [][]string {
    t := tarjan{
        g: g,

        indexTable: make(map[string]int, len(g)),
        lowLink:    make(map[string]int, len(g)),
        onStack:    make(map[string]bool, len(g)),
    }
    for v := range t.g {
        if t.indexTable[v] == 0 {
            t.strongconnect(v)
        }
    }
    return t.sccs
}

// tarjan implements Tarjan's strongly connected component finding
// algorithm. The implementation is from the pseudocode at
//
// http://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm
//
type tarjan struct {
    g graph

    index      int
    indexTable map[string]int
    lowLink    map[string]int
    onStack    map[string]bool

    stack []string

    sccs [][]string
}

// strongconnect is the strongconnect function described in the
// wikipedia article.
func (t *tarjan) strongconnect(v string) {
    // Set the depth index for v to the smallest unused index.
    t.index++
    t.indexTable[v] = t.index
    t.lowLink[v] = t.index
    t.stack = append(t.stack, v)
    t.onStack[v] = true

    // Consider successors of v.
    for w := range t.g[v] {
        if t.indexTable[w] == 0 {
            // Successor w has not yet been visited; recur on it.
            t.strongconnect(w)
            t.lowLink[v] = min(t.lowLink[v], t.lowLink[w])
        } else if t.onStack[w] {
            // Successor w is in stack s and hence in the current SCC.
            t.lowLink[v] = min(t.lowLink[v], t.indexTable[w])
        }
    }

    // If v is a root node, pop the stack and generate an SCC.
    if t.lowLink[v] == t.indexTable[v] {
        // Start a new strongly connected component.
        var (
            scc []string
            w   string
        )
        for {
            w, t.stack = t.stack[len(t.stack)-1], t.stack[:len(t.stack)-1]
            t.onStack[w] = false
            // Add w to current strongly connected component.
            scc = append(scc, w)
            if w == v {
                break
            }
        }
        // Output the current strongly connected component.
        t.sccs = append(t.sccs, scc)
    }
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}",4845
29262947,415,"package console

import (
    ""appengine""
    ""appengine/user""
    ""database/sql""
    _ ""github.com/go-sql-driver/mysql""
    ""html/template""
    ""io/ioutil""
    ""net/http""
    ""strconv""
    ""time""
)

//for deployment
var dbConnectString string = ""****************************""

//for local testing
//var dbConnectString string = ""root@/party""

func init() {
    http.HandleFunc(""/console"", consoleHandler)
}

func consoleHandler(w http.ResponseWriter, r *http.Request) {
    redirectIfNeeded(w, r)
    c := appengine.NewContext(r)
    u := user.Current(c)

    logoutUrl, e := user.LogoutURL(c, ""/redirect"")

    if e != nil {
        panic(e)
    }

    email := u.Email
    data := WebpageData{LogoutUrl: logoutUrl, UserName: email, NewPartyUrl: ""/console/newparty""}

    template := template.Must(template.New(""template"").Parse(generateUnsignedHtml(u)))

    err := template.Execute(w, data)
    if err != nil {
        http.Error(w, err.Error(), http.StatusInternalServerError)
    }

}

func generateUnsignedHtml(u *user.User) string {
    firstPart := fileValue(""./console/page/firstPart.html"")
    table := generateTable(u)
    secondPart := fileValue(""./console/page/secondPart.html"")

    html := firstPart + table + secondPart
    return html
}

func generateTable(u *user.User) string {
    con, e := sql.Open(""mysql"", dbConnectString)
    if e != nil {
        panic(e)
    }
    defer con.Close()

    var parties []Party
    partyRows, err := con.Query(""select id, name, datetime, host, location from parties where author='"" + u.Email + ""';"")
    if err != nil {
        panic(err)
    }

    var id int
    var name string
    var datetime string
    var host string
    var location string

    for partyRows.Next() {
        partyRows.Scan(&id, &name, &datetime, &host, &location)
        parties = append(parties, Party{Id: id, Name: name, DatetimeString: datetime, Host: host, Location: location})
    }

    html := """"
    for i, party := range parties {
        actionsHtml := ""Edit Delete""
        html += """" + makeTd(strconv.Itoa(i+1)) + makeTd(party.Name) + makeTd(party.DatetimeString) + makeTd(party.Host) + makeTd(party.Location) + makeTd(actionsHtml) + """"
    }

    html += """"
    return html
}

func makeTd(content string) string {
    return """" + content + """"
}

func redirectIfNeeded(w http.ResponseWriter, r *http.Request) {
    expire := time.Date(2000, 1, 1, 1, 1, 1, 0, time.UTC)
    cookie := &http.Cookie{Name: ""ACSID"", Value: """", Expires: expire, HttpOnly: true}
    http.SetCookie(w, cookie)
    cookie2 := &http.Cookie{Name: ""SACSID"", Value: """", Expires: expire, HttpOnly: true}
    http.SetCookie(w, cookie2)

    c := appengine.NewContext(r)
    u := user.Current(c)
    if u == nil {
        url, err := user.LoginURL(c, r.URL.String())
        if err != nil {
            http.Error(w, err.Error(), http.StatusInternalServerError)
            return
        }
        w.Header().Set(""Location"", url)
        w.WriteHeader(http.StatusFound)
        return
    }

    con, e := sql.Open(""mysql"", dbConnectString)
    if e != nil {
        panic(e)
    }
    defer con.Close()

    //check whether user is admin
    admRows, error := con.Query(""select email from admin_users;"")
    if error != nil {
        panic(error)
    }
    var email string
    isAdmin := false
    for admRows.Next() {
        admRows.Scan(&email)
        if email == u.Email {
            isAdmin = true
        }
    }

    //check if he is validated user
    validRows, error2 := con.Query(""select email from party_validated_users;"")
    if error2 != nil {
        panic(error2)
    }
    email = """"
    isValidated := false
    for validRows.Next() {
        validRows.Scan(&email)
        if email == u.Email {
            isValidated = true
        }
    }

    var url string

    if user.IsAdmin(c) || isAdmin {
        //user is declared as admin in db or is admin of gae app
        //we are allready here
        url = ""/console""
    } else if isValidated {
        //user is validated
        //we are allready here
        url = ""/console""
    } else {
        //user is not validated yet
        url = ""/redirect""
        w.Header().Set(""Location"", url)
        w.WriteHeader(http.StatusFound)
    }
}

func fileValue(path string) string {
    content, err := ioutil.ReadFile(path)
    if err != nil {
        panic(err)
    }
    return string(content)
}

type WebpageData struct {
    LogoutUrl   string
    UserName    string
    NewPartyUrl string
}

type Party struct {
    Id             int
    Name           string
    DatetimeString string
    Host           string
    Location       string
}",4635
29454288,416,"package main

import ""fmt""

func calc_ols_params(y []float64, x[][]float64, n_iterations int, alpha float64) []float64 {

    thetas := make([]float64, len(x))

    for i := 0; i < n_iterations; i++ {

        my_diffs := calc_diff(thetas, y, x)

        my_grad := calc_gradient(my_diffs, x)

        for j := 0; j < len(my_grad); j++ {
            thetas[j] += alpha * my_grad[j]
        }
    }
    return thetas
}

func calc_diff (thetas []float64, y []float64, x[][]float64) []float64 {
    diffs := make([]float64, len(y))
    for i := 0; i < len(y); i++ {
        prediction := 0.0
        for j := 0; j < len(thetas); j++ {
            prediction += thetas[j] * x[j][i]
        }
        diffs[i] = y[i] - prediction
    }
    return diffs
}

func calc_gradient(diffs[] float64, x[][]float64) []float64 {
    gradient := make([]float64, len(x))
    for i := 0; i < len(diffs); i++ {
        for j := 0; j < len(x); j++ {
            gradient[j] += diffs[i] * x[j][i]
        }
    }
    for i := 0; i < len(x); i++ {
        gradient[i] = gradient[i] / float64(len(diffs))
    }

    return gradient
}

func main(){
    y := []float64 {3,4,5,6,7}
    x := [][]float64 {{1,1,1,1,1}, {4,3,2,1,3}}

    thetas := calc_ols_params(y, x, 100000, 0.001)

    fmt.Println(""Thetas : "", thetas)

    y_2 := []float64 {1,2,3,4,3,4,5,4,5,5,4,5,4,5,4,5,6,5,4,5,4,3,4}

    x_2 := [][]float64 {{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
                            {4,2,3,4,5,4,5,6,7,4,8,9,8,8,6,6,5,5,5,5,5,5,5},
                    {4,1,2,3,4,5,6,7,5,8,7,8,7,8,7,8,7,7,7,7,7,6,5},
                    {4,1,2,5,6,7,8,9,7,8,7,8,7,7,7,7,7,7,6,6,4,4,4},}

    thetas_2 := calc_ols_params(y_2, x_2, 100000, 0.001)

    fmt.Println(""Thetas_2 : "", thetas_2)

}",1756
29525363,421,"address, err := net.ResolveTCPAddr(""tcp"", ""192.168.9.144:8080"")                                                                                                                                     
            if err != nil {                                                                                                                                                                                     
                    fmt.Println(err)                                                                                                                                                                            
            }                                                                                                                                                                                                   
            conn, err := net.DialTCP(""tcp"", nil, address)                                                                                                                                                       
            fmt.Println(""Connected"")                                                                                                                                                                            
            // conn, err := net.DialTCP(""tcp"", nil, address)                                                                                                                                                    
            if err != nil {                                                                                                                                                                                     
                    fmt.Println(""Can't conenct"")                                                                                                                                                                
                    log.Fatal(err)                                                                                                                                                                              
     }
     conn.File() 
     conn.Fd()",2130
29573148,424,"package main

import (
    ""fmt""
    ""math/rand""
)

type PersonID int

func contains(s []int, e int) bool {
    for _, a := range s {
        if a == e {
            return true
        }
    }
    return false
}

func Person(called_number chan int, claim_prize chan PersonID, received chan bool, coupon []int, person_id PersonID) {
    numFound := 0
    for i := 0; i < len(coupon); i++ {
        current_number := <-called_number
        found := contains(coupon, current_number)
        if found {
            numFound++
        }
        if numFound == len(coupon) {
            claim_prize <- person_id
        } else {
            received <- true
        }
    }
}

func main() {
    var called_number chan int
    var claim_prize chan PersonID
    var received chan bool

    tokens := make([][]int, 3)
    for i := 0; i < 3; i++ {
        tokens[i] = make([]int, 12)
        for j := 0; j < 12; j++ {
            num := rand.Intn(100) + 1
            found := contains(tokens[i], num)
            for found {
                num = rand.Intn(100) + 1
                found = contains(tokens[i], num)
            }
            tokens[i][j] = num
        }
    }

    go Person(called_number, claim_prize, received, tokens[0], 0)
    go Person(called_number, claim_prize, received, tokens[1], 1)
    go Person(called_number, claim_prize, received, tokens[2], 2)

    claimants := make([]PersonID, 0)
    prev_called := make(map[int]bool)
    for i := 0; i < 100; i++ {
        if len(claimants) == 3 {
            break
        }
        num := rand.Intn(100) + 1
        _, ok := prev_called[num]
        for ok {
            num = rand.Intn(100) + 1
            _, ok = prev_called[num]
        }
        prev_called[num] = true
        called_number <- num
        for j := 0; j < 3; j++ {
            select {
            case _ = <-received:
                continue
            case pid := <-claim_prize:
                claimants = append(claimants, pid)
            }
        }
    }

    fmt.Println(claimants)
}",2028
29690419,426,"package main

import (
    ""fmt""
    ""reflect""
    ""strings""
)
import (
    ""encoding/json""
    ""encoding/xml""
    ""errors""
)

type Query struct {
    XMLName xml.Name `xml:""http://marklogic.com/appservices/search query"" json:""-""`
    Field1  string
    Field2  int64
}

type TermQuery struct {
    XMLName xml.Name `xml:""http://marklogic.com/appservices/search term-query"" json:""-""`
    Field3  string
    Field4  int64
}

func getXmlName(d interface{}, label string) (string, bool) {
    switch reflect.TypeOf(d).Kind() {
    case reflect.Struct:
        v, _ := reflect.TypeOf(d).FieldByName(label)
        parts := strings.Split(v.Tag.Get(""xml""), "" "")
        return parts[1], true
    }
    return """", false
}

func wrapJson(item interface{}) ([]byte, error) {
    if n, ok := getXmlName(item, ""XMLName""); ok {
        b, err := json.Marshal(map[string]interface{}{n: item})
        if err != nil {
            return nil, err
        }
        return b, nil
    }
    return nil, errors.New(""You failed"")
}

func main() {
    // create a Query and encode it as {""query"": {struct}}
    q := Query{Field1: ""hello"", Field2: 42}
    wrappedQ, err := wrapJson(q)
    if err != nil {
        fmt.Println(err)
        return
    }
    fmt.Println(string(wrappedQ))

    // create a TermQuery and encode it as {""term-query"": {struct}}
    tq := TermQuery{Field3: ""world"", Field4: 99}
    wrappedTQ, err := wrapJson(tq)
    if err != nil {
        fmt.Println(err)
        return
    }
    fmt.Println(string(wrappedTQ))

}",1521
29786675,438,"package main

import (
        ""bufio""
        ""fmt""
        ""os""
        ""strconv""
        ""strings""
)

func main() {
        // Set up input and output.
        reader := bufio.NewReader(os.Stdin)
        writer := bufio.NewWriter(os.Stdout)
        defer writer.Flush()

        // Get the number of vertices and number of cliques from the first line.
        line, err := reader.ReadString('\n')
        if err != nil {
                fmt.Fprintf(os.Stderr, ""Error reading first line: %s\n"", err)
                return
        }
        var numVertices, numCliques int
        numScanned, err := fmt.Sscanf(line, ""%d %d"", &numVertices, &numCliques)
        if numScanned != 2 || err != nil {
                fmt.Fprintf(os.Stderr, ""Error parsing input parameters: %s\n"", err)   
                return
        }

        // Initialize the edge counts and vertex counts.
        edgeCounts := make([][]int, numVertices+1)
        for u := 1; u <= numVertices; u++ {
                edgeCounts[u] = make([]int, numVertices+1)
        }
        vertexCounts := make([]int, numVertices+1)

        // Read each clique and update the edge counts.
        for c := 0; c < numCliques; c++ {
                line, err = reader.ReadString('\n')
                if err != nil {
                        fmt.Fprintf(os.Stderr, ""Error reading clique: %s\n"", err)
                        return
                }
                tokens := strings.Split(strings.TrimSpace(line), "" "")
                clique := make([]int, len(tokens))
                for i, token := range tokens {
                        u, err := strconv.Atoi(token)
                        if err != nil {
                                fmt.Fprintf(os.Stderr, ""Atoi error: %s\n"", err)
                                return
                        }
                        vertexCounts[u]++
                        clique[i] = u
                        for j := 0; j < i; j++ {
                                v := clique[j]
                                edgeCounts[u][v]++
                                edgeCounts[v][u]++
                        }
                }
        }

        // Compute the number of edges between each pair of vertices.
        count2edges := make([][][]int, numCliques+1)
        for u := 1; u < numVertices; u++ {
                for v := u + 1; v <= numVertices; v++ {
                        count := edgeCounts[u][v]
                        count2edges[count] = append(count2edges[count],
                                []int{u, v})
                }
        }
        writer.WriteString(""Number of edges between pairs of vertices:\n"")
        for count := numCliques; count >= 1; count-- {
                edges := count2edges[count]
                if len(edges) == 0 {
                        continue
                }
                label := ""edge""
                if count > 1 {
                        label += ""s:""
                } else {
                        label += "": ""
                }
                writer.WriteString(fmt.Sprintf(""%5d %s"", count, label))
                for _, edge := range edges {
                        writer.WriteString(fmt.Sprintf("" (%d, %d)"",
                                edge[0], edge[1]))
                }
                writer.WriteString(""\n"")
        }

        // Group vertices according to the number of clique memberships.
        count2vertices := make([][]int, numCliques+1)
        for u := 1; u <= numVertices; u++ {
                count := vertexCounts[u]
                count2vertices[count] = append(count2vertices[count], u)
        }
        writer.WriteString(""\nNumber of cliques in which a vertex appears:\n"")
        for count := numCliques; count >= 1; count-- {
                vertices := count2vertices[count]
                if len(vertices) == 0 {
                        continue
                }
                label := ""clique""
                if count > 1 {
                        label += ""s:""
                } else {
                        label += "": ""
                }
                writer.WriteString(fmt.Sprintf(""%5d %s"", count, label))
                for _, u := range vertices {
                        writer.WriteString(fmt.Sprintf("" %d"", u))
                }
                writer.WriteString(""\n"")
        }
}",4320
29831469,446,"func getLineup() {
    // Open Database
    db, err := sql.Open(""sqlite3"", ""./database.db"")
    if err != nil {
            fmt.Println(err)
            os.Exit(1)
    }
    defer db.Close()

    // Prepare Query
    statement, err := db.Prepare(""SELECT team, player FROM lineup ORDER BY team DESC;"")
    if err != nil {
            fmt.Println(err)
            os.Exit(1)
    }

    // Execute Statement
    rows, err := statement.Query()
    defer rows.Close()


    fmt.Println(""Lineup:"")

    for rows.Next() {
            var team string
            var player string
            rows.Scan(&team, &player)
            fmt.Printf(""%v %v\n"", team, player)
    }

}",668
30495284,461,"package example

import (
    ""crypto""
    ""crypto/rsa""
    ""crypto/sha256""
    ""crypto/x509""
    ""fmt""
)

func Verify(key []byte, sig []byte, msg []byte) error {
    digest := sha256.Sum256(msg)

    pub, err := x509.ParsePKIXPublicKey(key)
    if err != nil {
        return fmt.Errorf(""Failed to parse key"")
    }

    rsaPub, ok := pub.(*rsa.PublicKey)
    if !ok {
        return fmt.Errorf(""Invalid value returned from ParsePKIXPublicKey"")
    }

    opts := rsa.PSSOptions{SaltLength: 16, Hash: crypto.SHA256}
    if err = rsa.VerifyPSS(rsaPub, crypto.SHA256, digest[:], sig, &opts); err != nil {
        return fmt.Errorf(""Failed Verification"")
    }
    return nil
}",676
30580746,464,"package galileo

import (
    ""encoding/json""
    ""golang.org/x/net/context""
    ""golang.org/x/oauth2""
    ""golang.org/x/oauth2/google""
    ""google.golang.org/appengine""
    ""google.golang.org/appengine/file""
    ""google.golang.org/appengine/urlfetch""
    ""google.golang.org/cloud""
    ""google.golang.org/cloud/storage""
    ""io""
    ""io/ioutil""
    ""log""
    ""net/http""
)

var bucket = ""prod_agl_expt""

// saveData struct holds information needed to run the various saving functions.
type saveData struct {
    c       context.Context
    r       *http.Request       //http response
    w       http.ResponseWriter //http writer
    ctx     context.Context
    cleanUp []string // cleanUp is a list of filenames that need cleaning up at the end of the saving.
    failed  bool     // failed indicates that one or more of the saving steps failed.
}

// saveData struct holds information needed to run the various saving functions.
type loadData struct {
    c       context.Context
    r       *http.Request       //http response
    w       http.ResponseWriter //http writer
    ctx     context.Context
    cleanUp []string // cleanUp is a list of filenames that need cleaning up at the end of the saving.
    failed  bool     // failed indicates that one or more of the saving steps failed.
}

type jsonStruct struct {
    User struct {
        Gender string `json:""gender""`
        Age    string `json:""age""`
        ID     string `json:""id""`
    } `json:""user""`
    Stim map[string]struct {
        Index           int    `json:""index""`
        Word            string `json:""word""`
        WordDisplayTime int    `json:""wordDisplayTime""`
        AnswerMaxTime   int    `json:""answerMaxTime""`
        FixationTime    int    `json:""fixationTime""`
        Train           bool   `json:""train""`
        Test            bool   `json:""test""`
        Grammatical     bool   `json:""grammatical""`
        Grammar         string `json:""grammar""`
        Keyboard        bool   `json:""keyboard""`
        TestSeq         int    `json:""testSeq""`
    } `json:""viewedTrials""`
    Answers struct {
        Training []struct {
            Answer   string  `json:""ans""`
            RT       float32 `json:""RT""`
            GtAnswer string  `json:""gtAns""`
            Correct  int     `json:""correct""`
        } `json:""training""`
        Test []struct {
            Answer   string  `json:""ans""`
            RT       float32 `json:""RT""`
            GtAnswer bool    `json:""gtAns""`
            Correct  int     `json:""correct""`
        } `json:""test""`
    } `json:""answers""`
    Trials []struct {
        Trial struct {
            Index           int    `json:""index""`
            Word            string `json:""word""`
            WordDisplayTime int    `json:""wordDisplayTime""`
            AnswerMaxTime   int    `json:""answerMaxTime""`
            FixationTime    int    `json:""fixationTime""`
            Train           bool   `json:""train""`
            Test            bool   `json:""test""`
            Grammatical     bool   `json:""grammatical""`
            Grammar         string `json:""grammar""`
            Keyboard        bool   `json:""keyboard""`
            TestSeq         int    `json:""testSeq""`
        } `json:""trial""`
        Metadata struct {
            Instructions string `json:""instructions""`
            SubmitUrl    string `json:""submitUrl""`
        } `json:""metadata""`
    } `json:""shuffledTrials""`
    Debriefing []struct {
        Type             string `json:""type""`
        RadioWithTextAns string `json:""radioWithTextAns""`
        TextAns          string `json:""textAns""`
        Rating           int    `json:""rating""`
        RadioOnlyAns     string `json:""radioOnlyAns""`
    } `json:""debriefingAns""`
}

type trialStruct []struct {
    Trial struct {
        Index           int    `json:""index""`
        Word            string `json:""word""`
        WordDisplayTime int    `json:""wordDisplayTime""`
        AnswerMaxTime   int    `json:""answerMaxTime""`
        FixationTime    int    `json:""fixationTime""`
        Train           bool   `json:""train""`
        Test            bool   `json:""test""`
        Grammatical     bool   `json:""grammatical""`
        Grammar         string `json:""grammar""`
        Keyboard        bool   `json:""keyboard""`
        TestSeq         int    `json:""testSeq""`
    } `json:""trial""`
    Metadata struct {
        Instructions string `json:""instructions""`
        SubmitUrl    string `json:""submitUrl""`
    } `json:""metadata""`
}

func fromJSON(r io.Reader) (jsonStruct, error) {
    var x jsonStruct
    dec := json.NewDecoder(r)
    err := dec.Decode(&x)
    return x, err
}

func toJSON(b io.Writer, trial trialStruct) (io.Writer, error) {
    enc := json.NewEncoder(b)
    err := enc.Encode(&trial)
    return b, err
}

func init() {
    http.HandleFunc(""/"", handleStatic)
    http.HandleFunc(""/saveUserData"", handleSaveUser)
    http.HandleFunc(""/loadTrials"", handleloadTrials)
}

func handleStatic(w http.ResponseWriter, r *http.Request) {
    w.Header().Set(""Cache-Control"", ""no-cache"")
    http.ServeFile(w, r, ""static/""+r.URL.Path)
}

// testSave is the main saving entry point that calls the GCS operations.
func handleSaveUser(w http.ResponseWriter, r *http.Request) {

    c := appengine.NewContext(r)
    if bucket == """" {
        var err error
        if bucket, err = file.DefaultBucketName(c); err != nil {
            // log.Errorf(c, ""failed to get default GCS bucket name: %v"", err)
            return
        }
    }
    hc := &http.Client{
        Transport: &oauth2.Transport{
            Source: google.AppEngineTokenSource(c, storage.ScopeFullControl),
            Base:   &urlfetch.Transport{Context: c},
        },
    }
    ctx := cloud.NewContext(appengine.AppID(c), hc)

    // structure to holds information needed to run the various saving functions
    d := &saveData{
        c:   c,
        r:   r,
        w:   w,
        ctx: ctx,
    }

    // retrieve data
    processedJson, trials, trainAns, testAns, stimSeq, userDetails, debriefingAns, rawJson := getJsonUserData(d.r, d.w)
    //
    d.createUserFolder(processedJson.User.ID)
    // d.saveJson(k.User.ID, ""raw"", z)
    d.saveJson(processedJson.User.ID, ""trials"", trials)
    d.saveJson(processedJson.User.ID, ""train"", trainAns)
    d.saveJson(processedJson.User.ID, ""test"", testAns)
    d.saveJson(processedJson.User.ID, ""stim"", stimSeq)
    d.saveJson(processedJson.User.ID, ""user"", userDetails)
    d.saveJson(processedJson.User.ID, ""debriefing"", debriefingAns)
    d.saveJson(processedJson.User.ID, ""raw"", rawJson)
}

// Deal with error
func (d *saveData) errorf(format string, args ...interface{}) {
    d.failed = true
}

func getJsonUserData(r *http.Request, w http.ResponseWriter) (jsonStruct, []byte, []byte, []byte, []byte, []byte, []byte, []byte) {
    defer r.Body.Close()

    procJson, err := fromJSON(r.Body)
    if err != nil {
        log.Fatal(err)
    }
    log.Printf(""initial structure: "", procJson)
    log.Printf(""%+v\n"", procJson)
    trials, err := json.Marshal(procJson.Trials)
    if err != nil {
        log.Fatal(err)
    }
    trainAns, err := json.Marshal(procJson.Answers.Training)
    if err != nil {
        log.Fatal(err)
    }
    testAns, err := json.Marshal(procJson.Answers.Test)
    if err != nil {
        log.Fatal(err)
    }
    stimSeq, err := json.Marshal(procJson.Stim)
    if err != nil {
        log.Fatal(err)
    }
    userDetail, err := json.Marshal(procJson.User)
    if err != nil {
        log.Fatal(err)
    }
    debriefingAns, err := json.Marshal(procJson.Debriefing)
    if err != nil {
        log.Fatal(err)
    }
    rawJson, err := json.Marshal(procJson)
    if err != nil {
        log.Fatal(err)
    }
    return procJson, trials, trainAns, testAns, stimSeq, userDetail, debriefingAns, rawJson
}

func (d *saveData) createUserFolder(folderName string) {
    fName := folderName + ""/""
    wc := storage.NewWriter(d.ctx, bucket, fName)
    wc.ContentType = ""text/plain""
    d.cleanUp = append(d.cleanUp, fName)

    if err := wc.Close(); err != nil {
        d.errorf(""createFile: unable to close bucket %q, file %q: %v"", bucket, fName, err)
        return
    }

}

func (d *saveData) saveJson(folderName string, fileName string, fileContent []byte) {
    fullName := folderName + ""/"" + fileName
    wc := storage.NewWriter(d.ctx, bucket, fullName)
    wc.ContentType = ""text/plain""
    d.cleanUp = append(d.cleanUp, fullName)
    d.createFile(fullName, fileContent)

}

func (d *saveData) createFile(fileName string, content []byte) {

    wc := storage.NewWriter(d.ctx, bucket, fileName)
    wc.ContentType = ""text/plain""
    d.cleanUp = append(d.cleanUp, fileName)

    if _, err := wc.Write([]byte(content)); err != nil {
        d.errorf(""createFile: unable to write data to bucket %q, file %q: %v"", bucket, fileName, err)
        return
    }
    if err := wc.Close(); err != nil {
        d.errorf(""createFile: unable to close bucket %q, file %q: %v"", bucket, fileName, err)
        return
    }
}

func handleloadTrials(w http.ResponseWriter, r *http.Request) {
    c := appengine.NewContext(r)
    if bucket == """" {
        var err error
        if bucket, err = file.DefaultBucketName(c); err != nil {
            // log.Errorf(c, ""failed to get default GCS bucket name: %v"", err)
            return
        }
    }
    hc := &http.Client{
        Transport: &oauth2.Transport{
            Source: google.AppEngineTokenSource(c, storage.ScopeFullControl),
            Base:   &urlfetch.Transport{Context: c},
        },
    }
    ctx := cloud.NewContext(appengine.AppID(c), hc)

    // structure to holds information needed to run the various saving functions
    d := &saveData{
        c:   c,
        r:   r,
        w:   w,
        ctx: ctx,
    }

    userID := r.URL.Query().Get(""id"")
    log.Println(userID)
    trialJson := d.readFile(userID)
    w.Write(trialJson)
}

// readFile reads the named file in Google Cloud Storage.
func (d *saveData) readFile(fileName string) []byte {
    trialName := fileName + ""/trials""
    rc, err := storage.NewReader(d.ctx, bucket, trialName)
    if err != nil {
        d.errorf(""readFile: unable to open file from bucket %q, file %q: %v"", bucket, trialName, err)

    }
    defer rc.Close()
    slurp, err := ioutil.ReadAll(rc)
    if err != nil {
        d.errorf(""readFile: unable to read data from bucket %q, file %q: %v"", bucket, fileName, err)
    }
    return slurp
}",10424
30702948,469,"package main

import (
    ""bytes""
    ""encoding/json""
    ""fmt""
    ""log""
    ""net/http""
)

func main() {
    client := &http.Client{}
    // Why this stringData is lost and was not send with POST request?
    stringData := `INSERT INTO V SET name = 'jack', boss = #11:19`
    req, err := http.NewRequest(""POST"", ""http://localhost:2480/command/GratefulDeadConcerts/sql"", bytes.NewBufferString(stringData))
    req.SetBasicAuth(""root"", ""1"")
    resp, err := client.Do(req)
    if err != nil {
        fmt.Printf(""Error : %s"", err)
    }
    fmt.Println(""resp"")
    fmt.Println(ToJson(resp))

    var b bytes.Buffer
    _, err = b.ReadFrom(resp.Body)
    if err != nil {
        log.Fatal(""Error : %s"", err)
    }
    fmt.Println(b.String())
}

func ToJson(obj interface{}) string {
    b, err := json.MarshalIndent(&obj, """", ""   "")
    if err != nil {
        fmt.Printf(""Error : %s"", err)
    }
    strJson := string(b)

    return strJson
}",943
30919986,486,"package main

import (
    ""github.com/gin-gonic/gin""
    ""database/sql""
    ""github.com/coopernurse/gorp""
    _ ""github.com/mattn/go-sqlite3""
    ""log""
    ""time""
    ""strconv""
    ""github.com/go-errors/errors""
)

type Article struct {
    Id int64 `db:""article_id""`
    Created int64
    Title string
    Content string
}

var dbmap = initDb()

func initDb() gorp.DbMap {
    db, err := sql.Open(""sqlite3"", ""db.sqlite3"")
    checkErr(err, ""sql.Open faild"")
    dbmap := gorp.DbMap{Db: db, Dialect: gorp.SqliteDialect{}}
    dbmap.AddTableWithName(Article{}, ""articles"").SetKeys(true, ""Id"")
    err = dbmap.CreateTablesIfNotExists()
    checkErr(err, ""Create tables failed"")
    return dbmap
}

func checkErr(err error, msg string) {
    if err != nil {
        log.Fatalln(msg, err.(*errors.Error).ErrorStack())
    }
}

func index (c *gin.Context) {
    content := gin.H{""Hello"": ""World""}
    c.JSON(200, content)
}

func ArticlesList(c *gin.Context) {
    var articles []Article
    _, err := dbmap.Select(&articles, ""select * from articles order by article_id"")
    checkErr(err, ""Select failed"")
    content := gin.H{}
    for k, v := range articles {
        content[strconv.Itoa(k)] =v
    }
    c.JSON(200, content)
}

func ArticlesDetail(c *gin.Context) {
    article_id := c.Params.ByName(""id"")
    a_id, _ := strconv.Atoi(article_id)
    article := getArticle(a_id)
    content := gin.H{""title"": article.Title, ""content"": article.Content}
    c.JSON(200, content)
}

func ArticlePost(c *gin.Context) {
    var json Article

    c.Bind(&json)
    article := createArticle(json.Title, json.Content)
    if article.Title == json.Title {
        content := gin.H{
            ""result"": ""Success"",
            ""title"": article.Title,
            ""content"": article.Content,
        }
        c.JSON(201, content)
    } else {
        c.JSON(500, gin.H{""result"": ""An error occured""})
    }
}

func createArticle(title, body string) Article {
    article := Article{
        Created: time.Now().UnixNano(),
        Title: title,
        Content: body,
    }

    err := dbmap.Insert(&article)
    checkErr(err, ""Insert failed"")
    return article
}

func getArticle(article_id int) Article {
    article := Article{}
    err := dbmap.SelectOne(&article, ""select * from articles where article_id=?"", article_id)
    checkErr(err, ""selectOne failed"")
    return article
}

func main() {
    app := gin.Default()
    app.GET(""/"", index)
    app.GET(""/articles"", ArticlesList)
    app.POST(""/articles"", ArticlePost)
    app.GET(""/articles/:article_id"", ArticlesDetail)
    app.Run("":8000"")
}",2593
31088111,491,"package main

import (
    ""encoding/json""
    ""fmt""
    ""io/ioutil""
    ""log""
    ""net/http""
    ""os""
    ""reflect""
    ""strconv""
    ""strings""

    ""github.com/gorilla/mux""
    ""gopkg.in/mgo.v2""
    ""gopkg.in/mgo.v2/bson""
)

type imageLinks struct {
    Link     string `bson:""link""`
    Upvote   int    `bson:""upvote""`
    Downvote int    `bson:""downvote""`
}

type Result struct {
    Photos struct {
        Page    int    `json: ""page""`
        Pages   int    `json: ""pages""`
        PerPage int    `json: ""perpage""`
        Total   string `json: ""total""`
        Photo   []struct {
            Id       string `json: ""id""`
            Owner    string `json: ""owner""`
            Secret   string `json: ""secret""`
            Server   string `json: ""server""`
            Farm     int    `json: ""farm""`
            Title    string `json: ""title""`
            IsPublic int    `json: ""ispublic""`
            IsFriend int    `json: ""isfriend""`
            IsFamily int    `json: ""isfamily`
        } `json: ""photo""`
    } `json: ""photos""`
    Stat string `json: ""stat""`
}

func main() {

    router := mux.NewRouter().StrictSlash(true)
    router.HandleFunc(""/Index"", Index)
    router.HandleFunc(""/UpVote"", UpVoteRoute)
    router.HandleFunc(""/DownVote"", DownVoteRoute)
    log.Fatal(http.ListenAndServe("":8080"", router))
}

func UpVoteRoute(w http.ResponseWriter, r *http.Request) {

    link := r.URL.Query().Get(""imagelink"")
    w.Header().Set(""Content-Type"", ""application/json"")
    session, err := mgo.Dial(""mongodb://:@ds061631.mongolab.com:61631/flickrimagedb"")
    if err != nil {
        fmt.Printf(""%s"", err)
        os.Exit(1)
    }
    defer session.Close()

    session.SetMode(mgo.Monotonic, true)
    c := session.DB(""flickrimagedb"").C(""image_links_votes"")

    err = c.Update(bson.M{""link"": link}, bson.M{""$inc"": bson.M{""upvote"": 1}})
    if err != nil {
        fmt.Printf(""Can't update document %v\n"", err)
        os.Exit(1)
    }
}

func DownVoteRoute(w http.ResponseWriter, r *http.Request) {

    link := r.URL.Query().Get(""imagelink"")
    w.Header().Set(""Content-Type"", ""application/json"")
    session, err := mgo.Dial(""mongodb://*********:*******@ds061631.mongolab.com:61631/flickrimagedb"")
    if err != nil {
        fmt.Printf(""%s"", err)
        os.Exit(1)
    }
    defer session.Close()

    session.SetMode(mgo.Monotonic, true)
    c := session.DB(""flickrimagedb"").C(""image_links_votes"")

    err = c.Update(bson.M{""link"": link}, bson.M{""$inc"": bson.M{""downvote"": 1}})
    if err != nil {
        fmt.Printf(""Can't update document %v\n"", err)
        os.Exit(1)
    }
}

func Index(w http.ResponseWriter, r *http.Request) {

    w.Header().Set(""Content-Type"", ""application/json"")
    session, err := mgo.Dial(""mongodb://*********:*********@ds061631.mongolab.com:61631/flickrimagedb"")
    if err != nil {
        fmt.Printf(""%s"", err)
        os.Exit(1)
    }

    defer session.Close()

    session.SetMode(mgo.Monotonic, true)
    c := session.DB(""flickrimagedb"").C(""image_links_votes"")

    checkResult := &imageLinks{}
    // Create a slice to begin with
    myType := reflect.TypeOf(checkResult)
    slice := reflect.MakeSlice(reflect.SliceOf(myType), 10, 10)
    // Create a pointer to a slice value and set it to the slice
    x := reflect.New(slice.Type())
    x.Elem().Set(slice)
    err = c.Find(bson.M{}).All(x.Interface())
    if err != nil {
        response, err := json.Marshal(x.Interface())
        if err != nil {
            fmt.Printf(""%s"", err)
            os.Exit(2)
        }
        fmt.Fprintf(w, string(response))
    } else {
        url := ""https://api.flickr.com/services/rest/?method=flickr.photos.search&api_key=*****************************&text=cute+puppies&per_page=12&format=json&nojsoncallback=1""
        res, err := http.Get(url)
        if err != nil {
            fmt.Printf(""%s"", err)
            os.Exit(3)
        }
        body, err := ioutil.ReadAll(res.Body)
        if err != nil {
            fmt.Printf(""%s"", err)
            os.Exit(4)
        }

        jsonData := &Result{}
        err = json.Unmarshal(body, jsonData)

        for value := range jsonData.Photos.Photo {
            s1 := []string{""https://farm"", "".staticflickr.com/""}
            s2 := []string{strings.Join(s1, strconv.Itoa(jsonData.Photos.Photo[value].Farm)), ""/""}
            s3 := []string{strings.Join(s2, jsonData.Photos.Photo[value].Server), ""_""}
            s4 := []string{strings.Join(s3, jsonData.Photos.Photo[value].Id), "".jpg""}
            s := strings.Join(s4, jsonData.Photos.Photo[value].Secret)
            singleReuslt := imageLinks{}
            err = c.Find(bson.M{""link"": s}).One(&singleReuslt)
            if err != nil {
                err = c.Insert(&imageLinks{Link: s, Upvote: 0, Downvote: 0})
                if err != nil {
                    fmt.Printf(""%s"", err)
                    os.Exit(5)
                }
            }
        }

        allResult := &imageLinks{}
        // Create a slice to begin with
        myType := reflect.TypeOf(allResult)
        slice := reflect.MakeSlice(reflect.SliceOf(myType), 10, 10)
        // Create a pointer to a slice value and set it to the slice
        x := reflect.New(slice.Type())
        x.Elem().Set(slice)
        err = c.Find(bson.M{}).All(x.Interface())
        response, err := json.Marshal(x.Interface())
        if err != nil {
            fmt.Printf(""%s"", err)
            os.Exit(6)
        }
        fmt.Fprintf(w, string(response))
    }
}",5484
31279557,496,"switch p := procedure.(type) {
case func(...scmer) scmer:
    value = p(args...)
case proc:
    en := &env{make(vars), p.en}
    switch params := p.params.(type) {
    case []scmer:
        for i, param := range params {
            en.vars[param.(symbol)] = args[i]
        }
    default:
        en.vars[params.(symbol)] = args
    }
    value = eval(p.body, en)
",365
31286087,500,"package main

import (
    ""reflect""
    ""fmt""
    ""log""
    ""os""
    ""encoding/json""
    ""sort""

    ""github.com/lxn/walk""
    . ""github.com/lxn/walk/declarative""
    //""strings""
)

type Task struct {
    TaskId string
    TaskNo string
    TaskName string
    ManDay string
    Term string
    ManDayDay string
    StartDate string
    EndDate string
    Progress string
}

type TaskModel struct {
    walk.TableModelBase
    walk.SorterBase
    sortColumn int
    sortOrder walk.SortOrder
    items []Task
}

func NewTaskModel() *TaskModel {
    t := new(TaskModel)

    t.items = make([]Task, 3)

    var tasks []Task
    tasks = read("""")

    for i := 0; i < len(tasks); i++ {
        var task Task
        task = tasks[i]
        t.items[i] = task
    }

    t.PublishRowsReset()

    return t
}

func (m *TaskModel) RowCount() int {
    return len(m.items)
}

func (m *TaskModel) Len() int {
    return len(m.items)
}

func (m *TaskModel) Value(row, col int) interface{} {
    item := m.items[row]

    switch col {
        case 0:
            return item.TaskId
        case 1:
            return item.TaskNo
        case 2:
            return item.TaskName
        case 3:
            return item.ManDay
        case 4:
            return item.Term
        case 5:
            return item.ManDayDay
        case 6:
            return item.StartDate
        case 7:
            return item.EndDate
        case 8:
            return item.Progress
    }

    panic(""unexpected col"")
}

func (m *TaskModel) Sort(col int, order walk.SortOrder) error {
    m.sortColumn, m.sortOrder = col, order

    sort.Sort(m)

    return m.SorterBase.Sort(col, order)
}

func (m *TaskModel) Less(i, j int) bool {
    a, b := m.items[i], m.items[j]

    c := func(ls bool) bool {
        if m.sortOrder == walk.SortAscending {
            return ls
        }

        return !ls
    }

    switch m.sortColumn {
        case 0:
            return c(a.TaskId < b.TaskId)
        case 1:
            return c(a.TaskNo < b.TaskNo)
        case 2:
            return c(a.TaskName < b.TaskName)
        case 3:
            return c(a.ManDay < b.ManDay)
        case 4:
            return c(a.Term < b.Term)
        case 5:
            return c(a.ManDayDay < b.ManDayDay)
        case 6:
            return c(a.StartDate < b.StartDate)
        case 7:
            return c(a.EndDate < b.EndDate)
        case 8:
            return c(a.Progress < b.Progress)
    }

    panic(""error"")
}

func (m *TaskModel) Swap(i, j int) {
    m.items[i], m.items[j] = m.items[j], m.items[i]
}

func read(filePath string) []Task{

    file, err := os.Open(""C:/Dev/xampp/htdocs/workspace/SampleGoProject/src/main/task.json"")
    //file, err := os.Open(filePath)

    if err != nil {
        log.Fatal(err)
    }

    defer file.Close()

    var tasks []Task

    decoder := json.NewDecoder(file)
    //json.NewDecoder(file)

    //fmt.Print(tasks)

    //err = decoder.Decode(&tasks)
    decoder.Decode(&tasks)
    if err != nil {
        log.Fatal(err)
    }

    //fmt.Print(tasks)

    return tasks;
}

func write(filePath string, mw *MyMainWindow) {

    var children *walk.WidgetList
    children = mw.MainWindow.Children()

    var child walk.Widget
    child = children.At(0)

    to := reflect.TypeOf(child)
    fv := reflect.ValueOf(child).Convert(to).Interface()

    //tableview := fv.Type().In(0)
    //var tableview TableView
    //tableview := child.Cursor()

    //fmt.Print(child)

    //fmt.Println(tableview)

    fmt.Println(to)
    fmt.Println(fv)



    //r := fv.InterfaceData()
    //fmt.Println(r)
    //fmt.Println(reflect.ValueOf(child).Convert(fv))

    file, err := os.Create(""C:/Dev/xampp/htdocs/workspace/SampleGoProject/src/main/task2.json"")
    if err != nil {
        log.Fatal(err)
    }

    defer file.Close()

    //var tasks []Task

    encoder := json.NewEncoder(file)

    err = encoder.Encode(fv)
    if err != nil {
        log.Fatal(err)
    }

}

type MyMainWindow struct {
    *walk.MainWindow
    prevFilePath string
}

func main() {

    model := NewTaskModel()

    mw := new (MyMainWindow)

    var openAction, saveAction *walk.Action

    if err:= (MainWindow{
        AssignTo: &mw.MainWindow,
        Title: ""WBS"",
        MenuItems: []MenuItem{
            Menu {
                Text: ""&File"",
                Items: []MenuItem{
                    Action{
                        AssignTo: &openAction,
                        Text: ""&Open"",
                        OnTriggered: mw.openAction_Triggered,
                    },
                    Action{
                        AssignTo: &saveAction,
                        Text: ""&Save"",
                        OnTriggered: mw.saveAction_Triggered,
                    },
                    Separator{},
                    Action{
                        Text: ""&Exit"",
                        OnTriggered: func() {
                            mw.Close()  
                        },
                    },
                },
            },
        },
        MinSize: Size{800, 400},
        Layout: VBox{},
        Children: []Widget{
            TableView {
                Columns: []TableViewColumn{
                    {Title: ""Task Id""},
                    {Title: ""Task No""},
                    {Title: ""Task Name""},
                    {Title: ""Man Day""},
                    {Title: ""Term""},
                    {Title: ""Man Day Day""},
                    {Title: ""Start Date""},
                    {Title: ""End Date""},
                    {Title: ""Progress""},
                },
                Model: model,
            },
        },
    }.Create()); err != nil {
        //fmt.Print(err)
        //log.Fatal(err)

    }

    mw.Run()
}

func (mw *MyMainWindow) openAction_Triggered() {
    if err := mw.openFile(); err != nil {
        log.Print(err)
    }
}

func (mw *MyMainWindow) openFile() error {
    dlg := new(walk.FileDialog)

    dlg.FilePath = mw.prevFilePath
    dlg.Filter = ""JSON Files|*.json""
    dlg.Title = ""Select a json file""

    if ok, err := dlg.ShowOpen(mw); err != nil {
        return err
    } else if !ok {
        return nil
    }

    mw.prevFilePath = dlg.FilePath

    read(mw.prevFilePath)

    return nil
}

func (mw *MyMainWindow) saveAction_Triggered() {
    if err := mw.saveFile(); err != nil {
        log.Print(err)
    }
}

func (mw *MyMainWindow) saveFile() error {
    dlg := new(walk.FileDialog)

    dlg.FilePath = mw.prevFilePath
    dlg.Filter = ""JSON Files|*.json""
    dlg.Title = ""Input a json file name""

    if ok, err := dlg.ShowSave(mw); err != nil {
        return err
    } else if !ok {
        return nil
    }

    mw.prevFilePath = dlg.FilePath

    write(mw.prevFilePath, mw)

    return nil
}",6747
31386044,501,"package main

import (
    ""net/http""
)

func main() {
    http.HandleFunc(""/"", func(w http.ResponseWriter, req *http.Request) {
        w.Write([]byte(""Hello World""))
    })
    http.ListenAndServe("":80"", nil)
}",213
31592548,538,"Following is what I could come up with from whatever I read across the net.
Working on local secondary indexes, range index and timestamps presently.
Thanks again!    


    package main

    import (
        ""github.com/aws/aws-sdk-go/aws""
        // ""github.com/aws/aws-sdk-go/aws/awserr""
        ""github.com/aws/aws-sdk-go/aws/awsutil""
        ""github.com/aws/aws-sdk-go/service/dynamodb""

        ""log""
        ""strconv""
        ""time""
    )

    type dynamo struct {
        db            *dynamodb.DynamoDB
        tableName     string
        readCapacity  int64
        writeCapacity int64
    }

    type metadata struct {
        dynamoDb  *dynamo
        batchID   string
        field1    string
        field2    string
        batchSize int //In Bytes
    }

    func newDynamo(name string, readCapacity, writeCapacity int64) *dynamo {
        cfg := aws.DefaultConfig
        return &dynamo{
            db:            dynamodb.New(cfg),
            tableName:     name,
            readCapacity:  readCapacity,
            writeCapacity: writeCapacity,
        }
    }

    func newMetadata(batchID, field1Val, field2Val string, batchSizeVal int) *metadata {
        return &metadata{
            batchID:   batchID,
            field1:    field1Val,
            field2:    field2Val,
            batchSize: batchSizeVal,
        }
    }

    var dynDB *dynamo
    var m *metadata

    func main() { //create the *metadata struct object, and it can then call writeToDynamo fn
        log.Println(""Entry"")

        dynDB = newDynamo(""tableName"", 1, 1) //make a new dynamo struct object
        dynDB.createTable()

        m = newMetadata(""field1Value"", ""field2Value"", 232)
        m.setDynamoDB()

        m.writeToDynamo()

        log.Println(""Exit"")
    }

    func (d *dynamo) createTable() (err error) {
        log.Println(""createTable Entry"")
        tableDefinition := &dynamodb.CreateTableInput{
            TableName: aws.String(d.tableName),
            AttributeDefinitions: []*dynamodb.AttributeDefinition{ // Required
                { // Required
                    AttributeName: aws.String(""batchID""),
                    AttributeType: aws.String(""S""), // Required
                },
            },
            KeySchema: []*dynamodb.KeySchemaElement{ // Required
                { // Required
                    AttributeName: aws.String(""batchID""),
                    KeyType:       aws.String(""HASH""), // Required
                },
            },
            ProvisionedThroughput: &dynamodb.ProvisionedThroughput{
                ReadCapacityUnits:  aws.Long(d.readCapacity),
                WriteCapacityUnits: aws.Long(d.writeCapacity),
            },
        }

        resp, err := dynDB.db.CreateTable(tableDefinition)
        log.Println(""After CreateTable---"")

        if err != nil {
            log.Println(""create table failed"", err.Error())
            return err
        }
        if resp != nil && resp.TableDescription != nil {
            log.Println(""TableStatus:"", resp.TableDescription.TableStatus)
        }

        log.Println(""CreateTable Exit"")

        //Sleep for 15 seconds, this is better when put in a function that validates the table that was created,
        //But for testing, the program is put to sleep for 15 seconds. Program may fail if writeToDynamo is exedcuted
        //without the table being in ACTIVE state.
        time.Sleep(15 * time.Second)
        return
    }

    func (m *metadata) writeToDynamo() {
        log.Println(""writeToDynamo"")

        //Not exactly able to figure out what was wrong with the prev code snippet
        params := &dynamodb.PutItemInput{
            TableName: aws.String(m.dynamoDb.tableName),
            Item: map[string]*dynamodb.AttributeValue{
                ""batchID"": &dynamodb.AttributeValue{
                    S: aws.String(m.batchID),
                },
                ""field2"": &dynamodb.AttributeValue{
                    S: aws.String(m.field2),
                },
                ""field3"": &dynamodb.AttributeValue{
                    S: aws.String(m.field3),
                },
                ""batchSize"": &dynamodb.AttributeValue{
                    N: aws.String(strconv.Itoa(m.batchSize_Compressed)),
                },
            },
        }

        resp2, err2 := dynDB.db.PutItem(params)

        if err2 != nil {
            // if awsErr, ok := err2.(awserr.Error); ok { // Generic AWS error with Code, Message, and original error (if any)
            //  log.Println(awsErr.Code(), awsErr.Message(), awsErr.OrigErr())
            //  if reqErr, ok := err.(awserr.RequestFailure); ok {
            //      // A service error occurred
            //      log.Println(reqErr.Code(), reqErr.Message(), reqErr.StatusCode(), reqErr.RequestID())
            //  }
            // } else { // This case should never be hit, the SDK should always return an //
            //  //error which satisfies the awserr.Error interface.
            //  log.Println(err2.Error())
            // }
            log.Println(""Error while Writing:"", err2.Error())
        }
        log.Println(""Response:"", awsutil.StringValue(resp2))
    }

    func (m *metadata) setDynamoDB() {
        m.dynamoDb = dynDB
    }",5243
31611616,539,"// Pack a folder into zip file
func (cloud *Cloud) Pack(srcFolder string, fileName string, contentType string, metaData *map[string]string) {

    log.Infof(cloud.c, ""Packing bucket %v folder %v to file %v"", cloud.bucket, srcFolder, fileName) 

    srcFolder = fmt.Sprintf(""%v/"", srcFolder)
    query := &storage.Query{Prefix: srcFolder, Delimiter: ""/""}

    objs, err := storage.ListObjects(cloud.ctx, cloud.bucket, query)
    if err != nil {
        log.Errorf(cloud.c, ""Packing failed to list bucket %q: %v"", cloud.bucket, err)
        return
    }

    totalFiles := len(objs.Results)
    if totalFiles == 0 {
        log.Errorf(cloud.c, ""Packing failed to find objects found in folder %q: %v"", cloud.bucket, srcFolder)
        return
    }

    // create storage file for writing
    log.Infof(cloud.c, ""Writing new zip file to %v/%v for %v files"", cloud.bucket, fileName, totalFiles)
    storageWriter := storage.NewWriter(cloud.ctx, cloud.bucket, fileName)

    // add optional content type and meta data  
    if len(contentType) > 0 { storageWriter.ContentType = contentType }
    if metaData != nil { storageWriter.Metadata = *metaData }

    // Create a buffer to write our archive to.
    buf := new(bytes.Buffer)

    // Create a new zip archive to memory buffer
    zipWriter := zip.NewWriter(buf)

    // go through each file in the folder
    for _, obj := range objs.Results {

        log.Infof(cloud.c, ""Packing file %v of size %v to zip file"", obj.Name, obj.Size)
        //d.dumpStats(obj)

        // read file in our source folder from storage - io.ReadCloser returned from storage
        storageReader, err := storage.NewReader(cloud.ctx, cloud.bucket, obj.Name)
        if err != nil {
            log.Errorf(cloud.c, ""Packing failed to read from bucket %q file %q: %v"", cloud.bucket, obj.Name, err)
            return  
        }
        defer storageReader.Close()

        // PERFORMANCE ISSUE: have to load the entire file into memory to get random access from the cloud
        slurp, err := ioutil.ReadAll(storageReader)
        if err != nil {
            log.Errorf(cloud.c, ""Packing failed to read data from bucket %q file %q: %v"", cloud.bucket, obj.Name, err)
            return
        }

        // grab just the filename from directory listing (don't want to store paths in zip)
        _, zipFileName := filepath.Split(obj.Name)

        newFileName := strings.ToLower(zipFileName)

        // add filename to zip
        zipFile, err := zipWriter.Create(newFileName)
        if err != nil {
            log.Errorf(cloud.c, ""Packing failed to create zip file from bucket %q file %q: %v"", cloud.bucket, zipFileName, err)
            return
        }

        // write entire file into zip archive
        _, err = zipFile.Write(slurp)
        if err != nil {
            log.Errorf(cloud.c, ""Packing failed to write zip file from bucket %q file %q: %v"", cloud.bucket, zipFileName, err)
            return
        }

        // flush that to buffer so we can write it off now
        //err = zipFile.Flush()
        //if err != nil {
        //  d.errorf(""pack: unable to flush write of zip file from bucket %q, file %q: %v"", cloud.bucket, zipFileName, err)
        //  //return
        //}

        // now drain all that buffered zip data to the cloud storage file   
        log.Infof(cloud.c, ""Writing zip buffer of size %v to cloud storage file %v"", buf.Len(), fileName)   
        _, err = buf.WriteTo(storageWriter)
        if err != nil {
            log.Errorf(cloud.c, ""Packing failed to write data to bucket %q file %q: %v"", cloud.bucket, fileName, err)   
            return          
        }
    }

    // Make sure to check the error on Close.
    log.Infof(cloud.c, ""Closing zip writer"")    
    err = zipWriter.Close()
    if err != nil {
        log.Errorf(cloud.c, ""Packing failed to close zip file writer from bucket %q file %q : %v"", cloud.bucket, fileName, err)
    }

    // write any leftover data
    if buf.Len() > 0 {
        // now drain all that buffered zip data to the cloud storage file   
        // log.Infof(cloud.c, ""Packing zip buffer of size %v to cloud storage file %v"", buf.Len(), fileName)    
        _, err := buf.WriteTo(storageWriter)
        if err != nil {
            log.Errorf(cloud.c, ""Packing failed to write data to bucket %q file %q: %v"", cloud.bucket, fileName, err)               
        }
    }

    // close up final write file
    //log.Infof(cloud.c, ""Closing cloud storage file %v"", fileName) 
    if err := storageWriter.Close(); err != nil {
        log.Errorf(cloud.c, ""Packing failed to close bucket %q file %q: %v"", cloud.bucket, fileName, err)
        return
    }

    // success!
    log.Infof(cloud.c, ""Packed files to new cloud storage file %v successful!"", fileName)   
}",4783
31744832,542,"package main

import (
    ""code.google.com/p/gcfg""
    ""database/sql""
    ""flag""
    ""fmt""
    _ ""github.com/go-sql-driver/mysql""
    ""github.com/parnurzeal/gorequest""
    ""log""
    ""strconv""
    ""time""
)

func main() {
    t := time.Now()
    initConfig()
    initRoundRobin()

    for i := vStart; i <= vStop; i++ {
        cache(""https://site.ru/url/""+strconv.Itoa(i), ""url"", i)
    }

    fmt.Println(""Time: "", time.Since(t))
}

var (
    db                  *sql.DB
    config              ConfigStruct
    configFile          = ""config.gcfg""
    roundRobin          map[int]string
    roundRobinNextId    int
    roundRobinMaxId     int
    vStart              int
    vStop               int
    vPart               int
    vScriptCount        int
    roundRobinShift     int
    failedRequestCount  int
    successRequestCount int
)

type ConfigStruct struct {
    Database struct {
        ConnectionString string
        TableNameCache   string
    }
    Part struct {
        CurrentPart             int
        CurrentProxyCheckerPart int
    }
}

type ProxyAddress struct {
    Id int
    Ip string
}

func check(e error) {
    if e != nil {
        panic(e)
        log.Fatal(e)
    }
}
",1202
32248489,560,"#ifndef IRUNNABLE_H
#define IRUNNABLE_H

#include 
#include 
#include 

class IRunnable
{
public:
    IRunnable(): mThread(nullptr) {
        mRunning.store(false);
    }

    virtual ~IRunnable() {
        if (mRunning.load())
            Stop();
        delete mThread;
    }


    virtual void Start() {
        mRunning.store(true);
        mThread = new std::thread(&IRunnable::Run, this);
    }

    virtual void Stop() {
        mRunning.store(false);
        if (mThread && mThread->joinable())
            mThread->join();
    }

    virtual bool IsRunning() {return mRunning.load();}

protected:
    virtual void Run() = 0;

    std::atomic mRunning;

private:
    std::thread *mThread;
};

#endif // IRUNNABLE_H",723
32281591,565,"package main
import (
    ""bytes""
    ""log""
    ""net/http""
    ""strconv""
    ""time""
)

func main() {

    http.HandleFunc(""/"", Method)
    log.Printf(""Server Started"")
    log.Fatal(http.ListenAndServe("":8080"", nil))

}

func Method(pResponse http.ResponseWriter, pRequest *http.Request) {
    timeInitial := time.Now()
    log.Printf(strconv.Itoa(timeInitial.Nanosecond()),     strconv.FormatFloat(time.Now().Sub(timeInitial).Seconds()*1000, 'f', 2, 64))
    buf := new(bytes.Buffer)
    buf.ReadFrom(pRequest.Body)
    buf.Bytes() 
    log.Printf(strconv.Itoa(timeInitial.Nanosecond()), strconv.FormatFloat(time.Now().Sub(timeInitial).Seconds()*1000, 'f', 2, 64))

}",669
32370700,573,"package main

import (
    //  ""bytes""
    ""encoding/binary""
    ""fmt""
    ""io""
    ""net""
    ""os""
    ""os/exec""
    ""runtime/trace""
    ""time""
    ""unsafe""
)

type TheMessageType struct {
    X             int32
    RestOfMessage [1000]byte
}

func listener(theCounter int, active bool, f *os.File) {
    var message TheMessageType
    var err error
    var conn net.Conn

    count := theCounter

    for {
        // Dial the server
        fmt.Printf(""LISTENER %d: connecting to socket\n"", count)
        conn, err = net.Dial(""tcp"", ""192.168.1.113:49152"")
        if err != nil {
            fmt.Printf(""LISTENER %d: not connected, retrying in 3 seconds\n"", count)
            time.Sleep(3 * time.Second)
        } else {
            fmt.Printf(""LISTENER %d: connected\n"", count)
            break
        }
    }
    defer conn.Close()

    // Loop writing to socket
    for {
        // Set deadline
        // conn.SetDeadline(time.Now().Add(2 * time.Second))

        // Print some info
        fmt.Printf(""LISTENER %d: writing from %v to %v\n"", count, conn.LocalAddr(), conn.RemoteAddr())

        // Prepare message to write to socket
        message.X = int32(count)
        theString := fmt.Sprintf(""%d"", count)
        copy(message.RestOfMessage[:], theString)

        // binary write directly to socket
        fmt.Printf(""LISTENER %d: binary.Write this: %d, %s\n"", count, message.X, message.RestOfMessage)

        f.Sync()
        err = binary.Write(conn, binary.LittleEndian, message)

        f.Sync()
        fmt.Printf(""LISTENER %d: written\n"", count)
        // time.Sleep(50 * time.Millisecond)
        checkError(err, ""LISTENER"")

        count = count + 1
    }
}

func main() {
    var myMessage TheMessageType
    var ln net.Listener
    var conn net.Conn
    var err error
    var theCount int
    var avgspeed, speed float64
    var speedlist [10]float64

    curspeed := 0

    const listenerActive = true
    const mainActive = false

    f, err := os.Create(""theFile.out"")
    trace.Start(f)

    t0 := time.Now()
    t1 := time.Now()

    transferSize := unsafe.Sizeof(myMessage)

    fmt.Printf(""MAIN: timestamp %s ; size of transfers is %d\n"", t0.String(), transferSize)

    if mainActive {
        fmt.Println(""MAIN: listen"")
        ln, err = net.Listen(""tcp"", "":49152"")
        fmt.Println(""MAIN: defer"")
        defer ln.Close()
        fmt.Println(""MAIN: checkError"")
        checkError(err, ""MAIN"")
    }

    // launch listener
    if listenerActive {
        go listener(theCount, listenerActive, f)
    }

    for theCount = 1; ; theCount++ {

        if mainActive {
            fmt.Println(""MAIN: accept"")
            conn, err = ln.Accept()
            checkError(err, ""MAIN"")

            exit := false

            for !exit {
                // Set deadline
                // conn.SetDeadline(time.Now().Add(2 * time.Second))

                // Print some info
                fmt.Printf(""MAIN: reading on %v from %v\n"", conn.LocalAddr(), conn.RemoteAddr())

                // move time
                t0 = t1

                // read from socket
                fmt.Println(""MAIN: reader"")

                f.Sync()
                err = binary.Read(conn, binary.LittleEndian, &myMessage)

                f.Sync()
                if err == io.EOF {
                    fmt.Println(""EOF!"")
                    exit = true
                    conn.Close()
                } else {
                    checkError(err, ""MAIN"")
                }

                // clear screen
                c := exec.Command(""clear"")
                c.Stdout = os.Stdout
                c.Run()

                // print received data
                fmt.Printf(""MAIN: socket message received: %d, %s\n"", myMessage.X, myMessage.RestOfMessage)

                // calculate speed & average
                t1 = time.Now()
                tdif := t1.Sub(t0)
                speed = float64(transferSize) / tdif.Seconds() / 1000000.0 * 8.0
                speedlist[curspeed] = speed
                curspeed = curspeed + 1
                if curspeed == 10 {
                    curspeed = 0
                }
                totalspeed := 0.0
                for i := 0; i < 10; i++ {
                    totalspeed += speedlist[i]
                }
                avgspeed = totalspeed / 10

                // print speed
                fmt.Printf(""MAIN: avg mbit/s %9.2f ; actual mbit/s: %9.2f\n"", avgspeed, speed)
                // time.Sleep(1 * time.Second)
            }
        }
    }
}

func checkError(err error, name string) {
    if err != nil {
        fmt.Fprintf(os.Stderr, ""%s: Fatal error: %s\n"", name, err.Error())
        //      panic(fmt.Sprintf(""%v"", err.Error()))
        os.Exit(1)
    }
}",4757
32501784,576,"func cities(w http.ResponseWriter, r *http.Request, _ httprouter.Params) error {
    var main string
    var secondary string
    var limit string
    queryParams := make(map[string]interface{})

    if k := r.PostFormValue(""keyword""); k != """" {
        main = ""city.name LIKE :keyword""
        queryParams[""keyword""] = k + ""%""
    }

    if sk := r.PostFormValue(""secondaryKeyword""); sk != """" && sk != ""null"" {
        secondary = ""OR city.name = :secondaryKeyword""
        queryParams[""secondaryKeyword""] = sk
    }

    if mr := r.PostFormValue(""maxResults""); mr != """" {
        limit = ""LIMIT :maxResults""
        queryParams[""maxResults""] = mr
    }

    if lr := r.PostFormValue(""lastRequest""); lr != """" && lr == ""1"" {
        limit = """"
    }

    query := fmt.Sprintf(`
        SELECT
            city.geonameid AS cityId,
            city.name AS cityName,
            COALESCE(admin1.name_local, '') AS admin1Name,
            country.name AS countryName,
            CONCAT_WS(' ', city.name, city.asciiname, country.name) AS searchString
        FROM geonames_cities1000 AS city
            INNER JOIN geonames_countryinfo AS country
                ON city.iso_alpha2 = country.iso_alpha2
            LEFT OUTER JOIN geonames_admin1_codes_ascii as admin1
                ON admin1.code = CONCAT(city.iso_alpha2, '.', city.admin1_code)
        WHERE %s %s
        ORDER BY city.name ASC %s;
    `, main, secondary, limit)

    nstmt, err := sql.DB.PrepareNamed(query)
    if err != nil {
        return err
    }

    rows, err := nstmt.Queryx(queryParams)
    if err != nil {
        return err
    }

    results := []interface{}{}

    for rows.Next() {
        row := make(map[string]interface{})
        err := rows.MapScan(row)
        if err != nil {
            return err
        }
        results = append(results, row)
    }

    b, err := json.Marshal(results)
    if err != nil {
        return err
    }
    w.Write(b)
    return nil
}",1962
32676227,590,"package main

import (
    ""bytes""
    ""database/sql""
    ""encoding/json""
    ""fmt""
    ""log""
    ""strconv""
    ""strings""
    ""time""

    _ ""github.com/go-sql-driver/mysql""
)

const dbformat = ""2006-01-02 15:04:05""

type MysqlReceipt struct {
    Id               int
    Amount           sql.NullFloat64
    Cc_last4         sql.NullString
    Employee_id      sql.NullString
    Employee_name    sql.NullString
    Is_test          byte
    Menu_items       sql.NullString
    Payable          sql.NullFloat64
    Pos_type         sql.NullString
    Pos_version      sql.NullString
    Punchh_key       string
    Receipt_datetime sql.NullString
    Subtotal_amount  sql.NullFloat64
    Transaction_no   sql.NullString
    Business_id      int
    Location_id      int
    Created_at       string
    Updated_at       sql.NullString
    Revenue_code     sql.NullString
    Revenue_id       sql.NullString
    Status           sql.NullString
    Ipv4_addr        sql.NullString
}

type Menu_item struct {
    id, name, family, major_group, item_type string
    qty                                      int
    amount                                   float64
}

type BigReceipt struct {
    Id                       int
    Amount                   float64
    Cc_last4                 string
    Employee_id              string `json:"",omitempty""`
    Employee_name            string `json:"",omitempty""`
    Is_test                  byte
    Menu_item_name           string
    Menu_item_id             string
    Menu_item_amount         float64
    Menu_item_family         string
    Menu_item_major_group    string
    Menu_item_type           string
    Menu_item_qty            int
    Payable                  float64
    Pos_type                 string `json:"",omitempty""`
    Pos_version              string `json:"",omitempty""`
    Punchh_key               string
    Receipt_datetime         string
    Subtotal_amount          float64
    Transaction_no           string `json:"",omitempty""`
    Business_id, Location_id int
    Created_at               time.Time
    Updated_at               time.Time `json:"",omitempty""`
    Revenue_code             string    `json:"",omitempty""`
    Revenue_id               string    `json:"",omitempty""`
    Status                   string    `json:"",omitempty""`
    Ipv4_addr                string    `json:"",omitempty""`
    Stored_at                int64
}

func (m Menu_item) ValidItem() bool {
    if m.item_type == ""M"" || m.item_type == ""D"" {
        return true
    } else {
        return false
    }
}

func main() {
    db, err := sql.Open(""mysql"", ""root:password@tcp(xxxxxxx.us-east-1.rds.amazonaws.com:3306)/db_name_goes_here"")
    if err != nil {
        log.Fatal(err)
    }
    err = db.Ping()
    if err != nil {
        log.Fatal(err)
    }
    defer db.Close()
    rows, err := db.Query(`select id,amount,cc_last4,employee_id,employee_name,is_test,menu_items,payable,pos_type,
    pos_version,punchh_key,receipt_datetime,subtotal_amount,transaction_no,business_id,location_id,created_at,
    updated_at,revenue_code,revenue_id,status,ipv4_addr from receipts`)
    if err != nil {
        log.Fatal(err)
    }
    defer rows.Close()
    for rows.Next() {
        var mr MysqlReceipt
        err = rows.Scan(&mr.Id, &mr.Amount, &mr.Cc_last4, &mr.Employee_id, &mr.Employee_name, &mr.Is_test, &mr.Menu_items,
            &mr.Payable, &mr.Pos_type, &mr.Pos_version, &mr.Punchh_key, &mr.Receipt_datetime, &mr.Subtotal_amount, &mr.Transaction_no,
            &mr.Business_id, &mr.Location_id, &mr.Created_at, &mr.Updated_at, &mr.Revenue_code, &mr.Revenue_id, &mr.Status, &mr.Ipv4_addr)
        if err != nil {
            log.Fatal(err)
        }
        if !mr.Menu_items.Valid {
            continue
        }
        r := BigReceipt{Id: mr.Id,
            Amount:           mr.Amount.Float64,
            Cc_last4:         mr.Cc_last4.String,
            Employee_id:      mr.Employee_id.String,
            Employee_name:    mr.Employee_name.String,
            Is_test:          mr.Is_test,
            Payable:          mr.Payable.Float64,
            Pos_type:         mr.Pos_type.String,
            Pos_version:      mr.Pos_version.String,
            Punchh_key:       mr.Punchh_key,
            Receipt_datetime: mr.Receipt_datetime.String,
            Subtotal_amount:  mr.Subtotal_amount.Float64,
            Transaction_no:   mr.Transaction_no.String,
            Business_id:      mr.Business_id,
            Location_id:      mr.Location_id,
            Revenue_code:     mr.Revenue_code.String,
            Revenue_id:       mr.Revenue_id.String,
            Status:           mr.Status.String,
            Ipv4_addr:        mr.Ipv4_addr.String,
            Stored_at:        time.Now().Unix(),
        }
        r.Created_at = datetimeParse(mr.Created_at)
        if mr.Updated_at.Valid {
            r.Updated_at = datetimeParse(mr.Updated_at.String)
        }
        menuItems := strings.Split(mr.Menu_items.String, ""^"")
        items := parseMenuItems(menuItems)
        for _, v := range items {
            r.Menu_item_name = v.name
            r.Menu_item_id = v.id
            r.Menu_item_amount = v.amount
            r.Menu_item_family = v.family
            r.Menu_item_major_group = v.major_group
            r.Menu_item_type = v.item_type
            r.Menu_item_qty = v.qty
            b, err := json.Marshal(r)
            if err != nil {
                log.Fatal(err)
            }
            fmt.Println(r.Id)
            var out bytes.Buffer
            json.Compact(&out, b)
            fmt.Println(string(b))
        }
    }
    err = rows.Err()
    if err != nil {
        log.Fatal(err)
    }
}

func datetimeParse(dateStr string) time.Time {
    datetime, err := time.Parse(dbformat, dateStr)
    if err != nil {
        log.Fatal(err)
    }
    return datetime
}

func parseMenuItems(menuItems []string) []Menu_item {
    var items []Menu_item
    var item Menu_item
    for _, v := range menuItems {
        itemParts := strings.Split(v, ""|"")

        item.name = itemParts[0]
        item.qty, _ = strconv.Atoi(itemParts[1])
        item.amount, _ = strconv.ParseFloat(itemParts[2], 64)
        item.item_type = strings.ToUpper(itemParts[3])
        item.id = itemParts[4]
        item.family = itemParts[5]
        item.major_group = itemParts[6]
        if item.ValidItem() {
            items = append(items, item)
        } else {
            continue
        }
    }
    return items
}",6496
33371270,616,"package main


import (  
    ""fmt""
    ""strconv""
)


const (
    encodePath encoding = 1 + iota
    encodeHost
    encodeUserPassword
    encodeQueryComponent
    encodeFragment
)

type encoding int
type EscapeError string

func (e EscapeError) Error() string {
    return ""invalid URL escape "" + strconv.Quote(string(e))
}


func ishex(c byte) bool {
    switch {
    case '0' <= c && c <= '9':
        return true
    case 'a' <= c && c <= 'f':
        return true
    case 'A' <= c && c <= 'F':
        return true
    }
    return false
}

func unhex(c byte) byte {
    switch {
    case '0' <= c && c <= '9':
        return c - '0'
    case 'a' <= c && c <= 'f':
        return c - 'a' + 10
    case 'A' <= c && c <= 'F':
        return c - 'A' + 10
    }
    return 0
}



// Return true if the specified character should be escaped when
// appearing in a URL string, according to RFC 3986.
//
// Please be informed that for now shouldEscape does not check all
// reserved characters correctly. See golang.org/issue/5684.
func shouldEscape(c byte, mode encoding) bool {
    // §2.3 Unreserved characters (alphanum)
    if 'A' <= c && c <= 'Z' || 'a' <= c && c <= 'z' || '0' <= c && c <= '9' {
        return false
    }

    if mode == encodeHost {
        // §3.2.2 Host allows
        //  sub-delims = ""!"" / ""$"" / ""&"" / ""'"" / ""("" / "")"" / ""*"" / ""+"" / "","" / "";"" / ""=""
        // as part of reg-name.
        // We add : because we include :port as part of host.
        // We add [ ] because we include [ipv6]:port as part of host
        switch c {
        case '!', '$', '&', '\'', '(', ')', '*', '+', ',', ';', '=', ':', '[', ']':
            return false
        }
    }

    switch c {
    case '-', '_', '.', '~': // §2.3 Unreserved characters (mark)
        return false

    case '$', '&', '+', ',', '/', ':', ';', '=', '?', '@': // §2.2 Reserved characters (reserved)
        // Different sections of the URL allow a few of
        // the reserved characters to appear unescaped.
        switch mode {
        case encodePath: // §3.3
            // The RFC allows : @ & = + $ but saves / ; , for assigning
            // meaning to individual path segments. This package
            // only manipulates the path as a whole, so we allow those
            // last two as well. That leaves only ? to escape.
            return c == '?'

        case encodeUserPassword: // §3.2.1
            // The RFC allows ';', ':', '&', '=', '+', '$', and ',' in
            // userinfo, so we must escape only '@', '/', and '?'.
            // The parsing of userinfo treats ':' as special so we must escape
            // that too.
            return c == '@' || c == '/' || c == '?' || c == ':'

        case encodeQueryComponent: // §3.4
            // The RFC reserves (so we must escape) everything.
            return true

        case encodeFragment: // §4.1
            // The RFC text is silent but the grammar allows
            // everything, so escape nothing.
            return false
        }
    }

    // Everything else must be escaped.
    return true
}




func escape(s string, mode encoding) string {
    spaceCount, hexCount := 0, 0
    for i := 0; i < len(s); i++ {
        c := s[i]
        if shouldEscape(c, mode) {
            if c == ' ' && mode == encodeQueryComponent {
                spaceCount++
            } else {
                hexCount++
            }
        }
    }

    if spaceCount == 0 && hexCount == 0 {
        return s
    }

    t := make([]byte, len(s)+2*hexCount)
    j := 0
    for i := 0; i < len(s); i++ {
        switch c := s[i]; {
        case c == ' ' && mode == encodeQueryComponent:
            t[j] = '+'
            j++
        case shouldEscape(c, mode):
            t[j] = '%'
            t[j+1] = ""0123456789ABCDEF""[c>>4]
            t[j+2] = ""0123456789ABCDEF""[c&15]
            j += 3
        default:
            t[j] = s[i]
            j++
        }
    }
    return string(t)
}


// unescape unescapes a string; the mode specifies
// which section of the URL string is being unescaped.
func unescape(s string, mode encoding) (string, error) {
    // Count %, check that they're well-formed.
    n := 0
    hasPlus := false
    for i := 0; i < len(s); {
        switch s[i] {
        case '%':
            n++
            if i+2 >= len(s) || !ishex(s[i+1]) || !ishex(s[i+2]) {
                s = s[i:]
                if len(s) > 3 {
                    s = s[:3]
                }
                return """", EscapeError(s)
            }
            i += 3
        case '+':
            hasPlus = mode == encodeQueryComponent
            i++
        default:
            i++
        }
    }

    if n == 0 && !hasPlus {
        return s, nil
    }

    t := make([]byte, len(s)-2*n)
    j := 0
    for i := 0; i < len(s); {
        switch s[i] {
        case '%':
            t[j] = unhex(s[i+1])<<4 | unhex(s[i+2])
            j++
            i += 3
        case '+':
            if mode == encodeQueryComponent {
                t[j] = ' '
            } else {
                t[j] = '+'
            }
            j++
            i++
        default:
            t[j] = s[i]
            j++
            i++
        }
    }
    return string(t), nil
}


func EncodeUriComponent(rawString string) string{
    return escape(rawString, encodeFragment)
}

func DecodeUriCompontent(encoded string) (string, error){
    return unescape(encoded, encodeQueryComponent)
}


// https://golang.org/src/net/url/url.go
// http://remove-line-numbers.ruurtjan.com/
func main() {
    // http://www.url-encode-decode.com/
    origin := ""äöüHel/lo world""
    encoded := EncodeUriComponent(origin)
    fmt.Println(encoded)

    s, _ := DecodeUriCompontent(encoded)
    fmt.Println(s)
}",5754
33445908,618,"package main

import (""fmt""
    ""net/http""
    ""time""
    ""net"")

func main() {


    for i:=0; i<2000; i++ {
        start := time.Now()

         client := &http.Client{} // this enough for the program to crash
        /*client := &http.Client{
            Transport: &http.Transport{
                Dial: (&net.Dialer{
                    Timeout:   1 * time.Second,
                    KeepAlive: 0,
                }).Dial,
                DisableKeepAlives: true,
                DisableCompression: true,
                MaxIdleConnsPerHost: 1,
                ResponseHeaderTimeout: 1*time.Second,
            },
        }*/

        req, _ := http.NewRequest(""GET"", ""http://mickle.com.au/wp-content/uploads/2015/03/11222.jpg"", nil)
        req.Header.Add(""Connection"", ""close"")
        req.Header.Add(""Accept-Encoding"", ""none"")

        response, _ := client.Do(req)
        fmt.Printf(""httpreq took %s. resp status: %s\n"", time.Since(start), response.Status)
        response.Body.Close()
    }
}",1008
33872157,625,len(),5
33988192,652,"// mysqlSSHtunnel project main.go
// Establish an ssh tunnel and connect to a remote mysql server using
// go-sql-driver for database queries. Encrypted private key pem files
// are supported.
//
// This is an example to give an idea. It's far from a performant solution. It 
// lacks of proper error handling and I'm sure it could really be much better 
// implemented. Please forgive me, as I just started with Go about 2 weeks ago.
//
// The database used in this example is from a real Opensimulator installation.
// It queries the migrations table in the opensim database.
//
package main

import (
    ""database/sql""
    ""fmt""
    _ ""github.com/go-sql-driver/mysql""
    ""os""
)

// Declare your connection data and user credentials here
const (
    // ssh connection related data
    sshServerHost     = ""test.example.com""
    sshServerPort     = 22
    sshUserName       = ""tester""
    sshPrivateKeyFile = ""testkey.pem"" // exported as OpenSSH key from .ppk
    sshKeyPassphrase  = ""testoster0n"" // key file encrytion password

    // ssh tunneling related data
    sshLocalHost  = ""localhost"" // local localhost ip (client side)
    sshLocalPort  = 9000        // local port used to forward the connection
    sshRemoteHost = ""127.0.0.1"" // remote local ip (server side)
    sshRemotePort = 3306        // remote MySQL port

    // MySQL access data
    mySqlUsername = ""opensim""
    mySqlPassword = ""h0tgrits""
    mySqlDatabase = ""opensimdb""
)

// The main entry point of the application
func main() {
    fmt.Println(""-> mysqlSSHtunnel"")

    tunnel := sshTunnel() // Initialize sshTunnel
    go tunnel.Start()     // Start the sshTunnel

    // Declare the dsn (aka database connection string)
    // dsn := ""opensim:h0tgrits@tcp(localhost:9000)/opensimdb""
    dsn := fmt.Sprintf(""%s:%s@tcp(%s:%d)/%s"",
        mySqlUsername, mySqlPassword, sshLocalHost, sshLocalPort, mySqlDatabase)

    // Open the database
    db, err := sql.Open(""mysql"", dsn)
    if err != nil {
        dbErrorHandler(err)
    }
    defer db.Close() // keep it open until we are finished

    // Simple select query to check migrations (provided here as an example)
    rows, err := db.Query(""SELECT * FROM migrations"")
    if err != nil {
        dbErrorHandler(err)
    }
    defer rows.Close()

    // Iterate though the rows returned and print them
    for rows.Next() {
        var version int
        var name string
        if err := rows.Scan(&name, &version); err != nil {
            dbErrorHandler(err)
        }
        fmt.Printf(""%s, %d\n"", name, version)
    }
    if err := rows.Err(); err != nil {
        dbErrorHandler(err)
    }

    // Done for now
    fmt.Println(""<- mysqlSSHtunnel"")
}

// Simple mySql error handling (yet to implement)
func dbErrorHandler(err error) {
    switch err := err.(type) {
    default:
        fmt.Printf(""Error %s\n"", err)
        os.Exit(-1)
    }
}",2885
34061783,654,"func (p *PartialParty) SendReadyCheck(party PartialParty) {
    msg, err := json.Marshal(&ReadyCheckMsg{""ReadyCheck"", """"})
    if err != nil {
        log.Println(err)
    }

    for _, member := range party.Members {
        member.Conn.send <- msg
    }

    counter := 0
    loopBreaker := true
    for {
        select {
        case <-p.Accept:
            counter++
            resp, err := json.Marshal(&ReadyCheckMsg{""ReadyAccepted"", """"})
            if err != nil {
                log.Println(err)
            }
            for _, member := range party.Members {
                member.Conn.send <- resp
            }
            if counter == 2 {
                // Create a new party with all members
                partyid := PartyID(feeds.NewUUID().String())
                db := common.Db()
                newParty := &Party{
                    Active:    true,
                    Members:   p.Members,
                    Broadcast: make(chan []byte),
                    PartyID:   partyid,
                }

                // Insert the new party into the database
                _, err := db.Exec(""INSERT INTO party SET party_id = ?, active = ?"", partyid.String(), true)
                if err != nil {
                    log.Println(err)
                }

                // Go through the members and update the database
                var wg sync.WaitGroup

                for _, member := range party.Members {
                    wg.Add(1)
                    m := member
                    go func() {
                        _, err := db.Exec(""UPDATE party_members SET active = ? WHERE steamid = ?"", false, m.SteamID)
                        if err != nil {
                            log.Println(err)
                        }
                        _, err = db.Exec(""INSERT INTO party_members SET belongs_to =?, active = ?, steamid = ?"", partyid.String(), true, m.SteamID)
                        if err != nil {
                            log.Println(err)
                        }
                        wg.Done()
                    }()
                }

                // Wait for all the database stuff to finish
                wg.Wait()
                PHub.AddNewParty(newParty)
                loopBreaker = false
                break
            }
        case conn := <-p.Decline:
            if conn.Ready {
                break
            }
            conn.Ready = false
            conn.InQueue = false
            conn.CurrentParty = """"
            resp, err := json.Marshal(&ReadyCheckMsg{""ReadyCheckDeclined"", """"})
            if err != nil {
                log.Println(err)
            }
            p.Accepting = true
            identifier := conn.Identifier
            if _, ok := party.Members[identifier]; ok {
                delete(p.Members, identifier)
            }
            for _, m := range party.Members {
                member := m
                member.Conn.send <- resp
            }
            log.Println(""Here"")
            loopBreaker = false
            break
        case <-time.After(30 * time.Second):
            if counter == 2 {
                return
            }
            p.Accepting = true
            failedMsg, err := json.Marshal(&ReadyCheckMsg{""FailedToReady"", """"})
            if err != nil {
                log.Println(err)
            }
            somebodyDeclinedMsg, err := json.Marshal(&ReadyCheckMsg{""ReadyCheckDeclined"", """"})
            if err != nil {
                log.Println(err)
            }


    >>>>     for _, member := range party.Members { ***<<<< This Line***
                m := member
                if !m.Conn.Ready {
                    m.Conn.Ready = false
                    m.Conn.InQueue = false
                    m.Conn.CurrentParty = """"
                    m.Conn.send <- failedMsg
                } else {
                    m.Conn.Ready = false
                    m.Conn.send <- somebodyDeclinedMsg
                }
            }
            loopBreaker = false
            break
        }
        if !loopBreaker {
            break
        }
    }
}",4113
34206809,679,"package main

import (
    ""fmt""
    ""io""
    ""net""
    ""time""
)

func main() {
    ln, err := net.Listen(""tcp"", "":9000"")
    if err != nil {
        panic(err)
    }
    defer ln.Close()

    for {
        conn, err := ln.Accept()
        if err != nil {
            panic(err)
        }

        io.WriteString(conn, fmt.Sprint(""Hello World\n"", time.Now(), ""\n""))

        conn.Close()
    }
}",396
34277857,684,"package euler

import ""testing""

func TestEulers(t *testing.T) {

    tests := map[string][]int{
        ""Euler1"": {Euler1(), 233168},
        ""Euler2"": {Euler2(), 4613732},
        ""Euler3"": {Euler3(), 6857},
        ""Euler4"": {Euler4(), 906609},
        ""Euler5"": {Euler5(), 232792560},
        ""Euler6"": {Euler6(), 25164150},
    }

    for key, value := range tests {
        if value[0] != value[1] {
            t.Errorf(""%s\nExpected: %d\nGot:%d"",
                key, value[0], value[1])
        }
    }
}",514
34498981,688,"const userName = ""xxxxxxxxxxxx""

func TestSynchroninze(t *testing.T) {
    c, err := channel.New(github.ChannelName, authToken)
    if err != nil {
        t.Fatalf(""Could not create channel: %s"", err)
        return
    }

    state := channel.NewState(nil)
    ctx := context.Background()
    ctx = context.WithValue(ctx, ""userId"", userName)
    user := api.User{}

    output, errs := c.Synchronize(state, ctx)

    if err = <-errs; err != nil {
        t.Fatalf(""Error performing synchronize: %s"", err)
        return
    }

    for o := range output {
        switch oo := o.Data.(type) {
        case api.User:
            user = oo
            glog.Infof(""we have a USER %s\n"", user)
        default:
            t.Errorf(""Encountered unexpected data type: %T"", oo)
        }
    }
}
",791
34500527,701,"package main

import (
    ""bufio""
    _ ""bytes""
    ""fmt""
    _ ""io""
    ""log""
    ""os""
    ""os/user""
    ""path/filepath""
    _ ""reflect""
    ""regexp""
    ""runtime""
    ""strconv""
    ""strings""
    ""sync""
    ""time""

    ""github.com/aws/aws-sdk-go/aws""
    ""github.com/aws/aws-sdk-go/aws/session""
    ""github.com/aws/aws-sdk-go/service/s3""
    ""github.com/aws/aws-sdk-go/service/s3/s3manager""
)

var (
    LocalDirectory   = ""s3logs"" // Into this directory
    Lock             sync.Mutex
    totalImpressions int
)

var data = make(map[string]map[string]int)

func main() {
    start := time.Now()
    // by adding this line i'm telling the program to run the threads on 4 different cores at the same time, Parallelism!!
    //REMEMBER TO ADD BLOCKS TO STOP RACE CONDITIONS
    runtime.GOMAXPROCS(4)
    var wg sync.WaitGroup

    var year, month, day = time.Now().Date()
    str_year := strconv.Itoa(year)
    str_month := strconv.Itoa(int(month))
    str_day := strconv.Itoa(day)

    if int(month) < 10 {
        str_month = ""0"" + strconv.Itoa(int(month))
    }
    if day < 10 {
        str_day = ""0"" + strconv.Itoa(day)
    }

    regBuckets := map[string]string{
        ""us-west-1"": ""pubgears-ca"",
        ""test"":      ""test"",
    }

    for region, bucket := range regBuckets {
        prefix := fmt.Sprintf(""tagserver/logs/AWSLogs/978380792767/elasticloadbalancing/%s/%s/%s/%s/"", region, str_year, str_month, str_day)
        wg.Add(1)
        go getLogs(region, bucket, LocalDirectory+bucket, &prefix, &wg)
    }
    wg.Wait()

    //salon/t1/728x90/index
    //totalImpressions := 0
    // var provider = make(map[string]int)
    // for key, value := range data {
    //   key = strings.TrimSpace(key)
    //   pro := strings.Split(key, ""_"")[3]
    //
    //   if strings.Contains(pro, ""pp"") == true || (pro == ""pulsepoint"") || (pro == ""cweb"") {
    //     provider[""pulsepoint""] += value
    //   } else if (pro == ""openx"") || (pro == ""openx3"") {
    //     provider[""openx""] += value
    //   } else if key == "" "" {
    //     continue
    //   } else {
    //     provider[pro] += value
    //   }
    //   totalImpressions += value
    // }

    for tag, value := range data {
        for hour, imp := range value {
            fmt.Printf(""tag: %s  \n hour: %s impression %s\n"", tag, hour, imp)
        }
    }

    //sl = sl[:len(sl)-1]

    elapsed := time.Since(start)
    fmt.Printf(""\nTime took %s\n"", elapsed)

}

func getLogs(region string, bucket string, directory string, prefix *string, wg *sync.WaitGroup) {
    sess := session.New()
    client := s3.New(sess, &aws.Config{Region: aws.String(region)})

    params := &s3.ListObjectsInput{Bucket: &bucket, Prefix: prefix}
    manager := s3manager.NewDownloaderWithClient(client, func(d *s3manager.Downloader) {
        d.PartSize = 5 * 1024 * 1024 // 6MB per part
        d.Concurrency = 4
    })
    d := downloader{bucket: bucket, dir: directory, Downloader: manager}
    client.ListObjectsPages(params, d.eachPage)
    wg.Done()
}

// downloader object and methods
type downloader struct {
    *s3manager.Downloader
    bucket, dir string
}

func (d *downloader) eachPage(page *s3.ListObjectsOutput, more bool) bool {
    for _, obj := range page.Contents {
        // fmt.Println(obj)
        //     return true
        d.downloadToFile(*obj.Key)
    }
    return true
}

func (d *downloader) downloadToFile(key string) {
    // Create the directories in the path
    // desktop path
    user, errs := user.Current()
    if errs != nil {
        panic(errs)
    }
    homedir := user.HomeDir
    desktop := homedir + ""/Desktop/"" + d.dir
    file := filepath.Join(desktop, key)
    if err := os.MkdirAll(filepath.Dir(file), 0775); err != nil {
        panic(err)
    }

    // Setup the local file
    fd, err := os.Create(file)
    if err != nil {
        panic(err)
    }
    defer fd.Close()

    // Download the file using the AWS SDK
    //fmt.Printf(""Downloading s3://%s/%s to %s...\n"", d.bucket, key, file)
    params := &s3.GetObjectInput{Bucket: &d.bucket, Key: &key}
    d.Download(fd, params)
    _, e := d.Download(fd, params)
    if e != nil {
        panic(e)
    }

    f, err := os.Open(file)
    if err != nil {
        log.Fatal(err)
    }
    defer f.Close()

    tag := regexp.MustCompile(""/([a-zA-Z0-9_]+/{1}[a-zA-Z0-9_]+/{1}[a-zA-Z0-9_]+/{1}[a-zA-Z0-9_]+)"")
    date := regexp.MustCompile(""T([^:]+)"")
    scanner := bufio.NewScanner(f)

    // HAVING TROUBLE HERE
    for scanner.Scan() {
        //dateCollection := make(map[string]int)
        m := tag.FindString(scanner.Text())
        if m != """" {
            // stop races
            Lock.Lock()
            arr := strings.Split(m, ""/"")
            taghash := strings.Join(arr, ""_"")
            taghash = strings.TrimLeft(taghash, ""_"")
            //data[taghash]++
            m = date.FindString(scanner.Text())
            if m != """" {
                hour := m
                data[taghash] = make(map[string]int)
                data[taghash][hour]++
            }
            Lock.Unlock()
        }
    }
    fmt.Println(file)
    os.Remove(file)
    if err := scanner.Err(); err != nil {
        log.Fatal(err)
    }
}",5185
34787709,710,"package main

 import (
   ""os""
   ""flag""
   ""fmt""
   ""io""
   ""path/filepath""
   ""os/exec""
   ""archive/zip""
   ""time""
 )

func RemoveContents(dir string) error {
    d, err := os.Open(dir)
    if err != nil {
        return err
    }
    names, err := d.Readdirnames(-1)
    if err != nil {
        return err
    }
    for _, name := range names { 
            err = os.RemoveAll(filepath.Join(dir, name))
            if err != nil {
                return err
            }
    }
    d.Close()
    return nil
}


func CopyFile(source string, dest string) (err error) {
     sourcefile, err := os.Open(source)
     if err != nil {
         return err
     }

     defer sourcefile.Close()

     destfile, err := os.Create(dest)
     if err != nil {
         return err
     }

     defer destfile.Close()

     _, err = io.Copy(destfile, sourcefile)
     if err == nil {
         sourceinfo, err := os.Stat(source)
         if err != nil {
             err = os.Chmod(dest, sourceinfo.Mode())
         }

     }

     return
 }

 func CopyDir(source string, dest string) (err error) {

     // get properties of source dir
     sourceinfo, err := os.Stat(source)
     if err != nil {
         return err
     }

     // create dest dir

     err = os.MkdirAll(dest, sourceinfo.Mode())
     if err != nil {
         return err
     }

     directory, _ := os.Open(source)

     objects, err := directory.Readdir(-1)

     for _, obj := range objects {

         sourcefilepointer := source + ""/"" + obj.Name()

         destinationfilepointer := dest + ""/"" + obj.Name()


         if obj.IsDir() {
             // create sub-directories - recursively
             err = CopyDir(sourcefilepointer, destinationfilepointer)
             if err != nil {
                 fmt.Println(err)
             }
         } else {
             // perform copy
             err = CopyFile(sourcefilepointer, destinationfilepointer)
             if err != nil {
                 fmt.Println(err)
             }
         }

     }
     return
 }




 func main() {
    flag.Parse() // get the source and destination directory

    source_dir := flag.Arg(0) // get the source directory from 1st argument

    dest_dir := flag.Arg(1) // get the destination directory from the 2nd argument

        os.MkdirAll(""E:\\go\\copyDirectory\\myFile.zip"",0777)
    zipFilePath := ""E:\\go\\copyDirectory\\myFile.zip""
    tempWrkDir := ""E:\\go\\copyDirectory\\""

    //Read zip file and get path handle.
    fileHandleReader, err := zip.OpenReader(zipFilePath)
    if err != nil {
        fmt.Println(err)
        os.Exit(1)
    }
    //open zip file and read all the folder and files inside
    for _, fileReadHandler := range fileHandleReader.Reader.File {
        //read the file or folder handle inside zip
        fileOpenHandle, err := fileReadHandler.Open()
        if err != nil {
            fmt.Println(err)
            os.Exit(1)
        }
        defer fileOpenHandle.Close()
    targetUnZipPath := filepath.Join(tempWrkDir, fileReadHandler.Name)
    if fileReadHandler.FileInfo().IsDir() {
            os.MkdirAll(targetUnZipPath, fileReadHandler.Mode())
            //fmt.Println(""Creating directory"", path)
        }else {
            // create new dummy file to copy original file.
            newTempFileHandle, err := os.OpenFile(targetUnZipPath, os.O_WRONLY|os.O_CREATE, fileReadHandler.Mode())

            if err != nil {
                fmt.Println(err)
                os.Exit(1)
            }

            defer newTempFileHandle.Close()
            //copying original file to dummy file.
            if _, err = io.Copy(newTempFileHandle, fileOpenHandle); err != nil {
                fmt.Println(err)
                os.Exit(1)
            }
        }
    }
      time.Sleep(1000*time.Millisecond)

      fmt.Println(""Source :"" + source_dir)

      // check if the source dir exist
      src, err := os.Stat(source_dir)
     if err != nil {
       panic(err)
    }

     if !src.IsDir() {
       fmt.Println(""Source is not a directory"")
       os.Exit(1)
    }

   // create the destination directory
   fmt.Println(""Destination :""+ dest_dir)

   /*_, err = os.Open(dest_dir)
   if !os.IsNotExist(err) {
     fmt.Println(""Destination directory already exists. Abort!"")
     os.Exit(1)
   }*/

   err = CopyDir(source_dir, dest_dir)
   if err != nil {
      fmt.Println(err)
   } else {
      fmt.Println(""Directory copied"")
   }
    err = RemoveContents(""./myFiles"")
       if err != nil {
        fmt.Println(""ERRR:::"",err)
       }
    //time.Sleep(10000*time.Millisecond)
 }",4573
35163475,715,"package main

import (
    ""fmt""
    ""math""
    ""runtime""
    ""testing""
    ""time""
)

var (
    f  float64
    e  float64 = math.E
    pi float64 = math.Pi
)

const nFlop = 20 // benchmarkFloatOps

func benchmarkFloatOps(n int) {
    for i := 0; i < n; i++ {
        f = pi + e
        f = pi - e
        f = pi * e
        f = pi / e
        f = pi + e
        f = pi - e
        f = pi * e
        f = pi / e
        f = pi + e
        f = pi - e
        f = pi * e
        f = pi / e
        f = pi + e
        f = pi - e
        f = pi * e
        f = pi / e
        f = pi + e
        f = pi - e
        f = pi * e
        f = pi / e
    }
}

func BenchmarkFloatOps(b *testing.B) {
    benchmarkFloatOps(b.N)
}

func Results(t time.Duration, n int, nFlop int) {
    fmt.Println(
        t, nFlop*n, ""ops"",
        float64(t)/float64(time.Duration((nFlop*n))), ""ns/op"",
    )
}

func main() {
    runtime.GOMAXPROCS(1)

    // testing benchmark
    br := testing.Benchmark(BenchmarkFloatOps)
    Results(br.T, br.N, nFlop)

    // manual benchmark
    n := br.N
    start := time.Now()
    benchmarkFloatOps(n)
    end := time.Now()
    elapsed := end.Sub(start)
    Results(elapsed, n, nFlop)
}",1200
35202961,721,"package main

import (
    ""encoding/json""
    ""fmt""
)

type PublicKey struct {
    name string
    price string
}

type KeysResponse struct {
    Collection []PublicKey
}

func main() {
    s := `[{""name"":""Galaxy Nexus"", ""price"":""3460.00""},{""name"":""Galaxy Nexus"", ""price"":""3460.00""}]`

    keys := make([]PublicKey,0)
    err := json.Unmarshal([]byte(s), &keys)
    if err == nil {
        fmt.Printf(""%+v\n"", keys)
    } else {
        fmt.Println(err)
        fmt.Printf(""%+v\n"", keys)
    }
}",497
35328272,730,"if monday == 0 {
            fmt.Println(0)
            printRecipeOfTheDay(recipe1)
        } else if monday == 1 {
            fmt.Println(1)",152
35329276,732,"package main

import (
    ""log""
    ""strconv""
    ""time""
)

// RowInfo holds the job info
type RowInfo struct {
    id int
}

// WorkerCount holds how many workers are currently running
var WorkerCount int

// WorkerLocked specifies whether a row ID is currently processing by a worker
var WorkerLocked map[string]bool

// Process the RowInfo
func worker(row RowInfo) {
    rowID := strconv.Itoa(row.id)

    WorkerCount++
    WorkerLocked[rowID] = true

    time.Sleep(1 * time.Second)
    log.Printf(""ID rcvd: %d"", row.id)

    WorkerLocked[rowID] = false
    WorkerCount--
}

// waiter will check if the row is already processing in a worker
// Block until it finishes completion, then dispatch
func waiter(row RowInfo) {
    rowID := strconv.Itoa(row.id)
    for WorkerLocked[rowID] == true {
        time.Sleep(1 * time.Second)
    }

    go worker(row)
}

func main() {
    jobsQueue := make(chan RowInfo, 10)
    WorkerLocked = make(map[string]bool)

    // Dispatcher waits for jobs on the channel and dispatches to waiter
    go func() {
        // Wait for a job
        for {
            // Only have a max of 3 workers running asynch at a time
            for WorkerCount > 3 {
                time.Sleep(1 * time.Second)
            }

            job := <-jobsQueue
            go waiter(job)
        }
    }()

    // Test the queue, send some data
    for i := 0; i < 12; i++ {
        r := RowInfo{
            id: i,
        }
        jobsQueue <- r
    }

    // Prevent exit!
    for {
        time.Sleep(1 * time.Second)
    }
}",1551
35332794,734,"package main

import (
    ""fmt""
    ""math/rand""
    ""time""
)

//Struct for Recipe below
type Recipe struct { //Struct for recipe information
    name        string
    prepTime    int
    cookTime    int
    Ingredients []string //this is now a slice that will accept multiple elements
    ID          int
    Yield       int
}

//main method
func main() {
    //5 variables below for 5 recipes for Monday-Friday
    var recipe1 Recipe //Declare recipe1 of Type Recipe
    var recipe2 Recipe
    var recipe3 Recipe
    var recipe4 Recipe
    var recipe5 Recipe

    //choose random number for recipe
    r := rand.New(rand.NewSource(time.Now().UnixNano()))
    i := r.Perm(5)
    fmt.Printf(""%v\n"", i)
    fmt.Printf(""%d\n"", i[0])
    fmt.Printf(""%d\n"", i[1])

    //assign slices of int from Perm to variables assigned days of the week
    var monday = i[0]
    var tuesday = i[1]
    var wednesday = i[2]
    var thursday = i[3]
    var friday = i[4]

    //testing printing of variables assigned to days
    fmt.Printf(""This is for the day Monday %d\n"", monday)
    fmt.Printf(""This is for the day Tuesday %d\n"", tuesday)
    fmt.Printf(""This is for the day Wednesday %d\n"", wednesday)
    fmt.Printf(""This is for the day Thursday %d\n"", thursday)
    fmt.Printf(""This is for the day Friday %d\n"", friday)

    /* recipe1 specifications */
    recipe1.name = ""BBQ Pulled Chicken""
    recipe1.prepTime = 25
    recipe1.cookTime = 5
    recipe1.Ingredients = append(
        recipe1.Ingredients,
        ""1 8-ounce can reduced-sodium tomato sauce"",
    )
    recipe1.Ingredients = append(
        recipe1.Ingredients,
        ""1/2 medium onion (grated),"",
    )
    recipe1.ID = 1
    recipe1.Yield = 8

    /* Recipe 2 specifications */

    recipe2.name = ""Steak Tacos with Pineapple""
    recipe2.prepTime = 45
    recipe2.cookTime = 45
    recipe2.Ingredients = append(
        recipe2.Ingredients,
        ""3 tablespoons soy sauce,"",
    )
    recipe2.Ingredients = append(
        recipe2.Ingredients,
        ""1 tablespoon finely grated garlic,"",
    )
    recipe2.Ingredients = append(
        recipe2.Ingredients,
        ""1 tablespoon finely grated peeled fresh ginger,"",
    )
    recipe2.Ingredients = append(
        recipe2.Ingredients,
        ""1 1/2 pounds skirt steak, cut into 5-inch lengths,"",
    )
    recipe2.Ingredients = append(
        recipe2.Ingredients,
        ""Salt"",
    )
    recipe2.Ingredients = append(
        recipe2.Ingredients,
        ""Pepper"",
    )
    recipe2.ID = 2
    recipe2.Yield = 4

    recipe3.name = ""Simple Lemon Herb Chicken""
    recipe3.prepTime = 10
    recipe3.cookTime = 15
    recipe3.Ingredients = append(
        recipe3.Ingredients,
        ""2 skinless boneless chicken breast halves,"",
    )
    recipe3.Ingredients = append(
        recipe3.Ingredients,
        ""1 Lemon,"",
    )
    recipe3.Ingredients = append(
        recipe3.Ingredients,
        ""Salt and Pepper to taste,"",
    )
    recipe3.Ingredients = append(
        recipe3.Ingredients,
        ""1 tablespoon olive oil,"",
    )
    recipe3.Ingredients = append(
        recipe3.Ingredients,
        ""2 sprigs fresh parsley (for garnish),"",
    )
    recipe3.Ingredients = append(
        recipe3.Ingredients,
        ""1 pinch dried oregano,"",
    )
    recipe3.ID = 3
    recipe3.Yield = 2

    //recipe4 specifications
    recipe4.name = ""Easy Meatloaf""
    recipe4.prepTime = 10
    recipe4.cookTime = 60
    recipe4.Ingredients = append(
        recipe4.Ingredients,
        ""1 onion (chopped),"",
    )
    recipe4.Ingredients = append(
        recipe4.Ingredients,
        ""1 cup milk,"",
    )
    recipe4.Ingredients = append(
        recipe4.Ingredients,
        ""1 cup dried bread crumbs,"",
    )
    recipe4.ID = 4
    recipe4.Yield = 8

    //recipe 5 specifications
    recipe5.name = ""Fast Salmon with a Ginger Glaze""
    recipe5.prepTime = 5
    recipe5.cookTime = 20
    recipe5.Ingredients = append(
        recipe5.Ingredients,
        ""salt to taste,"",
    )
    recipe5.Ingredients = append(
        recipe5.Ingredients,
        ""1/3 cup cold water,"",
    )
    recipe5.Ingredients = append(
        recipe5.Ingredients,
        ""1/4 cup seasoned rice vinegar,"",
    )
    recipe5.ID = 5
    recipe5.Yield = 4

    //call to printRecipe function below
    printRecipe(recipe1)
    totalTime(recipe1)
    printRecipe(recipe2)
    totalTime(recipe2)
    printRecipe(recipe3)
    totalTime(recipe3)
    printRecipe(recipe4)
    totalTime(recipe4)
    printRecipe(recipe5)
    totalTime(recipe5)

    //logic for Mondays Recipe
    if monday == 0 {
        fmt.Println(0)
        printRecipeOfTheDay(recipe1)
    } else if monday == 1 {
        fmt.Println(1)
        printRecipeOfTheDay(recipe2)
    } else if monday == 2 {
        fmt.Println(2)
        printRecipeOfTheDay(recipe3)
    } else if monday == 3 {
        fmt.Println(3)
        printRecipeOfTheDay(recipe4)
    } else if monday == 4 {
        fmt.Println(4)
        printRecipeOfTheDay(recipe5)
    }

    //logic for Tuesdays Recipe
    if tuesday == 0 {
        fmt.Println(0)
        printRecipeOfTheDay(recipe1)
    } else if tuesday == 1 {
        fmt.Println(1)
        printRecipeOfTheDay(recipe2)
    } else if tuesday == 2 {
        fmt.Println(2)
        printRecipeOfTheDay(recipe3)
    } else if tuesday == 3 {
        fmt.Println(3)
        printRecipeOfTheDay(recipe4)
    } else if tuesday == 4 {
        fmt.Println(4)
        printRecipeOfTheDay(recipe5)
    }
}

//function to print Recipe
func printRecipe(recipe Recipe) {
    fmt.Printf(""Recipe Name : %s\n"", recipe.name)
    fmt.Printf(""Prep Time : %d\n"", recipe.prepTime)
    fmt.Printf(""Cook Time : %d\n"", recipe.cookTime)
    fmt.Printf(""Ingredients : %s\n"", recipe.Ingredients)
    fmt.Printf(""Recipe ID : %d\n"", recipe.ID)
}

//Returns total time by addings cookTime and prepTime
func totalTime(recipe Recipe) {
    fmt.Printf(""The total time for this recipe is %d\n"", recipe.cookTime+recipe.prepTime)
}

//function to print the winner for recipe of the day to use
//for either lunch or dinner
func printRecipeOfTheDay(recipe Recipe) {
    fmt.Printf(""The recipe of the day is : %s\n"", recipe.name)
}",6183
35452424,735,"package main

import (
    ""flag""
    ""fmt""
    ""github.com/goraft/raft""
    ""github.com/goraft/raftd/command""
    ""github.com/goraft/raftd/server""
    ""log""
    ""math/rand""
    ""os""
    ""time""
    ""strconv""
)

var verbose bool
var trace bool
var debug bool
var host string
var port int
var join string

func init() {
    flag.Parse()
    flag.BoolVar(&verbose, ""v"", false, ""verbose logging"")
    flag.BoolVar(&trace, ""trace"", false, ""Raft trace debugging"")
    flag.BoolVar(&debug, ""debug"", false, ""Raft debugging"")
    flag.StringVar(&host, ""h"", ""localhost"", ""hostname"")
    p,_:=strconv.Atoi(flag.Arg(1))
    flag.IntVar(&port, ""p"", p, ""port"")
    flag.StringVar(&join, ""join"", """", ""host:port of leader to join"")
    flag.Usage = func() {
        fmt.Fprintf(os.Stderr, ""Usage: %s [arguments]  \n"", os.Args[0])
        flag.PrintDefaults()
    }
}

func main() {
    log.SetFlags(0)
    flag.Parse()
    if verbose {
        log.Print(""Verbose logging enabled."")
    }
    if trace {
        raft.SetLogLevel(raft.Trace)
        log.Print(""Raft trace debugging enabled."")
    } else if debug {
        raft.SetLogLevel(raft.Debug)
        log.Print(""Raft debugging enabled."")
    }

    rand.Seed(time.Now().UnixNano())

    // Setup commands.
    raft.RegisterCommand(&command.WriteCommand{})

    // Set the data directory.
    if flag.NArg() == 0 {
        flag.Usage()
        log.Fatal(""Data path argument required"")
    }
    path := flag.Arg(0)
    if err := os.MkdirAll(path, 0744); err != nil {
        log.Fatalf(""Unable to create path: %v"", err)
    }

    log.SetFlags(log.LstdFlags)
    s := server.New(path, host, port)
    log.Fatal(s.ListenAndServe(""localhost:2001""))
    fmt.Println(""I am changing my status"");
}",1733
35655966,750,"// Package classification User API.
//
// the purpose of this application is to provide an application
// that is using plain go code to define an API
//
// This should demonstrate all the possible comment annotations
// that are available to turn go code into a fully compliant swagger 2.0 spec
//
// Terms Of Service:
//
// there are no TOS at this moment, use at your own risk we take no responsibility
//
//     Schemes: http, https
//     Host: localhost
//     BasePath: /v2
//     Version: 0.0.1
//     License: MIT http://opensource.org/licenses/MIT
//     Contact: John Doe http://john.doe.com
//
//     Consumes:
//     - application/json
//     - application/xml
//
//     Produces:
//     - application/json
//     - application/xml
//
//
// swagger:meta
package main
import (
 ""github.com/gin-gonic/gin""
 ""strconv""
 ""database/sql""
 _ ""github.com/go-sql-driver/mysql""
 ""gopkg.in/gorp.v1""
 ""log""
)

// swagger:model
// User represents the user for this application
//
// A user is the security principal for this application.
// It's also used as one of main axis for reporting.
//
// A user can have friends with whom they can share what they like.
//
type User struct {
    // the id for this user
    //
    // required: true
    // min: 1
    Id int64 `db:""id"" json:""id""`
    // the first name for this user
    // required: true
    // min length: 3
    Firstname string `db:""firstname"" json:""firstname""`
    // the last name for this user
    // required: true
    // min length: 3
    Lastname string `db:""lastname"" json:""lastname""`
}

func main() {
 r := gin.Default()
 r.Use(Cors())
 v1 := r.Group(""api/v1"")
 {
 v1.GET(""/users"", GetUsers)
 v1.GET(""/users/:id"", GetUser)
 v1.POST(""/users"", PostUser)
 v1.PUT(""/users/:id"", UpdateUser)
 v1.DELETE(""/users/:id"", DeleteUser)
 v1.OPTIONS(""/users"", OptionsUser)     // POST
 v1.OPTIONS(""/users/:id"", OptionsUser) // PUT, DELETE
 }
r.Run("":8696"")
}


func GetUsers(c *gin.Context) {
    // swagger:route GET /user listPets pets users
    //
    // Lists pets filtered by some parameters.
    //
    // This will show all available pets by default.
    // You can get the pets that are out of stock
    //
    //     Consumes:
    //     - application/json
    //     - application/x-protobuf
    //
    //     Produces:
    //     - application/json
    //     - application/x-protobuf
    //
    //     Schemes: http, https, ws, wss
    //
    //     Security:
    //       api_key:
    //       oauth: read, write
    //
    //     Responses:
    //       default: genericError
    //       200: someResponse
    //       422: validationError
     var users []User
     _, err := dbmap.Select(&users, ""SELECT * FROM user"")
    if err == nil {
     c.JSON(200, users)
     } else {
     c.JSON(404, gin.H{""error"": ""no user(s) into the table""})
 }
// curl -i http://localhost:8080/api/v1/users
}

func GetUser(c *gin.Context) {
 id := c.Params.ByName(""id"")
 var user User
 err := dbmap.SelectOne(&user, ""SELECT * FROM user WHERE id=?"", id)
if err == nil {
 user_id, _ := strconv.ParseInt(id, 0, 64)
content := &User{
 Id: user_id,
 Firstname: user.Firstname,
 Lastname: user.Lastname,
 }
 c.JSON(200, content)
 } else {
 c.JSON(404, gin.H{""error"": ""user not found""})
 }
// curl -i http://localhost:8080/api/v1/users/1
}

func PostUser(c *gin.Context) {
 var user User
 c.Bind(&user)
if user.Firstname != """" && user.Lastname != """" {
if insert, _ := dbmap.Exec(`INSERT INTO user (firstname, lastname) VALUES (?, ?)`, user.Firstname, user.Lastname); insert != nil {
 user_id, err := insert.LastInsertId()
 if err == nil {
 content := &User{
 Id: user_id,
 Firstname: user.Firstname,
 Lastname: user.Lastname,
 }
 c.JSON(201, content)
 } else {
 checkErr(err, ""Insert failed"")
 }
 }
} else {
 c.JSON(422, gin.H{""error"": ""fields are empty""})
 }
// curl -i -X POST -H ""Content-Type: application/json"" -d ""{ \""firstname\"": \""Thea\"", \""lastname\"": \""Queen\"" }"" http://localhost:8080/api/v1/users
}

func UpdateUser(c *gin.Context) {
 id := c.Params.ByName(""id"")
 var user User
 err := dbmap.SelectOne(&user, ""SELECT * FROM user WHERE id=?"", id)
if err == nil {
 var json User
 c.Bind(&json)
user_id, _ := strconv.ParseInt(id, 0, 64)
user := User{
 Id: user_id,
 Firstname: json.Firstname,
 Lastname: json.Lastname,
 }
if user.Firstname != """" && user.Lastname != """"{
 _, err = dbmap.Update(&user)
if err == nil {
 c.JSON(200, user)
 } else {
 checkErr(err, ""Updated failed"")
 }
} else {
 c.JSON(422, gin.H{""error"": ""fields are empty""})
 }
} else {
 c.JSON(404, gin.H{""error"": ""user not found""})
 }
// curl -i -X PUT -H ""Content-Type: application/json"" -d ""{ \""firstname\"": \""Thea\"", \""lastname\"": \""Merlyn\"" }"" http://localhost:8080/api/v1/users/1
}

func DeleteUser(c *gin.Context) {
 id := c.Params.ByName(""id"")
var user User
 err := dbmap.SelectOne(&user, ""SELECT id FROM user WHERE id=?"", id)
if err == nil {
 _, err = dbmap.Delete(&user)
if err == nil {
 c.JSON(200, gin.H{""id #"" + id: "" deleted""})
 } else {
 checkErr(err, ""Delete failed"")
 }
} else {
 c.JSON(404, gin.H{""error"": ""user not found""})
 }
// curl -i -X DELETE http://localhost:8080/api/v1/users/1
}

var dbmap = initDb()
func initDb() *gorp.DbMap {
 db, err := sql.Open(""mysql"",
        ""root:max_123@tcp(127.0.0.1:3306)/gotest"")
 checkErr(err, ""sql.Open failed"")
 dbmap := &gorp.DbMap{Db: db, Dialect:           gorp.MySQLDialect{""InnoDB"", ""UTF8""}}
 dbmap.AddTableWithName(User{}, ""User"").SetKeys(true, ""Id"")
 err = dbmap.CreateTablesIfNotExists()
 checkErr(err, ""Create table failed"")
return dbmap
}

func checkErr(err error, msg string) {
 if err != nil {
 log.Fatalln(msg, err)
 }
}


func Cors() gin.HandlerFunc {
 return func(c *gin.Context) {
 c.Writer.Header().Add(""Access-Control-Allow-Origin"", ""*"")
 c.Next()
 }
}

func OptionsUser(c *gin.Context) {
 c.Writer.Header().Add(""Access-Control-Allow-Origin"", ""*"")
 c.Writer.Header().Set(""Access-Control-Allow-Methods"", ""DELETE,POST, PUT"")
 c.Writer.Header().Set(""Access-Control-Allow-Headers"", ""Content-Type"")
 c.Next()
}",5999
36062878,796,"package main

    import (
            ""fmt""
            ""golang.org/x/net/websocket""
            ""log""
    )

    var url = ""ws://10.0.1.19:5000/data/websocket""

    func main() {
            ws, err := websocket.Dial(url, """", origin)
            if err != nil {
                    log.Fatal(err)
            }

            var msg = make([]byte, 512)
            _, err = ws.Read(msg)
            if err != nil {
                    log.Fatal(err)
            }
            fmt.Printf(""Receive: %s\n"", msg)
    }",523
36474438,805,"package main

import (
    ""fmt""
    ""io/ioutil""
    ""net/http""
    ""os""
)

// http://www.whoscored.com/Matches/614052/Live is the match for
// Eveton vs Manchester
const match_address = ""http://www.whoscored.com/Matches/""

// the max id we get
const max_id = 300
const num_workers = 10

// function that get the bytes of the match id from the website
func match_fetch(matchid int) {
    url := fmt.Sprintf(""%s%d/Live"", match_address, matchid)

    resp, err := http.Get(url)
    if err != nil {
        fmt.Println(err)
        return
    }

    // if we sucessfully got a response, store the
    // body in memory
    defer resp.Body.Close()
    body, err := ioutil.ReadAll(resp.Body)
    if err != nil {
        fmt.Println(err)
        return
    }

    // write the body to memory
    pwd, _ := os.Getwd()
    filepath := fmt.Sprintf(""%s/match_data/%d"", pwd, matchid)
    err = ioutil.WriteFile(filepath, body, 0644)
    if err != nil {
        fmt.Println(err)
        return
    }
}

// data type to send to the workers,
// last means this job is the last one
// matchid is the match id to be fetched
// a matchid of -1 means don't fetch a match
type job struct {
    last    bool
    matchid int
}

func create_worker(jobs chan job) {
    for {
        next_job := <-jobs
        if next_job.matchid != -1 {
            match_fetch(next_job.matchid)
        }
        if next_job.last {
            return
        }
    }
}

func main() {
    // do the eveton match as a reference
    match_fetch(614052)

    var joblist [num_workers]chan job
    var v int

    for i := 0; i < num_workers; i++ {
        job_chan := make(chan job)
        joblist[i] = job_chan
        go create_worker(job_chan)
    }
    for i := 0; i < max_id; i = i + num_workers {
        for index, c := range joblist {
            if i+index < max_id {
                v = i + index
            } else {
                v = -1
            }
            c <- job{false, v}
        }
    }
    for _, c := range joblist {
        c <- job{true, -1}
    }
}",2038
36479646,807,"package main

import (
    ""fmt""
    ""sync""
    ""strconv""
    ""time""
)

/*
 * Data and Types
 * ===================================================================================
 */
var fetched map[string]bool    // Map of fetched URLs -> true: fetched
var lock sync.Mutex            // locks write access to fetched-map
var urlChan chan string        // Channel to Write fetched URL

type Fetcher interface {
    // Fetch returns the body of URL and
    // a slice of URLs found on that page.
    Fetch(url string) (body string, urls []string, err error)
}

// fakeFetcher is Fetcher that returns canned results.
type fakeFetcher map[string]*fakeResult

type fakeResult struct {
    body string
    urls []string
}

// fetcher is a populated fakeFetcher.
var fetcher = fakeFetcher{
    ""http://golang.org/"": &fakeResult{
        ""The Go Programming Language"",
        []string{
            ""http://golang.org/pkg/"",
            ""http://golang.org/cmd/"",
        },
    },
    ""http://golang.org/pkg/"": &fakeResult{
        ""Packages"",
        []string{
            ""http://golang.org/"",
            ""http://golang.org/cmd/"",
            ""http://golang.org/pkg/fmt/"",
            ""http://golang.org/pkg/os/"",
        },
    },
    ""http://golang.org/pkg/fmt/"": &fakeResult{
        ""Package fmt"",
        []string{
            ""http://golang.org/"",
            ""http://golang.org/pkg/"",
        },
    },
    ""http://golang.org/pkg/os/"": &fakeResult{
        ""Package os"",
        []string{
            ""http://golang.org/"",
            ""http://golang.org/pkg/"",
        },
    },
}
/*
 * End Data and Types
 * ===================================================================================
 */

/*
 * Webcrawler implementation
 * ===================================================================================
 */
func waitUntilDone(d int) {

    fMap := make(map[string]string)

    for i := 0; i < d; i++ {
        fMap[<-urlChan] = strconv.Itoa(time.Now().Nanosecond())
    }

    time.Sleep(time.Millisecond * 100)

    fmt.Println()
    fmt.Println(""Fetch stats"")
    fmt.Println(""=================================================================="")
    for k, v := range fMap {
        fmt.Println(""Fetched: "" + k + "" after: "" + v + "" ns"")
    }
    fmt.Println(""=================================================================="")
    fmt.Println()

}

func (f fakeFetcher) Fetch(url string) (string, []string, error) {
    var str string
    var strArr [] string
    var err error

    if fetched[url] {
        // already fetched?
        str, strArr, err = """", nil, fmt.Errorf(""already fetched: %s this will be ignored"", url)

    }else if res, ok := f[url]; ok {
        str, strArr, err = res.body, res.urls, nil
        urlChan <- url

    }else {
        str, strArr, err = """", nil, fmt.Errorf(""not found: %s"", url)
    }

    return str, strArr, err
}

// Crawl uses fetcher to recursively crawl
// pages starting with url, to a maximum of depth.
func Crawl(url string, depth int, fetcher Fetcher, goRoutNum int) {

    if depth <= 0 {
        return
    }

    // Start fetching url concurrently
    fmt.Println(""Goroutine "" + strconv.Itoa(goRoutNum) + "" is fetching: "" + url)
    body, urls, err := fetcher.Fetch(url)

    if err != nil {
        fmt.Println(err)
        return
    }

    // Lock map
    lock.Lock()
    fetched[url] = true

    // Unlock
    lock.Unlock()

    fmt.Printf(""found: %s %q\n"", url, body)

    for i, u := range urls {
        go func(url string, goRoutNumber int) {
            Crawl(url, depth - 1, fetcher, goRoutNumber)
        }(u, i + 1)
    }
    return
}

func StartCrawling(url string, depth int, fetcher Fetcher) {

    fmt.Println()
    fmt.Println(""Start crawling ..."")
    fmt.Println(""=================================================================="")

    go func(u string, i int, f Fetcher) {
        Crawl(u, i, f, 0)

    }(url, depth, fetcher)
}
/*
 * End Webcrawler implementation
 * ===================================================================================
 */


/*
 * Main
 * ====================================================================
 */
func main() {

    depth := len(fetcher)
    fetched = make(map[string]bool)
    url := ""http://golang.org/""
    urlChan = make(chan string, len(fetcher))
    go StartCrawling(url, depth, fetcher)
    waitUntilDone(depth)

}

/*
 * End Main
 * =====================================================================
 */",4460
36540246,810,"package serviceclient

import (
    ""bytes""
    ""io/ioutil""
    ""net""
    ""net/http""
    ""time""
    ""log""
)

const(
    HTTP_DIAL_TIME_OUT          = 5    //seconds
    HTTP_TLS_HANDSHAKE_TIME_OUT = 5
    HTTP_CLIENT_TIME_OUT        = 10
)

// RequestService requests the api through the service URL
func RequestService(methodType string, serviceURL string, data string, contentType string) string {
    log.Printf(""Request string %s"", data)
    dataBytes := bytes.NewBufferString(data)
    req, err := http.NewRequest(methodType, serviceURL, dataBytes)
    if err != nil {
        log.Printf(""Client request creation issue"")
    }
    req.Header.Set(""Content-Type"", contentType)

    client := getHTTPClient()
    res, err := client.Do(req)
    log.Printf(""Response Object original : %s"", res)
    if err != nil {
        log.Printf(""Could not make the client request"")
    }
    defer res.Body.Close()
    responseBytes, err := ioutil.ReadAll(res.Body)
    if err != nil {
        log.Printf(""Response string conversion issue"")
    }
    responseString := string(responseBytes[:])
    return responseString
}

func getHTTPClient() *http.Client {
    var netTransport = &http.Transport{
          Dial: (&net.Dialer{
            Timeout: HTTP_DIAL_TIME_OUT * time.Second,
          }).Dial,
          TLSHandshakeTimeout: HTTP_TLS_HANDSHAKE_TIME_OUT * time.Second,
        }
    var client = &http.Client{
          Timeout: time.Second * HTTP_CLIENT_TIME_OUT,
          Transport: netTransport,
        }
    return client
}",1527
36746256,837,"package main

import (
    ""flag""
    ""github.com/Shopify/sarama""
    ""log""
    ""os""
    ""fmt""
    ""strings""
    ""github.com/hpcloud/tail""
    ""github.com/spf13/viper""
    //""io/ioutil""
    ""reflect""
)



func produce(producer sarama.SyncProducer, cfg *sarama.Config, brokers *string, topic string, logger *log.Logger, log string, t *tail.Tail){
    logger.Printf(""Entering produce"")
    logger.Println(strings.Split(*brokers, "",""))
    logger.Println(reflect.TypeOf(strings.Split(*brokers, "","")))
    logger.Println(log)
    /*t, err := tail.TailFile(log, tail.Config{Follow: true, ReOpen: true})
    if err != nil {
        fmt.Println(fmt.Errorf(""Error with tail: %v\n"", err.Error()))
    }*/
    for line := range t.Lines {
        //logger.Println(line)
        //logger.Println(line.Text)
        msg := &sarama.ProducerMessage{Topic: topic, Value: sarama.StringEncoder(line.Text)}
        _, _, err := producer.SendMessage(msg)
        if err != nil {
            logger.Printf(""FAILED to send message: %s\n"", err)
        }
    }

}


func main() {
    //Getting config file params
    viper.SetConfigName(""config"") 
    viper.AddConfigPath(""/root/work/src/linux2kafka/"")
    err := viper.ReadInConfig()
    if err != nil {
        panic(err)
    }
    viper.WatchConfig()
    logList := viper.Get(""log_list"")
    //logListString, err := ioutil.ReadFile(logList.(string))
    //fmt.Println(logList)
    //fmt.Println(reflect.TypeOf(logList))
    logsConfig := strings.Split(logList.(string),"","")
    // print logs to watch
    /*for i := range logsConfig {
        fmt.Println(logsConfig[i])
    }*/
    brokerList := viper.Get(""brokerList"")
    brokers := flag.String(""brokers"", brokerList.(string), ""Comma separated kafka brokers list"") //must be set in config.toml
    topic := flag.String(""topic"", ""test0"", ""Kafka topic to send messages to"")
    flag.Parse()
    logger := log.New(os.Stdout, ""producer "", log.Lmicroseconds)
    cfg := sarama.NewConfig()
    //Wait for replication
    cfg.Producer.RequiredAcks = -1
    cfg.Producer.Flush.Frequency = 333
    cfg.Producer.Flush.Messages = 1000
    cfg.Producer.Flush.MaxMessages = 3000
    producer, err := sarama.NewSyncProducer(strings.Split(*brokers, "",""), cfg)
    if err != nil {
        logger.Fatalln(err)
    }

    defer func() {
        if err := producer.Close(); err != nil {
            logger.Fatalln(err)
        }
    }()
    for i := range logsConfig {
        fmt.Println(""go"")
        t, err := tail.TailFile(logsConfig[i], tail.Config{Follow: true, ReOpen: true})
        if err != nil {
            fmt.Println(fmt.Errorf(""Error with tail: %v\n"", err.Error()))
        }
        go produce(producer, cfg, brokers, *topic, logger, logsConfig[i], t)
        }
}",2743
37425805,867,"package hello

import (
    ""encoding/json""
    ""fmt""
    ""golang.org/x/net/context""
    ""golang.org/x/oauth2""
    ""golang.org/x/oauth2/google""
    ""google.golang.org/api/drive/v3""
    _ ""google.golang.org/appengine/urlfetch""
    ""io/ioutil""
    ""log""
    ""net/http""
    ""net/url""
    ""os""
    ""os/user""
    ""path/filepath""
)

const (
    assetfolder = ""0B-zdryEj60U_MXVkajFweXBQWHM""
)

var (
    dir *drive.FileList
)

func init() {
    http.HandleFunc(""/"", handler)

    ctx := context.Background()

    b, err := ioutil.ReadFile(""client_secret.json"")
    if err != nil {
        log.Fatalf(""Unable to read client secret file: %v"", err)
    }

    // If modifying these scopes, delete your previously saved credentials
    // at ~/.credentials/drive-go-quickstart.json
    config, err := google.ConfigFromJSON(b, drive.DriveMetadataReadonlyScope)
    if err != nil {
        log.Fatalf(""Unable to parse client secret file to config: %v"", err)
    }
    client := getClient(ctx, config)

    srv, err := drive.New(client)
    if err != nil {
        log.Fatalf(""Unable to retrieve drive Client %v"", err)
    }

    dir, err = srv.Files.List().PageSize(10).
        Fields(""nextPageToken, files(id, name)"").Do()
    if err != nil {
        log.Fatalf(""Unable to retrieve files."", err)
    }

}

func handler(w http.ResponseWriter, r *http.Request) {

    //fmt.Fprint(w, r.RequestURI)

    fmt.Fprint(w, ""Files:"")
    if len(dir.Files) > 0 {
        for _, i := range dir.Files {
            fmt.Fprint(w, ""%s (%s)\n"", i.Name, i.Id)
        }
    } else {
        fmt.Fprint(w, ""No files found."")
    }
}

// getClient uses a Context and Config to retrieve a Token
// then generate a Client. It returns the generated Client.
func getClient(ctx context.Context, config *oauth2.Config) *http.Client {
    cacheFile, err := tokenCacheFile()
    if err != nil {
        log.Fatalf(""Unable to get path to cached credential file. %v"", err)
    }
    tok, err := tokenFromFile(cacheFile)
    if err != nil {
        tok = getTokenFromWeb(config)
        saveToken(cacheFile, tok)
    }
    return config.Client(ctx, tok)
}

// getTokenFromWeb uses Config to request a Token.
// It returns the retrieved Token.
func getTokenFromWeb(config *oauth2.Config) *oauth2.Token {
    authURL := config.AuthCodeURL(""state-token"", oauth2.AccessTypeOffline)
    fmt.Printf(""Go to the following link in your browser then type the ""+
        ""authorization code: \n%v\n"", authURL)

    var code string
    if _, err := fmt.Scan(&code); err != nil {
        log.Fatalf(""Unable to read authorization code %v"", err)
    }

    tok, err := config.Exchange(oauth2.NoContext, code)
    if err != nil {
        log.Fatalf(""Unable to retrieve token from web %v"", err)
    }
    return tok
}

// tokenCacheFile generates credential file path/filename.
// It returns the generated credential path/filename.
func tokenCacheFile() (string, error) {
    usr, err := user.Current()
    if err != nil {
        return """", err
    }
    tokenCacheDir := filepath.Join(usr.HomeDir, "".credentials"")
    os.MkdirAll(tokenCacheDir, 0700)
    return filepath.Join(tokenCacheDir,
        url.QueryEscape(""drive-go-quickstart.json"")), err
}

// tokenFromFile retrieves a Token from a given file path.
// It returns the retrieved Token and any read error encountered.
func tokenFromFile(file string) (*oauth2.Token, error) {
    f, err := os.Open(file)
    if err != nil {
        return nil, err
    }
    t := &oauth2.Token{}
    err = json.NewDecoder(f).Decode(t)
    defer f.Close()
    return t, err
}

// saveToken uses a file path to create a file and store the
// token in it.
func saveToken(file string, token *oauth2.Token) {
    fmt.Printf(""Saving credential file to: %s\n"", file)
    f, err := os.Create(file)
    if err != nil {
        log.Fatalf(""Unable to cache oauth token: %v"", err)
    }
    defer f.Close()
    json.NewEncoder(f).Encode(token)
}

func main() {
    ctx := context.Background()

    b, err := ioutil.ReadFile(""client_secret.json"")
    if err != nil {
        log.Fatalf(""Unable to read client secret file: %v"", err)
    }

    // If modifying these scopes, delete your previously saved credentials
    // at ~/.credentials/drive-go-quickstart.json
    config, err := google.ConfigFromJSON(b, drive.DriveMetadataReadonlyScope)
    if err != nil {
        log.Fatalf(""Unable to parse client secret file to config: %v"", err)
    }
    client := getClient(ctx, config)

    srv, err := drive.New(client)
    if err != nil {
        log.Fatalf(""Unable to retrieve drive Client %v"", err)
    }

    r, err := srv.Files.List().PageSize(10).
        Fields(""nextPageToken, files(id, name)"").Do()
    if err != nil {
        log.Fatalf(""Unable to retrieve files."", err)
    }

    fmt.Println(""Files:"")
    if len(r.Files) > 0 {
        for _, i := range r.Files {
            fmt.Printf(""%s (%s)\n"", i.Name, i.Id)
        }
    } else {
        fmt.Print(""No files found."")
    }

}",4965
37500878,870,"package main

import (
    ""database/sql""
    ""fmt""
    ""runtime""
    ""strconv""
    ""time""

    _ ""github.com/go-sql-driver/mysql""
)

func main() {
    runtime.GOMAXPROCS(runtime.NumCPU())
    // defer profile.Start(profile.CPUProfile, profile.ProfilePath(""."")).Stop()
    dbRead, err := connectDB(""test:test@tcp(127.0.0.1:3306)/test_oltp?charset=utf8&readTimeout=600s&writeTimeout=600s"")
    if err != nil {
        fmt.Printf(""Error happend when connecting to DB. %s\n"", err.Error())
        return
    }
    defer dbRead.Close()
    dbRead.SetMaxIdleConns(0)
    dbRead.SetMaxOpenConns(100)

    query := fmt.Sprintf(""WHERE company_id in (11,22,33,44,55,66,77,88,99,00,111,222,333,4444,555,666,777,888,999)"")

    relations := getRelations(dbRead, query)
}
func connectDB(addr string) (*sql.DB, error) {
    db, err := sql.Open(""mysql"", addr)
    if err != nil {
        return nil, err
    }
    if err = db.Ping(); err != nil {
        return nil, err
    }
    return db, nil
}

type Relation struct {
    childId  int64 
    parentId int64 
}

func getRelations(db *sql.DB, where string)[]Relation {
    begin := time.Now()

    var err error
    var rows *sql.Rows
    query := fmt.Sprintf(""SELECT `child_id`, `parent_id` FROM `test_relations` %s"", where)
    rows, err = db.Query(query)
    if err != nil {
        fmt.Println(""query error:"", err.Error())
        return nil
    }
    defer rows.Close()

    columns, err := rows.Columns()
    buffer := make([]sql.RawBytes, len(columns))
    scanArgs := make([]interface{}, len(buffer))
    for i := range scanArgs {
        scanArgs[i] = &buffer[i]
    }

    relations := []Relation{}
    relation := Relation{}
    for rows.Next() {
        if err = rows.Scan(scanArgs...); err != nil {
            fmt.Println(""scan:"", err.Error())
            return nil
        }
        relation.parentId, _ = strconv.ParseInt(string(buffer[1]), 10, 64)
        relation.childId, _ = strconv.ParseInt(string(buffer[0]), 10, 64)

        relations = append(relations, relation)
    }

    if err = rows.Err(); err != nil {
        fmt.Println(""next error:"", err.Error())
        return nil
    }
    fmt.Printf("">>> getRelations cost: %s\n"", time.Since(begin).String())
    // output :>>> getRelations cost:1m45.791047s
    return relations
    // len(relations): 131123541
}",2325
37948574,896,"package controllers

import (
    ""errors""
    ""mobilebid/billable""
    db ""mobilebid/database""
    ""mobilebid/stripe""
    ""net/http""
    ""os""
    ""strconv""
    ""sync""
    ""time""

    log ""github.com/Sirupsen/logrus""
    ""github.com/gorilla/mux""
)

var (
    errBillableID     = errors.New(""It looks like there was an error while getting your billable ID. Do you have a credit card set up?"")
    errWinningItems   = errors.New(""It looks like there was an error while gathering your winning items. Please contact an event rep."")
    errAcctInfo       = errors.New(""We had some trouble getting the account information for the event. Please contact an event rep."")
    errLoggingTrans   = errors.New(""It looks like we had some sort of issue while logging your transaction. Please contact an event rep."")
    errParsingURL     = errors.New(""We had some issue looking at the URL."")
    errStripeIssue    = errors.New(""It looks like there was some kind of issue while talking with Stripe. If you were in the middle of a transaction, this doesn't mean the transaction was cancelled. Take a look at your transactions and/or contact an event rep."")
    errItemsPurchased = errors.New(""One or more of the items you're trying to purchase have already been purchased. If this doesn't sound right, please contact an event rep."")
)

func createLogCtx(bidderID, eventID int) *log.Entry {
    return log.WithFields(log.Fields{
        ""bidderID"": bidderID,
        ""eventID"":  eventID,
    })
}

var wg sync.WaitGroup

const gorutineCt = 6

//PurchaseItems purchases items from the event for the bidder and sends the funds to the customer
//  In order for PurchaseItems to work:
//      1. Bidder must have a customer account set up in Stripe
//      2. Event owner needs to have their Stripe registered with the apps Stripe account
//      3. Item must not have been purchased before (ever)
func PurchaseItems(dB db.AppDB) http.HandlerFunc {
    return http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {

        ps := mux.Vars(req)

        eventID, err := strconv.Atoi(ps[""eventID""])
        if err != nil {
            log.Error(err.Error())
            res.Write(ResErr(errParsingURL.Error()))
            return
        }

        bidderID, err := strconv.Atoi(ps[""bidderID""])
        if err != nil {
            log.Error(err.Error())
            res.Write(ResErr(errParsingURL.Error()))
            return
        }

        itemsChan := make(chan []db.ItemWon)
        billableBidderIDChan := make(chan string)
        creditableAcctChan := make(chan string)
        errsChan := make(chan error, gorutineCt)
        wg.Add(gorutineCt)

        logCtx := createLogCtx(bidderID, eventID)

        acct := stripe.New(os.Getenv(""SECRET_KEY""), os.Getenv(""PUBLISHABLE_KEY""))

        go func() {
            id, e := dB.GetBidderBillableID(bidderID)
            if e != nil {
                logCtx.Error(e.Error())
                errsChan <- errBillableID
                billableBidderIDChan <- id
            } else {
                errsChan <- nil
                billableBidderIDChan <- id
            }
            wg.Done()
        }()

        go func() {
            i, e := dB.GetWinningItemsForBidder(bidderID, eventID)
            if e != nil {
                logCtx.Error(e.Error())
                errsChan <- errWinningItems
                itemsChan <- i
            } else {
                errsChan <- nil
                itemsChan <- i
            }
            wg.Done()
        }()

        go func() {
            a, e := dB.GetCreditableAccountFromEvent(eventID)
            if e != nil {
                logCtx.Error(e.Error())
                errsChan <- errAcctInfo
                creditableAcctChan <- a
            } else {
                errsChan <- nil
                creditableAcctChan <- a
            }
            wg.Done()
        }()

        go func() {
            items := <-itemsChan
            for _, val := range items {
                e := dB.CheckIfItemPurchased(val.ItemID)
                if e != nil {
                    logCtx.WithFields(log.Fields{
                        ""itemID"":     val.ItemID,
                        ""_timestamp"": time.Now(),
                    }).Error(e.Error())
                    errsChan <- errItemsPurchased
                    itemsChan <- items
                    wg.Done()
                    return
                }
            }
            errsChan <- nil
            itemsChan <- items
            wg.Done() //SKIPPED
        }()

        go func() {
            billableBidderID := <-billableBidderIDChan
            e := acct.BuyerIsBillable(billableBidderID)
            if e != nil {
                logCtx.Error(e.Error())
                errsChan <- errStripeIssue
                billableBidderIDChan <- billableBidderID
            } else {
                errsChan <- nil
                billableBidderIDChan <- billableBidderID
            }
            wg.Done()
        }()

        go func() {
            creditableAcct := <-creditableAcctChan
            e := acct.CanReceiveFunds(creditableAcct)
            if e != nil {
                logCtx.Error(e.Error())
                errsChan <- errStripeIssue
                creditableAcctChan <- creditableAcct
            } else {
                errsChan <- nil
                creditableAcctChan <- creditableAcct
            }
            wg.Done()
        }()

        wg.Wait()
        close(errsChan)

        if err = checkConcurrentErrs(errsChan); err != nil {
            logCtx.Error(err.Error())
            res.Write(ResErr(err.Error()))
            return
        }

        items := <-itemsChan
        amount := addItems(items)
        appFee := calculateFee(amount, .03) //TODO: Store this somewhere where it can be edited without having to restart the app.

        invoice := billable.BillObject{
            Desc:     ""Test Charge"", //TODO: Generate this description from the event, items and bidder somehow.
            Amount:   amount,
            Currency: ""usd"",
            Dest:     <-creditableAcctChan,
            Fee:      appFee,
            Meta:     createItemsList(items),
            Customer: <-billableBidderIDChan,
        }

        trans, err := acct.ChargeBidder(invoice)
        if err != nil {
            logCtx.Error(err.Error())
            res.Write(ResErr(errStripeIssue.Error()))
            return
        }

        logCtx.WithFields(log.Fields{
            ""stripeTransID"": trans.TransID,
            ""itemcCount"":    len(items),
        }).Info(""Transferred funds from bidder to client"")

        dbTrans := db.Transaction{
            TransID:  trans.TransID,
            UserID:   5,
            BidderID: bidderID,
            EventID:  eventID,
            Amount:   int64(amount),
            AppFee:   int64(appFee),
            Desc:     ""Some test order"",
            Status:   ""completed"",
        }

        orderID, err := dB.InsertTransaction(dbTrans)
        if err != nil {
            logCtx.WithFields(log.Fields{
                ""stripeTransID"": dbTrans.TransID,
                ""_timestamp"":    time.Now(),
            }).Error(err.Error())
            res.Write(ResErr(errLoggingTrans.Error()))
            return
        }

        for it, val := range items {
            i := db.TransactionLine{
                OrderID: orderID,
                ItemID:  val.ItemID,
                Amount:  uint64(val.Bid * 100), //Must do this since the bid is in dollars but the amount is pennies
                Line:    it,
            }

            err := dB.InsertTransactionLine(i)
            if err != nil {
                logCtx.WithFields(log.Fields{
                    ""stripeTransID"": dbTrans.TransID,
                    ""lineNumber"":    i,
                    ""_timestamp"":    time.Now(),
                }).Error(err.Error())
                res.Write(ResErr(errLoggingTrans.Error()))
                return
            }
        }

        logCtx.WithField(""orderID"", orderID).Info(""Order created"")

        //TODO: Send receipt to buyer.
        res.Write(ResOK(trans.TransID))

    })
}",8135
38065565,903,"package query

import(
    ""net/url""
    ""strings""
)


//ParseQueryOp parses the URL-encoded query string and returns a map 
// listing the values specified for each key. ParseQueryOp always returns 
// a non-nil map containing all the valid query parameters found;
// err describes the first decoding error encountered, if any.
// If the query has operators (e.g. &amount>300) it is Add-ed in the map
// with a prefixed key ( {{prefix}}key ).
/*
 e.g. for a query &Amount>300 the operator("">"") is returnd
    s := ""query &Amount>300""
    q, _ := ParseQueryOp(s, ""_op_"")
    print(q.Get(""_op_Amount"")) // prints `>`
    print(q.Get(""Amount"")) // prints 300
*/
func ParseQueryOp(query, prefix string) (m url.Values, err error){
    m = make(url.Values)

    for query != """" {
        var opKey string
        key := query
        if i := strings.IndexAny(key, ""&;""); i >= 0 {
            key, query = key[:i], key[i+1:]
        } else {
            query = """"
        }
        if key == """" {
            continue
        }
        value := """"
        var err1 error
        if i := strings.Index(key, "">=""); i >= 0{
            key, value = key[:i], key[i+2:]
            opKey = prefix + key 
            opKey, err1 = url.QueryUnescape(opKey)
            if err1 != nil {
                if err == nil {
                    err = err1
                }
                continue
            }
            m[opKey] = append(m[opKey], "">="")
        }else if i = strings.Index(key, ""= 0{
            key, value = key[:i], key[i+2:]
            opKey = prefix + key 
            opKey, err1 = url.QueryUnescape(opKey)
            if err1 != nil {
                if err == nil {
                    err = err1
                }
                continue
            }
            m[opKey] = append(m[opKey], ""<="")
        }else if i = strings.Index(key, ""="");  i >= 0{
            key, value = key[:i], key[i+1:]
        }else if i = strings.Index(key, "">"");  i >= 0{
            key, value = key[:i], key[i+1:]
            opKey = prefix + key 
            opKey, err1 = url.QueryUnescape(opKey)
            if err1 != nil {
                if err == nil {
                    err = err1
                }
                continue
            }
            m[opKey] = append(m[opKey], "">"")
        }else if i = strings.Index(key, ""= 0{
            key, value = key[:i], key[i+1:]
            opKey = prefix + key 
            opKey, err1 = url.QueryUnescape(opKey)
            if err1 != nil {
                if err == nil {
                    err = err1
                }
                continue
            }
            m[opKey] = append(m[opKey], ""<"")
        }

        key, err1 = url.QueryUnescape(key)
        if err1 != nil {
            if err == nil {
                err = err1
            }
            continue
        }
        value, err1 = url.QueryUnescape(value)
        if err1 != nil {
            if err == nil {
                err = err1
            }
            continue
        }
        m[key] = append(m[key], value)
    }
    return m, err
}",3072
38079036,905,"//------------------------------------------------------------------
//  user
//----------------------------------------------------------------------
func (d *Database) UserCreate(email, password, username string, role int) *Answer {
    //variables
    answer := d.initCall(""UserCreate"")
    user := new(User)
    //check exist user
    if userExist := d.DB.Find(&User{}, &User{Email:email}).Error; userExist == nil {
        answer.AnswerJSON.ErrorAnswer.Message = ""[usercreate] user already exist""
        answer.AnswerJSON.Result = nil
        answer.AnswerJSON.Status = false
    } else {

        userinfo := UserInfo{Data:time.Now()}
        session := Session{Data:time.Now()}
        cook := Cook{}

        //make support  tables object
        //userinfo object
        userinfo.Password = password
        userinfo.Username = username
        //cook object
        cook.SessionID = session.ID
        cook.Cookie = d.cookgeneratenew(""somesaltforcooksgenerate"")
        cook.Status = true
        cook.Lastconnect = time.Now()
        cook.CountConnect += 1

        //user object
        user.Email = email
        user.Session = session
        user.UserInfo = userinfo
        user.Cook = cook
        user.Role = int64(role)

        //make request + //serizlizations to json answer
        if err := d.DB.Create(user).Error; err != nil {
            answer.AnswerJSON.ErrorAnswer.Message = err.Error()
            answer.AnswerJSON.Status = false
        } else {
            answer.AnswerJSON.Result = user
            answer.AnswerJSON.Status = true
        }
    }
    d.serilize(answer)
    return answer
}
func (d *Database) UserDelete(userid int64) *Answer {
    answer := d.initCall(""UserDelete"")
    user := new(User)
    //check exists
    if userExists := d.DB.Find(user, ""ID = ?"", userid).Error; userExists == nil {
        if userDelete := d.DB.Delete(user).Error; userDelete != nil {
            answer.AnswerJSON.ErrorAnswer.Message = userExists.Error()
            answer.AnswerJSON.Status = false
        } else {
            answer.AnswerJSON.Status = true
            answer.AnswerJSON.ErrorAnswer = nil
        }
    } else {
        answer.AnswerJSON.ErrorAnswer.Message = userExists.Error()
        answer.AnswerJSON.Status = false
    }
    d.serilize(answer)
    return answer
}
func (d *Database) UserRead(userid int64) *Answer {
    answer := d.initCall(""UserRead"")
    user := new(User)
    if userExists := d.DB.Find(user, ""ID = ?"", userid).Error; userExists != nil {
        answer.AnswerJSON.ErrorAnswer.Message = userExists.Error()
        answer.AnswerJSON.Status = false
    } else {
        if rel := d.DB.Model(user).Related(&user.Session).Error; rel != nil {
            answer.AnswerJSON.Result = nil
            answer.AnswerJSON.ErrorAnswer.Message = rel.Error()
            answer.AnswerJSON.Status = false
        } else if rel = d.DB.Model(user).Related(&user.UserInfo).Error; rel != nil {
            answer.AnswerJSON.Result = nil
            answer.AnswerJSON.ErrorAnswer.Message = rel.Error()
            answer.AnswerJSON.Status = false
        } else if rel = d.DB.Model(user).Related(&user.Cook).Error; rel != nil {
            answer.AnswerJSON.Result = nil
            answer.AnswerJSON.ErrorAnswer.Message = rel.Error()
            answer.AnswerJSON.Status = false
        } else {
            answer.AnswerJSON.Result = user
            answer.AnswerJSON.ErrorAnswer = nil
            answer.AnswerJSON.Status = true
        }
    }
    d.serilize(answer)
    return answer
}
func (d *Database) UserReadAll() *Answer {
    answer := d.initCall(""UserReadAll"")
    users := []User{}

    if usersGet := d.DB.Find(&users).Error; usersGet != nil {
        answer.AnswerJSON.ErrorAnswer.Message = usersGet.Error()
        answer.AnswerJSON.Status = false
    } else {
        for _, user := range users {
            d.DB.Model(user).Related(&user.Session)
            d.DB.Model(user).Related(&user.UserInfo)
            d.DB.Model(user).Related(&user.Cook)
        }
        answer.AnswerJSON.Result = users
        answer.AnswerJSON.ErrorAnswer = nil
        answer.AnswerJSON.Status = true
    }
    d.serilize(answer)
    return answer
}
func (d *Database) UserUpdate(userid int64, uu *UserUpdateStruct) *Answer {
    answer := d.initCall(""UserUpdate"")
    user := new(User)

    if userExists := d.DB.Find(user, ""ID = ?"", userid).Error; userExists != nil {
        answer.AnswerJSON.ErrorAnswer.Message = userExists.Error()
        answer.AnswerJSON.Status = false
    } else {
        //get relevating struct info
        d.DB.Model(user).Related(&user.Session)
        d.DB.Model(user).Related(&user.UserInfo)
        d.DB.Model(user).Related(&user.Cook)

        //update columns
        if uu.Email != """" {
            user.Email = uu.Email
        }
        if uu.Avatar > 0 {
            user.UserInfo.Avatar = uu.Avatar
        }
        if uu.Birthday != """" {
            user.UserInfo.Birthday = uu.Birthday
        }
        if uu.Location != """" {
            user.UserInfo.Location = uu.Location
        }
        if uu.Male != """" {
            user.UserInfo.Male = uu.Male
        }
        if uu.Password != """" {
            user.UserInfo.Password = uu.Password
        }
        if uu.Role > 0 {
            if roleErr := d.DB.Find(&Role{}).Error; roleErr != nil {
                //role not found
                fmt.Printf(""[userupdate] role not found `%d`\n"", uu.Role)
            } else {
                user.Role = uu.Role
            }
        }

        //update
        if errUpdate := d.DB.Save(user).Error; errUpdate != nil {
            answer.AnswerJSON.ErrorAnswer.Message = errUpdate.Error()
            answer.AnswerJSON.Status = false
        } else {
            answer.AnswerJSON.Result = user
            answer.AnswerJSON.ErrorAnswer = nil
            answer.AnswerJSON.Status = true
        }
    }
    d.serilize(answer)
    return answer
}
func (d *Database) UserPaginate(page, countPage int) *Answer {
    answer := d.initCall(""UserPaginate"")
    result := []*User{}
    if errPag := d.DB.Limit(countPage).Offset((page * countPage) - countPage).Find(&result).Error; errPag != nil {
        answer.AnswerJSON.ErrorAnswer.Message = errPag.Error()
        answer.AnswerJSON.Status = false
    } else {
        for _, user := range result {
            d.DB.Model(&user).Related(&user.Session)
            d.DB.Model(&user).Related(&user.UserInfo)
            d.DB.Model(&user).Related(&user.Cook)
        }
        answer.AnswerJSON.Result = result
        answer.AnswerJSON.ErrorAnswer = nil
        answer.AnswerJSON.Status = true
    }
    d.serilize(answer)
    return answer
}
//-------------------------------------------------------------------
//  category
//--------------------------------------------------------------------
func (d *Database) CategoryCreate(name string) *Answer {
    //variables
    answer := d.initCall(""CategoryCreate"")
    cat := new(Category)
    //check exist user
    if catExist := d.DB.Find(&Category{}, &Category{Name:name}).Error; catExist == nil {
        answer.AnswerJSON.ErrorAnswer.Message = ""[categorycreate] category already exist""
        answer.AnswerJSON.Result = nil
        answer.AnswerJSON.Status = false
    } else {
        cat.Name = name
        //make request + //serizlizations to json answer
        if err := d.DB.Create(cat).Error; err != nil {
            answer.AnswerJSON.ErrorAnswer.Message = err.Error()
            answer.AnswerJSON.Status = false
        } else {
            answer.AnswerJSON.Result = cat
            answer.AnswerJSON.Status = true
        }
    }
    d.serilize(answer)
    return answer
}
func (d *Database) CategoryDelete(catid int64) *Answer {
    answer := d.initCall(""CategoryDelete"")
    cat := new(Category)
    //check exists
    if catExists := d.DB.Find(cat, ""ID = ?"", catid).Error; catExists == nil {
        if catDelete := d.DB.Delete(cat).Error; catDelete != nil {
            answer.AnswerJSON.ErrorAnswer.Message = catExists.Error()
            answer.AnswerJSON.Status = false
        } else {
            answer.AnswerJSON.Status = true
            answer.AnswerJSON.ErrorAnswer = nil
        }
    } else {
        answer.AnswerJSON.ErrorAnswer.Message = catExists.Error()
        answer.AnswerJSON.Status = false
    }
    d.serilize(answer)
    return answer
}
func (d *Database) CategoryRead(catid int64) *Answer {
    answer := d.initCall(""CategoryRead"")
    cat := new(Category)
    if catExists := d.DB.Find(cat, ""ID = ?"", catid).Error; catExists != nil {
        answer.AnswerJSON.ErrorAnswer.Message = catExists.Error()
        answer.AnswerJSON.Status = false
    } else {
        if rel := d.DB.Model(cat).Related(&cat.Post).Error; rel != nil {
            answer.AnswerJSON.Result = nil
            answer.AnswerJSON.ErrorAnswer.Message = rel.Error()
            answer.AnswerJSON.Status = false
        } else {
            for x, p := range cat.Post {
                d.DB.Model(&p).Related(&p.Comment)
                d.DB.Model(&p).Related(&p.PostSeo)
                cat.Post[x] = p
            }
            answer.AnswerJSON.Result = cat
            answer.AnswerJSON.ErrorAnswer = nil
            answer.AnswerJSON.Status = true
        }
    }
    d.serilize(answer)
    return answer
}
func (d *Database) CategoryReadAll() *Answer {
    answer := d.initCall(""CategoryReadAll"")
    cats := []Category{}

    if catsGet := d.DB.Find(&cats).Error; catsGet != nil {
        answer.AnswerJSON.ErrorAnswer.Message = catsGet.Error()
        answer.AnswerJSON.Status = false
    } else {
        //categorys
        for _, cat := range cats {
            d.DB.Model(cat).Related(&cat.Post)
            //get relete POST
            for x, p := range cat.Post {
                d.DB.Model(&p).Related(&p.Comment)
                d.DB.Model(&p).Related(&p.PostSeo)
                cat.Post[x] = p
            }
        }
        answer.AnswerJSON.Result = cats
        answer.AnswerJSON.ErrorAnswer = nil
        answer.AnswerJSON.Status = true
    }
    d.serilize(answer)
    return answer
}
func (d *Database) CategoryUpdate(catid int64, name string) *Answer {
    answer := d.initCall(""CategoryUpdate"")
    cat := new(Category)

    if catExists := d.DB.Find(cat, ""ID = ?"", catid).Error; catExists != nil {
        answer.AnswerJSON.ErrorAnswer.Message = catExists.Error()
        answer.AnswerJSON.Status = false
    } else {
        //get relevating struct info
        d.DB.Model(cat).Related(&cat.Post)

        //update columns
        if name != """" {
            cat.Name = name
        }
        //update
        if errUpdate := d.DB.Save(cat).Error; errUpdate != nil {
            answer.AnswerJSON.ErrorAnswer.Message = errUpdate.Error()
            answer.AnswerJSON.Status = false
        } else {
            answer.AnswerJSON.Result = cat
            answer.AnswerJSON.ErrorAnswer = nil
            answer.AnswerJSON.Status = true
        }
    }
    d.serilize(answer)
    return answer
}
func (d *Database) CategoryPaginate(page, countPage int) *Answer {
    answer := d.initCall(""CategoryPaginate"")
    result := []*Category{}
    if errPag := d.DB.Limit(countPage).Offset((page * countPage) - countPage).Find(&result).Error; errPag != nil {
        answer.AnswerJSON.ErrorAnswer.Message = errPag.Error()
        answer.AnswerJSON.Status = false
    } else {
        for _, cat := range result {
            d.DB.Model(&cat).Related(&cat.Post)
            //get relete POST
            for x, p := range cat.Post {
                d.DB.Model(&p).Related(&p.Comment)
                d.DB.Model(&p).Related(&p.PostSeo)
                cat.Post[x] = p
            }
        }
        answer.AnswerJSON.Result = result
        answer.AnswerJSON.ErrorAnswer = nil
        answer.AnswerJSON.Status = true
    }
    d.serilize(answer)
    return answer
}",11894
38191972,909,"package main

import (
    ""fmt""
    ""syscall""
    ""unsafe""
)

var (
    shell32 = syscall.MustLoadDLL(""shell32.dll"")

    // https://msdn.microsoft.com/en-us/library/windows/desktop/bb762179(v=vs.85).aspx
    procSHGetFileInfo = shell32.MustFindProc(""SHGetFileInfoW"")

    //https://msdn.microsoft.com/en-us/library/windows/desktop/bb762185(v=vs.85).aspx
    procSHGetImageList = shell32.MustFindProc(""SHGetImageList"")
)

func main() {
    someExeFile := `c:\windows\explorer.exe`

    iconIndex := GetIconIndex(someExeFile)

    // The problem:
    HRESULT, _, _ := procSHGetImageList.Call(
        uintptr(SHIL_JUMBO),
        uintptr(unsafe.Pointer(&IID_IImageList2)),

        // I don't know how pass/create an ""IImageList interface"" in Go,
        // or if it's even possible without relying on CGO.
        // IImageList interface:
        // https://msdn.microsoft.com/en-us/library/windows/desktop/bb761419(v=vs.85).aspx

        // Currently there's just a pointer to an empty []byte so that the code will compile.
        // HRESULT naturally contains the error code E_NOINTERFACE (2147500034),
        // which makes sense seeing as I'm not passing a valid interface.
        uintptr(unsafe.Pointer(&[]byte{})),
    )

    fmt.Println(iconIndex, HRESULT)
}


const SHIL_JUMBO = 0x4

const shGetFileInfoLen = 3
const shGetFileInfoFlags = 16400 //(SysIconIndex|LargeIcon|UseFileAttributes)
// use SHGetFileInfo to get the icon index (only value we care about)
func GetIconIndex(fileName string) int {
    buf := make([]uint16, shGetFileInfoLen)
    ret, _, _ := procSHGetFileInfo.Call(
        uintptr(unsafe.Pointer(syscall.StringToUTF16Ptr(fileName))),
        0,
        uintptr(unsafe.Pointer(&buf[0])),
        shGetFileInfoLen,
        shGetFileInfoFlags,
    )

    if ret != 0 && buf[2] > 0 {
        return int(buf[2])
    }

    return 0
}

// From: ""192B9D83-50FC-457B-90A0-2B82A8B5DAE1""
var IID_IImageList2 = &GUID{0x192b9d83, 0x50fc, 0x457b, [8]byte{0x90, 0xa0, 0x2b, 0x82, 0xa8, 0xb5, 0xda, 0xe1}}

// http://msdn.microsoft.com/en-us/library/windows/desktop/aa373931.aspx
type GUID struct {
    Data1 uint32
    Data2 uint16
    Data3 uint16
    Data4 [8]byte
}",2187
38698066,930,"func static(w http.ResponseWriter, r *http.Request) {
    //check backend
    if user, err := aaa.CurrentUser(w, r); err == nil {
        //user is logged in
        log.Println(user)
        vars := mux.Vars(r)
        page := vars[""page""]
        data, _ := ioutil.ReadFile(""downloads/"" + page)
        w.Write(data)
        return
    }else {
        //user is not logged in
        http.Redirect(w,r,""/login"",http.StatusUnauthorized)
        w.Write([]byte(""alert('Please login')""))
        return
    }
} 
",511
38747259,933,"$ go get -d github.com/ipfs/go-ipfs

$ cd $GOPATH/src/github.com/ipfs/go-ipfs
Then install go-ipfs and its dependencies, including gx and gx-go:

$ make install
",161
38874816,1020,"package main

import (
    ""html/template""
    ""log""
    ""net/http""
    ""path/filepath""
    ""sync""
)

type templateHandler struct {
    //once is an object that will perform exactly one action
    once     sync.Once
    filename string
    templ    *template.Template
}

func (t *templateHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
    //this function call will be executed only once
    t.once.Do(func() {
        t.templ = template.Must(template.ParseFiles(filepath.Join(""templates"", t.filename)))
        log.Println(""one time"")
    })
    t.templ.Execute(w, nil)
}

func main() {
    http.Handle(""/"", &templateHandler{filename: ""chat.html""})
    if err := http.ListenAndServe("":5000"", nil); err != nil {
        log.Fatal(""ListenAndServe"", err)
    }
}",774
38879356,1024,"// ReceiveData - used to handle incoming data
func ReceiveData(w http.ResponseWriter, r *http.Request) {
    if r.Method != ""POST"" {
        http.NotFound(w, r)
        return
    }

    body, err := ioutil.ReadAll(r.Body)
    if err != nil {
        panic(err)
    }

    // database
    session, err := mgo.Dial(""localhost"")
    if err != nil {
        panic(err)
    } else {
        fmt.Println(""session created"")
        database := session.DB(""schedule_calculator"")
        collection := database.C(""schedule_save"")
        num, err := collection.Count()
        if err == nil {
            fmt.Println(""schedule_save collection count = "", num)
            mongodbData := SavedData{ID: bson.NewObjectId(), Data: string(body), Date: time.Now()}
            collection.Insert(mongodbData)
            num, _ := collection.Count()
            fmt.Println(""new count: "", num)
        } else {
            fmt.Println(""schedule_save error - "", err)
        }
    }

    if err := json.NewEncoder(w).Encode(""todos""); err != nil {
        panic(err)
    }
}

type SavedData struct {
    ID   bson.ObjectId `bson:""_id""`
    Data string
    Date time.Time
}

// SendData - Called by UI to get saved data
func SendData(w http.ResponseWriter, r *http.Request) {
    fmt.Println(""SendData function"")
    session, err := mgo.Dial(""localhost"")
    defer closeSession(session)
    if err != nil {
        panic(err)
    } else {
        fmt.Println(""session created"")
        database := session.DB(""schedule_calculator"")
        collection := database.C(""schedule_save"")
        num, err := collection.Count()
        if err == nil {
            fmt.Println(""schedule_save collection count = "", num)

            var myData SavedData
            dbSize, err2 := collection.Count()
            if err2 != nil {
                panic(err2)
            }

            if dbSize > 0 {
                // db not empty
                err2 = collection.Find(nil).Skip(dbSize - 1).One(&myData)
                if err2 != nil {
          // TODO: handle error
                    panic(err2)
                }

                // fmt.Println(myData.Data)

                w.Header().Set(""Content-Type"", ""application/json; charset=UTF-8"")
                w.WriteHeader(http.StatusOK)

                if err := json.NewEncoder(w).Encode(myData.Data); err != nil {
          // TODO: handle error
                    panic(err)
                }
            } else {
                // db empty
        fmt.Println(""DB is empty"")
            }

        } else {
            fmt.Println(""schedule_save error - "", err)
        }
    }
}

// closes the mongodb session
// TODO: make it use only 1 session
func closeSession(session *mgo.Session) {
    session.Close()
    fmt.Println(""session closed"")
}",2782
38898766,1026,"a8 := [8]int{1, 2, 3, 4, 5, 6, 7, 8}
fmt.Println(a8) // [1 2 3 4 5 6 7 8]",74
38927101,1031,"genes = readGenes(""lists/genes.csv"") // read the gene list
n := runtime.NumCPU()                // the number of goroutines
wg.Add(n + 1)
go scan() // read the ""fasta/sequences.tsv""
for i := 0; i < n; i++ {
    go search()
}
go WaitClose()
slice := []string{}
for t := range queue {
    slice = append(slice, t)
}
fmt.Println(slice)",333
38960704,1055,Marshal,7
39008249,1065,default,7
39044210,1106,structs,7
39045889,1114,"version: '2'
services:
    postgres:
        image: postgres
        ports:
            - ""5432""
        environment:
            - POSTGRES_PASSWORD=postgres
    server:
        build: ./server
        command: gin
        volumes:
            - ./server:/go/src/app
        ports:
            - ""8080:3000""",309
39061896,1117,"package main

import (
    ""io""
    ""net/http""
    ""os""
)

//Display the named template
func display(w http.ResponseWriter, tmpl string, data interface{}) {
    templates.ExecuteTemplate(w, tmpl+"".html"", data)
}

//This is where the action happens.
func uploadHandler(w http.ResponseWriter, r *http.Request) {
    switch r.Method {
    //POST takes the uploaded file(s) and saves it to disk.
    case ""POST"":
        //parse the multipart form in the request
        err := r.ParseMultipartForm(100000)
        if err != nil {
            http.Error(w, err.Error(), http.StatusInternalServerError)
            return
        }

        //get a ref to the parsed multipart form
        m := r.MultipartForm

        //get the *fileheaders
        files := m.File[""myfiles""]
        for i, _ := range files {
            //for each fileheader, get a handle to the actual file
            file, err := files[i].Open()
            defer file.Close()
            if err != nil {
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
            }
            //create destination file making sure the path is writeable.
            dst, err := os.Create(""/home/sanat/"" + files[i].Filename)
            defer dst.Close()
            if err != nil {
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
            }
            //copy the uploaded file to the destination file
            if _, err := io.Copy(dst, file); err != nil {
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
            }

        }
        //display success message.
        display(w, ""upload"", ""Upload successful."")
    default:
        w.WriteHeader(http.StatusMethodNotAllowed)
    }
}

func main() {
    http.HandleFunc(""/upload"", uploadHandler)

    //static file handler.
    http.Handle(""/assets/"", http.StripPrefix(""/assets/"", http.FileServer(http.Dir(""assets""))))

    //Listen on port 8080
    http.ListenAndServe("":8080"", nil)
}",2050
39063494,1119,"INFO     2016-08-20 22:48:03,786 devappserver2.py:769] Skipping SDK update check. 
INFO     2016-08-20 22:48:03,960 api_server.py:205] Starting API server at: http://localhost:64053 
INFO     2016-08-20 22:48:03,969 dispatcher.py:197] Starting module ""default"" running at: http://localhost:8080 
INFO     2016-08-20 22:48:03,974 admin_server.py:116] Starting admin server at:http://localhost:8000

Exception in thread Instance Adjustment: Traceback (most recent call last):   
    File ""C:\Python27\lib\threading.py"", line 801, in __bootstrap_inner 
      self.run()   
    File ""C:\Python27\lib\threading.py"", line 754, in run 
      self.__target(*self.__args, **self.__kwargs)   
    File ""C:\work\go_appengine\google\appengine\tools\devappserver2\module.py"",line 1485, in _loop_adjusting_instances 
      self._adjust_instances()  
    File ""C:\work\go_appengine\google\appengine\tools\devappserver2\module.py"",line 1460, in _adjust_instances 
      self._add_instance(permit_warmup=True)
    File ""C:\work\go_appengine\google\appengine\tools\devappserver2\module.py"",line 1338, in _add_instance 
      expect_ready_request=perform_warmup)  
    File ""C:\work\go_appengine\google\appengine\tools\devappserver2\go_runtime.py"",line 174, in new_instance 
      if self._go_application.maybe_build(self._modified_since_last_build):  
    File ""C:\work\go_appengine\google\appengine\tools\devappserver2\go_application.py"",line 304, in maybe_build 
      self._extras_hash, old_extras_hash = (self._get_extras_hash(),   
    File ""C:\work\go_appengine\google\appengine\tools\devappserver2\go_application.py"",line 247, in _get_extras_hash gab_stdout, 
      _ = self._run_gab(gab_args, env={})   
    File ""C:\work\go_appengine\google\appengine\tools\devappserver2\go_application.py"",line 175, in _run_gab
      gab_extra_args, env)   
    File ""C:\work\go_appengine\google\appengine\tools\devappserver2\go_application.py"",line 111, in _run_gab 
      env=env)   
    File ""C:\work\go_appengine\google\appengine\tools\devappserver2\safe_subprocess.py"",line 74, in start_process 
      stdin=subprocess.PIPE, startupinfo=startupinfo)   
    File ""C:\Python27\lib\subprocess.py"", line710, in __init__  
      errread, errwrite)   
    File ""C:\Python27\lib\subprocess.py"", line 958, in _execute_child 
      startupinfo) 
    WindowsError: [Error 206] The filename or extension is too long",2385
39064558,1126,io.Reader,9
39124035,1130,atomic.Value,12
39144961,1152,Stackoverflow,13
39311049,1158,"E:\Desktop\ManBear\golang\src>go run main.go
# command-line-arguments
.\main.go:71: cannot use cmdHandler (type HelloWorldCommandHandler) as type CommandHandler in array or slice literal:
        HelloWorldCommandHandler does not implement CommandHandler (wrong type for Handle method)
                have Handle(HelloWorldCommand)
                want Handle(Command)",370
39319481,1162,"import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.Scanner;
import org.json.JSONObject;

public class mid
{

    static String payload  ="""";
    public static void main (String[] args) throws Exception
  {
    try {
        @SuppressWarnings(""resource"")
        Scanner scanner = new Scanner(System.in);


         payload = scanner.nextLine();


        JSONObject obj = new JSONObject(payload);


        JSONObject response = obj.getJSONObject(""response"");

        response.remove(""status"");

        response.put(""status"", ""500"");



        String newjson = obj.toString();


         write (newjson);

        System.out.print(obj);


    } catch (Exception e) {
        e.printStackTrace();
    }



  }    
}",791
39333942,1167,vendor/vendor.json,18
39341513,1170,go vet ./...,12
39404625,1172,"gc 440 @51045.897s 0%: 0.034+4182+0.96 ms clock, 0.13+0/4182/12246+3.8 ms cpu, 4304->4309->4143 MB, 8266 MB goal, 4 P
scvg340: inuse: 4404, idle: 15, sys: 4419, released: 0, consumed: 4419 (MB)
GC forced
gc 441 @51170.096s 0%: 3.7+4355+1.4 ms clock, 14+2.9/4357/12795+5.8 ms cpu, 4317->4323->4158 MB, 8287 MB goal, 4 P
GC forced
gc 442 @51294.460s 0%: 0.034+3987+1.2 ms clock, 0.13+1.5/3987/11701+4.9 ms cpu, 4336->4341->4169 MB, 8316 MB goal, 4 P
scvg341: inuse: 4318, idle: 133, sys: 4451, released: 0, consumed: 4451 (MB)
GC forced
gc 443 @51418.451s 0%: 0.36+3925+0.99 ms clock, 1.4+4.0/3925/11554+3.9 ms cpu, 4350->4356->4182 MB, 8338 MB goal, 4 P
scvg342: inuse: 4363, idle: 103, sys: 4466, released: 0, consumed: 4466 (MB)
GC forced
gc 444 @51542.394s 0%: 0.042+3986+1.6 ms clock, 0.16+0/3981/11757+6.5 ms cpu, 4361->4367->4194 MB, 8365 MB goal, 4 P
scvg343: inuse: 4404, idle: 74, sys: 4478, released: 0, consumed: 4478 (MB)
GC forced
gc 445 @51666.384s 0%: 3.4+3987+1.4 ms clock, 13+2.5/3986/11747+5.7 ms cpu, 4375->4382->4208 MB, 8388 MB goal, 4 P
scvg344: inuse: 4454, idle: 39, sys: 4493, released: 0, consumed: 4493 (MB)
GC forced
gc 446 @51790.379s 0%: 0.055+4147+1.5 ms clock, 0.22+0/4139/12125+6.2 ms cpu, 4396->4402->4220 MB, 8416 MB goal, 4 P
scvg345: inuse: 4509, idle: 5, sys: 4514, released: 0, consumed: 4514 (MB)
GC forced
gc 447 @51914.542s 0%: 0.052+4205+2.1 ms clock, 0.21+1.5/4199/12348+8.5 ms cpu, 4413->4420->4234 MB, 8441 MB goal, 4 P
GC forced
gc 448 @52038.752s 0%: 2.7+4517+1.8 ms clock, 11+2.3/4517/13245+7.2 ms cpu, 4428->4436->4247 MB, 8469 MB goal, 4 P
scvg346: inuse: 4406, idle: 142, sys: 4548, released: 0, consumed: 4548 (MB)
GC forced
gc 449 @52163.276s 0%: 0.033+4206+1.3 ms clock, 0.13+0/4206/12306+5.3 ms cpu, 4442->4449->4259 MB, 8495 MB goal, 4 P
scvg347: inuse: 4452, idle: 109, sys: 4561, released: 0, consumed: 4561 (MB)
GC forced
gc 450 @52287.491s 0%: 0.044+4262+2.0 ms clock, 0.17+0/4261/12565+8.2 ms cpu, 4452->4459->4272 MB, 8519 MB goal, 4 P
scvg348: inuse: 4498, idle: 74, sys: 4572, released: 0, consumed: 4572 (MB)
GC forced
gc 451 @52411.769s 0%: 0.028+4012+2.0 ms clock, 0.11+0.066/3992/11762+8.0 ms cpu, 4471->4477->4285 MB, 8544 MB goal, 4 P
scvg349: inuse: 4550, idle: 40, sys: 4590, released: 0, consumed: 4590 (MB)",2284
39422084,1176,"curl -XPOST 'http://supersecreturl/mypost' -d '[{""i sware to ritchie"":""this json is 100 percent valid""},{""i can even"":""copy and paste it into a curl POST request and receive it flawlessly on the remote side""}]'",210
39437216,1179,"package main

import (
    ""database/sql""
    ""encoding/json""
    ""fmt""
    _ ""github.com/go-sql-driver/mysql""
    ""net/http""
    ""reflect""
    ""strings""
)

func main() {
    db, err := sql.Open(""mysql"", ""***:****@tcp(****:3306)/****"")
    fmt.Println(reflect.TypeOf(db))
    checkErr(err)
    fmt.Println(""Handle Request setup... OK"")
    http.HandleFunc(""/"", func(w http.ResponseWriter, req *http.Request) {

        jsonData, err := getListings(db)
        checkErr(err)

        w.Write([]byte(jsonData))

    })
    fmt.Println(""Starting Server...."")
    fmt.Println(""Listening on port 8081"")
    http.ListenAndServe("":8081"", nil)

}

func getListings(db *sql.DB) ([]byte, error) {
    var userId string = ""142""

    normalListings := sqlToArray(db, `******`)

    manualListings := sqlToArray(db, ""******"")

    var groupIds []string
    for key := range manualListings {

        groupId := ""142,"" + manualListings[key][""group_id""]
        if !stringInSlice(groupId, groupIds) {
            groupIds = append(groupIds, groupId)
        }
    }

    var groupIdsString string
    groupIdsString = strings.Join(groupIds, "", "")

    manualGroups := sqlToArray(db, ""*****"")

    for key := range manualListings {

        for key2 := range manualGroups {
            groupId := ""142,"" + manualListings[key][""group_id""]

            if groupId == manualGroups[key][""ticket_id""] {
                entry := make(map[string]string)
                entry[""ticket_id""] = manualListings[key][""listing_id""]
                entry[""date_created""] = manualGroups[key2][""date_created""]
                normalListings = append(normalListings, entry)

            }
        }
    }

    return json.Marshal(normalListings)

}

func stringInSlice(a string, list []string) bool {
    for _, b := range list {
        if b == a {
            return true
        }
    }
    return false
}

func sqlToArray(db *sql.DB, sqlString string) []map[string]string {

    rows, err := db.Query(sqlString)
    checkErr(err)
    columns, err := rows.Columns()
    count := len(columns)
    values := make([]interface{}, count)
    valuePtrs := make([]interface{}, count)
    tableData := make([]map[string]string, 0)

    for rows.Next() {

        for i := 0; i < count; i++ {
            valuePtrs[i] = &values[i]
        }
        rows.Scan(valuePtrs...)
        entry := make(map[string]string)
        for i, col := range columns {

            val := values[i]
            b, ok := val.([]byte)
            if ok {
                entry[col] = string(b)
            } else {
                entry[col] = string(b)
            }

        }
        tableData = append(tableData, entry)

    }

    return tableData

}

func checkErr(err error) {
    if err != nil {
        panic(err)
    }
}",2772
39502310,1182,"TEXT ·CountBitsUint64PopCnt(SB),NOSPLIT,$0
    POPCNTQ    x+0(FP), AX
    MOVQ       AX, ret+8(FP)
    RET",108
39523885,1188,math/big,8
39524224,1190,strings.Fields(s),17
39539884,1193,"panic:  not an Int

goroutine 68 [running]:
go/constant.Int64Val(0x0, 0x0, 0x2, 0xc8200d5180)
    /usr/local/go/src/go/constant/value.go:236 +0x338
github.com/derekparker/delve/proc.(*Variable).parseG(0xc8200a6700, 0xc8200a6700, 0x0, 0x0)
    /opt/buildAgent/work/b97f8195591f35ac/gopath/src/github.com/derekparker/delve/proc/variables.go:387 +0x734
github.com/derekparker/delve/proc.(*Thread).GetG(0xc8200e4690, 0xc8200e4690, 0x0, 0x0)
    /opt/buildAgent/work/b97f8195591f35ac/gopath/src/github.com/derekparker/delve/proc/threads.go:295 +0x69
github.com/derekparker/delve/proc.(*Thread).SetCurrentBreakpoint(0xc8200e4690, 0x0, 0x0)
    /opt/buildAgent/work/b97f8195591f35ac/gopath/src/github.com/derekparker/delve/proc/threads.go:352 +0x18e
github.com/derekparker/delve/proc.(*Process).setCurrentBreakpoints(0xc820116100, 0xc8200e4690, 0x0, 0x0)
    /opt/buildAgent/work/b97f8195591f35ac/gopath/src/github.com/derekparker/delve/proc/proc_linux.go:413 +0x9b
github.com/derekparker/delve/proc.(*Process).Continue(0xc820116100, 0x0, 0x0)
    /opt/buildAgent/work/b97f8195591f35ac/gopath/src/github.com/derekparker/delve/proc/proc.go:311 +0x214
github.com/derekparker/delve/service/debugger.(*Debugger).Command(0xc82010a720, 0xc82010a8a0, 0x0, 0x0, 0x0)
    /opt/buildAgent/work/b97f8195591f35ac/gopath/src/github.com/derekparker/delve/service/debugger/debugger.go:394 +0x847
github.com/derekparker/delve/service/rpc1.(*RPCServer).Command(0xc82081c140, 0xc82010a8a0, 0x7f86a9daaa38, 0xc820114300)
    /opt/buildAgent/work/b97f8195591f35ac/gopath/src/github.com/derekparker/delve/service/rpc1/server.go:52 +0x2f
reflect.Value.call(0x945540, 0xa69c40, 0x13, 0xa84850, 0x4, 0xc820080280, 0x3, 0x3, 0x0, 0x0, ...)
    /usr/local/go/src/reflect/value.go:432 +0x120a
reflect.Value.Call(0x945540, 0xa69c40, 0x13, 0xc820080280, 0x3, 0x3, 0x0, 0x0, 0x0)
    /usr/local/go/src/reflect/value.go:300 +0xb1
created by github.com/derekparker/delve/service/rpccommon.(*ServerImpl).serveJSONCodec
    /opt/buildAgent/work/b97f8195591f35ac/gopath/src/github.com/derekparker/delve/service/rpccommon/server.go:298 +0xf70

goroutine 1 [chan receive]:
github.com/derekparker/delve/cmd/dlv/cmds.execute(0x0, 0xc8201143c0, 0x1, 0x4, 0xc82010e038, 0x0, 0x0)
    /opt/buildAgent/work/b97f8195591f35ac/gopath/src/github.com/derekparker/delve/cmd/dlv/cmds/commands.go:428 +0xad5
github.com/derekparker/delve/cmd/dlv/cmds.New.func4(0xc820120c00, 0xc8201143c0, 0x1, 0x4)
    /opt/buildAgent/work/b97f8195591f35ac/gopath/src/github.com/derekparker/delve/cmd/dlv/cmds/commands.go:154 +0x53
github.com/derekparker/delve/vendor/github.com/spf13/cobra.(*Command).execute(0xc820120c00, 0xc8201142c0, 0x4, 0x4, 0x0, 0x0)
    /opt/buildAgent/work/b97f8195591f35ac/gopath/src/github.com/derekparker/delve/vendor/github.com/spf13/cobra/command.go:569 +0x869
github.com/derekparker/delve/vendor/github.com/spf13/cobra.(*Command).ExecuteC(0xc820120400, 0xc820120c00, 0x0, 0x0)
    /opt/buildAgent/work/b97f8195591f35ac/gopath/src/github.com/derekparker/delve/vendor/github.com/spf13/cobra/command.go:656 +0x56b
github.com/derekparker/delve/vendor/github.com/spf13/cobra.(*Command).Execute(0xc820120400, 0x0, 0x0)
    /opt/buildAgent/work/b97f8195591f35ac/gopath/src/github.com/derekparker/delve/vendor/github.com/spf13/cobra/command.go:615 +0x2d
main.main()
    /opt/buildAgent/work/b97f8195591f35ac/gopath/src/github.com/derekparker/delve/cmd/dlv/main.go:13 +0x4a

goroutine 17 [syscall, locked to thread]:
runtime.goexit()
    /usr/local/go/src/runtime/asm_amd64.s:1696 +0x1

goroutine 5 [syscall]:
os/signal.loop()
    /usr/local/go/src/os/signal/signal_unix.go:22 +0x18
created by os/signal.init.1
    /usr/local/go/src/os/signal/signal_unix.go:28 +0x37

goroutine 18 [chan receive, locked to thread]:
github.com/derekparker/delve/proc.(*Process).handlePtraceFuncs(0xc820116100)
    /opt/buildAgent/work/b97f8195591f35ac/gopath/src/github.com/derekparker/delve/proc/proc.go:774 +0xc3
created by github.com/derekparker/delve/proc.New
    /opt/buildAgent/work/b97f8195591f35ac/gopath/src/github.com/derekparker/delve/proc/proc.go:82 +0x1d0

goroutine 67 [IO wait]:
net.runtime_pollWait(0x7f86b0656290, 0x72, 0xc8200181c0)
    /usr/local/go/src/runtime/netpoll.go:157 +0x60
net.(*pollDesc).Wait(0xc82012a290, 0x72, 0x0, 0x0)
    /usr/local/go/src/net/fd_poll_runtime.go:73 +0x3a
net.(*pollDesc).WaitRead(0xc82012a290, 0x0, 0x0)
    /usr/local/go/src/net/fd_poll_runtime.go:78 +0x36
net.(*netFD).Read(0xc82012a230, 0xc82032c000, 0x200, 0x200, 0x0, 0x7f86b1e98050, 0xc8200181c0)
    /usr/local/go/src/net/fd_unix.go:232 +0x23a
net.(*conn).Read(0xc82055a000, 0xc82032c000, 0x200, 0x200, 0x0, 0x0, 0x0)
    /usr/local/go/src/net/net.go:172 +0xe4
encoding/json.(*Decoder).refill(0xc820132000, 0x0, 0x0)
    /usr/local/go/src/encoding/json/stream.go:152 +0x287
encoding/json.(*Decoder).readValue(0xc820132000, 0x1, 0x0, 0x0)
    /usr/local/go/src/encoding/json/stream.go:128 +0x41b
encoding/json.(*Decoder).Decode(0xc820132000, 0x99b9a0, 0xc82012e080, 0x0, 0x0)
    /usr/local/go/src/encoding/json/stream.go:57 +0x159
net/rpc/jsonrpc.(*serverCodec).ReadRequestHeader(0xc82012e060, 0xc82010a100, 0x0, 0x0)
    /usr/local/go/src/net/rpc/jsonrpc/server.go:66 +0x7c
github.com/derekparker/delve/service/rpccommon.(*ServerImpl).serveJSONCodec(0xc8201124b0, 0x7f86a9daa698, 0xc82055a000)
    /opt/buildAgent/work/b97f8195591f35ac/gopath/src/github.com/derekparker/delve/service/rpccommon/server.go:252 +0x3ec
created by github.com/derekparker/delve/service/rpccommon.(*ServerImpl).Run.func1
    /opt/buildAgent/work/b97f8195591f35ac/gopath/src/github.com/derekparker/delve/service/rpccommon/server.go:145 +0x185

goroutine 15 [select, locked to thread]:
runtime.gopark(0xb97eb0, 0xc82051af28, 0xa8d4a0, 0x6, 0x42bf18, 0x2)
    /usr/local/go/src/runtime/proc.go:185 +0x163
runtime.selectgoImpl(0xc82051af28, 0x0, 0x18)
    /usr/local/go/src/runtime/select.go:392 +0xa64
runtime.selectgo(0xc82051af28)
    /usr/local/go/src/runtime/select.go:212 +0x12
runtime.ensureSigM.func1()
    /usr/local/go/src/runtime/signal1_unix.go:227 +0x353
runtime.goexit()
    /usr/local/go/src/runtime/asm_amd64.s:1696 +0x1",6149
39572848,1194,"package search

import ""reflect""

// Search an arbitrary tree / map like data structure.
func concurrentSearch(output chan interface{}, data interface{}, key string) {
    // search() is your search algorithm.
    result := search(data, key)
    if result != nil {
        // Found something, so put it on the chan.
        // This is the point of the function.
        output <- result
        return // Success.
    }

    // Since we didn't find a match we will get a slice of the next level of values.
    iterableType := listValues(data)
    if len(iterableType) == 0 {
        return
    }

    var wg sync.WaitGroup
    for _, value := range iterableType {
        wg.Add(1)

        go func(next interface{}) {
            defer wg.Done()
            concurrentSearch(output, next, key)
        }(value)

    }
    wg.Wait()
    // Wait never finishes, so the function never returns
} 

// Returns a slice of values based on Type.
func listValues(data interface{}) []interface{} {
    value := reflect.ValueOf(data)
    values := []interface{}{}

    switch value.Kind() {
    case reflect.Map:
        for _, key := range value.MapKeys() {
            values = append(values, value.MapIndex(key).Interface())
        }

    case reflect.Slice:
        for ii := 0; ii < value.Len(); ii++ {
            values = append(values, value.Index(ii).Interface())
        }

    case reflect.Struct:
        for ii := 0; ii < value.NumField(); ii++ {
            if value.Field(ii).CanSet() {
                values = append(values, value.Field(ii).Interface())
            }
        }

    case reflect.Ptr:
        rawValue := value.Elem()
        if !rawValue.IsValid() {
            return nil
        }
        values = listValues(rawValue)

    case reflect.Interface:
        rawValue := value.Elem()
        values = listValues(rawValue)
    }

    return values
}

// search just checks the value for an index of key, otherwise returns nil.
func search(data interface{}, key string) interface{} {
    value := reflect.ValueOf(data)
    switch value.Kind() {

    // If the type is indexable, check the index.
    // Default to returning nil
    case reflect.Struct:
        for ii := 0; ii < value.NumField(); ii++ {
            field := value.Field(ii)
            // Without CanSet() reflect panics about Unexported fields.
            if field.CanSet() {
                if field.Type().Name() == key {
                    return field.Elem().Interface()
                }
            }
        }
        return nil

    case reflect.Map:
        for _, mapkey := range value.MapKeys() {
            if key == mapkey.String() {
                return value.MapIndex(mapkey).Elem().Interface()
            }
        }
        return nil

    case reflect.Slice:
        return nil

        // For pointer types we just unwrap and call again.
    case reflect.Ptr:
        rawValue := value.Elem()
        if !rawValue.IsValid() {
            return nil
        }
        return search(rawValue, key)

    case reflect.Interface:
        rawValue := value.Elem()
        return search(rawValue, key)

    case reflect.String:
        return nil

    default:
        return nil
    }

}",3197
39597109,1196,"var V1URLBase string = ""/api/v1""

func Load() http.Handler {

    r := mux.NewRouter().StrictSlash(true)

    // Status endpoints
    s := r.PathPrefix(fmt.Sprintf(""%s%s"", V1URLBase, ""/statuses"")).Subrouter()

    s.HandleFunc(""/"", handlers.GetStatuses).
        Methods(""GET"")
    s.HandleFunc(""/{status_id}/"", handlers.GetStatus).
        Methods(""GET"")
    s.HandleFunc(""/"", handlers.PostStatus).
        Methods(""POST"")
    s.HandleFunc(""/{status_id}/"", handlers.PutStatus).
        Methods(""PUT"")
    s.HandleFunc(""/{status_id}/"", handlers.DeleteStatus).
        Methods(""DELETE"")

    // Visit endpoints
    v := r.PathPrefix(fmt.Sprintf(""%s%s"", V1URLBase, ""/visits"")).Subrouter()

    v.HandleFunc(""/"", handlers.GetVisits).
        Methods(""GET"")
    v.HandleFunc(""/{visit_id}/"", handlers.GetVisit).
        Methods(""GET"")
    v.HandleFunc(""/"", handlers.PostVisit).
        Methods(""POST"")
    v.HandleFunc(""/{visit_id}/"", handlers.PutVisit).
        Methods(""PUT"")
    v.HandleFunc(""/{visit_id}/"", handlers.DeleteVisit).
        Methods(""DELETE"")

    // Member endpoints
    m := r.PathPrefix(fmt.Sprintf(""%s%s"", V1URLBase, ""/members"")).Subrouter()

    m.HandleFunc(""/"", handlers.GetMembers).
        Methods(""GET"")
    m.HandleFunc(""/{member_id}/"", handlers.GetMember).
        Methods(""GET"")
    m.HandleFunc(""/"", handlers.PostMember).
        Methods(""POST"")
    m.HandleFunc(""/{member_id}/"", handlers.PutMember).
        Methods(""PUT"")
    m.HandleFunc(""/{member_id}/"", handlers.DeleteMember).
        Methods(""DELETE"")

    // GymLocation endpoints
    gl := r.PathPrefix(fmt.Sprintf(""%s%s"", V1URLBase, ""/gym_locations"")).Subrouter()

    gl.HandleFunc(""/"", handlers.GetGymLocations).
        Methods(""GET"")
    gl.HandleFunc(""/{gym_location_id}/"", handlers.GetGymLocation).
        Methods(""GET"")
    gl.HandleFunc(""/"", handlers.PostGymLocation).
        Methods(""POST"")
    gl.HandleFunc(""/{gym_location_id}/"", handlers.PutGymLocation).
        Methods(""PUT"")
    gl.HandleFunc(""/{gym_location_id}/"", handlers.DeleteGymLocation).
        Methods(""DELETE"")

    router := ghandlers.LoggingHandler(os.Stdout, r)
    router = handlers.WriteCORSHeaders(r)

    return router
}",2190
39634610,1201,"type (
    SessionStore struct {
        c      *mgo.Session
        sid    string
        lock   sync.RWMutex
        values map[interface{}]interface{}
    }
)

var mgopder = &Provider{}

func (st *SessionStore) Set(key, value interface{}) error {
    st.lock.Lock()
    defer st.lock.Unlock()
    st.values[key] = value
    return nil
}

// Get value from mongodb session
func (st *SessionStore) Get(key interface{}) interface{} {
    st.lock.RLock()
    defer st.lock.RUnlock()
    if v, ok := st.values[key]; ok {
        return v
    }
    return nil
}

// Delete value in mongodb session
func (st *SessionStore) Delete(key interface{}) error {
    st.lock.Lock()
    defer st.lock.Unlock()
    delete(st.values, key)
    return nil
}

// Flush clear all values in mongodb session
func (st *SessionStore) Flush() error {
    st.lock.Lock()
    defer st.lock.Unlock()
    st.values = make(map[interface{}]interface{})
    return nil
}

// SessionID get session id of this mongodb session store
func (st *SessionStore) SessionID() string {
    return st.sid
}

// SessionRelease save mongodb session values to database.
// must call this method to save values to database.
func (st *SessionStore) SessionRelease(w http.ResponseWriter) {
    defer st.c.Close()
    b, err := session.EncodeGob(st.values)
    if err != nil {
        return
    }
    st.c.DB(""Employee"").C(""Sessions"").Update(nil, bson.M{""$set"": bson.M{
        ""session_data"":   b,
        ""session_expiry"": time.Now().Unix(),
        ""session_key"":    st.sid,
    },
    },
    )

    /*st.c.Exec(""UPDATE ""+TableName+"" set `session_data`=?, `session_expiry`=? where session_key=?"",
    b, time.Now().Unix(), st.sid)*/
}

type Provider struct {
    maxlifetime int64
    savePath    string
    Database    string
}

// connect to mongodb
func (mp *Provider) connectInit() *mgo.Session {
    ds, err := mgo.Dial(""Employee"")
    if err != nil {
        return nil
    }
    return ds
}

// SessionInit init mongodb session.
// savepath is the connection string of mongodb
func (mp *Provider) SessionInit(maxlifetime int64, savePath string) error {
    mp.maxlifetime = maxlifetime
    mp.savePath = savePath
    mp.Database = ""Employee""
    return nil
}

// SessionRead get mysql session by sid
func (mp *Provider) SessionRead(sid string) (session.Store, error) {
    var sessiondata []byte
    ds := mp.connectInit()
    defer ds.Close()
    c := ds.DB(mp.Database).C(""Session"")
    err := c.Find(bson.M{
        ""session_key"": sid,
    }).Select(bson.M{""session_data"": 1}).All(&sessiondata)
    if err != nil {
        if err.Error() == ""not found"" {
            c.Insert(bson.M{
                ""session_key"":    sid,
                ""session_data"":   "" "",
                ""session_expiry"": time.Now().Unix(),
            })
        }
    }

    var kv map[interface{}]interface{}
    if len(sessiondata) == 0 {
        kv = make(map[interface{}]interface{})
    } else {
        kv, err = session.DecodeGob(sessiondata)
        if err != nil {
            return nil, err
        }
    }
    rs := &SessionStore{c: ds, sid: sid, values: kv}
    return rs, nil
}

// SessionExist check mongodb session exist
func (mp *Provider) SessionExist(sid string) bool {
    var sessiondata []byte
    ds := mp.connectInit()
    defer ds.Close()
    c := ds.DB(""Employee"").C(""Sessions"")
    err := c.Find(bson.M{
        ""session_key"": sid,
    }).Select(bson.M{
        ""session_data"": 1,
    }).One(&sessiondata)
    if err != nil {
        if err.Error() == ""not found"" {
            return false
        }
    }
    return true

}

// SessionRegenerate generate new sid for mysql session
func (mp *Provider) SessionRegenerate(oldsid, sid string) (session.Store, error) {
    var sessiondata []byte
    ds := mp.connectInit()
    defer ds.Close()
    c := ds.DB(""Employee"").C(""Sessions"")
    err := c.Find(bson.M{
        ""session_key"": oldsid,
    }).Select(bson.M{
        ""session_data"": 1,
    }).One(&sessiondata)
    if err != nil {
        if err.Error() == ""not found"" {
            c.Insert(bson.M{
                ""sessoin_key"":    oldsid,
                ""session_data"":   "" "",
                ""session_expiry"": time.Now().Unix(),
            })
        }
    }
    /*  row := c.QueryRow(""select session_data from ""+TableName+"" where session_key=?"", oldsid)

        err := row.Scan(&sessiondata)

    c.Update(bson.M{""sessoin_key"": oldsid}, bson.M{
        ""$set"": bson.M{
            ""session_key"": sid,
        },
    })
    /*c.Exec(""update ""+TableName+"" set `session_key`=? where session_key=?"", sid, oldsid)
     */
    var kv map[interface{}]interface{}
    if len(sessiondata) == 0 {
        kv = make(map[interface{}]interface{})
    } else {
        kv, err = session.DecodeGob(sessiondata)
        if err != nil {
            return nil, err
        }
    }
    rs := &SessionStore{c: ds, sid: sid, values: kv}
    return rs, nil
}

// SessionDestroy delete mysql session by sid
func (mp *Provider) SessionDestroy(sid string) error {
    ds := mp.connectInit()
    defer ds.Close()
    c := ds.DB(""Employee"").C(""Sessions"")
    c.Remove(bson.M{
        ""session_key"": sid,
    }) 
    return nil
}

// SessionGC delete expired values in mysql session
func (mp *Provider) SessionGC() {
    ds := mp.connectInit()
    defer ds.Close()
    c := ds.DB(""Employee"").C(""Sessions"")
    c.Remove(bson.M{
        ""session_expiry"": bson.M{
            ""$lt"": time.Now().Unix() - mp.maxlifetime,
        },
    })
return
}

// SessionAll count values in mysql session
func (mp *Provider) SessionAll() int {
    var total int
    ds := mp.connectInit()
    defer ds.Close()
    c := ds.DB(""Employee"").C(""Sessions"")
    total, err := c.Count()

    if err != nil {
        return 0
    }
    return total
}

func init() {
    session.Register(""mongodb"", mgopder)
}",5833
39662001,1203,unit_type_name,14
39911980,1214,"func removeRuneAt(s string, runePosition int) string {
    if runePosition < 0 {
        return s
    }
    r := []rune(s)
    if runePosition >= len(r) {
        return s
    }
    copy(r[runePosition:], r[runePosition+1:])
    return string(r[:len(r)-1])
}",259
39982804,1234,"FROM golang:1.7-alpine
RUN echo http://dl-4.alpinelinux.org/alpine/edge/testing >> /etc/apk/repositories
RUN apk update && apk upgrade && apk add --no-cache bash git openssh alpine-sdk libgit2

RUN pkg-config --print-errors --exists libgit2",241
39990618,1238,"// popcount_test.go:226
 func BenchmarkCountBitsUint64(b *testing.B) {
+       stopDeadCodeElimination := 0
        for i := 0; i < b.N; i++ {
-               CountBitsUint64(uint64(i))
+               stopDeadCodeElimination |= CountBitsUint64(uint64(i))
        }
+       b.Logf(""stopDeadCodeElimination: %d"", stopDeadCodeElimination)
 }

 func BenchmarkCountBitsUint64Alt(b *testing.B) {",392
39990793,1245,"{
    ""_id"" : ObjectId(""57f940c4932a00aba387b0b0""),
    ""tenantID"" : 1,
    ""date"" : ""2016-10-09 00:23:56"",
    ""venueList"" : [
        {
            ""id"" : “VID1212”,
            ""sum"" : [
                {
                      ""name"" : ""linux"",
                      ""value"" : 12
                },
                {
                    ""name"" : ""ubuntu"",
                    ""value"" : 4
                }
            ],
            “ssidList” : [    // this is list of ssid’s in venue
                {
                    ""id"" : “SSID1212”,
                    ""sum"" : [
                        {
                            ""name"" : ""linux"",
                            ""value"" : 8
                        },
                        {
                            ""name"" : ""ubuntu"",
                            ""value"" : 6
                        }
                    ],
                    “macList” : [  // this is mac list inside particular ssid  ex: this is mac list inside the SSID1212
                        {
                            ""id"" : “12:12:12:12:12:12”,
                            ""sum"" : [
                                {
                                    ""name"" : ""linux"",
                                    ""value"" : 12
                                },
                                {
                                    ""name"" : ""ubuntu"",
                                    ""value"" : 1
                                }
                            ]
                        }
                    ]
                }
            ]
        },
        {
            ""id"" : “VID4343”,
            ""sum"" : [
                {
                     ""name"" : ""linux"",
                     ""value"" : 2
                }
            ],
            ""ssidList"" : [
                {
                    ""id"" : “SSID4343”,
                    ""sum"" : [
                        {
                            ""name"" : ""linux"",
                            ""value"" : 2
                        }
                    ],
                    ""macList"" : [
                        {
                            ""id"" : “43:43:43:43:43:34”,
                            ""sum"" : [
                                {
                                    ""name"" : ""linux"",
                                    ""value"" : 2
                                }
                            ]
                        }
                    ]
                }
            ]
        }
    ]
}",2527
40077813,1251,"package main
//This file is generated automatically. Do not try to edit it manually.

var resourceListingJson = `{
    ""apiVersion"": ""1.0.0"",
    ""swaggerVersion"": ""1.2"",
    ""basePath"": ""http://127.0.0.1:3000/"",
    ""apis"": [
        {
            ""path"": ""/testapi"",
            ""description"": ""Test API""
        }
    ],
    ""info"": {
        ""title"": ""Swagger Example API"",
        ""description"": ""Swagger Example API"",
        ""contact"": ""varyous@gmail.com"",
        ""termsOfServiceUrl"": ""http://yvasiyarov.com/"",
        ""license"": ""BSD"",
        ""licenseUrl"": ""http://yvasiyarov.com/""
    }
}`
var apiDescriptionsJson = map[string]string{""testapi"":`{
    ""apiVersion"": ""1.0.0"",
    ""swaggerVersion"": ""1.2"",
    ""basePath"": ""http://127.0.0.1:3000/"",
    ""resourcePath"": ""/testapi"",
    ""produces"": [
        ""application/json""
    ],
    ""apis"": [
        {
            ""path"": ""/testapi/get-string-by-int/{some_id}"",
            ""description"": ""get string by ID"",
            ""operations"": [
                {
                    ""httpMethod"": ""GET"",
                    ""nickname"": ""GetStringByInt"",
                    ""type"": ""string"",
                    ""items"": {},
                    ""summary"": ""get string by ID"",
                    ""parameters"": [
                        {
                            ""paramType"": ""path"",
                            ""name"": ""some_id"",
                            ""description"": ""Some ID"",
                            ""dataType"": ""int"",
                            ""type"": ""int"",
                            ""format"": """",
                            ""allowMultiple"": false,
                            ""required"": true,
                            ""minimum"": 0,
                            ""maximum"": 0
                        }
                    ],
                    ""responseMessages"": [
                        {
                            ""code"": 200,
                            ""message"": """",
                            ""responseType"": ""object"",
                            ""responseModel"": ""string""
                        },
                        {
                            ""code"": 400,
                            ""message"": ""We need ID!!"",
                            ""responseType"": ""object"",
                            ""responseModel"": ""git.corp.adobe.com.personal.test1.APIError""
                        },
                        {
                            ""code"": 404,
                            ""message"": ""Can not find ID"",
                            ""responseType"": ""object"",
                            ""responseModel"": ""git.corp.adobe.com.personal.test1.APIError""
                        }
                    ],
                    ""produces"": [
                        ""application/json""
                    ]
                }
            ]
        },
        {
            ""path"": ""/testapi/get-struct-by-int/{some_id}"",
            ""description"": ""get struct by ID"",
            ""operations"": [
                {
                    ""httpMethod"": ""GET"",
                    ""nickname"": ""GetStructByInt"",
                    ""type"": ""git.corp.adobe.com.personal.test1.StructureWithEmbededStructure"",
                    ""items"": {},
                    ""summary"": ""get struct by ID"",
                    ""parameters"": [
                        {
                            ""paramType"": ""path"",
                            ""name"": ""some_id"",
                            ""description"": ""Some ID"",
                            ""dataType"": ""int"",
                            ""type"": ""int"",
                            ""format"": """",
                            ""allowMultiple"": false,
                            ""required"": true,
                            ""minimum"": 0,
                            ""maximum"": 0
                        },
                        {
                            ""paramType"": ""query"",
                            ""name"": ""offset"",
                            ""description"": ""Offset"",
                            ""dataType"": ""int"",
                            ""type"": ""int"",
                            ""format"": """",
                            ""allowMultiple"": false,
                            ""required"": true,
                            ""minimum"": 0,
                            ""maximum"": 0
                        },
                        {
                            ""paramType"": ""query"",
                            ""name"": ""limit"",
                            ""description"": ""Offset"",
                            ""dataType"": ""int"",
                            ""type"": ""int"",
                            ""format"": """",
                            ""allowMultiple"": false,
                            ""required"": true,
                            ""minimum"": 0,
                            ""maximum"": 0
                        }
                    ],
                    ""responseMessages"": [
                        {
                            ""code"": 200,
                            ""message"": """",
                            ""responseType"": ""object"",
                            ""responseModel"": ""git.corp.adobe.com.personal.test1.StructureWithEmbededStructure""
                        },
                        {
                            ""code"": 400,
                            ""message"": ""We need ID!!"",
                            ""responseType"": ""object"",
                            ""responseModel"": ""git.corp.adobe.com.personal.test1.APIError""
                        },
                        {
                            ""code"": 404,
                            ""message"": ""Can not find ID"",
                            ""responseType"": ""object"",
                            ""responseModel"": ""git.corp.adobe.com.personal.test1.APIError""
                        }
                    ],
                    ""produces"": [
                        ""application/json""
                    ]
                }
            ]
        },
        {
            ""path"": ""/testapi/get-struct2-by-int/{some_id}"",
            ""description"": ""get struct2 by ID"",
            ""operations"": [
                {
                    ""httpMethod"": ""GET"",
                    ""nickname"": ""GetStruct2ByInt"",
                    ""type"": ""git.corp.adobe.com.personal.test1.StructureWithEmbededPointer"",
                    ""items"": {},
                    ""summary"": ""get struct2 by ID"",
                    ""parameters"": [
                        {
                            ""paramType"": ""path"",
                            ""name"": ""some_id"",
                            ""description"": ""Some ID"",
                            ""dataType"": ""int"",
                            ""type"": ""int"",
                            ""format"": """",
                            ""allowMultiple"": false,
                            ""required"": true,
                            ""minimum"": 0,
                            ""maximum"": 0
                        },
                        {
                            ""paramType"": ""query"",
                            ""name"": ""offset"",
                            ""description"": ""Offset"",
                            ""dataType"": ""int"",
                            ""type"": ""int"",
                            ""format"": """",
                            ""allowMultiple"": false,
                            ""required"": true,
                            ""minimum"": 0,
                            ""maximum"": 0
                        },
                        {
                            ""paramType"": ""query"",
                            ""name"": ""limit"",
                            ""description"": ""Offset"",
                            ""dataType"": ""int"",
                            ""type"": ""int"",
                            ""format"": """",
                            ""allowMultiple"": false,
                            ""required"": true,
                            ""minimum"": 0,
                            ""maximum"": 0
                        }
                    ],
                    ""responseMessages"": [
                        {
                            ""code"": 200,
                            ""message"": """",
                            ""responseType"": ""object"",
                            ""responseModel"": ""git.corp.adobe.com.personal.test1.StructureWithEmbededPointer""
                        },
                        {
                            ""code"": 400,
                            ""message"": ""We need ID!!"",
                            ""responseType"": ""object"",
                            ""responseModel"": ""git.corp.adobe.com.personal.test1.APIError""
                        },
                        {
                            ""code"": 404,
                            ""message"": ""Can not find ID"",
                            ""responseType"": ""object"",
                            ""responseModel"": ""git.corp.adobe.com.personal.test1.APIError""
                        }
                    ],
                    ""produces"": [
                        ""application/json""
                    ]
                }
            ]
        },
        {
            ""path"": ""/testapi/get-simple-array-by-string/{some_id}"",
            ""description"": ""get simple array by ID"",
            ""operations"": [
                {
                    ""httpMethod"": ""GET"",
                    ""nickname"": ""GetSimpleArrayByString"",
                    ""type"": ""array"",
                    ""items"": {
                        ""type"": ""string""
                    },
                    ""summary"": ""get simple array by ID"",
                    ""parameters"": [
                        {
                            ""paramType"": ""path"",
                            ""name"": ""some_id"",
                            ""description"": ""Some ID"",
                            ""dataType"": ""string"",
                            ""type"": ""string"",
                            ""format"": """",
                            ""allowMultiple"": false,
                            ""required"": true,
                            ""minimum"": 0,
                            ""maximum"": 0
                        },
                        {
                            ""paramType"": ""query"",
                            ""name"": ""offset"",
                            ""description"": ""Offset"",
                            ""dataType"": ""int"",
                            ""type"": ""int"",
                            ""format"": """",
                            ""allowMultiple"": false,
                            ""required"": true,
                            ""minimum"": 0,
                            ""maximum"": 0
                        },
                        {
                            ""paramType"": ""query"",
                            ""name"": ""limit"",
                            ""description"": ""Offset"",
                            ""dataType"": ""int"",
                            ""type"": ""int"",
                            ""format"": """",
                            ""allowMultiple"": false,
                            ""required"": true,
                            ""minimum"": 0,
                            ""maximum"": 0
                        }
                    ],
                    ""responseMessages"": [
                        {
                            ""code"": 200,
                            ""message"": """",
                            ""responseType"": ""array"",
                            ""responseModel"": ""string""
                        },
                        {
                            ""code"": 400,
                            ""message"": ""We need ID!!"",
                            ""responseType"": ""object"",
                            ""responseModel"": ""git.corp.adobe.com.personal.test1.APIError""
                        },
                        {
                            ""code"": 404,
                            ""message"": ""Can not find ID"",
                            ""responseType"": ""object"",
                            ""responseModel"": ""git.corp.adobe.com.personal.test1.APIError""
                        }
                    ],
                    ""produces"": [
                        ""application/json""
                    ]
                }
            ]
        },
        {
            ""path"": ""/testapi/get-struct-array-by-string/{some_id}"",
            ""description"": ""get struct array by ID"",
            ""operations"": [
                {
                    ""httpMethod"": ""GET"",
                    ""nickname"": ""GetStructArrayByString"",
                    ""type"": ""array"",
                    ""items"": {
                        ""$ref"": ""git.corp.adobe.com.personal.test1.SimpleStructureWithAnnotations""
                    },
                    ""summary"": ""get struct array by ID"",
                    ""parameters"": [
                        {
                            ""paramType"": ""path"",
                            ""name"": ""some_id"",
                            ""description"": ""Some ID"",
                            ""dataType"": ""string"",
                            ""type"": ""string"",
                            ""format"": """",
                            ""allowMultiple"": false,
                            ""required"": true,
                            ""minimum"": 0,
                            ""maximum"": 0
                        },
                        {
                            ""paramType"": ""query"",
                            ""name"": ""offset"",
                            ""description"": ""Offset"",
                            ""dataType"": ""int"",
                            ""type"": ""int"",
                            ""format"": """",
                            ""allowMultiple"": false,
                            ""required"": true,
                            ""minimum"": 0,
                            ""maximum"": 0
                        },
                        {
                            ""paramType"": ""query"",
                            ""name"": ""limit"",
                            ""description"": ""Offset"",
                            ""dataType"": ""int"",
                            ""type"": ""int"",
                            ""format"": """",
                            ""allowMultiple"": false,
                            ""required"": true,
                            ""minimum"": 0,
                            ""maximum"": 0
                        }
                    ],
                    ""responseMessages"": [
                        {
                            ""code"": 200,
                            ""message"": """",
                            ""responseType"": ""array"",
                            ""responseModel"": ""git.corp.adobe.com.personal.test1.SimpleStructureWithAnnotations""
                        },
                        {
                            ""code"": 400,
                            ""message"": ""We need ID!!"",
                            ""responseType"": ""object"",
                            ""responseModel"": ""git.corp.adobe.com.personal.test1.APIError""
                        },
                        {
                            ""code"": 404,
                            ""message"": ""Can not find ID"",
                            ""responseType"": ""object"",
                            ""responseModel"": ""git.corp.adobe.com.personal.test1.APIError""
                        }
                    ],
                    ""produces"": [
                        ""application/json""
                    ]
                }
            ]
        },
        {
            ""path"": ""/testapi/get-interface"",
            ""description"": ""get interface"",
            ""operations"": [
                {
                    ""httpMethod"": ""GET"",
                    ""nickname"": ""GetInterface"",
                    ""type"": ""git.corp.adobe.com.personal.test1.InterfaceType"",
                    ""items"": {},
                    ""summary"": ""get interface"",
                    ""responseMessages"": [
                        {
                            ""code"": 200,
                            ""message"": """",
                            ""responseType"": ""object"",
                            ""responseModel"": ""git.corp.adobe.com.personal.test1.InterfaceType""
                        },
                        {
                            ""code"": 400,
                            ""message"": ""We need ID!!"",
                            ""responseType"": ""object"",
                            ""responseModel"": ""git.corp.adobe.com.personal.test1.APIError""
                        },
                        {
                            ""code"": 404,
                            ""message"": ""Can not find ID"",
                            ""responseType"": ""object"",
                            ""responseModel"": ""git.corp.adobe.com.personal.test1.APIError""
                        }
                    ],
                    ""produces"": [
                        ""application/json""
                    ]
                }
            ]
        },
        {
            ""path"": ""/testapi/get-simple-aliased"",
            ""description"": ""get simple aliases"",
            ""operations"": [
                {
                    ""httpMethod"": ""GET"",
                    ""nickname"": ""GetSimpleAliased"",
                    ""type"": ""string"",
                    ""items"": {},
                    ""summary"": ""get simple aliases"",
                    ""responseMessages"": [
                        {
                            ""code"": 200,
                            ""message"": """",
                            ""responseType"": ""object"",
                            ""responseModel"": ""string""
                        },
                        {
                            ""code"": 400,
                            ""message"": ""We need ID!!"",
                            ""responseType"": ""object"",
                            ""responseModel"": ""git.corp.adobe.com.personal.test1.APIError""
                        },
                        {
                            ""code"": 404,
                            ""message"": ""Can not find ID"",
                            ""responseType"": ""object"",
                            ""responseModel"": ""git.corp.adobe.com.personal.test1.APIError""
                        }
                    ],
                    ""produces"": [
                        ""application/json""
                    ]
                }
            ]
        },
        {
            ""path"": ""/testapi/get-array-of-interfaces"",
            ""description"": ""get array of interfaces"",
            ""operations"": [
                {
                    ""httpMethod"": ""GET"",
                    ""nickname"": ""GetArrayOfInterfaces"",
                    ""type"": ""array"",
                    ""items"": {
                        ""$ref"": ""git.corp.adobe.com.personal.test1.InterfaceType""
                    },
                    ""summary"": ""get array of interfaces"",
                    ""responseMessages"": [
                        {
                            ""code"": 200,
                            ""message"": """",
                            ""responseType"": ""array"",
                            ""responseModel"": ""git.corp.adobe.com.personal.test1.InterfaceType""
                        },
                        {
                            ""code"": 400,
                            ""message"": ""We need ID!!"",
                            ""responseType"": ""object"",
                            ""responseModel"": ""git.corp.adobe.com.personal.test1.APIError""
                        },
                        {
                            ""code"": 404,
                            ""message"": ""Can not find ID"",
                            ""responseType"": ""object"",
                            ""responseModel"": ""git.corp.adobe.com.personal.test1.APIError""
                        }
                    ],
                    ""produces"": [
                        ""application/json""
                    ]
                }
            ]
        },
        {
            ""path"": ""/testapi/get-struct3"",
            ""description"": ""get struct3"",
            ""operations"": [
                {
                    ""httpMethod"": ""GET"",
                    ""nickname"": ""GetStruct3"",
                    ""type"": ""git.corp.adobe.com.personal.test1.StructureWithSlice"",
                    ""items"": {},
                    ""summary"": ""get struct3"",
                    ""responseMessages"": [
                        {
                            ""code"": 200,
                            ""message"": """",
                            ""responseType"": ""object"",
                            ""responseModel"": ""git.corp.adobe.com.personal.test1.StructureWithSlice""
                        },
                        {
                            ""code"": 400,
                            ""message"": ""We need ID!!"",
                            ""responseType"": ""object"",
                            ""responseModel"": ""git.corp.adobe.com.personal.test1.APIError""
                        },
                        {
                            ""code"": 404,
                            ""message"": ""Can not find ID"",
                            ""responseType"": ""object"",
                            ""responseModel"": ""git.corp.adobe.com.personal.test1.APIError""
                        }
                    ],
                    ""produces"": [
                        ""application/json""
                    ]
                }
            ]
        }
    ],
    ""models"": {
        ""git.corp.adobe.com.personal.test1.APIError"": {
            ""id"": ""git.corp.adobe.com.personal.test1.APIError"",
            ""properties"": {
                ""ErrorCode"": {
                    ""type"": ""int"",
                    ""description"": """",
                    ""items"": {},
                    ""format"": """"
                },
                ""ErrorMessage"": {
                    ""type"": ""string"",
                    ""description"": """",
                    ""items"": {},
                    ""format"": """"
                }
            }
        },
        ""git.corp.adobe.com.personal.test1.InterfaceType"": {
            ""id"": ""git.corp.adobe.com.personal.test1.InterfaceType"",
            ""properties"": null
        },
        ""git.corp.adobe.com.personal.test1.SimpleStructureWithAnnotations"": {
            ""id"": ""git.corp.adobe.com.personal.test1.SimpleStructureWithAnnotations"",
            ""required"": [
                ""Name""
            ],
            ""properties"": {
                ""Name"": {
                    ""type"": ""string"",
                    ""description"": """",
                    ""items"": {},
                    ""format"": """"
                },
                ""id"": {
                    ""type"": ""int"",
                    ""description"": """",
                    ""items"": {},
                    ""format"": """"
                }
            }
        },
        ""git.corp.adobe.com.personal.test1.StructureWithEmbededPointer"": {
            ""id"": ""git.corp.adobe.com.personal.test1.StructureWithEmbededPointer"",
            ""properties"": {
                ""Id"": {
                    ""type"": ""int"",
                    ""description"": """",
                    ""items"": {},
                    ""format"": """"
                },
                ""Name"": {
                    ""type"": ""array"",
                    ""description"": """",
                    ""items"": {
                        ""type"": ""byte""
                    },
                    ""format"": """"
                }
            }
        },
        ""git.corp.adobe.com.personal.test1.StructureWithEmbededStructure"": {
            ""id"": ""git.corp.adobe.com.personal.test1.StructureWithEmbededStructure"",
            ""properties"": {
                ""Id"": {
                    ""type"": ""int"",
                    ""description"": """",
                    ""items"": {},
                    ""format"": """"
                },
                ""Name"": {
                    ""type"": ""array"",
                    ""description"": """",
                    ""items"": {
                        ""type"": ""byte""
                    },
                    ""format"": """"
                }
            }
        },
        ""git.corp.adobe.com.personal.test1.StructureWithSlice"": {
            ""id"": ""git.corp.adobe.com.personal.test1.StructureWithSlice"",
            ""properties"": {
                ""Id"": {
                    ""type"": ""int"",
                    ""description"": """",
                    ""items"": {},
                    ""format"": """"
                },
                ""Name"": {
                    ""type"": ""array"",
                    ""description"": """",
                    ""items"": {
                        ""type"": ""byte""
                    },
                    ""format"": """"
                }
            }
        }
    }
}`,}",24714
40185912,1252,"package main

import (
    ""fmt""
    term ""github.com/nsf/termbox-go""
)

func reset() {
    term.Sync() // cosmestic purpose
}

func main() {
    err := term.Init()
    if err != nil {
        panic(err)
    }

    defer term.Close()

    fmt.Println(""Enter any key to see their ASCII code or press ESC button to quit"")

keyPressListenerLoop:
    for {
        switch ev := term.PollEvent(); ev.Type {
        case term.EventKey:
            switch ev.Key {
            case term.KeyEsc:
                break keyPressListenerLoop
            case term.KeyF1:
                reset()
                fmt.Println(""F1 pressed"")
            case term.KeyF2:
                reset()
                fmt.Println(""F2 pressed"")
            case term.KeyF3:
                reset()
                fmt.Println(""F3 pressed"")
            case term.KeyF4:
                reset()
                fmt.Println(""F4 pressed"")
            case term.KeyF5:
                reset()
                fmt.Println(""F5 pressed"")
            case term.KeyF6:
                reset()
                fmt.Println(""F6 pressed"")
            case term.KeyF7:
                reset()
                fmt.Println(""F7 pressed"")
            case term.KeyF8:
                reset()
                fmt.Println(""F8 pressed"")
            case term.KeyF9:
                reset()
                fmt.Println(""F9 pressed"")
            case term.KeyF10:
                reset()
                fmt.Println(""F10 pressed"")
            case term.KeyF11:
                reset()
                fmt.Println(""F11 pressed"")
            case term.KeyF12:
                reset()
                fmt.Println(""F12 pressed"")
            case term.KeyInsert:
                reset()
                fmt.Println(""Insert pressed"")
            case term.KeyDelete:
                reset()
                fmt.Println(""Delete pressed"")
            case term.KeyHome:
                reset()
                fmt.Println(""Home pressed"")
            case term.KeyEnd:
                reset()
                fmt.Println(""End pressed"")
            case term.KeyPgup:
                reset()
                fmt.Println(""Page Up pressed"")
            case term.KeyPgdn:
                reset()
                fmt.Println(""Page Down pressed"")
            case term.KeyArrowUp:
                reset()
                fmt.Println(""Arrow Up pressed"")
            case term.KeyArrowDown:
                reset()
                fmt.Println(""Arrow Down pressed"")
            case term.KeyArrowLeft:
                reset()
                fmt.Println(""Arrow Left pressed"")
            case term.KeyArrowRight:
                reset()
                fmt.Println(""Arrow Right pressed"")
            case term.KeySpace:
                reset()
                fmt.Println(""Space pressed"")
            case term.KeyBackspace:
                reset()
                fmt.Println(""Backspace pressed"")
            case term.KeyEnter:
                reset()
                fmt.Println(""Enter pressed"")
            case term.KeyTab:
                reset()
                fmt.Println(""Tab pressed"")

            default:
                // we only want to read a single character or one key pressed event
                reset()
                fmt.Println(""ASCII : "", ev.Ch)

            }
        case term.EventError:
            panic(ev.Err)
        }
    }
}",3397
40187186,1255,"func (p *parser) shuntingyard(input token.TQueue) *ast.Node {
    var operands ast.NStack
    var operators *token.TStack

    operands = make(ast.NStack, 0)
    operators = token.TokenStack()

    for tok := input.Dequeue(); tok.Sym != ""EOF""; tok = input.Dequeue() {
        switch tok.Kind {
        case ""LParen"":
            operators.Push(tok)
        case ""RParen"":
            for {
                // pop item (""("" or operator) from stack
                if operators.Empty() {
                    p.errorf(""Unmatched parenthesis on line %d, expected '(' to match closing parenthesis in expression"", p.lno)
                }

                op := operators.Pop()
                if op.Sym == ""("" {
                    break // discard ""(""
                }

                if isUnary(op.Sym) {
                    node := ast.MakeNode(*op)
                    node.AddChild(operands.Pop())
                    operands.Push(node)
                    break
                }

                RHS := operands.Pop()
                LHS := operands.Pop()
                operands.Push(ast.MakeParentNode(*op, RHS, LHS))
            }
        default:
            if o1, isOp := prOps[tok.Sym]; isOp {
                // token is an operator
                for !operators.Empty() {
                    // consider top item on stack
                    op := operators.PeekTop()
                    if o2, isOp := prOps[op.Sym]; !isOp || o1.prec > o2.prec || o1.prec == o2.prec && o1.rAssoc {
                        break
                    }

                    // top item is an operator that needs to come off
                    op = operators.Pop()
                    if isUnary(op.Sym) {
                        node := ast.MakeNode(*op)
                        node.AddChild(operands.Pop())
                        operands.Push(node)
                        break
                    }
                    RHS := operands.Pop()
                    LHS := operands.Pop()
                    operands.Push(ast.MakeParentNode(*op, RHS, LHS))
                }
                // push operator (the new one) to stack
                operators.Push(tok)
            } else {
                operands.Push(ast.MakeNode(*tok))
            }
        }
    }

    // drain stack to result
    for !operators.Empty() {
        if operators.PeekTop().Sym == ""("" {
            p.errorf(""Unmatched parenthesis on line %d, expected ')' to match previous parenthesis in expression"", p.lno)
        }

        RHS := operands.Pop()
        LHS := operands.Pop()
        operands.Push(ast.MakeParentNode(*operators.Pop(), RHS, LHS))
    }

    result := operands.Pop()
    for !operands.Empty() {
        result.AddSibling(operands.Pop())
    }

    return result
}",2766
40331761,1269,2>&1,4
40478523,1277,"type (
        Employee struct {
            Name               string
            Password           string
           EmailAddress       string
           Position           string
           Gender             string
           Nationality        string
           Department         string
           MaritalStatus      string
           Approvedby         string
           JoinDate           time.Time
           ConfirmationDate   time.Time
           EndDate            time.Time
            Leave             []*LeaveInfo  
        }
        LeaveInfo struct {
            Total        float64
            Id           int
            Days         float64
            From        time.Time
             To          time.Time  
            Status       string
            Certificate  []*CertificateInfo
        }
        CertificateInfo struct {
            FileName string
            FileType string
            FileSize int

        }",948
40511495,1281,"2016-11-09T03:06:41.240-0500 I JOURNAL  [journal writer] warning couldn't write to / rename file /data/data/db/journal/prealloc.2: Couldn't open directory '/data/data/db/journal' for flushing: errno:24 Too many open files
2016-11-09T03:06:41.240-0500 I JOURNAL  [journal writer] warning exception opening journal file couldn't open file /data/data/db/journal/j._213 for writing errno:9 Bad file descriptor
2016-11-09T03:06:41.240-0500 I JOURNAL  [journal writer] error exception in dur::journal couldn't open file /data/data/db/journal/j._213 for writing errno:9 Bad file descriptor
2016-11-09T03:06:41.242-0500 F JOURNAL  [journal writer] dbexception in journalWriterThread causing immediate shutdown: 13516 couldn't open file /data/data/db/journal/j._213 for writing errno:9 Bad file descriptor
2016-11-09T03:06:41.242-0500 I -        [journal writer] Invariant failure false src/mongo/db/storage/mmap_v1/dur_journal_writer.cpp 258
2016-11-09T03:06:41.246-0500 I JOURNAL  [durability] warning couldn't write to / rename file /data/data/db/journal/prealloc.2: couldn't open file /data/data/db/journal/prealloc.2 for writing errno:9 Bad file descriptor
2016-11-09T03:06:41.246-0500 F JOURNAL  [durability] dbexception in durThread causing immediate shutdown: 13516 couldn't open file /data/data/db/journal/j._213 for writing errno:9 Bad file descriptor
2016-11-09T03:06:41.246-0500 I -        [durability] Invariant failure false src/mongo/db/storage/mmap_v1/dur.cpp 862
2016-11-09T03:06:41.246-0500 I CONTROL  [journal writer]
 0xf51949 0xef1671 0xed6192 0xd17613 0xf9f9b4 0x7fd09697d184 0x7fd09544337d
----- BEGIN BACKTRACE -----
{""backtrace"":[{""b"":""400000"",""o"":""B51949""},{""b"":""400000"",""o"":""AF1671""},{""b"":""400000"",""o"":""AD6192""},{""b"":""400000"",""o"":""917613""},{""b"":""400000"",""o"":""B9F9B4""},{""b"":""7FD096975000"",""o"":""8184""},{""b"":""7FD095349000"",""o"":""FA37D""}],""processInfo"":{ ""mongodbVersion"" : ""3.0.3"", ""gitVersion"" : ""b40106b36eecd1b4407eb1ad1af6bc60593c6105"", ""uname"" : { ""sysname"" : ""Linux"", ""release"" : ""3.13.0-54-generic"", ""version"" : ""#91-Ubuntu SMP Tue May 26 19:15:08 UTC 2015"", ""machine"" : ""x86_64"" }, ""somap"" : [ { ""elfType"" : 2, ""b"" : ""400000"", ""buildId"" : ""F56F80CB96B4DBFC070BEB0ADAC7D6B274BFC6B1"" }, { ""b"" : ""7FFF14FD0000"", ""elfType"" : 3, ""buildId"" : ""1C0D0A18FF043EED9EE11DB5E5E90A3F74729341"" }, { ""b"" : ""7FD096975000"", ""path"" : ""/lib/x86_64-linux-gnu/libpthread.so.0"", ""elfType"" : 3, ""buildId"" : ""31E9F21AE8C10396171F1E13DA15780986FA696C"" }, { ""b"" : ""7FD096716000"", ""path"" : ""/lib/x86_64-linux-gnu/libssl.so.1.0.0"", ""elfType"" : 3, ""buildId"" : ""74864DB9D5F69D39A67E4755012FB6573C469B3D"" }, { ""b"" : ""7FD09633A000"", ""path"" : ""/lib/x86_64-linux-gnu/libcrypto.so.1.0.0"", ""elfType"" : 3, ""buildId"" : ""AAE7CFF8351B730830BDBCE0DCABBE06574B7144"" }, { ""b"" : ""7FD096132000"", ""path"" : ""/lib/x86_64-linux-gnu/librt.so.1"", ""elfType"" : 3, ""buildId"" : ""E2A6DD5048A0A051FD61043BDB69D8CC68192AB7"" }, { ""b"" : ""7FD095F2E000"", ""path"" : ""/lib/x86_64-linux-gnu/libdl.so.2"", ""elfType"" : 3, ""buildId"" : ""DA9B8C234D0FE9FD8CAAC8970A7EC1B6C8F6623F"" }, { ""b"" : ""7FD095C2A000"", ""path"" : ""/usr/lib/x86_64-linux-gnu/libstdc++.so.6"", ""elfType"" : 3, ""buildId"" : ""76190E922AF7457D078F75C9B15FA184E83EB506"" }, { ""b"" : ""7FD095924000"", ""path"" : ""/lib/x86_64-linux-gnu/libm.so.6"", ""elfType"" : 3, ""buildId"" : ""D144258E614900B255A31F3FD2283A878670D5BC"" }, { ""b"" : ""7FD09570E000"", ""path"" : ""/lib/x86_64-linux-gnu/libgcc_s.so.1"", ""elfType"" : 3, ""buildId"" : ""36311B4457710AE5578C4BF00791DED7359DBB92"" }, { ""b"" : ""7FD095349000"", ""path"" : ""/lib/x86_64-linux-gnu/libc.so.6"", ""elfType"" : 3, ""buildId"" : ""CF699A15CAAE64F50311FC4655B86DC39A479789"" }, { ""b"" : ""7FD096B93000"", ""path"" : ""/lib64/ld-linux-x86-64.so.2"", ""elfType"" : 3, ""buildId"" : ""D0F537904076D73F29E4A37341F8A449E2EF6CD0"" } ] }}
 mongod(_ZN5mongo15printStackTraceERSo+0x29) [0xf51949]
 mongod(_ZN5mongo10logContextEPKc+0xE1) [0xef1671]
 mongod(_ZN5mongo15invariantFailedEPKcS1_j+0xB2) [0xed6192]
 mongod(_ZN5mongo3dur13JournalWriter20_journalWriterThreadEv+0x953) [0xd17613]
 mongod(+0xB9F9B4) [0xf9f9b4]
 libpthread.so.0(+0x8184) [0x7fd09697d184]
 libc.so.6(clone+0x6D) [0x7fd09544337d]",4109
40770786,1285,go get github.com/go-vgo/robotgo,32
40785588,1287,defer profile.Start(profile.CPUProfile).Stop(),46
40796666,1292,"type Employee struct {
        Name               string
        EmpId              string
        Password           string
        PhoneNumber        int32
        EmailAddress       string
        Position           string
        AccessLevel        string
        Gender             string
        MaritalStatus      string
        Nationality        string
        Department         string
        ICNumber           string
        JoinDate           time.Time
        ConfirmationDate   time.Time
        EndDate            time.Time
        AnnualLeave        []*AnnualLeaveInfo
        MedicalLeave       []*MedicalLeaveInfo
        NopayLeave         []*NopayLeaveInfo
        ChildcareLeave     []*ChildcareLeaveInfo
    }

type AnnualLeaveInfo struct {
        Id           int
        Days         float64
        Type         string
        From         time.Time
        To           time.Time
        AppliedDate  time.Time
        Status       string
        Certificate  []*CertificateInfo
    }",1014
40866471,1295,"package ipvs

import (
    ""net""
    ""syscall""
    ""fmt""
    ""os/exec""
    ""strings""
    ""github.com/vishvananda/netlink/nl""
    ""bytes""
    ""encoding/binary""
)

// Service defines an IPVS service in its entirety.
type Service struct {
    // Virtual service address.
    Address  net.IP
    Protocol uint16
    Port     uint16
    FWMark   uint32 // Firewall mark of the service.

    // Virtual service options.
    SchedName     string
    Flags         uint32
    Timeout       uint32
    Netmask       uint32
    AddressFamily uint16
    PEName        string
}

// Destination defines an IPVS destination (real server) in its
// entirety.
type Destination struct {
    Address         net.IP
    Port            uint16
    Weight          int
    ConnectionFlags uint32
    AddressFamily   uint16
    UpperThreshold  uint32
    LowerThreshold  uint32
}


type ServiceDestination struct {
    Service *Service
    Destinations []*Destination
}

// Handle provides an ipvs handle to program ipvs rules.
type IPVSHandle struct {
    ipvsFamily int
}

// NewIPVSHandler provides a new ipvs handler
func NewIPVSHandle() (*IPVSHandle, error) {
    if out, err := exec.Command(""modprobe"", ""-va"", ""ip_vs"").CombinedOutput(); err != nil {
        return nil, fmt.Errorf(""Running modprobe ip_vs failed with message: `%s`, error: %v"", strings.TrimSpace(string(out)), err)
    }

    ipvsFamily, err := getIPVSFamily()
    if err != nil {
        return nil, fmt.Errorf(""Could not get ipvs family information from the kernel. It is possible that ipvs is not enabled in your kernel."")
    }

    return &IPVSHandle{ipvsFamily: ipvsFamily}, nil
}

func ( i *IPVSHandle) Restore(items []ServiceDestination)([][]byte, error) {
    req := nl.NewNetlinkRequest(i.ipvsFamily, syscall.NLM_F_REPLACE)
    req.AddData(&genlMsgHdr{cmd: ipvsCmdSetConfig, version: 1})


    listAttr := nl.NewRtAttr(ipvsCmdAttrUnspec, nl.Uint16Attr(uint16(i.ipvsFamily)))

    for _, item := range  items {
        itemAttr := nl.NewRtAttr(ipvsCmdAttrUnspec, nl.Uint16Attr(uint16(i.ipvsFamily)))

        srvAttr := toServiceAttr(item.Service)
        nl.NewRtAttrChild(itemAttr, ipvsCmdAttrService, srvAttr.Serialize())

        for _, d := range item.Destinations {
            nl.NewRtAttrChild(itemAttr, ipvsCmdAttrDest, fillDestinaton(d).Serialize())
        }

        nl.NewRtAttrChild(listAttr, ipvsCmdAttrUnspec, itemAttr.Serialize())
    }

    req.AddData(listAttr)
    return req.Execute(syscall.NETLINK_GENERIC, 0)
}

func toServiceAttr(s *Service) *nl.RtAttr {
    cmdAttr := nl.NewRtAttr(ipvsCmdAttrService, nil)
    nl.NewRtAttrChild(cmdAttr, ipvsSvcAttrAddressFamily, nl.Uint16Attr(s.AddressFamily))
    if s.FWMark != 0 {
        nl.NewRtAttrChild(cmdAttr, ipvsSvcAttrFWMark, nl.Uint32Attr(s.FWMark))
    } else {
        nl.NewRtAttrChild(cmdAttr, ipvsSvcAttrProtocol, nl.Uint16Attr(s.Protocol))
        nl.NewRtAttrChild(cmdAttr, ipvsSvcAttrAddress, rawIPData(s.Address))

        // Port needs to be in network byte order.
        portBuf := new(bytes.Buffer)
        binary.Write(portBuf, binary.BigEndian, s.Port)
        nl.NewRtAttrChild(cmdAttr, ipvsSvcAttrPort, portBuf.Bytes())
    }

    nl.NewRtAttrChild(cmdAttr, ipvsSvcAttrSchedName, nl.ZeroTerminated(s.SchedName))
    if s.PEName != """" {
        nl.NewRtAttrChild(cmdAttr, ipvsSvcAttrPEName, nl.ZeroTerminated(s.PEName))
    }

    f := &ipvsFlags{
        flags: s.Flags,
        mask:  0xFFFFFFFF,
    }
    nl.NewRtAttrChild(cmdAttr, ipvsSvcAttrFlags, f.Serialize())
    nl.NewRtAttrChild(cmdAttr, ipvsSvcAttrTimeout, nl.Uint32Attr(s.Timeout))
    nl.NewRtAttrChild(cmdAttr, ipvsSvcAttrNetmask, nl.Uint32Attr(s.Netmask))
    return cmdAttr
}

func fillDestinaton(d *Destination) nl.NetlinkRequestData {
    cmdAttr := nl.NewRtAttr(ipvsCmdAttrDest, nil)

    nl.NewRtAttrChild(cmdAttr, ipvsDestAttrAddress, rawIPData(d.Address))
    // Port needs to be in network byte order.
    portBuf := new(bytes.Buffer)
    binary.Write(portBuf, binary.BigEndian, d.Port)
    nl.NewRtAttrChild(cmdAttr, ipvsDestAttrPort, portBuf.Bytes())

    nl.NewRtAttrChild(cmdAttr, ipvsDestAttrForwardingMethod, nl.Uint32Attr(d.ConnectionFlags&ConnectionFlagFwdMask))
    nl.NewRtAttrChild(cmdAttr, ipvsDestAttrWeight, nl.Uint32Attr(uint32(d.Weight)))
    nl.NewRtAttrChild(cmdAttr, ipvsDestAttrUpperThreshold, nl.Uint32Attr(d.UpperThreshold))
    nl.NewRtAttrChild(cmdAttr, ipvsDestAttrLowerThreshold, nl.Uint32Attr(d.LowerThreshold))

    return cmdAttr
}",4484
41146449,1296,"var SAMLRESPONSE=""PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48c2FtbDJwOlJlc3BvbnNlIHhtbG5zOnNhbWwycD0idXJuOm9hc2lzOm5hbWVzOnRjOlNBTUw6Mi4wOnByb3RvY29sIiBEZXN0aW5hdGlvbj0iaHR0cHM6Ly9va3RhcHJveHkuY29tL3NhbWwucGhwIiBJRD0iaWQ3NjY1MjM5NDM4MTIxMjU5MjA4MDc2Mjc1MSIgSXNzdWVJbnN0YW50PSIyMDE2LTEyLTE0VDE1OjIwOjMwLjA0M1oiIFZlcnNpb249IjIuMCI+PHNhbWwyOklzc3VlciB4bWxuczpzYW1sMj0idXJuOm9hc2lzOm5hbWVzOnRjOlNBTUw6Mi4wOmFzc2VydGlvbiIgRm9ybWF0PSJ1cm46b2FzaXM6bmFtZXM6dGM6U0FNTDoyLjA6bmFtZWlkLWZvcm1hdDplbnRpdHkiPmh0dHA6Ly93d3cub2t0YS5jb20vZXhrMTc3NWZzdWdrcDBETlcxZDg8L3NhbWwyOklzc3Vlcj48ZHM6U2lnbmF0dXJlIHhtbG5zOmRzPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwLzA5L3htbGRzaWcjIj48ZHM6U2lnbmVkSW5mbz48ZHM6Q2Fub25pY2FsaXphdGlvbk1ldGhvZCBBbGdvcml0aG09Imh0dHA6Ly93d3cudzMub3JnLzIwMDEvMTAveG1sLWV4Yy1jMTRuIyIvPjxkczpTaWduYXR1cmVNZXRob2QgQWxnb3JpdGhtPSJodHRwOi8vd3d3LnczLm9yZy8yMDAxLzA0L3htbGRzaWctbW9yZSNyc2Etc2hhMjU2Ii8+PGRzOlJlZmVyZW5jZSBVUkk9IiNpZDc2NjUyMzk0MzgxMjEyNTkyMDgwNzYyNzUxIj48ZHM6VHJhbnNmb3Jtcz48ZHM6VHJhbnNmb3JtIEFsZ29yaXRobT0iaHR0cDovL3d3dy53My5vcmcvMjAwMC8wOS94bWxkc2lnI2VudmVsb3BlZC1zaWduYXR1cmUiLz48ZHM6VHJhbnNmb3JtIEFsZ29yaXRobT0iaHR0cDovL3d3dy53My5vcmcvMjAwMS8xMC94bWwtZXhjLWMxNG4jIi8+PC9kczpUcmFuc2Zvcm1zPjxkczpEaWdlc3RNZXRob2QgQWxnb3JpdGhtPSJodHRwOi8vd3d3LnczLm9yZy8yMDAxLzA0L3htbGVuYyNzaGEyNTYiLz48ZHM6RGlnZXN0VmFsdWU+cmFTS0Nna3ZxdDYzTjlCUWJpSHNxNGk3akt6K2FNK1lwT2VaVE1xdHhZRT08L2RzOkRpZ2VzdFZhbHVlPjwvZHM6UmVmZXJlbmNlPjwvZHM6U2lnbmVkSW5mbz48ZHM6U2lnbmF0dXJlVmFsdWU+UWgrK2VUTzU0RWd1eExCM3NFMFA5QW1Tekc3NVFwQlk0enZEUHlocHM5U0VCTEduQWg3cG1tUG1FdFJpemQvVWdsQU5lZmQ3dTVXZjZ1ZklpN09MR1plSU4xUUJTd0VidkRaMGVSNmkrN21ucDNUcjV2bnhtOXBiYlBYSlErS1liV3F4bk5pRXppNWUwYjNjTXVxWDlVTVlaQmlpMGR1K2U5MEphQ0pKRFY4eHhGMXpJMDhjU1A0UG8vVnFsSk9qU1I5SjlrSG93MzVlanJiV2tGV2lpZXlra3VoNUV3RmNJMC92dVVEVXA4MUc0eHVKUVRIZlFRSk1VdVBsT1Y5ZXB4UVF3RnNNZUJFb3NRZW04Zit0Q2ZhNVFiNzg0eUYweitCTS85V2tQbC93K3JtZ1dpd0h5dDJ3ZWVLRS9iT3lrYzlzZTZMVmZmNnJpbml4WjhxWCtnPT08L2RzOlNpZ25hdHVyZVZhbHVlPjxkczpLZXlJbmZvPjxkczpYNTA5RGF0YT48ZHM6WDUwOUNlcnRpZmljYXRlPk1JSURvRENDQW9pZ0F3SUJBZ0lHQVV0Q1RoSWJNQTBHQ1NxR1NJYjNEUUVCQlFVQU1JR1FNUXN3Q1FZRFZRUUdFd0pWVXpFVE1CRUcKQTFVRUNBd0tRMkZzYVdadmNtNXBZVEVXTUJRR0ExVUVCd3dOVTJGdUlFWnlZVzVqYVhOamJ6RU5NQXNHQTFVRUNnd0VUMnQwWVRFVQpNQklHQTFVRUN3d0xVMU5QVUhKdmRtbGtaWEl4RVRBUEJnTlZCQU1NQ0dOdmJYQmhibmw0TVJ3d0dnWUpLb1pJaHZjTkFRa0JGZzFwCmJtWnZRRzlyZEdFdVkyOXRNQjRYRFRFMU1ERXpNVEl6TWpJd04xb1hEVFExTURFek1USXpNak13TjFvd2daQXhDekFKQmdOVkJBWVQKQWxWVE1STXdFUVlEVlFRSURBcERZV3hwWm05eWJtbGhNUll3RkFZRFZRUUhEQTFUWVc0Z1JuSmhibU5wYzJOdk1RMHdDd1lEVlFRSwpEQVJQYTNSaE1SUXdFZ1lEVlFRTERBdFRVMDlRY205MmFXUmxjakVSTUE4R0ExVUVBd3dJWTI5dGNHRnVlWGd4SERBYUJna3Foa2lHCjl3MEJDUUVXRFdsdVptOUFiMnQwWVM1amIyMHdnZ0VpTUEwR0NTcUdTSWIzRFFFQkFRVUFBNElCRHdBd2dnRUtBb0lCQVFEdy9ZTnkKMHdSc3dRM212Rkw3RVdTcFlJVnVrQnNvaTBMWXBYcjdKZy9JdVlGYlZqdjlxRlJqL2VHbHJtdm5rOWhiU0x4c2UydGErakV5YVFwdQpJK0UvTGwrRmlLVC9DazV3UlZRTzd3ZlVzVkxHRXlNN2tXcitFeGFoTEwzS0hLeXI5MzRSWXZVMTYwdHFXdjB1QldIZEE5ZHoranh5CmdWVWMwM1hLZEtnd0pLSFhXNmdObFFaQVMwWlJhbDA1VDBEa1VJekVjL0xBRXlMU2ZBdlRzL0R5RFkxNDFtYUlIbml2S0hVcmhFZzMKWTRRY0UvZUNZZDc3UXFoY2Y0aEFzR3BYVi9wemZYWlpKTmpPSEtsTElEUTZ3dUxQeVBwa2tiSURHRjZmWGVqTkVrY1pjeWoycWlpYwp5dmtNL3NUZ2NabFIwQWd6eHY3UHN1ZXp2YmhueUdtZkFnTUJBQUV3RFFZSktvWklodmNOQVFFRkJRQURnZ0VCQUkvbFhvWXo0d2ZGCmNNZFNPOXBINUJTQ0NYTDN0Y0ZrMnI3VXQ2OEhyWUtLZDV4TWhSelVYN1BuOWFlNzJaR2diL0dYK3RVdkdlc3N2YUVzZXhsSDdIMmwKeHEydG5lTU13d3hQNkgyRnRESlhoV3A0THdMV0Jobkp1Q2RZMVg5b0NWWHVYQlhoMjFLaUtwV0dhQ3krRUptSmNBSEZKTHpsL3pKKwp4WkM3MTNRcGJ2bUlsc1hRaFNtaWc2VUJ3NHhGSDArUHlyUU5za1Y3OS8wUnpMYTlQNHdZU0g5ZzZBUlQyYXBuVlRPUy9abzJsUzNjCnFHeG9CdDJqSkpJV3N6SXZ5ZGs1Mi9adXVXV0FPbzdrNzJuM283TTk3cW5QZHNFRWgwS2ludUY2ZjZSUXd6RHk5citiU0VYRzhDeUkKMnd3Y0tSWGx1bm5tZ3ZCczVvUURiaFRHeERZPTwvZHM6WDUwOUNlcnRpZmljYXRlPjwvZHM6WDUwOURhdGE+PC9kczpLZXlJbmZvPjwvZHM6U2lnbmF0dXJlPjxzYW1sMnA6U3RhdHVzIHhtbG5zOnNhbWwycD0idXJuOm9hc2lzOm5hbWVzOnRjOlNBTUw6Mi4wOnByb3RvY29sIj48c2FtbDJwOlN0YXR1c0NvZGUgVmFsdWU9InVybjpvYXNpczpuYW1lczp0YzpTQU1MOjIuMDpzdGF0dXM6U3VjY2VzcyIvPjwvc2FtbDJwOlN0YXR1cz48c2FtbDI6QXNzZXJ0aW9uIHhtbG5zOnNhbWwyPSJ1cm46b2FzaXM6bmFtZXM6dGM6U0FNTDoyLjA6YXNzZXJ0aW9uIiBJRD0iaWQ3NjY1MjM5NDM4Mjg1MDQzMTg3ODcwMzg2MyIgSXNzdWVJbnN0YW50PSIyMDE2LTEyLTE0VDE1OjIwOjMwLjA0M1oiIFZlcnNpb249IjIuMCI+PHNhbWwyOklzc3VlciBGb3JtYXQ9InVybjpvYXNpczpuYW1lczp0YzpTQU1MOjIuMDpuYW1laWQtZm9ybWF0OmVudGl0eSIgeG1sbnM6c2FtbDI9InVybjpvYXNpczpuYW1lczp0YzpTQU1MOjIuMDphc3NlcnRpb24iPmh0dHA6Ly93d3cub2t0YS5jb20vZXhrMTc3NWZzdWdrcDBETlcxZDg8L3NhbWwyOklzc3Vlcj48ZHM6U2lnbmF0dXJlIHhtbG5zOmRzPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwLzA5L3htbGRzaWcjIj48ZHM6U2lnbmVkSW5mbz48ZHM6Q2Fub25pY2FsaXphdGlvbk1ldGhvZCBBbGdvcml0aG09Imh0dHA6Ly93d3cudzMub3JnLzIwMDEvMTAveG1sLWV4Yy1jMTRuIyIvPjxkczpTaWduYXR1cmVNZXRob2QgQWxnb3JpdGhtPSJodHRwOi8vd3d3LnczLm9yZy8yMDAxLzA0L3htbGRzaWctbW9yZSNyc2Etc2hhMjU2Ii8+PGRzOlJlZmVyZW5jZSBVUkk9IiNpZDc2NjUyMzk0MzgyODUwNDMxODc4NzAzODYzIj48ZHM6VHJhbnNmb3Jtcz48ZHM6VHJhbnNmb3JtIEFsZ29yaXRobT0iaHR0cDovL3d3dy53My5vcmcvMjAwMC8wOS94bWxkc2lnI2VudmVsb3BlZC1zaWduYXR1cmUiLz48ZHM6VHJhbnNmb3JtIEFsZ29yaXRobT0iaHR0cDovL3d3dy53My5vcmcvMjAwMS8xMC94bWwtZXhjLWMxNG4jIi8+PC9kczpUcmFuc2Zvcm1zPjxkczpEaWdlc3RNZXRob2QgQWxnb3JpdGhtPSJodHRwOi8vd3d3LnczLm9yZy8yMDAxLzA0L3htbGVuYyNzaGEyNTYiLz48ZHM6RGlnZXN0VmFsdWU+Q2xSdWgyZCtkVUZFakZlMHU0TEsrdTNTMXppZUI3SWtlU216alYvaGkrcz08L2RzOkRpZ2VzdFZhbHVlPjwvZHM6UmVmZXJlbmNlPjwvZHM6U2lnbmVkSW5mbz48ZHM6U2lnbmF0dXJlVmFsdWU+Y01PL1ZPTDA5bEZ6bExyTTJQYVM5Q1hPZWRlNUE2R0IyWm5nREVkVWMvdGNsa0Z4MlpxNWlRS3VwdEVudTJjbkNyK0dRb21kRlY3UDFPVjdTUWZPQWNYdlRvS1NuMHpPVDdmMjhaM1FYQnQrWmY3YkJlYi81dnZ1cFNiM2N1bVdpZk5GSHdxMHZpRlN1VVdZN2VBMTE0NUMxNVBTd3owakhVaHRPRzRGdlcwZkJYQlJ1R1ZSVG1rQnJqd0UyTzhWc3RBNEZ3K1JNZEVvaDlnT1llbnQzQklQdlBzb2tCdENPeWhxNGs3QjNTc2hlLzhvWDI2ODkxZllXSHRtaXhmUEVPTzhNYlRrdkFOQm9CQ0JoK3JvdVVobzlpTG8zeW9ZcGlOQ2lCTVZGdXVRZWx6SUpZYUhqcjVFKzU1WWNsaFoyZ1hjV1BYZXNjeXpFTW9rWmV3YklBPT08L2RzOlNpZ25hdHVyZVZhbHVlPjxkczpLZXlJbmZvPjxkczpYNTA5RGF0YT48ZHM6WDUwOUNlcnRpZmljYXRlPk1JSURvRENDQW9pZ0F3SUJBZ0lHQVV0Q1RoSWJNQTBHQ1NxR1NJYjNEUUVCQlFVQU1JR1FNUXN3Q1FZRFZRUUdFd0pWVXpFVE1CRUcKQTFVRUNBd0tRMkZzYVdadmNtNXBZVEVXTUJRR0ExVUVCd3dOVTJGdUlFWnlZVzVqYVhOamJ6RU5NQXNHQTFVRUNnd0VUMnQwWVRFVQpNQklHQTFVRUN3d0xVMU5QVUhKdmRtbGtaWEl4RVRBUEJnTlZCQU1NQ0dOdmJYQmhibmw0TVJ3d0dnWUpLb1pJaHZjTkFRa0JGZzFwCmJtWnZRRzlyZEdFdVkyOXRNQjRYRFRFMU1ERXpNVEl6TWpJd04xb1hEVFExTURFek1USXpNak13TjFvd2daQXhDekFKQmdOVkJBWVQKQWxWVE1STXdFUVlEVlFRSURBcERZV3hwWm05eWJtbGhNUll3RkFZRFZRUUhEQTFUWVc0Z1JuSmhibU5wYzJOdk1RMHdDd1lEVlFRSwpEQVJQYTNSaE1SUXdFZ1lEVlFRTERBdFRVMDlRY205MmFXUmxjakVSTUE4R0ExVUVBd3dJWTI5dGNHRnVlWGd4SERBYUJna3Foa2lHCjl3MEJDUUVXRFdsdVptOUFiMnQwWVM1amIyMHdnZ0VpTUEwR0NTcUdTSWIzRFFFQkFRVUFBNElCRHdBd2dnRUtBb0lCQVFEdy9ZTnkKMHdSc3dRM212Rkw3RVdTcFlJVnVrQnNvaTBMWXBYcjdKZy9JdVlGYlZqdjlxRlJqL2VHbHJtdm5rOWhiU0x4c2UydGErakV5YVFwdQpJK0UvTGwrRmlLVC9DazV3UlZRTzd3ZlVzVkxHRXlNN2tXcitFeGFoTEwzS0hLeXI5MzRSWXZVMTYwdHFXdjB1QldIZEE5ZHoranh5CmdWVWMwM1hLZEtnd0pLSFhXNmdObFFaQVMwWlJhbDA1VDBEa1VJekVjL0xBRXlMU2ZBdlRzL0R5RFkxNDFtYUlIbml2S0hVcmhFZzMKWTRRY0UvZUNZZDc3UXFoY2Y0aEFzR3BYVi9wemZYWlpKTmpPSEtsTElEUTZ3dUxQeVBwa2tiSURHRjZmWGVqTkVrY1pjeWoycWlpYwp5dmtNL3NUZ2NabFIwQWd6eHY3UHN1ZXp2YmhueUdtZkFnTUJBQUV3RFFZSktvWklodmNOQVFFRkJRQURnZ0VCQUkvbFhvWXo0d2ZGCmNNZFNPOXBINUJTQ0NYTDN0Y0ZrMnI3VXQ2OEhyWUtLZDV4TWhSelVYN1BuOWFlNzJaR2diL0dYK3RVdkdlc3N2YUVzZXhsSDdIMmwKeHEydG5lTU13d3hQNkgyRnRESlhoV3A0THdMV0Jobkp1Q2RZMVg5b0NWWHVYQlhoMjFLaUtwV0dhQ3krRUptSmNBSEZKTHpsL3pKKwp4WkM3MTNRcGJ2bUlsc1hRaFNtaWc2VUJ3NHhGSDArUHlyUU5za1Y3OS8wUnpMYTlQNHdZU0g5ZzZBUlQyYXBuVlRPUy9abzJsUzNjCnFHeG9CdDJqSkpJV3N6SXZ5ZGs1Mi9adXVXV0FPbzdrNzJuM283TTk3cW5QZHNFRWgwS2ludUY2ZjZSUXd6RHk5citiU0VYRzhDeUkKMnd3Y0tSWGx1bm5tZ3ZCczVvUURiaFRHeERZPTwvZHM6WDUwOUNlcnRpZmljYXRlPjwvZHM6WDUwOURhdGE+PC9kczpLZXlJbmZvPjwvZHM6U2lnbmF0dXJlPjxzYW1sMjpTdWJqZWN0IHhtbG5zOnNhbWwyPSJ1cm46b2FzaXM6bmFtZXM6dGM6U0FNTDoyLjA6YXNzZXJ0aW9uIj48c2FtbDI6TmFtZUlEIEZvcm1hdD0idXJuOm9hc2lzOm5hbWVzOnRjOlNBTUw6MS4xOm5hbWVpZC1mb3JtYXQ6dW5zcGVjaWZpZWQiPm9rdGFhZG1pbkBva3RhLmNvbTwvc2FtbDI6TmFtZUlEPjxzYW1sMjpTdWJqZWN0Q29uZmlybWF0aW9uIE1ldGhvZD0idXJuOm9hc2lzOm5hbWVzOnRjOlNBTUw6Mi4wOmNtOmJlYXJlciI+PHNhbWwyOlN1YmplY3RDb25maXJtYXRpb25EYXRhIE5vdE9uT3JBZnRlcj0iMjAxNi0xMi0xNFQxNToyNTozMC4wNDRaIiBSZWNpcGllbnQ9Imh0dHBzOi8vb2t0YXByb3h5LmNvbS9zYW1sLnBocCIvPjwvc2FtbDI6U3ViamVjdENvbmZpcm1hdGlvbj48L3NhbWwyOlN1YmplY3Q+PHNhbWwyOkNvbmRpdGlvbnMgTm90QmVmb3JlPSIyMDE2LTEyLTE0VDE1OjE1OjMwLjA0NFoiIE5vdE9uT3JBZnRlcj0iMjAxNi0xMi0xNFQxNToyNTozMC4wNDRaIiB4bWxuczpzYW1sMj0idXJuOm9hc2lzOm5hbWVzOnRjOlNBTUw6Mi4wOmFzc2VydGlvbiI+PHNhbWwyOkF1ZGllbmNlUmVzdHJpY3Rpb24+PHNhbWwyOkF1ZGllbmNlPmh0dHBzOi8vb2t0YXByb3h5LmNvbS9zYW1sLnBocDwvc2FtbDI6QXVkaWVuY2U+PC9zYW1sMjpBdWRpZW5jZVJlc3RyaWN0aW9uPjwvc2FtbDI6Q29uZGl0aW9ucz48c2FtbDI6QXV0aG5TdGF0ZW1lbnQgQXV0aG5JbnN0YW50PSIyMDE2LTEyLTE0VDE1OjIwOjMwLjA0M1oiIFNlc3Npb25JbmRleD0iaWQxNDgxNzI4ODMwMDQzLjk4NjE2MDI5MCIgeG1sbnM6c2FtbDI9InVybjpvYXNpczpuYW1lczp0YzpTQU1MOjIuMDphc3NlcnRpb24iPjxzYW1sMjpBdXRobkNvbnRleHQ+PHNhbWwyOkF1dGhuQ29udGV4dENsYXNzUmVmPnVybjpvYXNpczpuYW1lczp0YzpTQU1MOjIuMDphYzpjbGFzc2VzOlBhc3N3b3JkUHJvdGVjdGVkVHJhbnNwb3J0PC9zYW1sMjpBdXRobkNvbnRleHRDbGFzc1JlZj48L3NhbWwyOkF1dGhuQ29udGV4dD48L3NhbWwyOkF1dGhuU3RhdGVtZW50Pjwvc2FtbDI6QXNzZXJ0aW9uPjwvc2FtbDJwOlJlc3BvbnNlPg==""",9052
41209838,1298,"columns := make([]series.Series, df.ncols)
for i, column := range df.columns {
    s := column.Subset(indexes)
    columns[i] = s
}
",132
41433528,1303,$.getJSON(),11
41673576,1308,filesize >= FileSizeThreshold(50000bytes),41
41741702,1314,reader.ReadString('\n'),23
41789384,1323,"game.Projection = mgl32.Perspective(mgl32.DegToRad(45), game.Screen.X / game.Screen.Y, 0.1, 10)
game.Cam = mgl32.LookAtV(mgl32.Vec3{0, 0.1, 10}, mgl32.Vec3{game.Camera.X, game.Camera.Y, 0}, mgl32.Vec3{0, 1, 0})
game.Model = mgl32.Ident4()",239
41921158,1327,"func VideosStoreHandler(w http.ResponseWriter, r *http.Request) {
    r.ParseMultipartForm(32 << 20)

    clientFile, header, err := r.FormFile(""file"")
    if err != nil {
        logs.Create(logs.LevelError, ""[VideosStoreHandler] Unable to parse uploaded file: ""+err.Error())
        return
    }
    defer clientFile.Close()

    tfn := fmt.Sprintf(""%s%d%s"", config.TmpDir, time.Now().UnixNano(), filepath.Ext(header.Filename))
    tmpFile, err := os.OpenFile(tfn, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0666)
    if err != nil {
        logs.Create(logs.LevelError, ""[VideosStoreHandler] Unable to create temporary file: ""+err.Error())
        return
    }
    defer tmpFile.Close()

    io.Copy(tmpFile, clientFile)

    msg := fmt.Sprintf(""[VideosStoreHandler] Video %q uploaded with filename: %q."", r.FormValue(""name""), header.Filename)
    logs.Create(logs.LevelInfo, msg)

    vid := videos.CreateVideo(r.FormValue(""name""), filepath.Ext(header.Filename))

    go util.ParseVideo(vid, r.FormValue(""name""), tmpFile.Name())

    http.Redirect(w, r, ""/admin/logs"", http.StatusTemporaryRedirect)
}",1098
41968616,1336,"package main                                                                                                                                                                                                

import (                                                                                                                                                                                                    
    ""fmt""                                                                                                                                                                                                   
    ""reflect""                                                                                                                                                                                               
    ""syscall""                                                                                                                                                                                               
    ""unsafe""                                                                                                                                                                                                
)                                                                                                                                                                                                           

// We should do this because by default strings in Go are read-only.                                                                                                                                                                                                                                                                                                                                                                                                                  
func mprotect(ptr uintptr, w bool) {                                                                                                                                                                        
    // Need to avoid ""EINVAL addr is not a valid pointer,
    // or not a multiple of PAGESIZE.""                                                                                                                   
    start := ptr & ^(uintptr(syscall.Getpagesize() - 1))                                                                                                                                                    

    prot := syscall.PROT_READ                                                                                                                                                                               
    if w {                                                                                                                                                                                                  
        prot |= syscall.PROT_WRITE                                                                                                                                                                          
    }                                                                                                                                                                                                       

    _, _, err := syscall.Syscall(                                                                                                                                                                           
        syscall.SYS_MPROTECT,                                                                                                                                                                               
        start, uintptr(syscall.Getpagesize()),                                                                                                                                                              
        uintptr(prot),                                                                                                                                                                                      
    )                                                                                                                                                                                                       
    if err != 0 {                                                                                                                                                                                           
        panic(err.Error())                                                                                                                                                                                  
    }                                                                                                                                                                                                       
}                                                                                                                                                                                                           

// This function is very, very very very unsafe.                                                                                                                                                            
// Nowhere and never use it!                                                                                                                                                                                
func replaceAtIndex(s string, b byte, i int) {                                                                                                                                                              
    h := *(*reflect.StringHeader)(unsafe.Pointer(&s))                                                                                                                                                       

    mprotect(h.Data, true)                                                                                                                                                                                  
    defer mprotect(h.Data, false)                                                                                                                                                                           

    *(*byte)(unsafe.Pointer(h.Data + uintptr(i))) = b                                                                                                                                                       
}                                                                                                                                                                                                           

func main() {                                                                                                                                                                                               
    h := ""Hello, playground""                                                                                                                                                                                
    replaceAtIndex(h, 'x', 0)                                                                                                                                                                               
    fmt.Println(h)                                                                                                                                                                                          
}",7663
42010937,1338,gopkg.in/olivere/elastic.v5,27
42057466,1345,"static void Main(string[] args)
    {
        byte[] hashBytes = new byte[32] { 152, 154, 255, 19, 168, 20, 167, 43, 232, 133, 146, 13, 183, 80, 186, 85, 180, 249, 95, 142, 234, 71, 93, 188, 29, 147, 220, 164, 248, 83, 196, 80 };
        String privateKeyPemStr = @""-----BEGIN RSA PRIVATE KEY-----
MIICXAIBAAKBgQCIw68jARnmvTh+xvMcv5iugtoHXt60NWEebfbghLTFuTlQvK0e
xY5hxnN/uD2UVc/S3QGnBQn0AfynhxlEZkedpYBb5RWoVChGZMHu7hbZukMjByjx
ec0LjtuEQhY4m18XaVNmAQWD/EiROMGTghMwykkQ+SBtx4Gl/O/BB6F4SQIDAQAB
AoGAJLarODFee6OGG/paXvhMC2TTFLFyBVxjAuEwKdtWD9IGQdc0fhM4gqTccofJ
+B0FGiz7+ZMPtfImme5ZaRQv2wx7KOPbOdAyYxC7nLFCHYqDWZJ8/cCoS+hPJFd5
9OeGLGz3QKfEEPtYEAw4+E/UjilYAtRNREkISkYoB9Va8PUCQQDDHMPRSCfXbfZV
ufmlRZj2bH8sjVaSBbJIw+y9HKJ3ORRnKGjtIZ/+z70EwMwtbbQKnl71SruO5HB9
AUTtRka/AkEAs3GWQhplPbuH/fAlaEPy5GQilUNRt76NMsgtIFWPMXnt82cxTUUR
RIKwX7M96WBppPZ2Dy7uLrX8O+3fr6BK9wJATZ0lsBy57JKLiTJ/wmTbIjuqozhe
FZw6fYOiqt+3KSIFobuLcbkMgjp1AG0JS5D2K7swHvdpgMASl0dn+dMY1QJBAIPw
9QbN2bs2dJvnQ9oSfDoq1rLhuOheF/xK68Nmpc8/VBMwwTOLoVK6tWzoopFC7ur4
vX4Uh9WYwkpecab1OakCQD0SCs4zIggA/2NkUx8J5H07/drbm9uH+98EQUvzjTdz
qSW2jJPCA4GYYmtnnDRduukjmkJlbaaTdEH5YLCilF0=
-----END RSA PRIVATE KEY-----"";

        StringReader strReader = new StringReader(privateKeyPemStr);
        PemReader pemReader = new PemReader(strReader);
        AsymmetricCipherKeyPair keyPair = (AsymmetricCipherKeyPair)pemReader.ReadObject();
        RsaKeyParameters privateKey = (RsaKeyParameters)keyPair.Private;


        ISigner sig = SignerUtilities.GetSigner(""SHA256withRSA"");
        sig.Init(true, privateKey);
        sig.BlockUpdate(hashBytes, 0, hashBytes.Length);
        byte[] signedBytes = sig.GenerateSignature();

        var signedStr = Convert.ToBase64String(signedBytes);

        Console.WriteLine(signedStr);
        Console.ReadLine();            
    }",1811
42113153,1349,allpages.com,12
42209040,1355,"Router := gin.New()
Router.Use(gin.Logger())
Router.Use(gin.Recovery())
",72
42259364,1361,TCP,3
42281210,1366,"package main

import (
    ""./models""
    ""github.com/gin-gonic/gin""
    _ ""github.com/go-sql-driver/mysql""
)

func main() {
    router := gin.Default()

    opt := router.Group(""opt/v2"")
    {
        opt.GET(""/ping"", func(c *gin.Context) {
            c.String(200, ""pong"")
        })
        opt.GET(""/last-completed-test/:serial"", LastTest)
    }

    // Add API handlers here
    router.Run("":3000"")
}

func LastTest(c *gin.Context) {
    // Connection to the database
    db := models.InitDB()
    defer db.Close()

    var result models.TestResultDetail

    type Response struct {
        Status   string
        Id   int64
        Serial   string
        Product  string
        Stage    string

    }

    // get param and query
    serial := c.Params.ByName(""serial"")
    db.Model(&models.TestResultDetail{}).
        Select(""test_result.id, test_result.serial, test_result.product, test_result_detail.stage_id, seq_test_stage.description"").
        Joins(""join test_result on test_result.ID = test_result_detail.result_id"").
        Joins(""join seq_test_stage on seq_test_stage.ID = test_result_detail.stage_id"").
        Where(""test_result.serial = ?"", serial).
        Order(""test_result_detail.id desc"").
        Limit(1).
        Scan(&result)

    if result.ID != 0 {
        res1 := &Response{
            Status: ""OK"",
            Id: result.ResultId.ID,
            Serial: result.ResultId.Serial,
            Product: result.ResultId.Product,
            Stage: result.StageId.Description,
        }

        c.JSON(200, res1)
    } else {
        // Display JSON error
        c.JSON(404, gin.H{""error"": ""No Records"", ""code"": 404})
    }
}",1662
42326753,1370,Config.Database,15
42388090,1379,"package filter

import (
    ""net/http""

    ""github.com/valyala/fasthttp""
)

// Context filter context
type Context interface {
    SetStartAt(startAt int64)
    SetEndAt(endAt int64)
    GetStartAt() int64
    GetEndAt() int64

    GetProxyServerAddr() string
    GetProxyOuterRequest() *fasthttp.Request
    GetProxyResponse() *fasthttp.Response
    NeedMerge() bool

    GetOriginRequestCtx() *fasthttp.RequestCtx

    GetMaxQPS() int

    ValidateProxyOuterRequest() bool

    InBlacklist(ip string) bool
    InWhitelist(ip string) bool

    IsCircuitOpen() bool
    IsCircuitHalf() bool

    GetOpenToCloseFailureRate() int
    GetHalfTrafficRate() int
    GetHalfToOpenSucceedRate() int
    GetOpenToCloseCollectSeconds() int

    ChangeCircuitStatusToClose()
    ChangeCircuitStatusToOpen()

    RecordMetricsForRequest()
    RecordMetricsForResponse()
    RecordMetricsForFailure()
    RecordMetricsForReject()

    GetRecentlyRequestSuccessedCount(sec int) int
    GetRecentlyRequestCount(sec int) int
    GetRecentlyRequestFailureCount(sec int) int
}

// Filter filter interface
type Filter interface {
    Name() string

    Pre(c Context) (statusCode int, err error)
    Post(c Context) (statusCode int, err error)
    PostErr(c Context)
}

// BaseFilter base filter support default implemention
type BaseFilter struct{}

// Pre execute before proxy
func (f BaseFilter) Pre(c Context) (statusCode int, err error) {
    return http.StatusOK, nil
}

// Post execute after proxy
func (f BaseFilter) Post(c Context) (statusCode int, err error) {
    return http.StatusOK, nil
}

// PostErr execute proxy has errors
func (f BaseFilter) PostErr(c Context) {

}",1668
42475093,1386,socket.Recvfrom,15
42487166,1388,"$ wrk -t1 -c200 -d1s http://127.0.0.1:8080    
// this passes
...
21efef3
21efef3
21efef3
21efef3
21efef3
21efef3
21efef3
...

$ wrk -t1 -c400 -d1s http://127.0.0.1:8080
// this test fails with this error returned in go terminal
...
21efef3
21efef3
21efef3
21efef3
panic: runtime error: invalid memory address or nil pointer dereference
[signal SIGSEGV: segmentation violation code=0x1 addr=0x0 pc=0x6ada46]

goroutine 2325 [running]:
github.com/gocql/gocql.(*Session).Close(0x0)
/home/mda/.local/go/src/github.com/gocql/gocql/session.go:336 +0x26
panic(0x707f40, 0x8ed650)
/usr/lib/go-1.8/src/runtime/panic.go:489 +0x2cf
github.com/gocql/gocql.(*Session).Query(0x0, 0x777d4c, 0x34, 0xc428cfd190, 0x1, 0x1, 0x0)
/home/mda/.local/go/src/github.com/gocql/gocql/session.go:294 +0x26
main.getData()
/home/mda/code/api-go/main2.go:45 +0x1f6
created by main.main.func1
/home/mda/code/api-go/main2.go:18 +0x39
exit status 2

Process finished with exit code 1",952
42680728,1392,"package main

import (
    ""fmt""
    ""os""
    ""encoding/csv""
)




func main() {

    if len(os.Args) < 2 {
        fmt.Printf(""Error: Source file name is required\n"")
        fmt.Println(""Usage:"", os.Args[0], "" \n"")
        return
    }

    file, err := os.Open(os.Args[1])
    if err != nil {
        fmt.Println(""Error:"", err)
        return
    }
    // deferred call to Close() at the end of current method
    defer file.Close()
    //get a new cvsReader for reading file
    reader := csv.NewReader(file)
    //Configure reader options Ref http://golang.org/src/pkg/encoding/csv/reader.go?s=#L81
    reader.Comma = '|'
    reader.Comment = '#'        //Comment character
    reader.FieldsPerRecord = -1 //Number of records per record. Set to Negative value for variable
    reader.TrimLeadingSpace = true

    record, err := reader.Read()
    fmt.Println(record)
    result, _ := reader.ReadAll()
    fmt.Println(result)
    for i := range result {
        // Element count.
        fmt.Printf(""Elements: %v"", len(result[i]))
        fmt.Println()
        // Elements.
        fmt.Println(result[i])
    }

}",1117
42755310,1394,"func GetAllHourly(dbsession *mgo.Session, year, month, day, site, size, network, region string, code int) (items []MassAggregation, err error) {
    defer dbsession.Close()
    var match bson.M
    if network == ""openx3"" {
        network = ""openx""
    }

    group := bson.M{""$group"": bson.M{""_id"": bson.M{""aws_region"": ""$aws_region"", ""http_request_status"": ""$http_request_status"", ""hour"": ""$hour"", ""network"": ""$network"", ""site"": ""$site"", ""size"": ""$size"", ""zone"": ""$zone"", ""extra"": ""$extra""}, ""total"": bson.M{""$sum"": ""$count""}}}
    if site == """" && size == """" && network == """" && region == """" && code == -1 {
        match = bson.M{""$match"": bson.M{""year"": year, ""month"": month, ""day"": day}}
    } else if site != """" && size == """" && network == """" && region == """" && code == -1 {
        match = bson.M{""$match"": bson.M{""year"": year, ""month"": month, ""day"": day, ""site"": site}}
    } else if site != """" && size != """" && network == """" && region == """" && code == -1 {
        match = bson.M{""$match"": bson.M{""year"": year, ""month"": month, ""day"": day, ""site"": site, ""size"": size}}
    } else if site != """" && size != """" && network != """" && region == """" && code == -1 {
        match = bson.M{""$match"": bson.M{""year"": year, ""month"": month, ""day"": day, ""site"": site, ""size"": size, ""network"": &bson.RegEx{Pattern: network, Options: ""i""}}}
    } else if site != """" && size != """" && network != """" && region != """" && code == -1 {
        match = bson.M{""$match"": bson.M{""year"": year, ""month"": month, ""day"": day, ""site"": site, ""size"": size, ""network"": &bson.RegEx{Pattern: network, Options: ""i""}, ""aws_region"": region}}
    } else if site != """" && size != """" && network != """" && region != """" && code != -1 {
        match = bson.M{""$match"": bson.M{""year"": year, ""month"": month, ""day"": day, ""site"": site, ""size"": size, ""network"": &bson.RegEx{Pattern: network, Options: ""i""}, ""aws_region"": region, ""http_request_status"": code}}
    } else if site == """" && size != """" && network == """" && region == """" && code == -1 {
        match = bson.M{""$match"": bson.M{""year"": year, ""month"": month, ""day"": day, ""site"": site, ""size"": size}}
    } else if site == """" && size != """" && network != """" && region == """" && code == -1 {
        match = bson.M{""$match"": bson.M{""year"": year, ""month"": month, ""day"": day, ""size"": size, ""network"": &bson.RegEx{Pattern: network, Options: ""i""}}}
    } else if site == """" && size != """" && network != """" && region != """" && code == -1 {
        match = bson.M{""$match"": bson.M{""year"": year, ""month"": month, ""day"": day, ""site"": site, ""size"": size, ""network"": &bson.RegEx{Pattern: network, Options: ""i""}, ""aws_region"": region}}
    } else if site == """" && size == """" && network != """" && region == """" && code == -1 {
        match = bson.M{""$match"": bson.M{""year"": year, ""month"": month, ""day"": day, ""network"": &bson.RegEx{Pattern: network, Options: ""i""}}}
    } else if site == """" && size == """" && network != """" && region != """" && code == -1 {
        match = bson.M{""$match"": bson.M{""year"": year, ""month"": month, ""day"": day, ""network"": &bson.RegEx{Pattern: network, Options: ""i""}, ""aws_region"": region}}
    } else if site == """" && size == """" && network != """" && region != """" && code != -1 {
        match = bson.M{""$match"": bson.M{""year"": year, ""month"": month, ""day"": day, ""network"": &bson.RegEx{Pattern: network, Options: ""i""}, ""aws_region"": region, ""http_request_status"": code}}
    } else if site == """" && size == """" && network == """" && region != """" && code == -1 {
        match = bson.M{""$match"": bson.M{""year"": year, ""month"": month, ""day"": day, ""aws_region"": region}}
    } else if site == """" && size == """" && network == """" && region != """" && code != -1 {
        match = bson.M{""$match"": bson.M{""year"": year, ""month"": month, ""day"": day, ""aws_region"": region, ""http_request_status"": code}}
    } else if site == """" && size == """" && network == """" && region == """" && code != -1 {
        match = bson.M{""$match"": bson.M{""year"": year, ""month"": month, ""day"": day, ""http_request_status"": code}}
    } else if site != """" && size == """" && network == """" && region == """" && code != -1 {
        match = bson.M{""$match"": bson.M{""year"": year, ""month"": month, ""day"": day, ""site"": site, ""http_request_status"": code}}
    } else if site != """" && size == """" && network == """" && region != """" && code == -1 {
        match = bson.M{""$match"": bson.M{""year"": year, ""month"": month, ""day"": day, ""site"": site, ""aws_region"": region}}
    } else if site != """" && size == """" && network != """" && region == """" && code == -1 {
        match = bson.M{""$match"": bson.M{""year"": year, ""month"": month, ""day"": day, ""site"": site, ""network"": &bson.RegEx{Pattern: network, Options: ""i""}}}
    } else if site == """" && size != """" && network == """" && region == """" && code != -1 {
        match = bson.M{""$match"": bson.M{""year"": year, ""month"": month, ""day"": day, ""size"": size, ""http_request_status"": code}}
    } else if site == """" && size != """" && network == """" && region != """" && code == -1 {
        match = bson.M{""$match"": bson.M{""year"": year, ""month"": month, ""day"": day, ""size"": size, ""aws_region"": region}}
    } else if site == """" && size != """" && network != """" && region == """" && code == -1 {
        match = bson.M{""$match"": bson.M{""year"": year, ""month"": month, ""day"": day, ""size"": size, ""network"": &bson.RegEx{Pattern: network, Options: ""i""}}}
    } else if site == """" && size == """" && network != """" && region == """" && code != -1 {
        match = bson.M{""$match"": bson.M{""year"": year, ""month"": month, ""day"": day, ""network"": &bson.RegEx{Pattern: network, Options: ""i""}, ""http_request_status"": code}}
    } else if site == """" && size == """" && network != """" && region != """" && code == -1 {
        match = bson.M{""$match"": bson.M{""year"": year, ""month"": month, ""day"": day, ""network"": &bson.RegEx{Pattern: network, Options: ""i""}, ""aws_region"": region}}
    } else if site != """" && size != """" && network != """" && region == """" && code != -1 {
        match = bson.M{""$match"": bson.M{""year"": year, ""month"": month, ""day"": day, ""network"": &bson.RegEx{Pattern: network, Options: ""i""}, ""size"": size, ""http_request_status"": code}}
    } else if site != """" && size != """" && network == """" && region == """" && code != -1 {
        match = bson.M{""$match"": bson.M{""year"": year, ""month"": month, ""day"": day, ""site"": site, ""size"": size, ""http_request_status"": code}}
    } else if site == """" && size != """" && network != """" && region == """" && code != -1 {
        match = bson.M{""$match"": bson.M{""year"": year, ""month"": month, ""day"": day, ""network"": &bson.RegEx{Pattern: network, Options: ""i""}, ""size"": size, ""http_request_status"": code}}
    } else if site != """" && size == """" && network != """" && region != """" && code == -1 {
        match = bson.M{""$match"": bson.M{""year"": year, ""month"": month, ""day"": day, ""network"": &bson.RegEx{Pattern: network, Options: ""i""}, ""aws_region"": region, ""site"": site}}
    } else if site != """" && size == """" && network != """" && region != """" && code != -1 {
        match = bson.M{""$match"": bson.M{""year"": year, ""month"": month, ""day"": day, ""network"": &bson.RegEx{Pattern: network, Options: ""i""}, ""aws_region"": region, ""site"": site, ""http_request_status"": code}}
    } else if site != """" && size == """" && network == """" && region != """" && code != -1 {
        match = bson.M{""$match"": bson.M{""year"": year, ""month"": month, ""day"": day, ""aws_region"": region, ""site"": site, ""http_request_status"": code}}
    } else if site == """" && size != """" && network != """" && region != """" && code != -1 {
        match = bson.M{""$match"": bson.M{""year"": year, ""month"": month, ""day"": day, ""network"": &bson.RegEx{Pattern: network, Options: ""i""}, ""aws_region"": region, ""size"": size, ""http_request_status"": code}}
    }

    operations := []bson.M{match, group}
    err = dbsession.DB(""logs"").C(""prod"").Pipe(operations).All(&items)
    return
}",7813
42761866,1396,"listener 8883
cafile /etc/mosquitto/ca_certificates/ca.crt
certfile /etc/mosquitto/certs/server.crt
keyfile /etc/mosquitto/certs/server.key

require_certificate true",166
42774958,1404,"rabbitmqctl list_queues name messages_ready messages_unacknowledged
Listing queues ...
from    13796   16357",109
42784515,1407,"package main

import (
    ""encoding/json""
    ""log""
    ""net""
    ""net/http""
    ""net/http/fcgi""
    ""os""
)

func main() {
    //setup the config
    configFile := ""config.json""
    fd, err := os.Open(configFile)
    if err != nil {
        log.Fatalf(""Can't open config file: %v"", configFile)
    }
    CFG := config{}
    err = json.NewDecoder(fd).Decode(&CFG)
    if err != nil {
        log.Fatalf(""parse config error: %v"", err)
    }

    //init DB connection
    db.InitConnectionInfo(CFG.Database.Host, CFG.Database.Port, CFG.Database.Database, CFG.Database.Username, CFG.Database.Password)

    //register HTTP handler
    sessionHandler := &handlers.SessionHandler{}
    http.Handle(""/sessions"", sessionHandler)
    http.Handle(""/sessions/"", sessionHandler)

    userHandler := &handlers.UserHandler{
        Facebook:      &oa.OAuth{AppId: CFG.Facebook.Key, Secret: CFG.Facebook.Secret},
        Sina:          &oa.OAuth{AppId: CFG.Sina.Key, Secret: CFG.Sina.Secret},
        Google:        &oa.OAuth{AppId: CFG.Google.Key, Secret: CFG.Google.Secret},
        Tencent:       &oa.OAuth{AppId: CFG.Tencent.Key, Secret: CFG.Tencent.Secret},
        Mixpanel:      &hu.Share{Token: CFG.Mixpanel.Token},
        FacebookShare: &hu.Share{Token: CFG.Facebook.Token},
        SinaShare:     &hu.Share{Token: CFG.Sina.Token},
        GoogleShare:   &hu.Share{Token: CFG.Google.Token},
        TencentShare:  &hu.Share{Token: CFG.Tencent.Token},
    }
    http.Handle(""/users"", userHandler)
    http.Handle(""/users/"", userHandler)

    //and so on ...

    //run server
    log.Println(""start listen: "", CFG.FcgiAddr)
    l, _ := net.Listen(""tcp"", CFG.FcgiAddr)
    log.Fatalf(""server error is %v"", fcgi.Serve(l, nil))
    //@@select {}
    log.Println(""end listen"")
}
",1770
42796310,1418,CGO_ENABLED=1,13
42828602,1436,"#!/usr/bin/env python

MYPORT = 5353
MYGROUP_6 = 'ff02::fb'
MYTTL = 1 # Increase to reach other networks

import time
import struct
import socket
import sys

def main():
    sender(MYGROUP_6)


def sender(group):
    addrinfo = socket.getaddrinfo(group, None)[0]

    s = socket.socket(addrinfo[0], socket.SOCK_DGRAM)

    # Set Time-to-live (optional)
    ttl_bin = struct.pack('@i', MYTTL)
    s.setsockopt(socket.IPPROTO_IPV6, socket.IPV6_MULTICAST_HOPS, ttl_bin)

    while True:
        data = repr(time.time())
        s.sendto(data + '\0', (addrinfo[4][0], MYPORT))
        time.sleep(1)

if __name__ == '__main__':
    main()",634
42861589,1440,"package main

import (
    ""fmt""
    ""io/ioutil""
    ""log""
    ""os""
    ""os/exec""
    ""runtime""
    ""runtime/debug""
    ""strconv""
    ""time""
)

func main() {
    source := ""/tmp/1G.source""
    repeats, _ := strconv.Atoi(os.Args[1])
    m := &runtime.MemStats{}

    err := exec.Command(""dd"", ""if=/dev/zero"", ""of=""+source, ""bs=1073741824"", ""count=1"").Run()
    if err != nil {
        log.Fatalf(""failed to create 1GB file: %s\n"", err)
    }
    fmt.Printf(""created 1GB source file, %s\n"", memory_usage(m))

    // read it multiple times
    switch os.Args[2] {
    case ""1"":
        fmt.Println(""re-using a byte slice and emptying it each time"")
        // var data []byte
        for i := 1; i <= repeats; i++ {
            data, _ := ioutil.ReadFile(source)
            if len(data) > 0 { // just so we use data
                data = nil
            }
            fmt.Printf(""did read %d, %s\n"", i, memory_usage(m))
        }
    case ""2"":
        fmt.Println(""ignoring the return value entirely"")
        for i := 1; i <= repeats; i++ {
            ioutil.ReadFile(source)
            fmt.Printf(""did read %d, %s\n"", i, memory_usage(m))
        }
    case ""3"":
        fmt.Println(""ignoring the return value entirely, forcing memory freeing"")
        for i := 1; i <= repeats; i++ {
            ioutil.ReadFile(source)
            debug.FreeOSMemory()
            fmt.Printf(""did read %d, %s\n"", i, memory_usage(m))
        }
    }

    // wait incase garbage collection needs time to do something
    <-time.After(5 * time.Second)

    fmt.Printf(""all done, %s\n"", memory_usage(m))

    os.Exit(0)
}

func memory_usage(m *runtime.MemStats) string {
    runtime.ReadMemStats(m)
    return fmt.Sprintf(""system memory: %dMB; heap alloc: %dMB; heap idle-released: %dMB"", int((m.Sys/1024)/1024), int((m.HeapAlloc/1024)/1024), int(((m.HeapIdle-m.HeapReleased)/1024)/1024))
}",1874
43003683,1447,"package main

import (
  ""fmt""
  ""bitbucket.org/tradedefender/cryptocurrency/exchange-connector/cexio""
  ""github.com/shopspring/decimal""
  ""encoding/json""
  ""time""
)

type OrderBook struct {
  Asks []Ask
  Bids []Bid
}

type Ask struct {
  Rate    decimal.Decimal
  Amount  decimal.Decimal
}

type Bid struct {
  Rate    decimal.Decimal
  Amount  decimal.Decimal
}

func main() {
  cexioConn := new(cexio.Connection)

  err := cexioConn.Connect()
  if err != nil {
    fmt.Errorf(""error: %s"", err.Error())
  }

  err = cexioConn.Authenticate(""TLwYkktLf7Im6nqSKt6UO1IrU"", ""9ImOJcR7Qj3LMIyPCzky0D7WE"")
  if err != nil {
    fmt.Errorf(""error: %s"", err.Error())
  }

  readChannel := make(chan cexio.IntraAppMessage, 25)

  go cexioConn.ReadLoop(readChannel)

  processor := Processor{
    WatchPairs: [][2]string{
      [2]string{
        ""BTC"", ""USD"",
      },
    },
    conn: cexioConn,
  }

  go processor.Process(readChannel)

  // LOL
  for {
    continue
  }

}

type Processor struct {
  WatchPairs [][2]string
  conn *cexio.Connection
}

func (p *Processor) Process(ch <-chan cexio.IntraAppMessage) {

  p.conn.SubscribeToOrderBook(p.WatchPairs[0])

  pingTimer := time.Now().Unix()
  for {

    fmt.Printf(""(%v)\n"", time.Now().Unix())

    if (time.Now().Unix() - pingTimer) >= 10 {
      fmt.Println(""sending ping"")
      p.conn.SendPing()
      pingTimer = time.Now().Unix()
    }

    readMsg := <- ch
    output, _ := json.Marshal(readMsg.SocketMessage)
    fmt.Println(string(output))

    if readMsg.SocketMessage.Event == ""ping"" {
      fmt.Println(""sending pong"")
      p.conn.SendPong()
      pingTimer = time.Now().Unix()
    }

  }
}",1653
43018667,1449,.go,3
43184477,1455,"$ go get -d github.com/cockroachdb/cockroach
$ cd $GOPATH/src/github.com/cockroachdb/cockroach
$ git checkout beta-20170330
$ make install",139
43218484,1466,"package main


//ConfigurationParameters provides the struct to hold configuration parameters from config file
type ConfigurationParameters struct {
    Title string
    //serviceDiscovery captures configuration parameters needed for service discovery registration with Consul
    ServiceDiscovery ConsulConf `toml:""ServiceDiscovery""`
    //metadataReporting captures which metadata to be registered with service into consul for use during discovery
    MetadataReporting MetaDataConf `toml:""MetadataReporting""`
    //awsTagsToLabels captures the aws tags that should be added to reported metrics as Labels
    AwsTagsToLabels LabelConf `toml:""AwsTagsToLabels""`
    //collectors captures the list of collectors to use
    Collectors CollectorConf `toml:""Collectors""`
    //service captures agent related configurations
    Service ServiceConf `toml:""Service""`
}

//ConsulConf captures configuration parameters needed for service discovery registration with Consul
type ConsulConf struct {
    enabled    bool
    endpoint   string
    port       int
    datacenter string
    serviceID  string
}
//MetaDataConf captures which metadata to be registered with service into consul for use during discovery
    type MetaDataConf struct {
        enabled   bool
        awsregion string
    }
//LabelConf captures the aws tags that should be added to reported metrics as Labels
type LabelConf struct {
    enabled       bool
    refreshPeriod int
}

//CollectorConf captures the list of collectors to use
type CollectorConf struct {
    goCollectionEnabled       bool
    exporterCollectionEnabled bool
    wmiCollectionEnabled      bool
    agentCollectionEnabled    bool
    enabledCollectors         string
    metricMap                 []MetricMap
}

//MetricMap captures a mapping between one or more WMI metrics and the name it should be reported with
type MetricMap struct {
    wmiMetricName  []string
    exportName     string
    dropMetric     bool
    computedMetric bool
    computeLogic   string
}

//ServiceConf captures agent related configurations
type ServiceConf struct {
    listenIP           string
    listenPort         int
    metricPath         string
    collectionInterval int
    serviceName        string
}
",2231
43293493,1470,go build,8
43327252,1476,"web: todo
",10
43345705,1482,main function,13
43351857,1496,"map[struct]func

map[
    {contact %!s(int=1)}:%!s(main.Controller=0x4c7b50) 
    {services/basket %!s(int=2)}:%!s(main.Controller=0x4c7ad0) 
    {categories %!s(int=1)}:%!s(main.Controller=0x4c7ae0) 
    {categories/{category} %!s(int=2)}:%!s(main.Controller=0x4c7af0)
    {categories/{category}/{product} %!s(int=3)}:%!s(main.Controller=0x4c7b00) 
    {basket %!s(int=1)}:%!s(main.Controller=0x4c7b10) 
    {checkout %!s(int=1)}:%!s(main.Controller=0x4c7b40) 
    {sitemap %!s(int=1)}:%!s(main.Controller=0x4c7b30) 
    {services/order %!s(int=2)}:%!s(main.Controller=0x4c7ac0) 
    {services/image %!s(int=2)}:%!s(main.Controller=0x4c7b20) 
    {/ %!s(int=1)}:%!s(main.Controller=0x4c7a00)
]

c := RouteMap[struct]",718
43438219,1500,"package llvm.org/llvm/bindings/go/llvm: unrecognized import path ""llvm.org/llvm/bindings/go/llvm"" (parse https://llvm.org/llvm/bindings/go/llvm?go-get=1: no go-import meta tags ())",181
43460604,1514,"package main

import (
    ""bytes""
    ""fmt""
    ""runtime/debug""
    ""time""
)

const variations = 30

var time1, time2 time.Time
var delta, catcher string
var x, deltaSize, k, dataSize, operations uint64
var i, j, x_min uint64
var l int
var delta_byte []byte
var method1Speed, method2Speed, method3Speed, method3ASpeed, method2ASpeed [variations]uint64
var dataTotal [variations]uint64
var tmp []byte

func main() {

    x_min = 2
    operations = 1

    for x = variations; x >= x_min; x = x - 2 {
        deltaSize = 1 << x // 2^x
        dataSize = operations * deltaSize
        dataTotal[x-1] = dataSize

        fmt.Println(""Step #"", x, ""delta="", deltaSize, ""op.="", operations, ""data="", dataSize)
        fmt.Println(""Preparing Data..."")
        delta_byte = make([]byte, deltaSize)
        for i = 0; i < deltaSize; i++ {
            delta_byte[i] = 255
        }
        delta = string(delta_byte)

        delta_byte = nil
        catcher = """"
        debug.FreeOSMemory()

        fmt.Println(""Testing Method #1..."")
        time1 = time.Now()
        for j = 1; j <= operations; j++ {
            //----------------------------
            catcher += delta
            //----------------------------
        }
        time2 = time.Now()
        method1Speed[x-1] = uint64((1000000 * float64(dataSize)) / float64(time2.Sub(time1).Nanoseconds())) // KiB/sec.

        catcher = """"
        debug.FreeOSMemory()

        fmt.Println(""Testing Method #2..."")
        time1 = time.Now()
        for j = 1; j <= operations; j++ {
            //----------------------------
            stringsJoinViaCopy(&catcher, &catcher, &delta)
            //----------------------------
        }
        time2 = time.Now()
        method2Speed[x-1] = uint64((1000000 * float64(dataSize)) / float64(time2.Sub(time1).Nanoseconds())) // KiB/sec.

        catcher = """"
        debug.FreeOSMemory()

        fmt.Println(""Testing Method #3..."")
        time1 = time.Now()
        for j = 1; j <= operations; j++ {
            //----------------------------
            stringsJoinViaBuffer(&catcher, &catcher, &delta)
            //----------------------------
        }
        time2 = time.Now()
        method3Speed[x-1] = uint64((1000000 * float64(dataSize)) / float64(time2.Sub(time1).Nanoseconds())) // KiB/sec.

        catcher = """"
        debug.FreeOSMemory()

        fmt.Println(""Testing Method #3A..."")
        time1 = time.Now()
        buffer := bytes.NewBuffer(nil)
        for j = 1; j <= operations; j++ {
            //----------------------------
            buffer.WriteString(delta)
            //----------------------------
        }
        catcher = buffer.String()
        time2 = time.Now()
        method3ASpeed[x-1] = uint64((1000000 * float64(dataSize)) / float64(time2.Sub(time1).Nanoseconds())) // KiB/sec.

        catcher = """"
        debug.FreeOSMemory()

        fmt.Println(""Testing Method #2A..."")
        time1 = time.Now()
        tmp = make([]byte, int(operations)*len(delta)) // Cheating (guessing) with size
        l = 0
        for j = 1; j <= operations; j++ {
            //----------------------------
            l += copy(tmp[l:], delta)
            //----------------------------
        }
        catcher = string(tmp)
        time2 = time.Now()
        method2ASpeed[x-1] = uint64((1000000 * float64(dataSize)) / float64(time2.Sub(time1).Nanoseconds())) // KiB/sec.

        catcher = """"
        delta = """"
        debug.FreeOSMemory()

        ///
        operations *= 2
    }

    // Show Results
    fmt.Println(""#. ops. Total Data, B. Speed (KiB/sec) M1 M2 M3 M3A M2A"")
    for x = x_min; x <= variations; x = x + 2 {
        dataSize = 1 << x // 2^x
        operations = 1 << (variations - x)
        fmt.Println(x, operations, dataTotal[x-1], method1Speed[x-1], method2Speed[x-1], method3Speed[x-1],
            method3ASpeed[x-1], method2ASpeed[x-1])
    }
}

//------------------------------------------------------------------------------

func stringsJoinViaBuffer(dest, a, b *string) {

    // Joins two strings (a & b) using Buffer and puts them into dest.

    buffer := bytes.NewBuffer(nil)
    buffer.WriteString(*a)
    buffer.WriteString(*b)

    *dest = buffer.String()
}

//------------------------------------------------------------------------------

func stringsJoinViaCopy(dest, a, b *string) {
    x := make([]byte, len(*a)+len(*b))
    i := 0
    i += copy(x[i:], *a)
    i += copy(x[i:], *b)

    *dest = string(x)
}",4484
43515002,1516,go version go1.7.4 linux/amd64,31
43675122,1518,b.N,3
43682714,1536,interval.go,11
43978018,1562,"output, err := exec.Command(""ffmpeg"", ""-i"", source, ""-vcodec"", ""h264"", ""-acodec"", ""aac"", ""-strict"", ""-2"", destination).CombinedOutput()",136
44091098,1565,"/****** MIT License **********
Copyright (c) 2017 Zonkiie
Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the ""Software""), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
***************************/

package main

/// http://stackoverflow.com/questions/23030884/is-there-a-way-to-create-an-instance-of-a-struct-from-a-string
/// http://stackoverflow.com/questions/7850140/how-do-you-create-a-new-instance-of-a-struct-from-its-type-at-runtime-in-go
/// http://stackoverflow.com/questions/29435783/gorm-golang-orm-associations

import (
    ""github.com/jinzhu/gorm""
    _ ""github.com/jinzhu/gorm/dialects/sqlite""
    ""fmt""
    ""reflect""
    ""regexp""
    ""encoding/json""
    ""encoding/xml""
    //""strconv""
    ""os""
    ""flag""
    ""strings""
)

type rs struct {
    //Parent    *rs `gorm:""ForeignKey:ID;AssociationForeignKey:ParentID""`
    Childs  []*rs   `gorm:""ForeignKey:ID;AssociationForeignKey:ParentID"" walkrec:""true""`
    ID  int64
    ParentID    int64   `gorm:""column:ParentID""`
    Value   string
    Sub []rs_sub    `gorm:""ForeignKey:ID;AssociationForeignKey:Rs_ID"" walkrec:""true""`
}

type rs_sub struct {
    ID  int64
    Rs_ID   int64   `gorm:""column:rs_id""`
    Value   string
}

var db *gorm.DB

func populateDb(db *gorm.DB) {

    rs1 := rs{ID: 1, ParentID: 0, Value: ""root""}
    db.Save(&rs1)
    rs2 := rs{ID: 2, ParentID: 1, Value: ""Child1""}
    db.Save(&rs2)
    rs3 := rs{ID: 3, ParentID: 2, Value: ""Child2""}
    db.Save(&rs3)
    rs4 := rs{ID: 4, ParentID: 3, Value: ""Child3""}
    db.Save(&rs4)
    rs5 := rs{ID: 5, ParentID: 3, Value: ""Child4""}
    db.Save(&rs5)
    rs_s := rs_sub{ID:1, Rs_ID:4, Value: ""SubChild1""}
    db.Save(&rs_s)
}

func PStdErr(format string, args ...interface{}) {
    fmt.Fprintf(os.Stderr, format, args...)
}

func JsonMarshal(data interface{}) string {
    b, err := json.Marshal(data)
    if err != nil {
        return ""Error""
    }
    return string(b[:])
}

func XmlMarshal(data interface{}) string {
    b, err := xml.Marshal(data)
    if err != nil {
        return ""Error""
    }
    return string(b[:])
}

func InitDB() *gorm.DB {
db, err := gorm.Open(""sqlite3"", "":memory:"")
if err != nil {
    panic(""failed to connect database"")
}
db.Exec(""DROP TABLE IF EXISTS rs;"")

    db.SingularTable(true)

// Migrate the schema
db.AutoMigrate(&rs{})
db.AutoMigrate(&rs_sub{})

populateDb(db)
//db.LogMode(true)
return db

}

// This function fetches all related objects from a given object in the data parameter.
// The struct must be fully tagged, we don't recognize automatically related IDs and so on.
// The function works only with not combined keys.
// Every field which should be fetched must be tagged with:
// walkrec:""true"" gorm:""ForeignKey:ID;AssociationForeignKey:ForeignKey""
// See: http://stackoverflow.com/questions/24537525/reflect-value-fieldbyname-causing-panic
// See: http://stackoverflow.com/questions/34493062/how-to-reflect-struct-recursive-in-golang
func fetchRec(db *gorm.DB, data interface{}) {
    // With data *rs: Type: *main.rs
    // With data interface{}: *main.rs
    var ref reflect.Value
    if reflect.TypeOf(data).Kind() == reflect.Struct {
        ref = reflect.ValueOf(data)
    } else if reflect.TypeOf(data).Kind() == reflect.Ptr {
        ref = reflect.Indirect(reflect.ValueOf(data))
    }
    if ref.Type().Kind() == reflect.Slice {
        for i := 0; i < ref.Len(); i++ {
            if ref.Index(i).Type().Kind() == reflect.Ptr {
                fetchRec(db, ref.Index(i).Elem().Addr().Interface())
            } else if ref.Index(i).Type().Kind() == reflect.Struct {
                // What should we do here?
            }
        }

    } else if ref.Type().Kind() == reflect.Struct {
        for i := 0; i < ref.NumField(); i++ {
            var IDFieldRaw string
            var IDFields []string
            var RefFieldRaw string
            var RefFields []string
            var re *regexp.Regexp
            var matches []string

            if ref.Field(i).CanAddr() && strings.EqualFold(ref.Type().Field(i).Tag.Get(""walkrec""), ""true"") {
                gormflags := ref.Type().Field(i).Tag.Get(""gorm"")
                if gormflags == """" {
                    panic(""No gorm flags found!"")
                } else {
                    re = regexp.MustCompile(`\bForeignKey:([a-zA-Z0-9_,]+)\b`)
                    matches = re.FindStringSubmatch(gormflags)
                    if len(matches) == 2 {
                        IDFieldRaw = matches[1]
                        IDFields = strings.Split(IDFieldRaw, "","")
                    }
                    re = regexp.MustCompile(`\bAssociationForeignKey:([a-zA-Z0-9_,]+)\b`)
                    matches = re.FindStringSubmatch(gormflags)
                    if len(matches) == 2 {
                        RefFieldRaw = matches[1]
                        RefFields = strings.Split(RefFieldRaw, "","")
                    }
                }
                if len(IDFields) == 0 { continue }
                if len(RefFields) != 0 {
                    WhereMap := make(map[string]interface{})
                    for fk := 0; fk < len(RefFields); fk++ {
                        WhereMap[RefFields[fk]] = fmt.Sprint(ref.FieldByName(IDFields[fk]))
                    }
                    db.Where(WhereMap).Find(ref.Field(i).Addr().Interface())
                    if ref.Field(i).Addr().Interface() != nil {
                        fetchRec(db, ref.Field(i).Addr().Interface())
                    }
                } else {
                    panic(""AssociationForeignKey empty!"")
                }
            }
        }
    }
}

func getParams() (id int) {
    flag.IntVar(&id, ""id"", 1, ""the id to fetch"")
    flag.Parse()
    return
}

func fetch(db *gorm.DB, id interface{}) (d rs, found bool) {

    //db.First(&d, id)
    found = false
    found = !db.Find(&d, id).RecordNotFound()
    if found {
        fetchRec(db, &d)
    }
    return
}

// Execute this program. For example:
// go run main.go --id=2
func main() {
    db = InitDB()
    defer db.Close()
    id := getParams()
    PStdErr(""Loading data with ID %d\n"", id)
    rs, found := fetch(db, id)
    if found {
        fmt.Print(XmlMarshal(rs) + ""\n"")
    }
}",7092
44213267,1566,"/**
    {
        ""created_on"": ""26 may 2017"",
        ""todos"": [
            ""go get github.com/go-sql-driver/mysql"",
            ""postman(optional)"",
            ""browser(optional)"",    
        ],
        ""aim"": ""Reading fname column into []string(slice of strings)""
    }
*/


/* 
    mysql> select * from users;
    +----+-----------+----------+----------+-------------------------------+--------------+-------------------------------------------------------------------------------------------------+
    | id | fname     | lname    | uname    | email                         | contact      | profile_pic                                                                                     |
    +----+-----------+----------+----------+-------------------------------+--------------+-------------------------------------------------------------------------------------------------+
    |  1 | Rishikesh | Agrawani | hygull   | rishikesh0014051992@gmail.com | 917353787704 | https://cdn4.iconfinder.com/data/icons/rcons-user/32/user_group_users_accounts_contacts-512.png |
    |  2 | Sandeep   | E        | sandeep  | sandeepeswar8@gmail.com       | 919739040038 | https://cdn4.iconfinder.com/data/icons/eldorado-user/40/user-512.png                            |
    |  3 | Darshan   | Sidar    | darshan  | sidardarshan@gmail.com        | 917996917565 | https://cdn4.iconfinder.com/data/icons/rcons-user/32/child_boy-512.png                          |
    |  4 | Surendra  | Prajapat | surendra | surendrakgadwal@gmail.com     | 918385894407 | https://cdn4.iconfinder.com/data/icons/rcons-user/32/account_male-512.png                       |
    |  5 | Mukesh    | Jakhar   | mukesh   | mjakhar.kjakhar@gmail.com     | 919772254140 | https://cdn2.iconfinder.com/data/icons/rcons-user/32/male-circle-512.png                        |
    +----+-----------+----------+----------+-------------------------------+--------------+-------------------------------------------------------------------------------------------------+
    5 rows in set (0.00 sec)

    mysql> 
*/

package main

import ""log""
import ""net/http""
import ""encoding/json""

import (
    _""github.com/go-sql-driver/mysql""   
    ""database/sql""
)

func users(w http.ResponseWriter, r *http.Request) {
    // db, err := sql.Open(""mysql"", "":@tcp(127.0.0.1:)/?charset=utf8"" )
    db, err := sql.Open(""mysql"", ""hygull:admin@67@tcp(127.0.0.1:3306)/practice_db?charset=utf8"")

    w.Header().Set(""Content-Type"", ""application/json"")

    if err != nil {
        log.Fatal(err)
    }

    rows, err := db.Query(""select id, fname, lname, uname, email, contact, profile_pic from users"")

    if err != nil {
        log.Fatal(err)
    }

    type User struct {
        Id int       `json:""id""`
        Fname string `json:""firstname""`
        Lname string `json:""lastname""`
        Uname string `json:""username""`
        Email string `json:""email""`
        Contact int `json:""contact""`
        ProfilePic string `json:""profile_pic""`
    }

    var users []User

    for rows.Next() {
        var id, contact int
        var fname string
        var lname string
        var uname, email, profile_pic string

        rows.Scan(&id ,&fname, &lname, &uname, &email, &contact, &profile_pic)
        users = append(users, User{id, fname, lname, uname, email, contact, &profile_pic })
    }

    usersBytes, _ := json.Marshal(&users)

    w.Write(usersBytes)
    db.Close()
}

func main() {
    http.HandleFunc(""/users/"", users)
    http.ListenAndServe("":8080"", nil)
}

/* REQUSET

   http://127.0.0.1:8080/users/
*/

/* RESPONSE
[
  {
    ""id"": 1,
    ""firstname"": ""Rishikesh"",
    ""lastname"": ""Agrawani"",
    ""username"": ""hygull"",
    ""email"": ""rishikesh0014051992@gmail.com"",
    ""contact"": 917353787704,
    ""profile_pic"": ""https://cdn4.iconfinder.com/data/icons/rcons-user/32/user_group_users_accounts_contacts-512.png""
  },
  {
    ""id"": 2,
    ""firstname"": ""Sandeep"",
    ""lastname"": ""E"",
    ""username"": ""sandeep"",
    ""email"": ""sandeepeswar8@gmail.com"",
    ""contact"": 919739040038,
    ""profile_pic"": ""https://cdn4.iconfinder.com/data/icons/eldorado-user/40/user-512.png""
  },
  {
    ""id"": 3,
    ""firstname"": ""Darshan"",
    ""lastname"": ""Sidar"",
    ""username"": ""darshan"",
    ""email"": ""sidardarshan@gmail.com"",
    ""contact"": 917996917565,
    ""profile_pic"": ""https://cdn4.iconfinder.com/data/icons/rcons-user/32/child_boy-512.png""
  },
  {
    ""id"": 4,
    ""firstname"": ""Surendra"",
    ""lastname"": ""Prajapat"",
    ""username"": ""surendra"",
    ""email"": ""surendrakgadwal@gmail.com"",
    ""contact"": 918385894407,
    ""profile_pic"": ""https://cdn4.iconfinder.com/data/icons/rcons-user/32/account_male-512.png""
  },
  {
    ""id"": 5,
    ""firstname"": ""Mukesh"",
    ""lastname"": ""Jakhar"",
    ""username"": ""mukesh"",
    ""email"": ""mjakhar.kjakhar@gmail.com"",
    ""contact"": 919772254140,
    ""profile_pic"": ""https://cdn2.iconfinder.com/data/icons/rcons-user/32/male-circle-512.png""
  }
]
*/",4941
44579470,1567,"package main

import (
    ""fmt""
    ""html/template""
    ""io""
    ""net/http""
    ""os""
    ""path/filepath""
    ""strings""

    ""google.golang.org/appengine""

    ""github.com/gorilla/sessions""
)

type IndexPage struct {
    Photos  []string
    LogedIn bool
}

type LoginPage struct {
    Body      string
    FirstName string
    LastName  string
    Email     string
    Error     string
}
type UploadPage struct {
    Error string
    Msg   string
}

func getPhotos() []string {
    photos := make([]string, 0)
    filepath.Walk(""assets/img"", func(path string, fi os.FileInfo, err error) error {
        if fi.IsDir() {
            return nil
        }
        path = strings.Replace(path, ""\\"", ""/"", -1)
        photos = append(photos, path)
        return nil
    })
    return photos
}

var store = sessions.NewCookieStore([]byte(""HelloWorld""))

func loginPage(res http.ResponseWriter, req *http.Request) {
    loginError := """"
    session, _ := store.Get(req, ""session"")
    str, _ := session.Values[""logged-in""].(string)
    if str == ""YES"" {
        http.Redirect(res, req, ""/admin"", 302)
        return
    }
    if req.Method == ""POST"" {
        email := req.FormValue(""email"")
        password := req.FormValue(""password"")
        if email == ""test@example.com"" && password == ""test"" {
            session.Values[""logged-in""] = ""YES""
            session.Save(req, res)
            http.Redirect(res, req, ""/admin"", 302)
            return
        } else {
            loginError = ""Invalid Credential. Please Resubmit""
        }
    }
    tpl, err := template.ParseFiles(""assets/tpl/login.gohtml"", ""assets/tpl/header.gohtml"")
    if err != nil {
        http.Error(res, err.Error(), 500)
        return
    }
    err = tpl.Execute(res, LoginPage{
        Error: loginError,
    })
}

func admin(res http.ResponseWriter, req *http.Request) {
    uploadError := """"
    successMsg := """"
    session, _ := store.Get(req, ""session"")
    str, _ := session.Values[""logged-in""].(string)
    if str != ""YES"" {
        http.Redirect(res, req, ""/login"", 302)
        return
    }
    if req.Method == ""POST"" {
        // 
        src, hdr, err := req.FormFile(""file"")
        if err != nil {
            http.Error(res, ""Invalid File."", 500)
            return
        }

        defer src.Close()
        // create a new file
        // make sure you have a ""tmp"" directory in your web root
        dst, err := os.Create(""assets/img/"" + hdr.Filename)
        if err != nil {
            http.Error(res, err.Error(), 500)
            return
        }

        defer dst.Close()

        // copy the uploaded file into the new file
        io.Copy(dst, src)
    }
    tpl, err := template.ParseFiles(""assets/tpl/admin.gohtml"", ""assets/tpl/header.gohtml"")
    if err != nil {
        http.Error(res, err.Error(), 500)
        return
    }
    err = tpl.Execute(res, UploadPage{
        Error: uploadError,
        Msg:   successMsg,
    })
    if err != nil {
        http.Error(res, err.Error(), 500)
    }
}

func index(res http.ResponseWriter, req *http.Request) {
    session, _ := store.Get(req, ""session"")
    str, _ := session.Values[""logged-in""].(string)
    logged := false
    if str == ""YES"" {
        logged = true
    }

    tpl, err := template.ParseFiles(""assets/tpl/index.gohtml"", ""assets/tpl/header.gohtml"")
    if err != nil {
        fmt.Println(err)
        http.Error(res, err.Error(), 500)
        return
    }
    err = tpl.Execute(res, IndexPage{
        Photos:  getPhotos(),
        LogedIn: logged,
    })
    if err != nil {
        fmt.Println(err)
        http.Error(res, err.Error(), 500)
    }
}

func logout(res http.ResponseWriter, req *http.Request) {
    session, _ := store.Get(req, ""session"")
    str, _ := session.Values[""logged-in""].(string)
    if str == ""YES"" {
        delete(session.Values, ""logged-in"")
        session.Save(req, res)
        http.Redirect(res, req, ""/"", 302)
    } else {
        http.Redirect(res, req, ""/login"", 302)
    }
}

func deletePic(res http.ResponseWriter, req *http.Request) {
    session, _ := store.Get(req, ""session"")
    str, _ := session.Values[""logged-in""].(string)
    if str != ""YES"" {
        http.Redirect(res, req, ""/"", 302)
        return
    }

    if req.Method == ""POST"" {
        imgName := req.FormValue(""imgName"")
        err := os.Remove(imgName)
        if err != nil {
            http.Error(res, err.Error(), 500)
        }
    }

    tpl, err := template.ParseFiles(""assets/tpl/delete.gohtml"", ""assets/tpl/header.gohtml"")
    if err != nil {
        http.Error(res, err.Error(), 500)
    }
    err = tpl.Execute(res, IndexPage{
        Photos: getPhotos(),
    })
    if err != nil {
        http.Error(res, err.Error(), 500)
    }
}

func main() {
    http.HandleFunc(""/delete"", deletePic)
    http.Handle(""/assets/"", http.StripPrefix(""/assets"", http.FileServer(http.Dir(""./assets""))))
    http.HandleFunc(""/"", index)
    http.HandleFunc(""/admin"", admin)
    http.HandleFunc(""/login"", loginPage)
    http.HandleFunc(""/logout"", logout)
    appengine.Main()
}",5052
44580389,1569,"package main

import (
    ""encoding/xml""
    ""fmt""
    ""io/ioutil""
    ""os""
)

type Query struct {
    rpc Rpc_reply `xml:""urn:ietf:params:xml:ns:netconf:base:1.0 rpc-reply,omitempty"" json:""rpc-reply,omitempty""`
}

type Addr_tag_list struct {
    Addr_tag Addr_tag `xml:""urn:ietf:params:xml:ns:netconf:base:1.0 addr,omitempty"" json:""addr,omitempty""`
    Pref_tag Pref_tag `xml:""urn:ietf:params:xml:ns:netconf:base:1.0 pref,omitempty"" json:""pref,omitempty""`
    Tag Tag `xml:""urn:ietf:params:xml:ns:netconf:base:1.0 tag,omitempty"" json:""tag,omitempty""`
    Type_tag Type_tag `xml:""urn:ietf:params:xml:ns:netconf:base:1.0 type,omitempty"" json:""type,omitempty""`
    VpcPeer_tag VpcPeer_tag `xml:""urn:ietf:params:xml:ns:netconf:base:1.0 vpcPeer,omitempty"" json:""vpcPeer,omitempty""`
    XMLName  xml.Name `xml:""urn:ietf:params:xml:ns:netconf:base:1.0 Addr-list,omitempty"" json:""Addr-list,omitempty""`
}

type Dom_list struct {
    If_items If_items `xml:""urn:ietf:params:xml:ns:netconf:base:1.0 if-items,omitempty"" json:""if-items,omitempty""`
    Name_tag Name_tag `xml:""urn:ietf:params:xml:ns:netconf:base:1.0 name,omitempty"" json:""name,omitempty""`
    XMLName  xml.Name `xml:""urn:ietf:params:xml:ns:netconf:base:1.0 Dom-list,omitempty"" json:""Dom-list,omitempty""`
}

type If_list struct {
    Addr_items_tag Addr_items_tag `xml:""urn:ietf:params:xml:ns:netconf:base:1.0 addr-items,omitempty"" json:""addr-items,omitempty""`
    Id_tag Id_tag `xml:""urn:ietf:params:xml:ns:netconf:base:1.0 id,omitempty"" json:""id,omitempty""`
    XMLName  xml.Name `xml:""urn:ietf:params:xml:ns:netconf:base:1.0 If-list,omitempty"" json:""If-list,omitempty""`
}

type Systemtag struct {
    Ipv4_items Ipv4_items `xml:""urn:ietf:params:xml:ns:netconf:base:1.0 ipv4-items,omitempty"" json:""ipv4-items,omitempty""`
    Test_name Test_name `xml:""urn:ietf:params:xml:ns:netconf:base:1.0 test-name,omitempty"" json:""test-name,omitempty""`
    XMLName  xml.Name `xml:""urn:ietf:params:xml:ns:netconf:base:1.0 System,omitempty"" json:""System,omitempty""`
}

type Addr_tag struct {
    Text string `xml:"",chardata"" json:"",omitempty""`
    XMLName  xml.Name `xml:""urn:ietf:params:xml:ns:netconf:base:1.0 addr,omitempty"" json:""addr,omitempty""`
}

type Addr_items_tag struct {
    Addr_tag_list Addr_tag_list `xml:""urn:ietf:params:xml:ns:netconf:base:1.0 Addr-list,omitempty"" json:""Addr-list,omitempty""`
    XMLName  xml.Name `xml:""urn:ietf:params:xml:ns:netconf:base:1.0 addr-items,omitempty"" json:""addr-items,omitempty""`
}

type Data_tag struct {
    Systemtag Systemtag `xml:""urn:ietf:params:xml:ns:netconf:base:1.0 System,omitempty"" json:""System,omitempty""`
    XMLName  xml.Name `xml:""urn:ietf:params:xml:ns:netconf:base:1.0 data,omitempty"" json:""data,omitempty""`
}

type Dom_items struct {
    Dom_list []Dom_list `xml:""urn:ietf:params:xml:ns:netconf:base:1.0 Dom-list,omitempty"" json:""Dom-list,omitempty""`
    XMLName  xml.Name `xml:""urn:ietf:params:xml:ns:netconf:base:1.0 dom-items,omitempty"" json:""dom-items,omitempty""`
}

type Id_tag struct {
    Text string `xml:"",chardata"" json:"",omitempty""`
    XMLName  xml.Name `xml:""urn:ietf:params:xml:ns:netconf:base:1.0 id,omitempty"" json:""id,omitempty""`
}

type If_items struct {
    If_list []If_list `xml:""urn:ietf:params:xml:ns:netconf:base:1.0 If-list,omitempty"" json:""If-list,omitempty""`
    XMLName  xml.Name `xml:""urn:ietf:params:xml:ns:netconf:base:1.0 if-items,omitempty"" json:""if-items,omitempty""`
}

type Inst_items struct {
    Dom_items Dom_items `xml:""urn:ietf:params:xml:ns:netconf:base:1.0 dom-items,omitempty"" json:""dom-items,omitempty""`
    XMLName  xml.Name `xml:""urn:ietf:params:xml:ns:netconf:base:1.0 inst-items,omitempty"" json:""inst-items,omitempty""`
}

type Ipv4_items struct {
    Inst_items Inst_items `xml:""urn:ietf:params:xml:ns:netconf:base:1.0 inst-items,omitempty"" json:""inst-items,omitempty""`
    XMLName  xml.Name `xml:""urn:ietf:params:xml:ns:netconf:base:1.0 ipv4-items,omitempty"" json:""ipv4-items,omitempty""`
}

type Name_tag struct {
    Text string `xml:"",chardata"" json:"",omitempty""`
    XMLName  xml.Name `xml:""urn:ietf:params:xml:ns:netconf:base:1.0 name,omitempty"" json:""name,omitempty""`
}

type Pref_tag struct {
    Text bool `xml:"",chardata"" json:"",omitempty""`
    XMLName  xml.Name `xml:""urn:ietf:params:xml:ns:netconf:base:1.0 pref,omitempty"" json:""pref,omitempty""`
}

type Rpc_reply struct {
    Attr_message_id string `xml:"" message-id,attr""  json:"",omitempty""`
    Attr_xmlns string `xml:"" xmlns,attr""  json:"",omitempty""`
    Data_tag Data_tag `xml:""urn:ietf:params:xml:ns:netconf:base:1.0 data,omitempty"" json:""data,omitempty""`
    XMLName  xml.Name `xml:""urn:ietf:params:xml:ns:netconf:base:1.0 rpc-reply,omitempty"" json:""rpc-reply,omitempty""`
}

type Tag struct {
    Text bool `xml:"",chardata"" json:"",omitempty""`
    XMLName  xml.Name `xml:""urn:ietf:params:xml:ns:netconf:base:1.0 tag,omitempty"" json:""tag,omitempty""`
}

type Type_tag struct {
    Text string `xml:"",chardata"" json:"",omitempty""`
    XMLName  xml.Name `xml:""urn:ietf:params:xml:ns:netconf:base:1.0 type,omitempty"" json:""type,omitempty""`
}

type VpcPeer_tag struct {
    Text string `xml:"",chardata"" json:"",omitempty""`
    XMLName  xml.Name `xml:""urn:ietf:params:xml:ns:netconf:base:1.0 vpcPeer,omitempty"" json:""vpcPeer,omitempty""`
}

type Test_name struct {
    Text string `xml:"",chardata"" json:"",omitempty""`
    XMLName  xml.Name `xml:""urn:ietf:params:xml:ns:netconf:base:1.0 test-name,omitempty"" json:""test-name,omitempty""`
}


func main() {
    xmlFile, err := os.Open(""interface.xml"")
    if err != nil {
        fmt.Println(""Error opening file:"", err)
        return
    }
    defer xmlFile.Close()

    b, _ := ioutil.ReadAll(xmlFile)

    var q Query
    err2 := xml.Unmarshal(b, &q)
    if err2 != nil {
        fmt.Printf(""error: %v"", err2)
        return
    }
    fmt.Println(q)
    //fmt.Printf(""%#v"",q)
     fmt.Printf(""%s"",q.rpc.Attr_message_id);

}",5886
44605108,1571,"C:\Go\pkg\tool\windows_amd64\link.exe: running gcc failed: exit status 1
/usr/lib/w32api/libntdll.a(dmsqs01966.o):(.text+0x0): multiple definition of `pow'
/usr/lib/gcc/x86_64-pc-cygwin/5.4.0/../../../../lib/libm.a(t-d000990.o):fake:(.text+0x0): first defined here
/usr/lib/w32api/libntdll.a(dmsqs01956.o):(.text+0x0): multiple definition of `log'
/usr/lib/gcc/x86_64-pc-cygwin/5.4.0/../../../../lib/libm.a(t-d000824.o):fake:(.text+0x0): first defined here
/usr/lib/w32api/libntdll.a(dmsqs01934.o):(.text+0x0): multiple definition of `ceil'
/usr/lib/gcc/x86_64-pc-cygwin/5.4.0/../../../../lib/libm.a(t-d000253.o):fake:(.text+0x0): first defined here
C:\cygwin64\tmp\go-link-845985599/000001.o: In function `x_cgo_sys_thread_create':
C:/workdir/go/src/runtime/cgo/gcc_libinit_windows.c:12: undefined reference to `__imp___iob_func'
C:/workdir/go/src/runtime/cgo/gcc_libinit_windows.c:12:(.text+0x6): relocation truncated to fit: R_X86_64_PC32 against undefined symbol `__imp___iob_func'
C:\cygwin64\tmp\go-link-845985599/000001.o: In function `x_cgo_thread_start':
C:/workdir/go/src/runtime/cgo/gcc_util.c:43: undefined reference to `__imp___iob_func'
C:/workdir/go/src/runtime/cgo/gcc_util.c:43:(.text+0xdc): relocation truncated",1231
44614413,1573,"var NodeRSA = require('node-rsa');

var ClientSide = new NodeRSA({ b: 512 });
var privateKey = `-----BEGIN RSA PRIVATE KEY-----
MIIEogIBAAKCAQEAj1IEeouqDYiMX0rMiPAI64UntzNxE01+tB+k+aKesHzVXE5A
GnyWHIFdrByfjR93CMh3y56xsL78VP1/Xp8iVmAnbiFN5kpmawJ1owhDvNIl8A+Q
UiDzMg0z/yepzjp61Dg4CUFzGrmTfYO1aMWyWhR0ZKfy+HvVaGjpod2ioScU7Fkz
eO+fDR85quLFta7OXDwqD4NCPYeZTS5fgK1Nn72nrItoj5e36fzWvZntfvi4NHt7
nqOj4VH5e5YJHvmLWHh5Swh+OVyIAwhxYSK5PSupicGG8ixVy75hkjzZ2vW5JdVW
MPYbVUMpqjtE+i1zQTYNJ36hM/zznZR/drU7UwIDAQABAoIBAHvs02qTMWuaUqZj
KxCNXWkpLfo/RNsH+zMM2b3xW34HswWps8wzRilHwxN7fIquVmMF1HAAvGyz98QV
nfjXaP1/DxkvOwiR9JU6/zUFhGzU2XEGRCh/zUnOGNPcG/vynRq7sdhu+3R0WpAB
Pu9lYp55aVtPzcwGZ7VsYfhQiLsGnJ5GkBS7z4P3aG29By6fGnTwR83iQHtR5SvQ
Rb/xJxZjTM00OZ2ssAtw24Hu8QXTuOAHdy2B5E1tsF+hVHs4iB0OiLzW7m4GBkb/
/og76ouB4G+j6IjG2E5TO0eAdslKn2w3dZRgqnVDF5CPtRdbAc83xOwSouuuqN26
FPsLkwECgYEA4Jyf3j9UzW0znnOcul4MDvfKuMCzD/5wnc24aYBbie4Joi/jqDbc
9J5jqyfgzdqwjxiwkEFJi7gBcclO1i1SoIfA6ooVoJeQlzdMpSytZVhzgE2aJO1E
ORP7kLimAHysjMJ27Fix1VRZltcZe0E9DErkw/hoPemAMvDvW2myyaECgYEAo1k7
iS4O9GSHUKvbEJWR5r+9Qvv4aObOaRFRDfq4/E9fZwujzKAvxwkGFXjxwpzxKJqN
paVEL2cWY+S46f4B501xgnNknuf6po8ZEaXD5vy281xoU4YX1KFySbV8eXGmkyiO
M2+vPGrsTGOIsKnQW8jmaxWTClbSdPoLWfwzqHMCgYAS/Kp2+xuMEgMfDd7d0j1q
tn+ohoGchIG4lT9Vi8gxLLIbx7iS67BZ7Vm3ijNys13hetDSIPK6oN9eYwoLCOHH
ODKSoQGbBbTvU3ljLRerTYLWAblaDcSKnqnRXgqKV/+uFnI/IHBH/E1mduBsjuM+
OsaD2mfVc/umUr+pFpJKgQKBgCeaTb3fhc6oxMnBMLZfnOT13Zvs3PgJ5UdB5IXg
IJNDZxzjjI3i1FKMFIaGMQ7+39T5S5g6bkKT2rDTViWc6Lc8ZmW7Nkz0byeMkAZg
SxOod26fG8gMPaDWl4/ZSVlkPX92GKvNyw152tpWU2CJezOVjI+vxlt+Wz3zFWd2
psuTAoGAbdlzYFK+7e2ru8fdbVk9SBLn9cnPdDCx+wgJV7dB0zzSh1oqIrE766Mx
c9wBIKWNqNEsFsFI4ejuMRdC4Hyc6ecCNea3nj3BHCS70V0p1MtFII6SpADDqBTW
3ZnLfcN2MiFDBXVqNkCsMcqd8KVdzEqEy1JDplmW84OpfQu88ms=
-----END RSA PRIVATE KEY-----`
var publicKey = `-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAj1IEeouqDYiMX0rMiPAI
64UntzNxE01+tB+k+aKesHzVXE5AGnyWHIFdrByfjR93CMh3y56xsL78VP1/Xp8i
VmAnbiFN5kpmawJ1owhDvNIl8A+QUiDzMg0z/yepzjp61Dg4CUFzGrmTfYO1aMWy
WhR0ZKfy+HvVaGjpod2ioScU7FkzeO+fDR85quLFta7OXDwqD4NCPYeZTS5fgK1N
n72nrItoj5e36fzWvZntfvi4NHt7nqOj4VH5e5YJHvmLWHh5Swh+OVyIAwhxYSK5
PSupicGG8ixVy75hkjzZ2vW5JdVWMPYbVUMpqjtE+i1zQTYNJ36hM/zznZR/drU7
UwIDAQAB
-----END PUBLIC KEY-----`

ClientSide.importKey(privateKey, 'pkcs1');
let result = ClientSide.sign('test_message', 'base64')

console.log(result)

var serverSide = new NodeRSA({ b: 512 });
serverSide.importKey(publicKey, 'pkcs8-public');
console.log(serverSide.verify('test_message', new Buffer(result, 'base64')))",2530
44625610,1576,"goroutine profile: total 32685

1 @ 0x42fd33 0x42a7ee 0x429cb0 0x629fba 0x62a086 0x62d084 0x640964 0x5e6306 0x73b75b 0x73b0b2 0x744660 0x5f13ea 0x5fbc12 0x5f8dd0 0x5ffd9f 0x48dcea 0x5f729f 0x460ae1
#   0x429cb0    net.runtime_pollWait+0x60                       /usr/local/go/src/runtime/netpoll.go:160
#   0x629fba    net.(*pollDesc).Wait+0x3a                       /usr/local/go/src/net/fd_poll_runtime.go:73
#   0x62a086    net.(*pollDesc).WaitWrite+0x36                      /usr/local/go/src/net/fd_poll_runtime.go:82
#   0x62d084    net.(*netFD).Write+0x414                        /usr/local/go/src/net/fd_unix.go:336
#   0x640964    net.(*conn).Write+0xe4                          /usr/local/go/src/net/net.go:184
#   0x5e6306    github.com/moonfrog/heimdall/network.(*Messenger).WriteMessage+0x86 /home/rts/gopath/src/github.com/moonfrog/heimdall/network/messenger.go:40
#   0x73b75b    github.com/moonfrog/heimdall/service.(*Service).sendPacket+0x55b    /home/rts/gopath/src/github.com/moonfrog/heimdall/service/service.go:91
#   0x73b0b2    github.com/moonfrog/heimdall/service.(*Service).Send+0x442      /home/rts/gopath/src/github.com/moonfrog/heimdall/service/service.go:79
#   0x744660    github.com/moonfrog/heimdall/service/manager.(*Sticky).Send+0x5e0   /home/rts/gopath/src/github.com/moonfrog/heimdall/service/manager/sticky.go:91
#   0x5f13ea    github.com/moonfrog/heimdall/serviceController.(*Controller).Send+0x22a /home/rts/gopath/src/github.com/moonfrog/heimdall/serviceController/controller.go:169
#   0x5fbc12    github.com/moonfrog/heimdall/client.(*Client).sendToService+0x482   /home/rts/gopath/src/github.com/moonfrog/heimdall/client/client.go:452
#   0x5f8dd0    github.com/moonfrog/heimdall/client.(*Client).process+0xfd0     /home/rts/gopath/src/github.com/moonfrog/heimdall/client/client.go:256
#   0x5ffd9f    github.com/moonfrog/heimdall/client.(*Client).stateMachine.func1+0x3f   /home/rts/gopath/src/github.com/moonfrog/heimdall/client/client.go:136
#   0x48dcea    github.com/moonfrog/heimdall/common.Safe+0x3a               /home/rts/gopath/src/github.com/moonfrog/heimdall/common/utils.go:49
#   0x5f729f    github.com/moonfrog/heimdall/client.(*Client).stateMachine+0x1df    /home/rts/gopath/src/github.com/moonfrog/heimdall/client/client.go:137

1 @ 0x460ae1

1148 @ 0x42fd33 0x42fdf4 0x43f877 0x43f506 0x6299cc 0x62b7d9 0x62ccdc 0x640964 0x5e6306 0x73b75b 0x73cb72 0x74475e 0x5f1ea3 0x491dac 0x491c99 0x5fa486 0x5f7467 0x460ae1
#   0x43f506    net.runtime_Semacquire+0x26                         /usr/local/go/src/runtime/sema.go:52
#   0x6299cc    net.(*fdMutex).RWLock+0x16c                         /usr/local/go/src/net/fd_mutex.go:143
#   0x62b7d9    net.(*netFD).writeLock+0x39                         /usr/local/go/src/net/fd_unix.go:194
#   0x62ccdc    net.(*netFD).Write+0x6c                             /usr/local/go/src/net/fd_unix.go:319
#   0x640964    net.(*conn).Write+0xe4                              /usr/local/go/src/net/net.go:184
#   0x5e6306    github.com/moonfrog/heimdall/network.(*Messenger).WriteMessage+0x86     /home/rts/gopath/src/github.com/moonfrog/heimdall/network/messenger.go:40
#   0x73b75b    github.com/moonfrog/heimdall/service.(*Service).sendPacket+0x55b        /home/rts/gopath/src/github.com/moonfrog/heimdall/service/service.go:91
#   0x73cb72    github.com/moonfrog/heimdall/service.(*Service).OnDisconnect+0xb2       /home/rts/gopath/src/github.com/moonfrog/heimdall/service/service.go:179
#   0x74475e    github.com/moonfrog/heimdall/service/manager.(*Sticky).Disconnect+0x5e      /home/rts/gopath/src/github.com/moonfrog/heimdall/service/manager/sticky.go:97
#   0x5f1ea3    github.com/moonfrog/heimdall/serviceController.(*Controller).OnDisconnect+0x393 /home/rts/gopath/src/github.com/moonfrog/heimdall/serviceController/controller.go:210
#   0x491dac    github.com/moonfrog/heimdall/router.(*Router).onDisconnect+0x8c         /home/rts/gopath/src/github.com/moonfrog/heimdall/router/router.go:151
#   0x491c99    github.com/moonfrog/heimdall/router.(*Router).UnregisterClient+0x309        /home/rts/gopath/src/github.com/moonfrog/heimdall/router/router.go:146
#   0x5fa486    github.com/moonfrog/heimdall/client.(*Client).disconnect+0x206          /home/rts/gopath/src/github.com/moonfrog/heimdall/client/client.go:329
#   0x5f7467    github.com/moonfrog/heimdall/client.(*Client).stateMachine+0x3a7        /home/rts/gopath/src/github.com/moonfrog/heimdall/client/client.go:150

11385 @ 0x42fd33 0x43e9f7 0x43df52 0x5fc6df 0x49181f 0x5faae9 0x5f94bf 0x5f8cdb 0x5ffd9f 0x48dcea 0x5f729f 0x460ae1
#   0x5fc6df    github.com/moonfrog/heimdall/client.(*Client).ForceDisconnect+0xdf  /home/rts/gopath/src/github.com/moonfrog/heimdall/client/client.go:502
#   0x49181f    github.com/moonfrog/heimdall/router.(*Router).RegisterClient+0x7af  /home/rts/gopath/src/github.com/moonfrog/heimdall/router/router.go:114
#   0x5faae9    github.com/moonfrog/heimdall/client.(*Client).join+0x5e9        /home/rts/gopath/src/github.com/moonfrog/heimdall/client/client.go:379
#   0x5f94bf    github.com/moonfrog/heimdall/client.(*Client).handleRouterMsg+0x61f /home/rts/gopath/src/github.com/moonfrog/heimdall/client/client.go:265
#   0x5f8cdb    github.com/moonfrog/heimdall/client.(*Client).process+0xedb     /home/rts/gopath/src/github.com/moonfrog/heimdall/client/client.go:254
#   0x5ffd9f    github.com/moonfrog/heimdall/client.(*Client).stateMachine.func1+0x3f   /home/rts/gopath/src/github.com/moonfrog/heimdall/client/client.go:136
#   0x48dcea    github.com/moonfrog/heimdall/common.Safe+0x3a               /home/rts/gopath/src/github.com/moonfrog/heimdall/common/utils.go:49
#   0x5f729f    github.com/moonfrog/heimdall/client.(*Client).stateMachine+0x1df    /home/rts/gopath/src/github.com/moonfrog/heimdall/client/client.go:137

1 @ 0x42fd33 0x42fdf4 0x43f877 0x43f4c6 0x4c6d64 0x6f9081 0x704b71 0x460ae1
#   0x43f4c6    sync.runtime_Semacquire+0x26                /usr/local/go/src/runtime/sema.go:47
#   0x4c6d64    sync.(*WaitGroup).Wait+0xb4             /usr/local/go/src/sync/waitgroup.go:127
#   0x6f9081    github.com/samuel/go-zookeeper/zk.(*Conn).loop+0x8c1    /home/rts/gopath/src/github.com/samuel/go-zookeeper/zk/conn.go:436
#   0x704b71    github.com/samuel/go-zookeeper/zk.Connect.func1+0x21    /home/rts/gopath/src/github.com/samuel/go-zookeeper/zk/conn.go:218

11343 @ 0x42fd33 0x43e9f7 0x43df52 0x5f70ab 0x460ae1
#   0x5f70ab    github.com/moonfrog/heimdall/client.(*Client).readPump+0x70b    /home/rts/gopath/src/github.com/moonfrog/heimdall/client/client.go:111

4332 @ 0x42fd33 0x43e9f7 0x43df52 0x5f6d54 0x460ae1
#   0x5f6d54    github.com/moonfrog/heimdall/client.(*Client).readPump+0x3b4    /home/rts/gopath/src/github.com/moonfrog/heimdall/client/client.go:104

1438 @ 0x42fd33 0x42fdf4 0x43f877 0x43f506 0x6299cc 0x62b7d9 0x62ccdc 0x640964 0x5e6306 0x73b75b 0x73ca92 0x7447ee 0x5f1fd4 0x491897 0x5faae9 0x5f94bf 0x5f8cdb 0x5ffd9f 0x48dcea 0x5f729f 0x460ae1
#   0x43f506    net.runtime_Semacquire+0x26                         /usr/local/go/src/runtime/sema.go:52
#   0x6299cc    net.(*fdMutex).RWLock+0x16c                         /usr/local/go/src/net/fd_mutex.go:143
#   0x62b7d9    net.(*netFD).writeLock+0x39                         /usr/local/go/src/net/fd_unix.go:194
#   0x62ccdc    net.(*netFD).Write+0x6c                             /usr/local/go/src/net/fd_unix.go:319
#   0x640964    net.(*conn).Write+0xe4                              /usr/local/go/src/net/net.go:184
#   0x5e6306    github.com/moonfrog/heimdall/network.(*Messenger).WriteMessage+0x86     /home/rts/gopath/src/github.com/moonfrog/heimdall/network/messenger.go:40
#   0x73b75b    github.com/moonfrog/heimdall/service.(*Service).sendPacket+0x55b        /home/rts/gopath/src/github.com/moonfrog/heimdall/service/service.go:91
#   0x73ca92    github.com/moonfrog/heimdall/service.(*Service).OnReconnect+0xb2        /home/rts/gopath/src/github.com/moonfrog/heimdall/service/service.go:171
#   0x7447ee    github.com/moonfrog/heimdall/service/manager.(*Sticky).Reconnect+0x5e       /home/rts/gopath/src/github.com/moonfrog/heimdall/service/manager/sticky.go:105
#   0x5f1fd4    github.com/moonfrog/heimdall/serviceController.(*Controller).OnReconnect+0xd4   /home/rts/gopath/src/github.com/moonfrog/heimdall/serviceController/controller.go:218
#   0x491897    github.com/moonfrog/heimdall/router.(*Router).RegisterClient+0x827      /home/rts/gopath/src/github.com/moonfrog/heimdall/router/router.go:116
#   0x5faae9    github.com/moonfrog/heimdall/client.(*Client).join+0x5e9            /home/rts/gopath/src/github.com/moonfrog/heimdall/client/client.go:379
#   0x5f94bf    github.com/moonfrog/heimdall/client.(*Client).handleRouterMsg+0x61f     /home/rts/gopath/src/github.com/moonfrog/heimdall/client/client.go:265
#   0x5f8cdb    github.com/moonfrog/heimdall/client.(*Client).process+0xedb         /home/rts/gopath/src/github.com/moonfrog/heimdall/client/client.go:254
#   0x5ffd9f    github.com/moonfrog/heimdall/client.(*Client).stateMachine.func1+0x3f       /home/rts/gopath/src/github.com/moonfrog/heimdall/client/client.go:136
#   0x48dcea    github.com/moonfrog/heimdall/common.Safe+0x3a                   /home/rts/gopath/src/github.com/moonfrog/heimdall/common/utils.go:49
#   0x5f729f    github.com/moonfrog/heimdall/client.(*Client).stateMachine+0x1df        /home/rts/gopath/src/github.com/moonfrog/heimdall/client/client.go:137

18 @ 0x42fd33 0x43e9f7 0x43df52 0x73fbab 0x460ae1
#   0x73fbab    github.com/moonfrog/heimdall/service.(*Service).startHB.func1+0x23b /home/rts/gopath/src/github.com/moonfrog/heimdall/service/service.go:241

1 @ 0x42fd33 0x42fdf4 0x4061ef 0x405d0b 0x587454 0x460ae1
#   0x587454    github.com/moonfrog/badger/lib/stats/serverside/golang.(*Client).startScheduler+0x94    /home/rts/gopath/src/github.com/moonfrog/badger/lib/stats/serverside/golang/client.go:182

1 @ 0x42fd33 0x42a7ee 0x429cb0 0x629fba 0x62a026 0x62dcbc 0x64bbfd 0x54d121 0x54c2b9 0x54c106 0x54c808 0x5807ac 0x460ae1
#   0x429cb0    net.runtime_pollWait+0x60                   /usr/local/go/src/runtime/netpoll.go:160
#   0x629fba    net.(*pollDesc).Wait+0x3a                   /usr/local/go/src/net/fd_poll_runtime.go:73
#   0x62a026    net.(*pollDesc).WaitRead+0x36                   /usr/local/go/src/net/fd_poll_runtime.go:78
#   0x62dcbc    net.(*netFD).accept+0x27c                   /usr/local/go/src/net/fd_unix.go:426
#   0x64bbfd    net.(*TCPListener).AcceptTCP+0x4d               /usr/local/go/src/net/tcpsock_posix.go:254
#   0x54d121    net/http.tcpKeepAliveListener.Accept+0x41           /usr/local/go/src/net/http/server.go:2427
#   0x54c2b9    net/http.(*Server).Serve+0x129                  /usr/local/go/src/net/http/server.go:2117
#   0x54c106    net/http.(*Server).ListenAndServe+0x136             /usr/local/go/src/net/http/server.go:2098
#   0x54c808    net/http.ListenAndServe+0x98                    /usr/local/go/src/net/http/server.go:2195
#   0x5807ac    github.com/moonfrog/heimdall/debugger.(*Debugger).Start+0x55c   /home/rts/gopath/src/github.com/moonfrog/heimdall/debugger/debugger.go:89

2361 @ 0x42fd33 0x42fdf4 0x43f877 0x43f4c6 0x4c65b8 0x5f2066 0x5f9d26 0x5f8cdb 0x5ffd9f 0x48dcea 0x5f729f 0x460ae1
#   0x43f4c6    sync.runtime_Semacquire+0x26                            /usr/local/go/src/runtime/sema.go:47
#   0x4c65b8    sync.(*RWMutex).RLock+0x58                          /usr/local/go/src/sync/rwmutex.go:37
#   0x5f2066    github.com/moonfrog/heimdall/serviceController.(*Controller).OnConnect+0x46 /home/rts/gopath/src/github.com/moonfrog/heimdall/serviceController/controller.go:224
#   0x5f9d26    github.com/moonfrog/heimdall/client.(*Client).handleRouterMsg+0xe86     /home/rts/gopath/src/github.com/moonfrog/heimdall/client/client.go:284
#   0x5f8cdb    github.com/moonfrog/heimdall/client.(*Client).process+0xedb         /home/rts/gopath/src/github.com/moonfrog/heimdall/client/client.go:254
#   0x5ffd9f    github.com/moonfrog/heimdall/client.(*Client).stateMachine.func1+0x3f       /home/rts/gopath/src/github.com/moonfrog/heimdall/client/client.go:136
#   0x48dcea    github.com/moonfrog/heimdall/common.Safe+0x3a                   /home/rts/gopath/src/github.com/moonfrog/heimdall/common/utils.go:49
#   0x5f729f    github.com/moonfrog/heimdall/client.(*Client).stateMachine+0x1df        /home/rts/gopath/src/github.com/moonfrog/heimdall/client/client.go:137

387 @ 0x42fd33 0x42fdf4 0x43f877 0x43f506 0x6299cc 0x62b7d9 0x62ccdc 0x640964 0x5e6306 0x73b75b 0x73b0b2 0x744660 0x5f13ea 0x5fbc12 0x5f8dd0 0x5ffd9f 0x48dcea 0x5f729f 0x460ae1
#   0x43f506    net.runtime_Semacquire+0x26                     /usr/local/go/src/runtime/sema.go:52
#   0x6299cc    net.(*fdMutex).RWLock+0x16c                     /usr/local/go/src/net/fd_mutex.go:143
#   0x62b7d9    net.(*netFD).writeLock+0x39                     /usr/local/go/src/net/fd_unix.go:194
#   0x62ccdc    net.(*netFD).Write+0x6c                         /usr/local/go/src/net/fd_unix.go:319
#   0x640964    net.(*conn).Write+0xe4                          /usr/local/go/src/net/net.go:184
#   0x5e6306    github.com/moonfrog/heimdall/network.(*Messenger).WriteMessage+0x86 /home/rts/gopath/src/github.com/moonfrog/heimdall/network/messenger.go:40
#   0x73b75b    github.com/moonfrog/heimdall/service.(*Service).sendPacket+0x55b    /home/rts/gopath/src/github.com/moonfrog/heimdall/service/service.go:91
#   0x73b0b2    github.com/moonfrog/heimdall/service.(*Service).Send+0x442      /home/rts/gopath/src/github.com/moonfrog/heimdall/service/service.go:79
#   0x744660    github.com/moonfrog/heimdall/service/manager.(*Sticky).Send+0x5e0   /home/rts/gopath/src/github.com/moonfrog/heimdall/service/manager/sticky.go:91
#   0x5f13ea    github.com/moonfrog/heimdall/serviceController.(*Controller).Send+0x22a /home/rts/gopath/src/github.com/moonfrog/heimdall/serviceController/controller.go:169
#   0x5fbc12    github.com/moonfrog/heimdall/client.(*Client).sendToService+0x482   /home/rts/gopath/src/github.com/moonfrog/heimdall/client/client.go:452
#   0x5f8dd0    github.com/moonfrog/heimdall/client.(*Client).process+0xfd0     /home/rts/gopath/src/github.com/moonfrog/heimdall/client/client.go:256
#   0x5ffd9f    github.com/moonfrog/heimdall/client.(*Client).stateMachine.func1+0x3f   /home/rts/gopath/src/github.com/moonfrog/heimdall/client/client.go:136
#   0x48dcea    github.com/moonfrog/heimdall/common.Safe+0x3a               /home/rts/gopath/src/github.com/moonfrog/heimdall/common/utils.go:49
#   0x5f729f    github.com/moonfrog/heimdall/client.(*Client).stateMachine+0x1df    /home/rts/gopath/src/github.com/moonfrog/heimdall/client/client.go:137

1 @ 0x42fd33 0x42fdf4 0x43f877 0x43f4c6 0x4c67b1 0x5f3391 0x460ae1
#   0x43f4c6    sync.runtime_Semacquire+0x26                            /usr/local/go/src/runtime/sema.go:47
#   0x4c67b1    sync.(*RWMutex).Lock+0xa1                           /usr/local/go/src/sync/rwmutex.go:88
#   0x5f3391    github.com/moonfrog/heimdall/serviceController.(*Controller).monitor+0xc1   /home/rts/gopath/src/github.com/moonfrog/heimdall/serviceController/controller.go:286

1 @ 0x42fd33 0x42fdf4 0x43f877 0x43f506 0x6299cc 0x62b7d9 0x62ccdc 0x640964 0x5e6306 0x73b75b 0x73fb4c 0x460ae1
#   0x43f506    net.runtime_Semacquire+0x26                     /usr/local/go/src/runtime/sema.go:52
#   0x6299cc    net.(*fdMutex).RWLock+0x16c                     /usr/local/go/src/net/fd_mutex.go:143
#   0x62b7d9    net.(*netFD).writeLock+0x39                     /usr/local/go/src/net/fd_unix.go:194
#   0x62ccdc    net.(*netFD).Write+0x6c                         /usr/local/go/src/net/fd_unix.go:319
#   0x640964    net.(*conn).Write+0xe4                          /usr/local/go/src/net/net.go:184
#   0x5e6306    github.com/moonfrog/heimdall/network.(*Messenger).WriteMessage+0x86 /home/rts/gopath/src/github.com/moonfrog/heimdall/network/messenger.go:40
#   0x73b75b    github.com/moonfrog/heimdall/service.(*Service).sendPacket+0x55b    /home/rts/gopath/src/github.com/moonfrog/heimdall/service/service.go:91
#   0x73fb4c    github.com/moonfrog/heimdall/service.(*Service).startHB.func1+0x1dc /home/rts/gopath/src/github.com/moonfrog/heimdall/service/service.go:252

1 @ 0x42fd33 0x43e9f7 0x43df52 0x4558a8 0x460ae1
#   0x42fd33    runtime.gopark+0x163        /usr/local/go/src/runtime/proc.go:263
#   0x43e9f7    runtime.selectgoImpl+0xa67  /usr/local/go/src/runtime/select.go:392
#   0x43df52    runtime.selectgo+0x12       /usr/local/go/src/runtime/select.go:215
#   0x4558a8    runtime.ensureSigM.func1+0x358  /usr/local/go/src/runtime/signal1_unix.go:279

2 @ 0x42fd33 0x42a7ee 0x429cb0 0x629fba 0x62a026 0x62dcbc 0x64bbfd 0x5e6f16 0x460ae1
#   0x429cb0    net.runtime_pollWait+0x60                       /usr/local/go/src/runtime/netpoll.go:160
#   0x629fba    net.(*pollDesc).Wait+0x3a                       /usr/local/go/src/net/fd_poll_runtime.go:73
#   0x62a026    net.(*pollDesc).WaitRead+0x36                       /usr/local/go/src/net/fd_poll_runtime.go:78
#   0x62dcbc    net.(*netFD).accept+0x27c                       /usr/local/go/src/net/fd_unix.go:426
#   0x64bbfd    net.(*TCPListener).AcceptTCP+0x4d                   /usr/local/go/src/net/tcpsock_posix.go:254
#   0x5e6f16    github.com/moonfrog/heimdall/network.(*TCPServer).Start.func1+0x46  /home/rts/gopath/src/github.com/moonfrog/heimdall/network/tcpServer.go:22

12 @ 0x42fd33 0x42fdf4 0x43f877 0x43f506 0x6299cc 0x62b7d9 0x62ccdc 0x640964 0x5e6306 0x73b75b 0x73b0b2 0x744660 0x5f13ea 0x73c308 0x73f5cf 0x48dcea 0x73f89c 0x460ae1
#   0x43f506    net.runtime_Semacquire+0x26                     /usr/local/go/src/runtime/sema.go:52
#   0x6299cc    net.(*fdMutex).RWLock+0x16c                     /usr/local/go/src/net/fd_mutex.go:143
#   0x62b7d9    net.(*netFD).writeLock+0x39                     /usr/local/go/src/net/fd_unix.go:194
#   0x62ccdc    net.(*netFD).Write+0x6c                         /usr/local/go/src/net/fd_unix.go:319
#   0x640964    net.(*conn).Write+0xe4                          /usr/local/go/src/net/net.go:184
#   0x5e6306    github.com/moonfrog/heimdall/network.(*Messenger).WriteMessage+0x86 /home/rts/gopath/src/github.com/moonfrog/heimdall/network/messenger.go:40
#   0x73b75b    github.com/moonfrog/heimdall/service.(*Service).sendPacket+0x55b    /home/rts/gopath/src/github.com/moonfrog/heimdall/service/service.go:91
#   0x73b0b2    github.com/moonfrog/heimdall/service.(*Service).Send+0x442      /home/rts/gopath/src/github.com/moonfrog/heimdall/service/service.go:79
#   0x744660    github.com/moonfrog/heimdall/service/manager.(*Sticky).Send+0x5e0   /home/rts/gopath/src/github.com/moonfrog/heimdall/service/manager/sticky.go:91
#   0x5f13ea    github.com/moonfrog/heimdall/serviceController.(*Controller).Send+0x22a /home/rts/gopath/src/github.com/moonfrog/heimdall/serviceController/controller.go:169
#   0x73c308    github.com/moonfrog/heimdall/service.(*Service).process+0x8a8       /home/rts/gopath/src/github.com/moonfrog/heimdall/service/service.go:142
#   0x73f5cf    github.com/moonfrog/heimdall/service.(*Service).readPump.func1.1+0x3f   /home/rts/gopath/src/github.com/moonfrog/heimdall/service/service.go:111
#   0x48dcea    github.com/moonfrog/heimdall/common.Safe+0x3a               /home/rts/gopath/src/github.com/moonfrog/heimdall/common/utils.go:49
#   0x73f89c    github.com/moonfrog/heimdall/service.(*Service).readPump.func1+0x2bc    /home/rts/gopath/src/github.com/moonfrog/heimdall/service/service.go:112

102 @ 0x42fd33 0x42fdf4 0x43f877 0x43f506 0x6299cc 0x62b7d9 0x62ccdc 0x640964 0x5e6306 0x73b75b 0x73cb72 0x74475e 0x7457a6 0x5f23d9 0x5f9d26 0x5f8cdb 0x5ffd9f 0x48dcea 0x5f729f 0x460ae1
#   0x43f506    net.runtime_Semacquire+0x26                         /usr/local/go/src/runtime/sema.go:52
#   0x6299cc    net.(*fdMutex).RWLock+0x16c                         /usr/local/go/src/net/fd_mutex.go:143
#   0x62b7d9    net.(*netFD).writeLock+0x39                         /usr/local/go/src/net/fd_unix.go:194
#   0x62ccdc    net.(*netFD).Write+0x6c                             /usr/local/go/src/net/fd_unix.go:319
#   0x640964    net.(*conn).Write+0xe4                              /usr/local/go/src/net/net.go:184
#   0x5e6306    github.com/moonfrog/heimdall/network.(*Messenger).WriteMessage+0x86     /home/rts/gopath/src/github.com/moonfrog/heimdall/network/messenger.go:40
#   0x73b75b    github.com/moonfrog/heimdall/service.(*Service).sendPacket+0x55b        /home/rts/gopath/src/github.com/moonfrog/heimdall/service/service.go:91
#   0x73cb72    github.com/moonfrog/heimdall/service.(*Service).OnDisconnect+0xb2       /home/rts/gopath/src/github.com/moonfrog/heimdall/service/service.go:179
#   0x74475e    github.com/moonfrog/heimdall/service/manager.(*Sticky).Disconnect+0x5e      /home/rts/gopath/src/github.com/moonfrog/heimdall/service/manager/sticky.go:97
#   0x7457a6    github.com/moonfrog/heimdall/service/manager.(*Sticky).Connect+0x856        /home/rts/gopath/src/github.com/moonfrog/heimdall/service/manager/sticky.go:147
#   0x5f23d9    github.com/moonfrog/heimdall/serviceController.(*Controller).OnConnect+0x3b9    /home/rts/gopath/src/github.com/moonfrog/heimdall/serviceController/controller.go:235
#   0x5f9d26    github.com/moonfrog/heimdall/client.(*Client).handleRouterMsg+0xe86     /home/rts/gopath/src/github.com/moonfrog/heimdall/client/client.go:284
#   0x5f8cdb    github.com/moonfrog/heimdall/client.(*Client).process+0xedb         /home/rts/gopath/src/github.com/moonfrog/heimdall/client/client.go:254
#   0x5ffd9f    github.com/moonfrog/heimdall/client.(*Client).stateMachine.func1+0x3f       /home/rts/gopath/src/github.com/moonfrog/heimdall/client/client.go:136
#   0x48dcea    github.com/moonfrog/heimdall/common.Safe+0x3a                   /home/rts/gopath/src/github.com/moonfrog/heimdall/common/utils.go:49
#   0x5f729f    github.com/moonfrog/heimdall/client.(*Client).stateMachine+0x1df        /home/rts/gopath/src/github.com/moonfrog/heimdall/client/client.go:137

13 @ 0x42fd33 0x42fdf4 0x43f877 0x43f506 0x6299cc 0x62b7d9 0x62ccdc 0x640964 0x5e6306 0x73b75b 0x73cb72 0x74475e 0x5f1ea3 0x491dac 0x491c99 0x5fa486 0x5fa25a 0x5f8cdb 0x5ffd9f 0x48dcea 0x5f729f 0x460ae1
#   0x43f506    net.runtime_Semacquire+0x26                         /usr/local/go/src/runtime/sema.go:52
#   0x6299cc    net.(*fdMutex).RWLock+0x16c                         /usr/local/go/src/net/fd_mutex.go:143
#   0x62b7d9    net.(*netFD).writeLock+0x39                         /usr/local/go/src/net/fd_unix.go:194
#   0x62ccdc    net.(*netFD).Write+0x6c                             /usr/local/go/src/net/fd_unix.go:319
#   0x640964    net.(*conn).Write+0xe4                              /usr/local/go/src/net/net.go:184
#   0x5e6306    github.com/moonfrog/heimdall/network.(*Messenger).WriteMessage+0x86     /home/rts/gopath/src/github.com/moonfrog/heimdall/network/messenger.go:40
#   0x73b75b    github.com/moonfrog/heimdall/service.(*Service).sendPacket+0x55b        /home/rts/gopath/src/github.com/moonfrog/heimdall/service/service.go:91
#   0x73cb72    github.com/moonfrog/heimdall/service.(*Service).OnDisconnect+0xb2       /home/rts/gopath/src/github.com/moonfrog/heimdall/service/service.go:179
#   0x74475e    github.com/moonfrog/heimdall/service/manager.(*Sticky).Disconnect+0x5e      /home/rts/gopath/src/github.com/moonfrog/heimdall/service/manager/sticky.go:97
#   0x5f1ea3    github.com/moonfrog/heimdall/serviceController.(*Controller).OnDisconnect+0x393 /home/rts/gopath/src/github.com/moonfrog/heimdall/serviceController/controller.go:210
#   0x491dac    github.com/moonfrog/heimdall/router.(*Router).onDisconnect+0x8c         /home/rts/gopath/src/github.com/moonfrog/heimdall/router/router.go:151
#   0x491c99    github.com/moonfrog/heimdall/router.(*Router).UnregisterClient+0x309        /home/rts/gopath/src/github.com/moonfrog/heimdall/router/router.go:146
#   0x5fa486    github.com/moonfrog/heimdall/client.(*Client).disconnect+0x206          /home/rts/gopath/src/github.com/moonfrog/heimdall/client/client.go:329
#   0x5fa25a    github.com/moonfrog/heimdall/client.(*Client).handleRouterMsg+0x13ba        /home/rts/gopath/src/github.com/moonfrog/heimdall/client/client.go:274
#   0x5f8cdb    github.com/moonfrog/heimdall/client.(*Client).process+0xedb         /home/rts/gopath/src/github.com/moonfrog/heimdall/client/client.go:254
#   0x5ffd9f    github.com/moonfrog/heimdall/client.(*Client).stateMachine.func1+0x3f       /home/rts/gopath/src/github.com/moonfrog/heimdall/client/client.go:136
#   0x48dcea    github.com/moonfrog/heimdall/common.Safe+0x3a                   /home/rts/gopath/src/github.com/moonfrog/heimdall/common/utils.go:49
#   0x5f729f    github.com/moonfrog/heimdall/client.(*Client).stateMachine+0x1df        /home/rts/gopath/src/github.com/moonfrog/heimdall/client/client.go:137

7 @ 0x42fd33 0x42a7ee 0x429cb0 0x629fba 0x62a026 0x62be7a 0x640644 0x611d09 0x612b7a 0x612eb9 0x5e60f4 0x73f614 0x460ae1
#   0x429cb0    net.runtime_pollWait+0x60                       /usr/local/go/src/runtime/netpoll.go:160
#   0x629fba    net.(*pollDesc).Wait+0x3a                       /usr/local/go/src/net/fd_poll_runtime.go:73
#   0x62a026    net.(*pollDesc).WaitRead+0x36                       /usr/local/go/src/net/fd_poll_runtime.go:78
#   0x62be7a    net.(*netFD).Read+0x23a                         /usr/local/go/src/net/fd_unix.go:250
#   0x640644    net.(*conn).Read+0xe4                           /usr/local/go/src/net/net.go:172
#   0x611d09    bufio.(*Reader).fill+0x1e9                      /usr/local/go/src/bufio/bufio.go:97
#   0x612b7a    bufio.(*Reader).ReadSlice+0x21a                     /usr/local/go/src/bufio/bufio.go:328
#   0x612eb9    bufio.(*Reader).ReadBytes+0xa9                      /usr/local/go/src/bufio/bufio.go:406
#   0x5e60f4    github.com/moonfrog/heimdall/network.(*Messenger).ReadMessage+0x54  /home/rts/gopath/src/github.com/moonfrog/heimdall/network/messenger.go:29
#   0x73f614    github.com/moonfrog/heimdall/service.(*Service).readPump.func1+0x34 /home/rts/gopath/src/github.com/moonfrog/heimdall/service/service.go:102

1 @ 0x42fd33 0x42fdf4 0x43f877 0x43f4c6 0x4c5704 0x4c6740 0x5f2d6a 0x5f5fcc 0x5f5dc4 0x5890f3 0x460ae1
#   0x43f4c6    sync.runtime_Semacquire+0x26                                /usr/local/go/src/runtime/sema.go:47
#   0x4c5704    sync.(*Mutex).Lock+0x1c4                                /usr/local/go/src/sync/mutex.go:83
#   0x4c6740    sync.(*RWMutex).Lock+0x30                               /usr/local/go/src/sync/rwmutex.go:83
#   0x5f2d6a    github.com/moonfrog/heimdall/serviceController.(*Controller).refreshServices+0x4a   /home/rts/gopath/src/github.com/moonfrog/heimdall/serviceController/controller.go:257
#   0x5f5fcc    github.com/moonfrog/heimdall/serviceController.(*Controller).init.func1+0x1ec       /home/rts/gopath/src/github.com/moonfrog/heimdall/serviceController/controller.go:333
#   0x5f5dc4    github.com/moonfrog/heimdall/serviceController.loadConfig.func2+0x84            /home/rts/gopath/src/github.com/moonfrog/heimdall/serviceController/configServices.go:84
#   0x5890f3    github.com/moonfrog/badger/zootils.(*ZooKeeper).watchFunc+0x53              /home/rts/gopath/src/github.com/moonfrog/badger/zootils/zootils.go:62

1 @ 0x42fd33 0x43e9f7 0x43df52 0x5fc579 0x491911 0x5faae9 0x5f94bf 0x5f8cdb 0x5ffd9f 0x48dcea 0x5f729f 0x460ae1
#   0x5fc579    github.com/moonfrog/heimdall/client.(*Client).RejectConnection+0x369    /home/rts/gopath/src/github.com/moonfrog/heimdall/client/client.go:495
#   0x491911    github.com/moonfrog/heimdall/router.(*Router).RegisterClient+0x8a1  /home/rts/gopath/src/github.com/moonfrog/heimdall/router/router.go:109
#   0x5faae9    github.com/moonfrog/heimdall/client.(*Client).join+0x5e9        /home/rts/gopath/src/github.com/moonfrog/heimdall/client/client.go:379
#   0x5f94bf    github.com/moonfrog/heimdall/client.(*Client).handleRouterMsg+0x61f /home/rts/gopath/src/github.com/moonfrog/heimdall/client/client.go:265
#   0x5f8cdb    github.com/moonfrog/heimdall/client.(*Client).process+0xedb     /home/rts/gopath/src/github.com/moonfrog/heimdall/client/client.go:254
#   0x5ffd9f    github.com/moonfrog/heimdall/client.(*Client).stateMachine.func1+0x3f   /home/rts/gopath/src/github.com/moonfrog/heimdall/client/client.go:136
#   0x48dcea    github.com/moonfrog/heimdall/common.Safe+0x3a               /home/rts/gopath/src/github.com/moonfrog/heimdall/common/utils.go:49
#   0x5f729f    github.com/moonfrog/heimdall/client.(*Client).stateMachine+0x1df    /home/rts/gopath/src/github.com/moonfrog/heimdall/client/client.go:137",28570
44643110,1577,"package main

import (
    ""encoding/json""
    ""errors""
    ""fmt""
    ""math/rand""
    ""sync""
    ""time""
)

type node struct {
    Left  *node
    Right *node
    Data  int
}

// Tree ...
type Tree struct {
    Root  *node
    Total int
}

// FindNode ...
func (t *Tree) FindNode(data int) bool {
    newNode := node{
        Data: data,
    }
    if t.Root != nil {
        if t.findNode(t.Root, newNode) != nil {
            return true
        }
    }
    return false
}

func (t *Tree) findNode(search *node, target node) *node {
    var returnNode *node
    if search == nil {
        return returnNode
    }
    if search.Data == target.Data {
        return search
    }
    returnNode = t.findNode(search.Left, target)
    if returnNode == nil {
        returnNode = t.findNode(search.Right, target)
    }
    return returnNode
}

// Add ...
func (t *Tree) Add(data int) {
    t.Total += data
    if data < 0 {
        panic(errors.New(""Only submit positive integers""))
    }
    nodeToAdd := node{
        Data: data,
    }
    if t.Root == nil {
        t.Root = new(node)
    }
    if t.Root.Data == 0 {
        t.Root = &nodeToAdd
        return
    }

    t.add(t.Root, nodeToAdd)
    return
}

func (t *Tree) add(oldnode *node, newNode node) {
    if newNode.Data < oldnode.Data {
        if oldnode.Left == nil {
            // t.Total += newNode.Data
            oldnode.Left = &newNode
        } else {
            // t.Total += newNode.Data
            t.add(oldnode.Left, newNode)
        }
    } else if newNode.Data > oldnode.Data {
        if oldnode.Right == nil {
            // t.Total += newNode.Data
            oldnode.Right = &newNode
        } else {
            // t.Total += newNode.Data
            t.add(oldnode.Right, newNode)
        }
    }
    return
}

// InOrderTraversal ...
func (t *Tree) InOrderTraversal() {
    if t.Root != nil {
        currentNode := t.Root
        if currentNode.Left == nil && currentNode.Right == nil {
            fmt.Println(currentNode.Data)
        } else {
            t.inOrderTraversal(currentNode)
        }
    }
    return
}

func (t *Tree) inOrderTraversal(n *node) {
    if n.Left != nil {
        t.inOrderTraversal(n.Left)
    }
    fmt.Println(n.Data)
    if n.Right != nil {
        t.inOrderTraversal(n.Right)
    }
    return
}

// Traversal ...
func (t *Tree) Traversal() {
    if t.Root != nil {
        currentNode := t.Root
        if currentNode.Left == nil && currentNode.Right == nil {
            fmt.Println(currentNode.Data)
        } else {
            t.traversal(currentNode)
        }
    }
    return
}

func (t *Tree) traversal(n *node) {
    fmt.Println(n.Data)
    if n.Left != nil {
        t.traversal(n.Left)
    }

    if n.Right != nil {
        t.traversal(n.Right)
    }
    return
}

// Sum ...
func (t *Tree) Sum() (total int) {
    var wg sync.WaitGroup
    c := make(chan int, 100)
    if t.Root != nil {
        currentNode := t.Root
        if currentNode.Left == nil && currentNode.Right == nil {
            return 1
        }
        wg.Add(1)
        t.sum(currentNode, c, &wg)
    }
    go func() {
        wg.Wait()
        close(c)
    }()
    for n := range c {
        total += n
    }
    return total
}

func (t *Tree) sum(n *node, counter chan int, wg *sync.WaitGroup) {
    defer wg.Done()

    if n.Left != nil {
        wg.Add(1)
        go t.sum(n.Left, counter, wg)
    }

    counter <- n.Data

    if n.Right != nil {
        wg.Add(1)
        go t.sum(n.Right, counter, wg)
    }

    return
}

// CountEdges ...
func (t *Tree) CountEdges() (edges int) {
    c := make(chan int, 10)
    if t.Root != nil {
        currentNode := t.Root
        if currentNode.Left == nil && currentNode.Right == nil {
            return 1
        }
        t.countEdges(currentNode, c)
    }

    for {
        n := <-c
        if n == 0 {
            close(c)
            break
        }
        edges++
    }
    return edges
}

func (t *Tree) countEdges(n *node, counter chan int) {
    if n.Left != nil {
        go t.countEdges(n.Left, counter)
    }

    if n.Left == nil && n.Right == nil {
        counter <- 0
    } else {
        counter <- 1
    }

    if n.Right != nil {
        go t.countEdges(n.Right, counter)
    }
    return
}

// GenerateRandomTree ...
func (t *Tree) GenerateRandomTree() {
    u := time.Now()
    source := rand.NewSource(u.Unix())
    r := rand.New(source)
    arr := r.Perm(1000)
    for _, a := range arr {
        t.Add(a)
    }
    return
}

// GetRootData ...
func (t *Tree) GetRootData() int {
    return t.Root.Data
}

// GetTreeTotal ...
func (t *Tree) GetTreeTotal() int {
    return t.Total
}

// TreeToArray ...
func (t *Tree) TreeToArray() []int {
    ch := make(chan int, 10)
    arr := []int{}
    if t.Root != nil {
        currentNode := t.Root
        if currentNode.Left == nil && currentNode.Right == nil {
            return []int{currentNode.Data}
        }
        t.traversalGetVals(currentNode, ch)
    }

    for {
        n := <-ch
        if n == -1 {
            close(ch)
            break
        }
        arr = append(arr, n)
    }
    return arr
}

func (t *Tree) traversalGetVals(n *node, ch chan int) {
    if n.Left != nil {
        ch <- n.Left.Data
        go t.traversalGetVals(n.Left, ch)
    }

    if n.Right != nil {
        ch <- n.Right.Data
        go t.traversalGetVals(n.Right, ch)
    }
    if n.Left == nil && n.Right == nil {
        ch <- -1
    }
    return
}

// ShiftRoot ...
func (t *Tree) ShiftRoot(newRoot int) {
    arr := t.TreeToArray()
    n := Tree{}
    n.Add(newRoot)
    for _, i := range arr {
        n.Add(i)
    }
    *t = n
}

// PrintTree ...
func (t *Tree) PrintTree() {
    b, err := json.MarshalIndent(t, """", "" "")
    if err != nil {
        panic(err)
    }
    fmt.Println(string(b))
}

func main() {
    // t := Tree{}
    // t.GenerateRandomTree()
    // t.PrintTree()
    // fmt.Println(""total:"", t.Sum())

    t := Tree{}
    t.Add(10)
    t.Add(100)
    t.Add(2)
    t.Add(3)

    fmt.Println(t.Sum()) // should be 115
    fmt.Println(t.GetTreeTotal())

    // t := Tree{}
    // for i := 1; i <= 23; i++ {
    //  t.Add(i)
    // }
    // fmt.Println(""total:"", t.Sum())

}",6212
44842132,1578,"req:=""https://domain.atlassian.net/wiki/rest/api/content?expand=body.view,version&type=page&start=0&limit=""
res, err := w.sendRequest(req)
    if err != nil {
        return nil, err
    }
    if strings.EqualFold(contentID, """") == false {
        if len(res.Results) != 0 {
            for i, _ := range res.Results {
                Log.Info(""files processed is:"", i)
                extension := filepath.Ext(res.Results[i].Title)
                isExtenstionExclude := isExcludedExtenstion(sbConfig, extension)
                ispathExclude := isExcludedFolder(sbConfig, res.Results[i].Links.Webui)
                if sbgoclient.ExtesionMap[extension] == 0 || isExtenstionExclude == true || ispathExclude == true {
                    binarycount++
                    Log.Info(""Excluded by extension"" + extension + "" for file"" + res.Results[i].Title)
                } else {
                    md5HashInBytes := md5.Sum([]byte(res.Results[i].Title))
                    md5HashInString := hex.EncodeToString(md5HashInBytes[:])
                    file_path := parameter[0] + ""/"" + md5HashInString + strings.Replace(res.Results[i].Title, "" "", """", -1)
                    file, err := os.Create(file_path)

                    if err != nil {
                        fmt.Println(err)
                        panic(err)
                    }
                    url_1 := sbConfig.ConfluenceUrl + res.Results[i].Links.Download
                    req, err := http.NewRequest(""GET"", url_1, nil)
                    resp, _ := w.client.Do(req) // add a filter to check redirect

                    if err != nil {
                        fmt.Println(err)
                        panic(err)
                    }
                    // Close body on function exit
                    defer resp.Body.Close()
                    fmt.Println(resp.Status)

                    size, err = io.Copy(file, resp.Body)

                    if err != nil {
                        panic(err)
                    }

                    defer file.Close()
                    fmt.Printf(""%s with %v bytes downloaded"", res.Results[i].Title, size)
                    meta := map[string]string{
                        ""size"": strconv.FormatInt(size, 10),
                    }
                }
            }
        }
    } else {

        if len(res.Results) != 0 {
            for i, _ := range res.Results {
                Log.Info(""page indexing is"", res.Results[i].Title, ""and i value is:"", i)
                fmt.Println(""hmtl content is"", res.Results[i].Body.View.Value)
                fmt.Println(""page name is:"", res.Results[i].Title)
                md5HashInBytes := md5.Sum([]byte(res.Results[i].Title))
                md5HashInString := hex.EncodeToString(md5HashInBytes[:])
                file_path := parameter[0] + ""/"" + md5HashInString + strings.Replace(res.Results[i].Title, "" "", """", -1) + "".html""
                file, err := os.Create(file_path)

                if err != nil {
                    fmt.Println(err)
                    panic(err)
                }
                defer file.Close()
                html_content := """" + res.Results[i].Body.View.Value + """"
                err = ioutil.WriteFile(file.Name(), []byte(html_content), 0777)
                if err != nil {
                    fmt.Println(""error writing into file"", err)
                    panic(err)
                }
                file.Close()                    
        }",3471
44863386,1581,"// SecureDevice holds a user's device's infos
type SecureDevice struct {
    Name     string // Defined by the user
    DeviceIP string
    Token    struct {
        Token        string
        StartingDate time.Time // The token is supposed to last only a week before becoming invalid
    }
}

// GlobalUser is a struct defining all user's infos registered inside the server
type GlobalUser struct {
    Username          string
    Password          string
    Salt              string
    Mail              string
    ValidationToken   string // Used to validate the user's mail adress
    Lang              string
    ConversationsID   []int // The private messages the user has part in
    SecureDevicesList []SecureDevice
}
",730
44874566,1585,"id  title           latlng                  id  title           locationid  
1   Fox Thea...     43.6640673,-79.4213863  1   Bob's Event     1
1   Fox Thea...     43.6640673,-79.4213863  2   Jill's Event    1
2   Wrigley ...     43.6640673,-79.4213863  3   Mary's Event    2
3   Blues Bar       43.6640673,-79.4213863  4   John's Event    3
1   Fox Thea...     43.6640673,-79.4213863  5   Monthly G...    1
1   Fox Thea...     43.6640673,-79.4213863  6   A Special...    1
1   Fox Thea...     43.6640673,-79.4213863  7   The Final...    1",539
44892236,1591,"// rpc_json_server.go

    package main

    import (
        ""log""
        ""net""
        ""net/http""
        ""net/rpc""
        ""net/rpc/jsonrpc""
    )

    //------------------------------------------------------------------------------
    // Types
    //------------------------------------------------------------------------------

    type Arithmetic int // Used as RPC Service called 'Arithmetic'

    type Arguments struct {
        A int
        B int
    }

    type Result int

    //------------------------------------------------------------------------------
    // Methods
    //------------------------------------------------------------------------------

    func (t *Arithmetic) Multiply(args *Arguments, res *Result) error {

        *res = Result(args.A * args.B)

        return nil
    }

    //------------------------------------------------------------------------------

    func main() {

        var srv *rpc.Server
        var err error
        var arith *Arithmetic
        var listener net.Listener
        var codec rpc.ServerCodec
        var srv_conntype, srv_host, srv_port, srv_addr, srv_path string
        var srv_debugPath string
        var connection net.Conn

        srv_conntype = ""tcp""
        srv_host = ""0.0.0.0""
        srv_port = ""3000""
        srv_addr = srv_host + "":"" + srv_port
        srv_path = ""/""
        srv_debugPath = ""/debug""

        // Create Server, register Service
        srv = rpc.NewServer()
        arith = new(Arithmetic)
        err = srv.Register(arith)
        if err != nil {
            log.Fatalf(""Error. Service Format is not correct. %s\r\n"", err) //dbg
        }

        // Handle, listen
        srv.HandleHTTP(srv_path, srv_debugPath)
        listener, err = net.Listen(srv_conntype, srv_addr)
        if err != nil {
            log.Fatalf(""Error. Can not listen on %s. %s\r\n"", srv_addr, err) //dbg
        }
        log.Printf(""Started RPC Handler at %s.\r\n"", srv_addr) //dbg

        // Serve
        for {

            connection, err = listener.Accept()
            if err != nil {
                log.Fatal(err)
            }

            codec = jsonrpc.NewServerCodec(connection)

            go srv.ServeCodec(codec)
        }

        err = http.Serve(listener, nil)
        if err != nil {
            log.Fatalf(""Serve Error. %s\r\n"", err) //dbg
        }
    }

    //------------------------------------------------------------------------------",2451
44907323,1594,AES,3
44958839,1604,"github.com\mxplusb\bigcache\caches_bench> go test -v -bench ""."" -benchtime ""10s"" . -timeout 30m
 -benchmem
BenchmarkMapSet-8                       20000000               917 ns/op             296 B/op          3 allocs/op
BenchmarkFreeCacheSet-8                 30000000               861 ns/op             360 B/op          3 allocs/op
BenchmarkBigCacheSet-8                  30000000               615 ns/op             311 B/op          2 allocs/op
BenchmarkMapGet-8                       50000000               410 ns/op              24 B/op          2 allocs/op
BenchmarkFreeCacheGet-8                 30000000               770 ns/op             152 B/op          4 allocs/op
BenchmarkBigCacheGet-8                  30000000               548 ns/op             152 B/op          4 allocs/op
BenchmarkBigCacheSetParallel-8          runtime: VirtualAlloc of 7340032 bytes failed with errno=1455
fatal error: runtime: cannot map pages in arena address space

runtime stack:
runtime.throw(0x55ca82, 0x30)
        C:/Go/src/runtime/panic.go:596 +0x9c
runtime.sysMap(0xc4fc330000, 0x700000, 0x428e01, 0x6152f8)
        C:/Go/src/runtime/mem_windows.go:116 +0x129
runtime.(*mheap).sysAlloc(0x5fb5c0, 0x700000, 0x419fd70)
        C:/Go/src/runtime/malloc.go:440 +0x37b
runtime.(*mheap).grow(0x5fb5c0, 0x380, 0x0)
        C:/Go/src/runtime/mheap.go:774 +0x69
runtime.(*mheap).allocSpanLocked(0x5fb5c0, 0x380, 0x874ca20)
        C:/Go/src/runtime/mheap.go:678 +0x456
runtime.(*mheap).alloc_m(0x5fb5c0, 0x380, 0x100000000, 0x0)
        C:/Go/src/runtime/mheap.go:562 +0xf0
runtime.(*mheap).alloc.func1()
        C:/Go/src/runtime/mheap.go:627 +0x52
runtime.systemstack(0x419fe68)
        C:/Go/src/runtime/asm_amd64.s:343 +0xb5
runtime.(*mheap).alloc(0x5fb5c0, 0x380, 0x10100000000, 0x0)
        C:/Go/src/runtime/mheap.go:628 +0xa7
runtime.largeAlloc(0x700000, 0x44fd01, 0xc4f61be000)
        C:/Go/src/runtime/malloc.go:807 +0x9a
runtime.mallocgc.func1()
        C:/Go/src/runtime/malloc.go:702 +0x45
runtime.systemstack(0xc0420278a0)
        C:/Go/src/runtime/asm_amd64.s:327 +0x7e
runtime.mstart()
        C:/Go/src/runtime/proc.go:1132

goroutine 31 [running]:
runtime.systemstack_switch()
        C:/Go/src/runtime/asm_amd64.s:281 fp=0xc042555980 sp=0xc042555978
runtime.mallocgc(0x700000, 0x53c400, 0x1, 0xc042031800)
        C:/Go/src/runtime/malloc.go:703 +0x96f fp=0xc042555a20 sp=0xc042555980
runtime.newarray(0x53c400, 0x10000, 0x522b20)
        C:/Go/src/runtime/malloc.go:833 +0x6b fp=0xc042555a60 sp=0xc042555a20
runtime.makemap(0x52d8a0, 0x5f5e1, 0x0, 0x0, 0x112)
        C:/Go/src/runtime/hashmap.go:281 +0x30d fp=0xc042555ab8 sp=0xc042555a60
github.com/allegro/bigcache.initNewShard(0x100, 0x8bb2c97000, 0x5f5e100, 0x100, 0x1, 0x5e1820, 0x612938, 0x0, 0x0, 0xc0423fa000, ...)
        E:/Programming/Go/src/github.com/allegro/bigcache/shard.go:45 +0xc5 fp=0xc042555c80 sp=0xc042555ab8
github.com/allegro/bigcache.newBigCache(0x100, 0x8bb2c97000, 0x5f5e100, 0x100, 0x1, 0x5e1820, 0x612938, 0x0, 0x0, 0x5e1560, ...)
        E:/Programming/Go/src/github.com/allegro/bigcache/bigcache.go:58 +0x36e fp=0xc042555dc8 sp=0xc042555c80
github.com/allegro/bigcache.NewBigCache(0x100, 0x8bb2c97000, 0x5f5e100, 0x100, 0x1, 0x0, 0x0, 0x0, 0x0, 0xbc02a, ...)
        E:/Programming/Go/src/github.com/allegro/bigcache/bigcache.go:27 +0x7f fp=0xc042555e48 sp=0xc042555dc8
github.com/mxplusb/bigcache/caches_bench.initBigCache(0x5f5e100, 0x4b6af8)
        E:/Programming/Go/src/github.com/mxplusb/bigcache/caches_bench/caches_bench_test.go:159 +0x99 fp=0xc042555f00 sp=0xc042555e48
github.com/mxplusb/bigcache/caches_bench.BenchmarkBigCacheSetParallel(0xc042088420)
        E:/Programming/Go/src/github.com/mxplusb/bigcache/caches_bench/caches_bench_test.go:79 +0x3d fp=0xc042555f38 sp=0xc042555f00
testing.(*B).runN(0xc042088420, 0x5f5e100)
        C:/Go/src/testing/benchmark.go:140 +0xb9 fp=0xc042555f78 sp=0xc042555f38
testing.(*B).launch(0xc042088420)
        C:/Go/src/testing/benchmark.go:281 +0x129 fp=0xc042555fd8 sp=0xc042555f78
runtime.goexit()
        C:/Go/src/runtime/asm_amd64.s:2197 +0x1 fp=0xc042555fe0 sp=0xc042555fd8
created by testing.(*B).doBench
        C:/Go/src/testing/benchmark.go:250 +0x77

goroutine 1 [chan receive]:
testing.(*B).doBench(0xc042088420, 0x0, 0x0, 0x0, 0x0, 0x0)
        C:/Go/src/testing/benchmark.go:251 +0xa1
testing.(*benchContext).processBench(0xc0420030e0, 0xc042088420)
        C:/Go/src/testing/benchmark.go:433 +0x1fe
testing.(*B).run(0xc042088420, 0x0, 0x0, 0x0, 0x0, 0x0)
        C:/Go/src/testing/benchmark.go:241 +0x74
testing.(*B).Run(0xc0420882c0, 0x5593df, 0x1c, 0x55dc98, 0x4b6a00)
        C:/Go/src/testing/benchmark.go:494 +0x254
testing.runBenchmarks.func1(0xc0420882c0)
        C:/Go/src/testing/benchmark.go:403 +0x6e
testing.(*B).runN(0xc0420882c0, 0x1)
        C:/Go/src/testing/benchmark.go:140 +0xb9
testing.runBenchmarks(0xc0420030c0, 0x5f6240, 0xa, 0xa, 0xc042040100)
        C:/Go/src/testing/benchmark.go:409 +0x494
testing.(*M).Run(0xc042097f20, 0xc042039f20)
        C:/Go/src/testing/testing.go:828 +0x30c
main.main()
        github.com/mxplusb/bigcache/caches_bench/_test/_testmain.go:60 +0xfe
exit status 2
FAIL    github.com/mxplusb/bigcache/caches_bench        223.732s",5244
45086992,1609,"package main

import (
       ""bytes""
       ""crypto/tls""
       ""encoding/xml""
       ""fmt""
       ""io/ioutil""
       ""log""
       ""net""
       ""net/http""
       ""time""
)

// against ""unused imports""
var _ time.Time
var _ xml.Name

type Char int32

const ()

type Duration *Duration

const ()

type Guid string

const ()

type ItemAvailabilitySearchParamters struct {
       XMLName xml.Name `xml:""http://schemas.datacontract.org/2004/07/Dynamics.Ax.Application ItemAvailabilitySearchParamters""`

       *XppObjectBase

       ParamFromDate         string `xml:""paramFromDate,omitempty""`
       ParamNumberOfFrames   int32  `xml:""paramNumberOfFrames,omitempty""`
       ParamItemDefinitionId string `xml:""paramItemDefinitionId,omitempty""`
       ParamToDate           string `xml:""paramToDate,omitempty""`
}

type ItemAvailabilityServiceNewGetDataRequest struct {
       XMLName xml.Name `xml:""http://schemas.microsoft.com/netfx/2009/05/routing ItemAvailabilityServiceNewGetDataRequest""`

       ItemAvailabilitySearchParamters *ItemAvailabilitySearchParamters `xml:""mMSItemAvailabilitySearchParamters,omitempty""`
}

type ItemAvailabilityContract struct {
       XMLName xml.Name `xml:""http://schemas.datacontract.org/2004/07/Dynamics.Ax.Application ItemAvailabilityContract""`

       *XppObjectBase

       Pct               float64 `xml:""pct,omitempty""`
       QuantityAvailable int32   `xml:""quantityAvailable,omitempty""`
       TargetQuantity    int32   `xml:""targetQuantity,omitempty""`
}

type ArrayOfItemAvailabilityContract struct {
       XMLName xml.Name `xml:""http://schemas.datacontract.org/2004/07/Dynamics.Ax.Application ArrayOfItemAvailabilityContract""`

       ItemAvailabilityContract []*ItemAvailabilityContract `xml:""ItemAvailabilityContract,omitempty""`
}

type XppObjectBase struct {
       XMLName xml.Name `xml:""http://schemas.datacontract.org/2004/07/Microsoft.Dynamics.Ax.Xpp XppObjectBase""`
}



type ItemAvailabilityServiceNewGetDataResponse struct {
       XMLName xml.Name `xml:""http://schemas.microsoft.com/netfx/2009/05/routing ItemAvailabilityServiceNewGetDataResponse""`

       Response *ArrayOfItemAvailabilityContract `xml:""response,omitempty""`
}

type CallContext struct {
       XMLName xml.Name `xml:""http://schemas.microsoft.com/dynamics/2010/01/datacontracts CallContext""`

       Company      string                         `xml:""Company,omitempty""`
       Language     string                         `xml:""Language,omitempty""`
       LogonAsUser  string                         `xml:""LogonAsUser,omitempty""`
       MessageId    string                         `xml:""MessageId,omitempty""`
       PartitionKey string                         `xml:""PartitionKey,omitempty""`
       PropertyBag  *ArrayOfKeyValueOfstringstring `xml:""PropertyBag,omitempty""`
}

type ArrayOfKeyValueOfstringstring struct {
       XMLName xml.Name `xml:""http://schemas.microsoft.com/2003/10/Serialization/Arrays ArrayOfKeyValueOfstringstring""`

       KeyValueOfstringstring struct {
                      Key   string `xml:""Key,omitempty""`
                      Value string `xml:""Value,omitempty""`
               } `xml:""KeyValueOfstringstring,omitempty""`
}

type AifFault struct {
       XMLName xml.Name `xml:""http://schemas.microsoft.com/dynamics/2008/01/documents/Fault AifFault""`

       CustomDetailXml       string                   `xml:""CustomDetailXml,omitempty""`
       FaultMessageListArray *ArrayOfFaultMessageList `xml:""FaultMessageListArray,omitempty""`
       InfologMessageList    *ArrayOfInfologMessage   `xml:""InfologMessageList,omitempty""`
       StackTrace            string                   `xml:""StackTrace,omitempty""`
       XppExceptionType      int32                    `xml:""XppExceptionType,omitempty""`
}

type ArrayOfFaultMessageList struct {
       XMLName xml.Name `xml:""http://schemas.microsoft.com/dynamics/2008/01/documents/Fault ArrayOfFaultMessageList""`

       FaultMessageList []*FaultMessageList `xml:""FaultMessageList,omitempty""`
}

type FaultMessageList struct {
       XMLName xml.Name `xml:""http://schemas.microsoft.com/dynamics/2008/01/documents/Fault FaultMessageList""`

       Document                  string               `xml:""Document,omitempty""`
       DocumentOperation         string               `xml:""DocumentOperation,omitempty""`
       FaultMessageArray         *ArrayOfFaultMessage `xml:""FaultMessageArray,omitempty""`
       Field                     string               `xml:""Field,omitempty""`
       Service                   string               `xml:""Service,omitempty""`
       ServiceOperation          string               `xml:""ServiceOperation,omitempty""`
       ServiceOperationParameter string               `xml:""ServiceOperationParameter,omitempty""`
       XPath                     string               `xml:""XPath,omitempty""`
       XmlLine                   string               `xml:""XmlLine,omitempty""`
       XmlPosition               string               `xml:""XmlPosition,omitempty""`
}

type ArrayOfFaultMessage struct {
       XMLName xml.Name `xml:""http://schemas.microsoft.com/dynamics/2008/01/documents/Fault ArrayOfFaultMessage""`

       FaultMessage []*FaultMessage `xml:""FaultMessage,omitempty""`
}

type FaultMessage struct {
       XMLName xml.Name `xml:""http://schemas.microsoft.com/dynamics/2008/01/documents/Fault FaultMessage""`

       Code    string `xml:""Code,omitempty""`
       Message string `xml:""Message,omitempty""`
}

type InfologMessageType string

const (
       InfologMessageTypeInfo InfologMessageType = ""Info""

       InfologMessageTypeWarning InfologMessageType = ""Warning""

       InfologMessageTypeError InfologMessageType = ""Error""
)

type ArrayOfInfologMessage struct {
       XMLName xml.Name `xml:""http://schemas.datacontract.org/2004/07/Microsoft.Dynamics.AX.Framework.Services ArrayOfInfologMessage""`

       InfologMessage []*InfologMessage `xml:""InfologMessage,omitempty""`
}

type InfologMessage struct {
       XMLName xml.Name `xml:""http://schemas.datacontract.org/2004/07/Microsoft.Dynamics.AX.Framework.Services InfologMessage""`

       InfologMessageType *InfologMessageType `xml:""InfologMessageType,omitempty""`
       Message            string              `xml:""Message,omitempty""`
}

type IRequestReplyRouter struct {
       client *SOAPClient
}

func NewIRequestReplyRouter(url string, tls bool, auth *BasicAuth) *IRequestReplyRouter {
       if url == """" {
              url = """"
       }
       client := NewSOAPClient(url, tls, auth)

       return &IRequestReplyRouter{
              client: client,
       }
}

type ItemAvailabilityServiceNew struct {
       client *SOAPClient
}

func NewItemAvailabilityServiceNew(url string, tls bool, auth *BasicAuth) *ItemAvailabilityServiceNew {
       if url == """" {
              url = """"
       }
       client := NewSOAPClient(url, tls, auth)

       return &ItemAvailabilityServiceNew{
              client: client,
       }
}

// Error can be either of the following types:
//
//   - AifFaultFault

func (service *ItemAvailabilityServiceNew) GetData(request *ItemAvailabilityServiceNewGetDataRequest) (*ItemAvailabilityServiceNewGetDataResponse, error) {
       response := new(ItemAvailabilityServiceNewGetDataResponse)
       err := service.client.Call(""http://schemas.microsoft.com/netfx/2009/05/routing/ItemAvailabilityServiceNew/getData"", request, response)
       if err != nil {
              return nil, err
       }

       return response, nil
}

var timeout = time.Duration(30 * time.Second)

func dialTimeout(network, addr string) (net.Conn, error) {
       return net.DialTimeout(network, addr, timeout)
}

type SOAPEnvelope struct {
       XMLName xml.Name `xml:""http://schemas.xmlsoap.org/soap/envelope/ Envelope""`

       Body SOAPBody
}

type SOAPHeader struct {
       XMLName xml.Name `xml:""http://schemas.xmlsoap.org/soap/envelope/ Header""`

       Header interface{}
}

type SOAPBody struct {
       XMLName xml.Name `xml:""http://schemas.xmlsoap.org/soap/envelope/ Body""`

       Fault   *SOAPFault  `xml:"",omitempty""`
       Content interface{} `xml:"",omitempty""`
}

type SOAPFault struct {
       XMLName xml.Name `xml:""http://schemas.xmlsoap.org/soap/envelope/ Fault""`

       Code   string `xml:""faultcode,omitempty""`
       String string `xml:""faultstring,omitempty""`
       Actor  string `xml:""faultactor,omitempty""`
       Detail string `xml:""detail,omitempty""`
}

type BasicAuth struct {
       Login    string
       Password string
}

type SOAPClient struct {
       url  string
       tls  bool
       auth *BasicAuth
}

func (b *SOAPBody) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
       if b.Content == nil {
              return xml.UnmarshalError(""Content must be a pointer to a struct"")
       }

       var (
              token    xml.Token
              err      error
              consumed bool
       )

       Loop:
       for {
              if token, err = d.Token(); err != nil {
                     return err
              }

              if token == nil {
                     break
              }

              switch se := token.(type) {
              case xml.StartElement:
                     if consumed {
                            return xml.UnmarshalError(""Found multiple elements inside SOAP body; not wrapped-document/literal WS-I compliant"")
                     } else if se.Name.Space == ""http://schemas.xmlsoap.org/soap/envelope/"" && se.Name.Local == ""Fault"" {
                            b.Fault = &SOAPFault{}
                            b.Content = nil

                            err = d.DecodeElement(b.Fault, &se)
                            if err != nil {
                                   return err
                            }

                            consumed = true
                     } else {
                            if err = d.DecodeElement(b.Content, &se); err != nil {
                                   return err
                            }

                            consumed = true
                     }
              case xml.EndElement:
                     break Loop
              }
       }

       return nil
}

func (f *SOAPFault) Error() string {
       return f.String
}

func NewSOAPClient(url string, tls bool, auth *BasicAuth) *SOAPClient {
       return &SOAPClient{
              url:  url,
              tls:  tls,
              auth: auth,
       }
}

func (s *SOAPClient) Call(soapAction string, request, response interface{}) error {
       envelope := SOAPEnvelope{
              //Header:        SoapHeader{},
       }

       envelope.Body.Content = request
       buffer := new(bytes.Buffer)

       encoder := xml.NewEncoder(buffer)
       //encoder.Indent(""  "", ""    "")

       if err := encoder.Encode(envelope); err != nil {
              return err
       }

       if err := encoder.Flush(); err != nil {
              return err
       }

       log.Println(buffer.String())

       req, err := http.NewRequest(""POST"", s.url, buffer)
       if err != nil {
              return err
       }
       if s.auth != nil {
              req.SetBasicAuth(s.auth.Login, s.auth.Password)
       }

       req.Header.Add(""Content-Type"", ""text/xml; charset=\""utf-8\"""")
       if soapAction != """" {
              req.Header.Add(""SOAPAction"", soapAction)
       }

       req.Header.Set(""User-Agent"", ""gowsdl/0.1"")
       req.Close = true

       tr := &http.Transport{
              TLSClientConfig: &tls.Config{
                     InsecureSkipVerify: s.tls,
              },
              Dial: dialTimeout,
       }

       client := &http.Client{Transport: tr}
       res, err := client.Do(req)
       if err != nil {
              return err
       }
       defer res.Body.Close()

       rawbody, err := ioutil.ReadAll(res.Body)
       if err != nil {
              return err
       }
       if len(rawbody) == 0 {
              log.Println(""empty response"")
              return nil
       }

       log.Println(string(rawbody))
       respEnvelope := new(SOAPEnvelope)
       respEnvelope.Body = SOAPBody{Content: response}
       err = xml.Unmarshal(rawbody, respEnvelope)
       if err != nil {
              return err
       }

       fault := respEnvelope.Body.Fault
       if fault != nil {
              return fault
       }

       return nil
}



func main() {
       basicAuth := BasicAuth{Login: ""user"", Password: ""pass""}
       mMSItemAvalabilityService := NewItemAvailabilityServiceNew(""http://localhost/xppservice.svc"", false, &basicAuth)
       fmt.Println(mMSItemAvalabilityService)
        mMSItemAvailabilitySearch := ItemAvailabilitySearchParamters{

              ParamItemDefinitionId: ""Itm000001849"",
              ParamNumberOfFrames:   125,
              ParamFromDate:         ""17/7/2017"",
              ParamToDate:           ""18/7/2017"",
       }
      // fmt.Println(mMSItemAvailabilitySearch)
       mMSItemAvalabilityServiceGetRequest := ItemAvailabilityServiceNewGetDataRequest{ItemAvailabilitySearchParamters: &mMSItemAvailabilitySearch}
       fmt.Println(mMSItemAvalabilityServiceGetRequest)
       response, error := mMSItemAvalabilityService.GetData(&mMSItemAvalabilityServiceGetRequest)
       fmt.Println(error)
       if error != nil {
              fmt.Println(response)
              return
       }
}",13288
45177958,1610,"$ ./autogen.sh
$ ./configure
$ make
$ ./tests
$ sudo make install  # optional
",78
45238337,1622,"package main

import ""fmt""

func main() {
    fmt.Println(""hello world"")
    for i:=uint(0); i< 10; i++{
        fmt.Println(i)
    }
}",136
45240642,1630,"package main

import (
    ""bytes""
    ""database/sql""
    ""flag""
    // ""github.com/garyburd/redigo/redis""
    _ ""github.com/go-sql-driver/mysql""
    //""gopkg.in/redis.v4""
    ""github.com/chasex/redis-go-cluster""
    ""log""
    ""runtime""
    // ""strings""
    ""sync""
    ""time""

)

var client *redis.Cluster

type Task interface {
    Execute()
}

type Pool struct {
    mu sync.Mutex

    size  int
    tasks chan Task
    kill  chan struct{}
    wg    sync.WaitGroup
}

func NewPool(size int) *Pool {
    pool := &Pool{
        tasks: make(chan Task, 128),
        kill:  make(chan struct{}),
    }
    pool.Resize(size)
    return pool
}

func (p *Pool) worker() {
    defer p.wg.Done()
    for {
        select {
        case task, ok := <-p.tasks:
            if !ok {
                return
            }
            task.Execute()
        case <-p.kill:
            return
        }
    }
}

func (p *Pool) Resize(n int) {
    p.mu.Lock()
    defer p.mu.Unlock()
    for p.size < n {
        p.size++
        p.wg.Add(1)
        go p.worker()
    }
    for p.size > n {
        p.size--
        p.kill <- struct{}{}
    }
}

func (p *Pool) Close() {
    close(p.tasks)
}

func (p *Pool) Wait() {
    p.wg.Wait()
}

func (p *Pool) Exec(task Task) {
    p.tasks <- task
}

type RedisTask struct {
    Index   int
    Command string
    Key     string
    Value   string
    MapData map[string]string
}

func (e RedisTask) Execute() {
    log.Println(""executing:"", e.Key, "","", e.Index)

    if e.Command == ""SET"" {
        _,err := redis.String(client.Do(""SET"", e.Key, e.Value))
        checkErr(err, ""set error:"")
    } else if e.Command == ""SADD"" {
        _,err := redis.Strings(client.Do(""SADD"", e.Key, e.Value))
        checkErr(err, ""sadd error:"") 
    } else if e.Command == ""HMSET"" {
        _,err := redis.StringMap(client.Do(""HMSET"", e.Key, e.MapData))
        checkErr(err, ""hmset error:"")
    }
    // TODO: clean data
}

func main() {
    runtime.GOMAXPROCS(runtime.NumCPU())
    startTime := time.Now().UnixNano() / int64(time.Millisecond)
    host := flag.String(""s"", ""localhost:3306"", ""mysql server host and port ,eg localhost:3306"")
    username := flag.String(""u"", ""test"", ""username to login mysql"")
    password := flag.String(""p"", ""test"", ""password for mysql"")
    database := flag.String(""d"", ""test"", ""database you want to execute query"")
    query := flag.String(""q"", ""select 1;"", ""your query sql"")
    ds := flag.String(""ds"", ""key"", ""redis structure"")
    PK := flag.String(""pk"", ""Rkey"", ""the redis Key in the fields of mysql query result"")

    //redisHost := flag.String(""rs"", ""localhost:6379"", ""redis host and port ,eg localhost:6379"")
    //redisPassword := flag.String(""rp"", ""test"", ""redis password"")

    poolSize := flag.Int(""size"", 10000, ""redis pool size"")

    flag.Parse()
    var buf bytes.Buffer = bytes.Buffer{}
    buf.WriteString(*username)
    buf.WriteString("":"")
    buf.WriteString(*password)
    buf.WriteString(""@tcp("")
    buf.WriteString(*host)
    buf.WriteString("")/"")
    buf.WriteString(*database)

    db, err := sql.Open(""mysql"", buf.String())
    checkErr(err, ""connect to mysql error !"")
    defer db.Close()

    poolWorker := NewPool(*poolSize)

    // Execute the query
    rows, err := db.Query(*query)
    checkErr(err, ""execute sql error!"")

    // pool = newPool(*redisHost, *redisPassword, *poolSize)

    //client = redis.NewClient(&redis.Options{
    //  Addr:     *redisHost,
    //  Password: *redisPassword, // no password set
    //  DB:       0,              // use default DB
    //})

    client,_ = redis.NewCluster(&redis.Options{
            StartNodes: []string{""10.x.x.x:6000"", ""10.x.x.x:6001"", ""10.x.x.x:6002""},
            ConnTimeout: 50 * time.Millisecond,
            ReadTimeout: 50 * time.Millisecond,
            WriteTimeout: 50 * time.Millisecond,
            KeepAlive: 16,
            AliveTime: 60 * time.Second,
    })
    //checkErr(err, ""client error:"")

    //pong, err := client.Ping().Result()
    //checkErr(err, ""redis client error:"")
    //log.Println(pong)

    columns, err := rows.Columns()
    checkErr(err, ""get columns error!"")

    length := len(columns)
    values := make([]sql.RawBytes, length)

    scanArgs := make([]interface{}, len(values))
    for i := range values {
        scanArgs[i] = &values[i]
    }

    count := 0
    for rows.Next() {
        count += 1
        err = rows.Scan(scanArgs...)
        checkErr(err, ""scan error"")

        var value string
        var key string

        var task RedisTask

        if *ds == ""key"" {
            key = getStringData(values[0])
            value = getStringData(values[1])
            if value != """" {
                task = RedisTask{
                    Index:   count,
                    Command: ""SET"",
                    Key:     key,
                    Value:   value,
                }
            }
        } else if *ds == ""set"" {
            key = getStringData(values[0])
            value = getStringData(values[1])
            if value != """" {
                task = RedisTask{
                    Index:   count,
                    Command: ""SADD"",
                    Key:     key,
                    Value:   value,
                }
            }
        } else if *ds == ""hash"" {
            key = getStringData(values[0])
            // args := redis.Args{}.Add(key)

            m := make(map[string]string)

            for i, col := range values {
                if col != nil && columns[i] != *PK {
                    value = getStringData(col)
                    m[columns[i]] = value
                }
            }
            task = RedisTask{
                Index:   count,
                Command: ""HMSET"",
                Key:     key,
                MapData: m,
            }
        }
        poolWorker.Exec(task)
    }
    if err = rows.Err(); err != nil {
        panic(err.Error()) // proper error handling instead of panic in your app
    }

    poolWorker.Close()

    poolWorker.Wait()

    EndTime := time.Now().UnixNano() / int64(time.Millisecond)
    log.Println(""======================================== executing time:"", EndTime-startTime, "" ms, total:"", count)
}

func getStringData(data sql.RawBytes) string {
    if data == nil {
        return """"
    }
    value := string(data)
    return clearBad(value)
}

func clearBad(str string) string {
    // str = strings.Trim(str, ""`"")
    // str = strings.Trim(str, ""ï½€"")
    // str = strings.Trim(str, ""-"")
    // str = strings.Trim(str, ""."")
    // str = strings.Trim(str, "" "")
    // str = strings.Trim(str, "";"")
    // str = strings.Trim(str, "","")
    // str = strings.Trim(str, "":"")
    // str = strings.Trim(str, "";"")
    // str = strings.Trim(str, ""'"")
    // str = strings.Trim(str, ""!"")
    return str
}

func checkErr(err error, msg string) {
    if err != nil {
        log.Fatalln(msg, err)
    }
}",6891
45243027,1632,"clusterCfg.ConnectTimeout undefined (type *gocql.ClusterConfig has no field 
or method ConnectTimeout)
",103
45264265,1635,"package main

import (
    ""fmt""
    ""html/template""
    ""log""
    ""net/http""
    ""strings""
)

func sayhelloName(w http.ResponseWriter, r *http.Request) {
    r.ParseForm() //Parse url parameters passed, then parse the response packet for the POST body (request body)
    // attention: If you do not call ParseForm method, the following data can not be obtained form
    fmt.Println(r.Form) // print information on server side.
    fmt.Println(""path"", r.URL.Path)
    fmt.Println(""scheme"", r.URL.Scheme)
    fmt.Println(r.Form[""url_long""])
    for k, v := range r.Form {
        fmt.Println(""key:"", k)
        fmt.Println(""val:"", strings.Join(v, """"))
    }
    fmt.Fprintf(w, ""Hello astaxie!"") // write data to response
}

func login(w http.ResponseWriter, r *http.Request) {
    fmt.Println(""method:"", r.Method) //get request method
    if r.Method == ""GET"" {
        t, _ := template.ParseFiles(""login.gtpl"")
        t.Execute(w, nil)
    } else {
        r.ParseForm()
        // logic part of log in
        fmt.Println(""username:"", r.Form[""username""])
        fmt.Println(""password:"", r.Form[""password""])
    }
}

func main() {
    http.HandleFunc(""/"", sayhelloName) // setting router rule
    http.HandleFunc(""/login"", login)
    err := http.ListenAndServe("":9090"", nil) // setting listening port
    if err != nil {
        log.Fatal(""ListenAndServe: "", err)
    }
}",1375
45269528,1638,INSERT INTO,11
45310580,1657,"syntax = ""proto3"";
package tutorial;

message Person {
    string name = 1;
    int32 id = 2; 
    string email = 3;

    enum PhoneType {
        MOBILE = 0;
        HOME = 1;
        WORK = 2;
    }

    message PhoneNumber {
        string number = 1;
        PhoneType type = 2;
    }

    repeated PhoneNumber phones = 4;
}

message AddressBook {
    repeated Person people = 1;
}",386
45315801,1661,square.png,10
45374658,1667,"[{""Name"":""QA1"",""Server"":""BOT1"",""Description"":""Tools"",""Apps"":""""},
{""Name"":""QA1"",""Server"":"""",""Description"":"""",""Apps"":""Duo""},
{""Name"":""QA1"",""Server"":"""",""Description"":"""",""Apps"":""Git""},
{""Name"":""QA1"",""Server"":"""",""Description"":"""",""Apps"":""php""}]",239
45377224,1670,"package main

import (
    ""net""
    ""fmt""
    ""net/rpc""
    ""log""
    ""sync""
)

type Server struct {
    name string
}

type SpeakArgs struct {
}

type SpeakReply struct {
    Success bool
}

type AddArgs struct {
    A, B int
}

type AddReply struct {
    Answer int
    Success bool
}

func (s *Server) Add(args *AddArgs, reply *AddReply) error {
    reply.Answer = args.A + args.B
    reply.Success = true
    return nil
}

func (s *Server) Speak(args *SpeakArgs, reply *SpeakReply) error {
    fmt.Printf(""My name is %v.\n"", s.name)
    reply.Success = true
    return nil
}

func main() {
    var wgMain, wgRegister, wgCall sync.WaitGroup
    wgMain.Add(3)
    wgRegister.Add(2)
    wgCall.Add(1)

    go func() {
        server := &Server{name: ""RICHARD""}
        rpc.Register(server)
        la, e := net.Listen(""unix"", ""/tmp/example1.sock"")
        if e != nil {
            log.Fatal(""listen error:"", e)
        }
        wgRegister.Done()
        go rpc.Accept(la)
        wgCall.Wait()
        la.Close()
        wgMain.Done()
        fmt.Println(""Server exited."")
    }()

    go func() {
        server := &Server{name: ""BENNY""}
        rpc.Register(server)
        lb, e := net.Listen(""unix"", ""/tmp/example2.sock"")
        if e != nil {
            log.Fatal(""listen error:"", e)
        }
        wgRegister.Done()
        go rpc.Accept(lb)
        wgCall.Wait()
        lb.Close()
        wgMain.Done()
        fmt.Println(""Server exited."")
    }()

    go func() {
        wgRegister.Wait()
        oneclient, err1 := rpc.Dial(""unix"", ""/tmp/example1.sock"")
        twoclient, err2 := rpc.Dial(""unix"", ""/tmp/example2.sock"")
        if err1 != nil {
            log.Fatal(""listen error:"", err1)
        }
        if err2 != nil {
            log.Fatal(""listen error:"", err2)
        }

        addArgs := &AddArgs{1, 2}
        addReply := &AddReply{}
        speakArgs := &SpeakArgs{}
        speakReply := SpeakReply{}
        oneclient.Call(""Server.Add"", addArgs, addReply)
        oneclient.Call(""Server.Speak"", speakArgs, speakReply)
        twoclient.Call(""Server.Speak"", speakArgs, speakReply)

        fmt.Printf(""Added numbers! %v + %v = %v.\n"", addArgs.A, addArgs.B, addReply.Answer)
        wgCall.Done()
        oneclient.Close()
        twoclient.Close()
        wgMain.Done()
        fmt.Println(""Client exited."")
    }()
    wgMain.Wait()
}",2371
45378537,1676,"Input:

{
 'reports_portal': 'select * from reports_portal',
 'billing_portal': 'select * from billing_portal',
}

output:

{
 'reports_portal': [23, 123, 5234, 632],
 'billing_portal': [23, 123, 5234, 632],
}",210
45401800,1685,"GoSago
    


    
        
            
                
            
            
                
                    
                        Kung asukal ka, ako naman ay sago. Wala akong kwenta kung wala ang tamis mo.
                        Miriam Santiago 
                    
                
            
            
                 Welcome Back, Sunil 
            
        


        
        
            
                
                    
                    
                        
                            6
                            All Categories
                        
                        
                            6
                            Dessert
                        
                        
                            0
                            Appetizer
                        
                        
                            0
                            Main Course
                        
                    
                
                
                    
                        
                            
                                
                                    
                                        Sago't Gulaman
                                        A local Filipino beverage made of brown sugar, water, gelatin, and tapioca pearls
                                        P75
                                        
                                        
                                             Add to Cart
                                        
                                    
                                

                            
                        
                        
                            
                                
                                    
                                        Taho with sago
                                         a Philippine snack food made of fresh soft/silken tofu, arnibal, and sago pearl
                                        P30
                                        
                                        
                                             Add to Cart
                                        
                                    
                                

                            
                        
                        
                            
                                
                                    
                                        Chilled Taho
                                        chilled taho is a refreshing twist and a great way to beat the summer heat
                                        P45
                                        
                                        
                                             Add to Cart
                                        
                                    
                                

                            
                        
                        
                            
                                
                                    
                                        Sago Cakes
                                        Simple and quick vegan dessert made from tapioca pearls
                                        P230
                                        
                                        
                                             Add to Cart
                                        
                                    
                                

                            
                        
                        
                            
                                
                                    
                                        Sago Pudding
                                        From the English repertoire of steamed fruit puddings comes this classic.
                                        P230
                                        
                                        
                                             Add to Cart
                                        
                                    
                                

                            
                        
                        
                            
                                
                                    
                                        Pearl Sago Fritters
                                        Sabudana Vada or Pearl Sago Fritters is a crispy & delicious snack of North India
                                        P230
                                        
                                        
                                             Add to Cart",4964
45415962,1687,mongodb,7
45470989,1693,"import (
""bufio""
""fmt""
""os""
""strings""
""strconv""
""math/big""
""bytes""
""io/ioutil""
""github.com/Azure/azure-sdk-for-go/storage""
""compress/gzip""
""encoding/base64""
""crypto/md5""
)

func main() {
    var filter bool = true                                                  //check smart filter
    test := 0
    configfile, err := os.Open(""config.txt"")                                //open configfile
    check(err)                                                              //check file opened
    ConfigScanner := bufio.NewScanner(configfile)                           //open buffer
    ConfigScanner.Scan()                                                    //get serial number
    serialnum := ConfigScanner.Text()
    configfile.Close()                                                      //close the config file
    CanLUT := ParseDBC(""file.dbc"")                                          //parse the associated DBC file
    check(err)                                                              //check file opened
    m := make(map[int64]string)                                             //map of last seen message
    //Azure API
    client, err := storage.NewBasicClient(accountName, accountKey)          //get client from azure
    check(err)
    bsc := client.GetBlobService()                                          //access blob service
    cnt := bsc.GetContainerReference(""containerblob"")                           //get container of the blob
    LBP := storage.ListBlobsParameters{}                                    
    LBP.Prefix = ""dev4/dev4""                                                //only get blobs with dev4/dev4 prefix
    list, err := cnt.ListBlobs(LBP)                                         //get list of all matching blobs
    check(err)
    for _, b := range list.Blobs {                                          //read all blobs from azure with prefix dev4/dev4
        oa := make([]byte,0)
        fmt.Println(""getting blob: "",b.Name)
        readCloser, err := b.Get(nil)                                       //get blob data
        check(err)
        bytesRead, err := ioutil.ReadAll(readCloser)                        //read blob data to byte[]
        check(err)
        if len(bytesRead) < 1 {
            continue
        }
        br := bytes.NewReader(bytesRead)
        zr, err := gzip.NewReader(br)                                       //use gzip reader for zipped data
        check(err)
        uz, err := ioutil.ReadAll(zr)                                       //uz byte[] of unzipped file
        check(err)
        readCloser.Close()                                                  //close the reader
        zr.Close()                                                          //close gzip reader
        r := bytes.NewReader(uz)
        scanner := bufio.NewScanner(r)
        for scanner.Scan() {                                                //loop on each line in the input file
            temp := ParseToFrame(scanner.Text())                            //parse the line into a usable struct
            _, exists := m[temp.nodeid]                                     //check if the frame has alread been seen and is stored in the hashmap
            if exists {                                                     //if exists in the map
                if ChkDuplicate(m, temp) {                                  //is the msg a duplicate? if true the message isnt so add it
                    m[temp.nodeid] = temp.data                              //update the data to the hashmap
                    DecodeFrame(temp, &oa, CanLUT, filter, serialnum)       //decode the frame and output it to another file
                }
            } else {                                                        //DNE in map so add it
                m[temp.nodeid] = temp.data
                DecodeFrame(temp, &oa, CanLUT,filter, serialnum)            //decode the frame and output it to another file
            }
        }//end blob file
        filestr := strings.Split(b.Name, ""_"")[1]
        filestr = ""filtered/filtered_"" + filestr
        var buffout bytes.Buffer
        gz := gzip.NewWriter(&buffout)
        _, err = gz.Write(oa)
        check(err)
        gz.Flush()
        gz.Close()
        compressedData := buffout.Bytes()
        //push block blob to azure
        fmt.Println(""uploading: "",filestr)
        clientnew, err := storage.NewBasicClient(accountName, accountKey)           //get client from azure
        check(err)
        senderbsc := clientnew.GetBlobService()                                         //access blob service
        sendercnt := senderbsc.GetContainerReference(""storeblob"")                           //get container of store blob
        bblob := sendercnt.GetBlobReference(""filtered_"" + strings.Split(b.Name, ""/"")[1])
        err = bblob.CreateBlockBlob(nil)
        check(err)
        blockID := base64.StdEncoding.EncodeToString([]byte(""00000""))
        err = bblob.PutBlock(blockID, compressedData, nil)
        check(err)
        list, err := b.GetBlockList(storage.BlockListTypeUncommitted, nil)
        check(err)
        uncommittedBlocksList := make([]storage.Block, len(list.UncommittedBlocks))
        for i := range list.UncommittedBlocks {
            uncommittedBlocksList[i].ID = list.UncommittedBlocks[i].Name
            uncommittedBlocksList[i].Status = storage.BlockStatusUncommitted
        }
        err = b.PutBlockList(uncommittedBlocksList, nil)
        //check if upload was good.
        CheckHash(&compressedData,filestr,sendercnt)
        check(err)
        if(test == 0){
            break       //test only read one file
        }
        test++
    }//end for blobs     
}//end main",5714
45500420,1694,"package beater

import (
    ""fmt""
    ""io/ioutil""
    ""math""
    ""time""
    //""log""
    ""strconv""
    ""strings""

    ""github.com/elastic/beats/libbeat/beat""
    ""github.com/elastic/beats/libbeat/common""
    ""github.com/elastic/beats/libbeat/logp""
    ""github.com/elastic/beats/libbeat/publisher""

    ""github.com/bob96/hc34/config""
)

type Hc34 struct {
    done   chan struct{}

    config config.Config

    client publisher.Client

    siteKey string

    fileKey string

    callEndDateTime string 

    callStartDateTime string

    callerPartyNumber string

    calledPartyNumber string

    incomingTrunkKey string

    outgoingTrunkKey string

    blockNumber string

    blockDateTime string

    headerFunction int

    headerUser int

    callerCategory int

    callerOrigineIdentity string

    complementaryIdentity string 

    calledDigits string 

    traficType int 

    serviceType int 

    supportService int 

    chargeDuration int 

    chargeMeters int 

    outgoingTrunk string

    reserved string 

    operatorIdentity string

    operatorServiceType string

    block string

    filekey string

    lastIndexTime time.Time
}
// Creates beater
func New(b *beat.Beat, cfg *common.Config) (beat.Beater, error) {
    config := config.DefaultConfig
    if err := cfg.Unpack(&config); err != nil {
        return nil, fmt.Errorf(""Error reading config file: %v"", err)
    }

    bt := &Hc34{
        done: make(chan struct{}),
        config: config,
    }
    return bt, nil
}

func (bt *Hc34) Run(b *beat.Beat) error {
    logp.Info(""hc34 is running! Hit CTRL-C to stop it."")

    bt.client = b.Publisher.Connect()
    ticker := time.NewTicker(bt.config.Period) 
    //counter := 1
    for {
        now := time.Now()
        bt.hc34DataHolderfunc(bt.config.Path) 
        bt.lastIndexTime = now             
        logp.Info(""Event sent"")
        select {
        case <-bt.done:
            return nil
        case <-ticker.C:
        }

        /*event := common.MapStr{
            ""@timestamp"": common.Time(time.Now()),
            ""type"":       b.Name,
            ""counter"":    counter,
        }
        bt.client.PublishEvent(event)
        logp.Info(""Event sent"")
        counter++*/
    }
}

func (bt *Hc34) Stop() {
    bt.client.Close()
    close(bt.done)
}
//checking error
func check(e error) {
    if e != nil {
        panic(e)
    }
}

func (bt *Hc34) hc34DataHolderfunc(dirfile string) {    
//reading the binary file
    data, err := ioutil.ReadFile(dirfile)
    check(err)
    //t := f.ModTime() 
    bt.hc34decoderfunc(string(data))

    event := common.MapStr{
            ""@timestamp"": common.Time(time.Now()),
            /*""siteKey"": siteKey,
            ""fileKey"": fileKey,*/
            //""callEndDateTime"":    bt.callEndDateTime,
            //""callStartDateTime"": bt.callStartDateTime,
            ""callerPartyNumber"": bt.callerPartyNumber,
            ""calledPartyNumber"": bt.calledPartyNumber,
            //""incomingTrunkKey"": bt.incomingTrunkKey,
            //""outgoingTrunkKey"": bt.outgoingTrunkKey,
            ""blockNumber"": bt.blockNumber,
            ""blockDateTime"": bt.blockDateTime,
            ""headerFunction"": bt.headerFunction,
            ""headerUser"": bt.headerUser,
            ""callerCategory"": bt.callerCategory,
            ""callerOrigineIdentity"": bt.callerOrigineIdentity,
            ""complementaryIdentity"": bt.complementaryIdentity,
            ""calledDigits"": bt.calledDigits,
            ""traficType"": bt.traficType,
            ""serviceType"": bt.serviceType,
            ""supportService"": bt.supportService,
            ""chargeDuration"": bt.chargeDuration,
            ""chargeMeters"": bt.chargeMeters,
            //""outgoingTrunk"": bt.outgoingTrunk,
            ""reserved"": bt.reserved,
            ""peratorIdentity"": bt.operatorIdentity,
            ""operatorServiceType"": bt.operatorServiceType,
        }
            bt.client.PublishEvent(event)


}
type hc34decoder struct{
    block string
    siteKey string
    filekey string
}
func (bt *Hc34) hc34decoderfunc(block string){
    // Get header (32 bytes) and content (1932 bytes) from block

    header :=block[0:64]
    content :=block[64:len(block)]
    // Get block key and date time from header
    blockKey :=header[4:10]
    yearBlock :=header[10:12]
    //BDTdecode, err := hex.DecodeString(header[10:12])

    bt.blockDateTime =bt.getDate(bt.getDateBlockHeader(header[10:22]))
    /*if err != nil {
        log.Fatal(err)
    }*/
    // process content to extract CDRs
    start := 0
    totalCdr := len(content) / 84
    for z := 0; z < totalCdr; z++ {
        record := content[start:start + 84]
        start = start + 84
        // Extract data from single record
        //CEDdecode, err :=hex.DecodeString(record[10:12])
        a:= hex2decimal(record[54:56])
        headerFunction:= hex2decimal(record[0:2])
        headerUser:= hex2decimal(record[2:4])
        callerCategory:= hex2decimal(record[4:6])
        callEndDateTime :=bt.getDate(bt.getDateCall(record[6:16], yearBlock))
        callerOrigineIdentity:= strings.Replace(string(record[16:26]),""F"","""",-1)
        complementaryIdentity := strings.Replace(string(record[26:36]),""F"","""",-1)
        calledDigits:= strings.Replace(string(record[36:54]),""F"","""",-1)
        traficType:= hex2decimal(strings.Replace(string(a),""F"","""",-1))
        serviceType := hex2decimal(record[56:58])
        supportService :=hex2decimal(record[58:60])
        duration :=hex2decimal(record[60:64])
        meters:= hex2decimal(record[64:70])
        //outgoingTrunk :=strings.Replace(string(record[70:74]),""F"", """",-1)
        bt.reserved = record[74:78]
        bt.operatorIdentity = strings.Replace(string(record[78:82]),""F"", """",-1)
        bt.operatorServiceType =record[82:84]
        bt.blockNumber=blockKey
        bt.callerPartyNumber = bt.getFormattedMsisdnHc34Caller(complementaryIdentity, callerOrigineIdentity)
        bt.calledPartyNumber = bt.getFormattedMsisdnHc34Called(calledDigits)

        bt.callStartDateTime  = bt.getStartDate(callEndDateTime, int(duration) )
        /*if err !=nil{
            log.Fatal(err)
        }*/
        bt.headerFunction=int(headerFunction)
        bt.headerUser=int(headerUser)
        bt.callerCategory=int(callerCategory)
        bt.traficType=int(traficType)
        bt.serviceType=int(serviceType)
        bt.supportService=int(supportService)
        bt.chargeMeters=int(meters)
        bt.chargeDuration=int(duration)

func (bt *Hc34) getStartDate(endTime string, duration int) string{
    layout := ""2006-01-02T15:04:05.000Z""
    t, err := time.Parse(layout, endTime)
    if err!=nil{
        panic(err)
    }
    return (t.Add(time.Duration(-duration) * time.Second)).String()

}
/**
     * Get the date of the call.
     * @param input the quanted date
     * @param year the year
     * @return the date of the call
     */
func (bt *Hc34) getDateCall(input string,year string) string{
        quant:= hex2decimal(input[1:4])
        hour := input[4:len(input)]

        return ""20"" + year + bt.getQuantDate(quant) + """" + hour
    }

    /**
     * Get date of block header.
     * @param input the quanted date
     * @return the date block header
     */
func(bt *Hc34) getDateBlockHeader(input string) string{
        year := input[0:2]
        quant:= hex2decimal(input[3:6])
        hour := input[6:len(input)];
        /*if err!=nil{
            panic(err)
        }*/
        return ""20"" + year + bt.getQuantDate(quant) + """" + hour
    }

    /**
     * format date.
     * @param date the date
     * @return the formatted date
     */

func(bt *Hc34) getDate(date string) string{
        year := date[0:4]
        month := date[4:6]
        day := date[6:8]
        hour := date[8:10]
        minute := date[10:12]
        second := date[12:14]
        return year + ""-"" + month + ""-"" + day + "" "" + hour + "":"" + minute + "":"" + second;
    }
     /**
     * Format quanted date.
     * @param quant the quanted date
     * @return the formatted date
     */
func(bt *Hc34) getQuantDate(quant int) string{
        nanoDayOfYear:=string(quant*24*60*60*1000*1000*1000) + ""ns""
        durt,err:=time.ParseDuration(nanoDayOfYear)
        t := time.Date(2009, time.January, 01, 00, 0, 0, 0, time.UTC)
        t=t.Add(durt)
        if err!=nil{

            panic(err)
        }
        return string(t.Month())+""""+string(t.Day())

    }
func bin(i int, prefix bool) string {
      i64 := int64(i)

      if prefix {
              return ""0b"" + strconv.FormatInt(i64, 2) // base 2 for binary
      } else {
              return strconv.FormatInt(i64, 2) // base 2 for binary
      }
}

func bin2int(binStr string) int {

// base 2 for binary
result, _ := strconv.ParseInt(binStr, 2, 64)
return int(result)
}


func hex(i int, prefix bool) string {
  i64 := int64(i)

  if prefix {
          return ""0x"" + strconv.FormatInt(i64, 16) // base 16 for hexadecimal
  } else {
          return strconv.FormatInt(i64, 16) // base 16 for hexadecimal
  }
}

func hex2int(hexStr string) int {
  // base 16 for hexadecimal
  result, _ := strconv.ParseInt(hexStr, 16, 64)
  return int(result)
}
func hex2decimal(hexStr string) int{

    base16 := 16;

    var val float64
    for i:=0; i>len(hexStr);i++{
        vala:=hex2int(string(base16))
        valo:=hex2int(string(hexStr[len(hexStr)-i]))
        val+=float64(valo)*math.Pow(float64(vala),float64(i))
    }
    return int(val)

}",9437
45515182,1696,"> mkdir -p ""$HOME/Go/src/github.com/fabric8io""
> export GOPATH=""$HOME/Go""
> cd ""$HOME/Go/src/github.com/fabric8io""
> git clone https://github.com/fabric8io/kubernetes-model
> cd kubernetes-model
> brew install go
> brew install godep
> make
CGO_ENABLED=0 GO15VENDOREXPERIMENT=1 go build -a ./cmd/generate/generate.go
cmd/generate/generate.go:27:2: cannot find package ""github.com/openshift/origin/pkg/authorization/api/v1"" in any of:
    /usr/local/Cellar/go/1.8.3/libexec/src/github.com/openshift/origin/pkg/authorization/api/v1 (from $GOROOT)
    /Users/joangoyeau/Code/go/src/github.com/openshift/origin/pkg/authorization/api/v1 (from $GOPATH)
cmd/generate/generate.go:28:2: cannot find package ""github.com/openshift/origin/pkg/build/api/v1"" in any of:
    /usr/local/Cellar/go/1.8.3/libexec/src/github.com/openshift/origin/pkg/build/api/v1 (from $GOROOT)
    /Users/joangoyeau/Code/go/src/github.com/openshift/origin/pkg/build/api/v1 (from $GOPATH)
cmd/generate/generate.go:29:2: cannot find package ""github.com/openshift/origin/pkg/deploy/api/v1"" in any of:
    /usr/local/Cellar/go/1.8.3/libexec/src/github.com/openshift/origin/pkg/deploy/api/v1 (from $GOROOT)
    /Users/joangoyeau/Code/go/src/github.com/openshift/origin/pkg/deploy/api/v1 (from $GOPATH)
cmd/generate/generate.go:30:2: cannot find package ""github.com/openshift/origin/pkg/image/api/v1"" in any of:
    /usr/local/Cellar/go/1.8.3/libexec/src/github.com/openshift/origin/pkg/image/api/v1 (from $GOROOT)
    /Users/joangoyeau/Code/go/src/github.com/openshift/origin/pkg/image/api/v1 (from $GOPATH)
cmd/generate/generate.go:31:2: cannot find package ""github.com/openshift/origin/pkg/oauth/api/v1"" in any of:
    /usr/local/Cellar/go/1.8.3/libexec/src/github.com/openshift/origin/pkg/oauth/api/v1 (from $GOROOT)
    /Users/joangoyeau/Code/go/src/github.com/openshift/origin/pkg/oauth/api/v1 (from $GOPATH)
cmd/generate/generate.go:32:2: cannot find package ""github.com/openshift/origin/pkg/project/api/v1"" in any of:
    /usr/local/Cellar/go/1.8.3/libexec/src/github.com/openshift/origin/pkg/project/api/v1 (from $GOROOT)
    /Users/joangoyeau/Code/go/src/github.com/openshift/origin/pkg/project/api/v1 (from $GOPATH)
cmd/generate/generate.go:33:2: cannot find package ""github.com/openshift/origin/pkg/route/api/v1"" in any of:
    /usr/local/Cellar/go/1.8.3/libexec/src/github.com/openshift/origin/pkg/route/api/v1 (from $GOROOT)
    /Users/joangoyeau/Code/go/src/github.com/openshift/origin/pkg/route/api/v1 (from $GOPATH)
cmd/generate/generate.go:34:2: cannot find package ""github.com/openshift/origin/pkg/template/api/v1"" in any of:
    /usr/local/Cellar/go/1.8.3/libexec/src/github.com/openshift/origin/pkg/template/api/v1 (from $GOROOT)
    /Users/joangoyeau/Code/go/src/github.com/openshift/origin/pkg/template/api/v1 (from $GOPATH)
cmd/generate/generate.go:35:2: cannot find package ""github.com/openshift/origin/pkg/user/api/v1"" in any of:
    /usr/local/Cellar/go/1.8.3/libexec/src/github.com/openshift/origin/pkg/user/api/v1 (from $GOROOT)
    /Users/joangoyeau/Code/go/src/github.com/openshift/origin/pkg/user/api/v1 (from $GOPATH)
cmd/generate/generate.go:36:2: cannot find package ""k8s.io/apiextensions-server/pkg/apis/apiextensions/v1beta1"" in any of:
    /usr/local/Cellar/go/1.8.3/libexec/src/k8s.io/apiextensions-server/pkg/apis/apiextensions/v1beta1 (from $GOROOT)
    /Users/joangoyeau/Code/go/src/k8s.io/apiextensions-server/pkg/apis/apiextensions/v1beta1 (from $GOPATH)
cmd/generate/generate.go:37:2: cannot find package ""k8s.io/kubernetes/pkg/api/resource"" in any of:
    /usr/local/Cellar/go/1.8.3/libexec/src/k8s.io/kubernetes/pkg/api/resource (from $GOROOT)
    /Users/joangoyeau/Code/go/src/k8s.io/kubernetes/pkg/api/resource (from $GOPATH)
cmd/generate/generate.go:38:2: cannot find package ""k8s.io/kubernetes/pkg/api/unversioned"" in any of:
    /usr/local/Cellar/go/1.8.3/libexec/src/k8s.io/kubernetes/pkg/api/unversioned (from $GOROOT)
    /Users/joangoyeau/Code/go/src/k8s.io/kubernetes/pkg/api/unversioned (from $GOPATH)
cmd/generate/generate.go:39:2: cannot find package ""k8s.io/kubernetes/pkg/api/v1"" in any of:
    /usr/local/Cellar/go/1.8.3/libexec/src/k8s.io/kubernetes/pkg/api/v1 (from $GOROOT)
    /Users/joangoyeau/Code/go/src/k8s.io/kubernetes/pkg/api/v1 (from $GOPATH)
cmd/generate/generate.go:40:2: cannot find package ""k8s.io/kubernetes/pkg/apis/apps/v1beta1"" in any of:
    /usr/local/Cellar/go/1.8.3/libexec/src/k8s.io/kubernetes/pkg/apis/apps/v1beta1 (from $GOROOT)
    /Users/joangoyeau/Code/go/src/k8s.io/kubernetes/pkg/apis/apps/v1beta1 (from $GOPATH)
cmd/generate/generate.go:41:2: cannot find package ""k8s.io/kubernetes/pkg/apis/autoscaling/v1"" in any of:
    /usr/local/Cellar/go/1.8.3/libexec/src/k8s.io/kubernetes/pkg/apis/autoscaling/v1 (from $GOROOT)
    /Users/joangoyeau/Code/go/src/k8s.io/kubernetes/pkg/apis/autoscaling/v1 (from $GOPATH)
cmd/generate/generate.go:43:2: cannot find package ""k8s.io/kubernetes/pkg/apis/batch/v1"" in any of:
    /usr/local/Cellar/go/1.8.3/libexec/src/k8s.io/kubernetes/pkg/apis/batch/v1 (from $GOROOT)
    /Users/joangoyeau/Code/go/src/k8s.io/kubernetes/pkg/apis/batch/v1 (from $GOPATH)
cmd/generate/generate.go:42:2: cannot find package ""k8s.io/kubernetes/pkg/apis/batch/v2alpha1"" in any of:
    /usr/local/Cellar/go/1.8.3/libexec/src/k8s.io/kubernetes/pkg/apis/batch/v2alpha1 (from $GOROOT)
    /Users/joangoyeau/Code/go/src/k8s.io/kubernetes/pkg/apis/batch/v2alpha1 (from $GOPATH)
cmd/generate/generate.go:44:2: cannot find package ""k8s.io/kubernetes/pkg/apis/extensions/v1beta1"" in any of:
    /usr/local/Cellar/go/1.8.3/libexec/src/k8s.io/kubernetes/pkg/apis/extensions/v1beta1 (from $GOROOT)
    /Users/joangoyeau/Code/go/src/k8s.io/kubernetes/pkg/apis/extensions/v1beta1 (from $GOPATH)
cmd/generate/generate.go:45:2: cannot find package ""k8s.io/kubernetes/pkg/client/unversioned/clientcmd/api/v1"" in any of:
    /usr/local/Cellar/go/1.8.3/libexec/src/k8s.io/kubernetes/pkg/client/unversioned/clientcmd/api/v1 (from $GOROOT)
    /Users/joangoyeau/Code/go/src/k8s.io/kubernetes/pkg/client/unversioned/clientcmd/api/v1 (from $GOPATH)
cmd/generate/generate.go:46:2: cannot find package ""k8s.io/kubernetes/pkg/watch/json"" in any of:
    /usr/local/Cellar/go/1.8.3/libexec/src/k8s.io/kubernetes/pkg/watch/json (from $GOROOT)
    /Users/joangoyeau/Code/go/src/k8s.io/kubernetes/pkg/watch/json (from $GOPATH)
make: *** [build] Error 1",6391
45532809,1698,"Location string `json:""location""`  
",36
45547741,1705,"package main

import (
    “bytes”
    “encoding/binary”
    “fmt”
    “os”
    “os/exec”
    “syscall”
)

// parses through the /proc/bus/input/devices file for keyboard devices.
// Copied from `github.com/gearmover/keylogger` with trivial modification.
func dumpDevices() ([]string, error) {
    cmd := exec.Command(“/bin/sh”, “-c”, “/bin/grep -E ‘Handlers|EV=’ /proc/bus/input/devices | /bin/grep -B1 ‘EV=120013’ | /bin/grep -Eo ‘event[0-9]+’”)

    output, err := cmd.Output()
    if err != nil {
        return nil, err
    }

    buf := bytes.NewBuffer(output)

    var devices []string

    for line, err := buf.ReadString(‘\n’); err == nil; {
        devices = append(devices, “/dev/input/”+line[:len(line)-1])

        line, err = buf.ReadString(‘\n’)
    }

    return devices, nil
}

// Using MS names, just because I don’t feel like looking up the Linux versions.
var keys = map[uint16]string{
    0xa3: “VK_MEDIA_NEXT_TRACK”,
    0xa5: “VK_MEDIA_PREV_TRACK”,
    0xa6: “VK_MEDIA_STOP”,
    0xa4: “VK_MEDIA_PLAY_PAUSE”,
}

// Most of the code here comes from `github.com/gearmover/keylogger`.
func main() {
    // drop privileges when executing other programs
    syscall.Setgid(65534)
    syscall.Setuid(65534)

    // dump our keyboard devices from /proc/bus/input/devices
    devices, err := dumpDevices()
    if err != nil {
        fmt.Println(err)
    }
    if len(devices) == 0 {
        fmt.Println(“No input devices found”)
        return
    }

    // bring back our root privs
    syscall.Setgid(0)
    syscall.Setuid(0)

    // Open the first keyboard device.
    input, err := os.OpenFile(devices[0], os.O_RDONLY, 0600)
    if err != nil {
        fmt.Println(err)
        return
    }
    defer input.Close()

    // Log media keys
    var buffer = make([]byte, 24)
    for {
        // read the input events as they come in
        n, err := input.Read(buffer)
        if err != nil {
            return
        }

        if n != 24 {
            fmt.Println(“Weird Input Event Size: “, n)
            continue
        }

        // parse the input event according to the  header struct
        binary.LittleEndian.Uint64(buffer[0:8]) // Time stamp stuff I could care less about
        binary.LittleEndian.Uint64(buffer[8:16])
        etype := binary.LittleEndian.Uint16(buffer[16:18])        // Event Type. Always 1 for keyboard events
        code := binary.LittleEndian.Uint16(buffer[18:20])         // Key scan code
        value := int32(binary.LittleEndian.Uint32(buffer[20:24])) // press(1), release(0), or repeat(2)

        if etype == 1 && value == 1 && keys[code] != “” {
            // In a real application I would send a message here.
            fmt.Println(keys[code])
        }
    }
}",2822
45567283,1707,"//main func runs perfectly fine
func main() {
    //ODBC connection to vertica via DSN
    db, err := sql.Open(""odbc"", ""DSN=HPVerticaDSN"")
    if err != nil {
        panic(err)
    }
    defer db.Close()

    if err := db.Ping(); err != nil {
        fmt.Printf(""ping err: %v"", err)
    }

    //start gin
    r := gin.Default()
    r.GET(""/ping"", func(c *gin.Context) {
        handler(c, db)
    })
    r.Run() // listen and serve on 0.0.0.0:8080
}",452
45590483,1711,"170809/044343.745, [log,connection,client,error] message: write EPIPE, stack: Error: write EPIPE
    at exports._errnoException (util.js:1018:11)
    at WriteWrap.afterWrite (net.js:800:14)",191
45654383,1718,"

...
",6
45686269,1720,"{
    ""3211"": {
        ""entity_id"": ""3211"",
        ""status"": ""complete"",
        ""coupon_code"": ""COUPON"",
        ""shipping_description"": ""Shipping - AU Courier"",
        ""customer_id"": ""2775"",
        ""base_discount_amount"": ""-50.0000"",
        ""base_grand_total"": ""149.0000"",
        ""base_shipping_amount"": ""0.0000"",
        ""base_shipping_tax_amount"": ""0.0000"",
        ""base_subtotal"": ""199.0000"",
        ""base_tax_amount"": ""0.0000"",
        ""base_total_paid"": ""149.0000"",
        ""base_total_refunded"": null,
        ""discount_amount"": ""-50.0000"",
        ""grand_total"": ""149.0000"",
        ""shipping_amount"": ""0.0000"",
        ""shipping_tax_amount"": ""0.0000"",
        ""store_to_order_rate"": ""1.0000"",
        ""subtotal"": ""199.0000"",
        ""tax_amount"": ""0.0000"",
        ""total_paid"": ""149.0000"",
        ""total_refunded"": null,
        ""base_shipping_discount_amount"": ""0.0000"",
        ""base_subtotal_incl_tax"": ""199.0000"",
        ""base_total_due"": ""0.0000"",
        ""shipping_discount_amount"": ""0.0000"",
        ""subtotal_incl_tax"": ""199.0000"",
        ""total_due"": ""0.0000"",
        ""increment_id"": ""200000423"",
        ""base_currency_code"": ""AUD"",
        ""discount_description"": ""COUPON"",
        ""remote_ip"": ""123.123.123.123"",
        ""store_currency_code"": ""AUD"",
        ""store_name"": ""Australia"",
        ""created_at"": ""2017-07-17 03:07:40"",
        ""shipping_incl_tax"": ""0.0000"",
        ""payment_method"": ""ewayrapid_ewayone"",
        ""gift_message_from"": null,
        ""gift_message_to"": null,
        ""gift_message_body"": null,
        ""tax_name"": null,
        ""tax_rate"": null,
        ""addresses"": [
            {
                ""region"": ""South Australia"",
                ""postcode"": ""5000"",
                ""lastname"": ""Doe"",
                ""street"": ""Level 6\n25 Example Street"",
                ""city"": ""Adelaide"",
                ""email"": ""example@email.com"",
                ""telephone"": ""+61 123 456 789"",
                ""country_id"": ""AU"",
                ""firstname"": ""John"",
                ""address_type"": ""billing"",
                ""prefix"": null,
                ""middlename"": null,
                ""suffix"": null,
                ""company"": null
            },
            {
                ""region"": ""South Australia"",
                ""postcode"": ""5000"",
                ""lastname"": ""Doe"",
                ""street"": ""Level 6\n25 Example Street"",
                ""city"": ""Adelaide"",
                ""email"": ""example@email.com"",
                ""telephone"": ""+61 123 456 789"",
                ""country_id"": ""AU"",
                ""firstname"": ""John"",
                ""address_type"": ""shipping"",
                ""prefix"": null,
                ""middlename"": null,
                ""suffix"": null,
                ""company"": null
            }
        ]
    }
}",2806
45756667,1726,"package main

import (
     ""log""
     ""bufio""
     ""fmt""
     ""encoding/csv""
     ""encoding/json""
     ""io""
     ""os""
     ""sync""
)

type IMDBDataModel struct {
     Color                  string `json:""color""`
     DirectorName           string `json:""director_name""`
     NumCriticForReviews    string `json:""num_critic_for_reviews""`
     Duration               string `json:""duration""`
     DirectorFacebookLikes  string `json:""director_facebook_likes""`
     Actor3FacebookLikes    string `json:""actor_3_facebook_likes""`
     Actor2Name             string `json:""actor_2_name""`
     Actor1FacebookLikes    string `json:""actor_1_facebook_likes""`
     Gross                  string `json:""gross""`
     Genre                  string `json:""genres""`
     Actor1Name             string `json:""actor_1_name""`
     MovieTitle             string `json:""movie_title""`
     NumVotedUser           string `json:""num_voted_users""`
     CastTotalFacebookLikes string `json:""cast_total_facebook_likes""`
     Actor3Name             string `json:""actor_3_name""`
     FaceNumberInPoster     string `json:""facenumber_in_poster""`
     PlotKeywords           string `json:""plot_keywords""`
     MovieIMDBLink          string `json:""movie_imdb_link""`
     NumUserForReviews      string `json:""num_user_for_reviews""`
     Language               string `json:""language""`
     Country                string `json:""country""`
     ContentRating          string `json:""content_rating""`
     Budget                 string `json:""budget""`
     TitleYear              string `json:""title_year""`
     Actor2FacebookLikes    string `json:""actor_2_facebook_likes""`
     IMDBScore              string `json:""imdb_score""`
     AspectRatio            string `json:""aspect_ratio""`
     MovieFacebookLikes     string `json:""movie_facebook_likes""`
}

var iterated int64
var out []*IMDBDataModel

func populateString(input []IMDBDataModel, out []*IMDBDataModel, wg *sync.WaitGroup) {
     for _ , data := range input {          
          out = append(out, &data)
     }     
     wg.Done()
}

func consumeData(input <-chan *IMDBDataModel, wg *sync.WaitGroup){
     defer wg.Done()
     for data := range input {          
          iterated++          
          fmt.Printf(""%d : %s\n"", iterated, data.MovieTitle)
          out = append(out, data)
     }
     fmt.Println(""output size : "", len(out))

}

func processCSV(path string) (imdbList []IMDBDataModel){
     csvFile, _ := os.Open(path)
     reader := csv.NewReader(bufio.NewReader(csvFile))

     for {          
          line, error := reader.Read()
          if error == io.EOF {
               break
          } else if error != nil {
               log.Fatal(error)
          }
          imdbList = append(imdbList, 
               IMDBDataModel{
                    Color: line[0],
                    DirectorName: line[1],
                    NumCriticForReviews : line[2],
                    Duration: line[3],
                    DirectorFacebookLikes: line[4],
                    Actor3FacebookLikes: line[5],
                    Actor2Name: line[6],
                    Actor1FacebookLikes: line[7],
                    Gross: line[8],
                    Genre: line[9],
                    Actor1Name: line[10],
                    MovieTitle: line[11],
                    NumVotedUser: line[12],
                    CastTotalFacebookLikes: line[13],
                    Actor3Name: line[14],
                    FaceNumberInPoster: line[15],
                    PlotKeywords: line[16],
                    MovieIMDBLink: line[17],
                    NumUserForReviews: line[18],
                    Language: line[19],
                    Country: line[20],
                    ContentRating: line[21],
                    Budget: line[22],
                    TitleYear: line[23],
                    Actor2FacebookLikes: line[24],
                    IMDBScore: line[25],
                    AspectRatio: line[26],
                    MovieFacebookLikes: line[27],
               },
          )          
     }
     imdbJson, err := json.Marshal(imdbList)
     if err != nil {
          log.Println(imdbJson)
     }

     return 
}

func main() {     
     imdbList := processCSV(""movie_metadata.csv"")     
     imdbChannel  := make(chan *IMDBDataModel, 100) // buffer

     var wg sync.WaitGroup
     for i := 0; i < 5;i++ {
          wg.Add(1)
          go consumeData(imdbChannel,&wg)     
     }

     for _ ,task := range imdbList {          
          imdbChannel <- &task               
     }

     close(imdbChannel)     
     wg.Wait()

     // for _, item := range out {
     //      fmt.Println(item.MovieTitle)
     // }

     fmt.Println(""Total Channel :"", len(imdbChannel)) 
     fmt.Println(""Total IMDB :"", len(imdbList))
     fmt.Println(""Total Data: "", len(out))
     fmt.Println(""Iterated : "", iterated)
     fmt.Println(""Goroutines finished.."")


}",4913
45774425,1729,"data := []byte(`{
    ""fantasy_content"": {
        ""copyright"": ""Data provided by Yahoo! and STATS, LLC"",
        ""league"": [
            {
                ""allow_add_to_dl_extra_pos"": 0,
                ""current_week"": ""1"",
                ""draft_status"": ""predraft"",
                ""edit_key"": ""1"",
                ""end_date"": ""2017-12-25"",
                ""end_week"": ""16"",
                ""game_code"": ""nfl"",
                ""is_cash_league"": ""0"",
                ""is_pro_league"": ""0"",
                ""league_id"": ""XXXXX"",
                ""league_key"": ""XXXX"",
                ""league_type"": ""private"",
                ""league_update_timestamp"": null,
                ""name"": ""XXXXXX"",
                ""num_teams"": 14,
                ""renew"": ""XXXX"",
                ""renewed"": """",
                ""scoring_type"": ""head"",
                ""season"": ""2017"",
                ""short_invitation_url"": ""XXXXX"",
                ""start_date"": ""2017-09-07"",
                ""start_week"": ""1"",
                ""url"": ""XXXXXX"",
                ""weekly_deadline"": """"
            },
            {
                ""teams"": {
                    ""0"": {
                        ""team"": [
                            [
                                {
                                    ""team_key"": ""XXXX""
                                },
                                {
                                    ""team_id"": ""1""
                                },
                                {
                                    ""name"": ""XXXXX""
                                },
                                [],
                                {
                                    ""url"": ""XXXXX""
                                },
                                {
                                    ""team_logos"": [
                                        {
                                            ""team_logo"": {
                                                ""size"": ""large"",
                                                ""XXX""
                                            }
                                        }
                                    ]
                                },
                                [],
                                {
                                    ""waiver_priority"": """"
                                },
                                {
                                    ""faab_balance"": ""100""
                                },
                                {
                                    ""number_of_moves"": 0
                                },
                                {
                                    ""number_of_trades"": 0
                                },
                                {
                                    ""roster_adds"": {
                                        ""coverage_type"": ""week"",
                                        ""coverage_value"": ""1"",
                                        ""value"": ""0""
                                    }
                                },
                                [],
                                {
                                    ""league_scoring_type"": ""head""
                                },
                                [],
                                [],
                                {
                                    ""has_draft_grade"": 0
                                },
                                [],
                                [],
                                {
                                    ""managers"": [
                                        {
                                            ""manager"": {
                                                ""email"": ""XXXXX"",
                                                ""guid"": ""XX"",
                                                ""image_url"": ""https://s.yimg.com/wm/modern/images/default_user_profile_pic_64.png"",
                                                ""is_commissioner"": ""1"",
                                                ""manager_id"": ""1"",
                                                ""nickname"": ""Andrew""
                                            }
                                        }
                                    ]
                                }
                            ]
                        ]
                    },
                    ""1"": {
                        ""team"": [
                            [
                                {
                                    ""team_key"": ""XXXXX""
                                },
                                {
                                    ""team_id"": ""2""
                                },
                                {
                                    ""name"": ""XXXXX""
                                },
                                [],
                                {
                                    ""url"": ""XXXXX""
                                },
                                {
                                    ""team_logos"": [
                                        {
                                            ""team_logo"": {
                                                ""size"": ""large"",
                                                ""url"": ""XXXX""
                                            }
                                        }
                                    ]
                                },
                                [],
                                {
                                    ""waiver_priority"": """"
                                },
                                {
                                    ""faab_balance"": ""100""
                                },
                                {
                                    ""number_of_moves"": 0
                                },
                                {
                                    ""number_of_trades"": 0
                                },
                                {
                                    ""roster_adds"": {
                                        ""coverage_type"": ""week"",
                                        ""coverage_value"": ""1"",
                                        ""value"": ""0""
                                    }
                                },
                                [],
                                {
                                    ""league_scoring_type"": ""head""
                                },
                                [],
                                [],
                                {
                                    ""has_draft_grade"": 0
                                },
                                [],
                                [],
                                {
                                    ""managers"": [
                                        {
                                            ""manager"": {
                                                ""email"": ""XXXX@yahoo.com"",
                                                ""guid"": ""XXXX"",
                                                ""image_url"": ""https://s.yimg.com/wm/modern/images/default_user_profile_pic_64.png"",
                                                ""manager_id"": ""2"",
                                                ""nickname"": ""Andrew""
                                            }
                                        },
                                        {
                                            ""manager"": {
                                                ""email"": ""XXX@yahoo.com"",
                                                ""guid"": ""XX"",
                                                ""image_url"": ""https://s.yimg.com/wm/modern/images/default_user_profile_pic_64.png"",
                                                ""is_comanager"": ""1"",
                                                ""manager_id"": ""15"",
                                                ""nickname"": ""XX""
                                            }
                                        }
                                    ]
                                }
                            ]
                        ]
                    },
                    ""10"": {
                        ""team"": [
                            [
                                {
                                    ""team_key"": ""XXX""
                                },
                                {
                                    ""team_id"": ""11""
                                },
                                {
                                    ""name"": ""XXX""
                                },
                                [],
                                {
                                    ""url"": ""https://football.fantasysports.yahoo.com/f1/XXX""
                                },
                                {
                                    ""team_logos"": [
                                        {
                                            ""team_logo"": {
                                                ""size"": ""large"",
                                                ""url"": ""https://s.yimg.com/dh/ap/fantasy/nfl/img/icon_01_100.png""
                                            }
                                        }
                                    ]
                                },
                                [],
                                {
                                    ""waiver_priority"": """"
                                },
                                {
                                    ""faab_balance"": ""100""
                                },
                                {
                                    ""number_of_moves"": 0
                                },
                                {
                                    ""number_of_trades"": 0
                                },
                                {
                                    ""roster_adds"": {
                                        ""coverage_type"": ""week"",
                                        ""coverage_value"": ""1"",
                                        ""value"": ""0""
                                    }
                                },
                                [],
                                {
                                    ""league_scoring_type"": ""head""
                                },
                                [],
                                [],
                                {
                                    ""has_draft_grade"": 0
                                },
                                [],
                                [],
                                {
                                    ""managers"": [
                                        {
                                            ""manager"": {
                                                ""email"": ""XXX@gmail.com"",
                                                ""guid"": ""XX"",
                                                ""image_url"": ""https://s.yimg.com/wm/modern/images/default_user_profile_pic_64.png"",
                                                ""manager_id"": ""11"",
                                                ""nickname"": ""XX""
                                            }
                                        }
                                    ]
                                }
                            ]
                        ]
                    },
                    ""2"": {
                        ""team"": [
                            [
                                {
                                    ""team_key"": ""371.l.102542.t.3""
                                },
                                {
                                    ""team_id"": ""3""
                                },
                                {
                                    ""name"": ""XXX""
                                },
                                [],
                                {
                                    ""url"": ""https://football.fantasysports.yahoo.com/f1/XX/3""
                                },
                                {
                                    ""team_logos"": [
                                        {
                                            ""team_logo"": {
                                                ""size"": ""large"",
                                                ""url"": ""https://ct.yimg.com/cy/5603/30147468023_1c705edb29_192sq.jpg?ct=fantasy""
                                            }
                                        }
                                    ]
                                },
                                [],
                                {
                                    ""waiver_priority"": """"
                                },
                                {
                                    ""faab_balance"": ""100""
                                },
                                {
                                    ""number_of_moves"": 0
                                },
                                {
                                    ""number_of_trades"": 0
                                },
                                {
                                    ""roster_adds"": {
                                        ""coverage_type"": ""week"",
                                        ""coverage_value"": ""1"",
                                        ""value"": ""0""
                                    }
                                },
                                [],
                                {
                                    ""league_scoring_type"": ""head""
                                },
                                [],
                                [],
                                {
                                    ""has_draft_grade"": 0
                                },
                                [],
                                [],
                                {
                                    ""managers"": [
                                        {
                                            ""manager"": {
                                                ""email"": ""XXXgmail.com"",
                                                ""guid"": ""XXXX"",
                                                ""image_url"": ""https://s.yimg.com/wv/images/6c93ed606f742d4c075bc091633cc072_64.jpg"",
                                                ""manager_id"": ""3"",
                                                ""nickname"": ""XX""
                                            }
                                        }
                                    ]
                                }
                            ]
                        ]
                    },
                    ""3"": {
                        ""team"": [
                            [
                                {
                                    ""team_key"": ""371.l.102542.t.4""
                                },
                                {
                                    ""team_id"": ""4""
                                },
                                {
                                    ""name"": ""XX""
                                },
                                [],
                                {
                                    ""url"": ""https://football.fantasysports.yahoo.com/f1/XX/4""
                                },
                                {
                                    ""team_logos"": [
                                        {
                                            ""team_logo"": {
                                                ""size"": ""large"",
                                                ""url"": ""https://s.yimg.com/dh/ap/fantasy/nfl/img/icon_10_100.png""
                                            }
                                        }
                                    ]
                                },
                                [],
                                {
                                    ""waiver_priority"": """"
                                },
                                {
                                    ""faab_balance"": ""100""
                                },
                                {
                                    ""number_of_moves"": 0
                                },
                                {
                                    ""number_of_trades"": 0
                                },
                                {
                                    ""roster_adds"": {
                                        ""coverage_type"": ""week"",
                                        ""coverage_value"": ""1"",
                                        ""value"": ""0""
                                    }
                                },
                                [],
                                {
                                    ""league_scoring_type"": ""head""
                                },
                                [],
                                [],
                                {
                                    ""has_draft_grade"": 0
                                },
                                [],
                                [],
                                {
                                    ""managers"": [
                                        {
                                            ""manager"": {
                                                ""email"": ""XXX@yahoo.com"",
                                                ""guid"": ""XX"",
                                                ""image_url"": ""https://s.yimg.com/wm/modern/images/default_user_profile_pic_64.png"",
                                                ""manager_id"": ""4"",
                                                ""nickname"": ""XX""
                                            }
                                        }
                                    ]
                                }
                            ]
                        ]
                    },
                    ""8"": {
                        ""team"": [
                            [
                                {
                                    ""team_key"": ""XXX""
                                },
                                {
                                    ""team_id"": ""9""
                                },
                                {
                                    ""name"": ""XxX""
                                },
                                [],
                                {
                                    ""url"": ""https://football.fantasysports.yahoo.com/f1/XX/9""
                                },
                                {
                                    ""team_logos"": [
                                        {
                                            ""team_logo"": {
                                                ""size"": ""large"",
                                                ""url"": ""https://ct.yimg.com/cy/8393/28682944304_33bda49603_192sq.jpg?ct=fantasy""
                                            }
                                        }
                                    ]
                                },
                                [],
                                {
                                    ""waiver_priority"": """"
                                },
                                {
                                    ""faab_balance"": ""100""
                                },
                                {
                                    ""number_of_moves"": 0
                                },
                                {
                                    ""number_of_trades"": 0
                                },
                                {
                                    ""roster_adds"": {
                                        ""coverage_type"": ""week"",
                                        ""coverage_value"": ""1"",
                                        ""value"": ""0""
                                    }
                                },
                                [],
                                {
                                    ""league_scoring_type"": ""head""
                                },
                                [],
                                [],
                                {
                                    ""has_draft_grade"": 0
                                },
                                [],
                                [],
                                {
                                    ""managers"": [
                                        {
                                            ""manager"": {
                                                ""email"": ""XXX"",
                                                ""guid"": ""XXX"",
                                                ""image_url"": ""https://s.yimg.com/wm/modern/images/default_user_profile_pic_64.png"",
                                                ""manager_id"": ""9"",
                                                ""nickname"": ""XXX""
                                            }
                                        }
                                    ]
                                }
                            ]
                        ]
                    },
                    ""count"": 14
                }
            }
        ],
        ""refresh_rate"": ""60"",
        ""time"": ""110.55207252502ms"",
        ""xml:lang"": ""en-US"",
        ""yahoo:uri"": ""/fantasy/v2/league/XXXX/teams""
    }
}`)",21901
45839846,1731,"package testing

import (
    ""encoding/xml""
    ""fmt""
    ""reflect""

    ""github.com/fiorix/wsdl2go/soap""
)

// Namespace was auto-generated from WSDL.
var Namespace = ""http://schemas.microsoft.com/sharepoint/soap/""

// NewAuthenticationSoap creates an initializes a AuthenticationSoap.
func NewAuthenticationSoap(cli *soap.Client) AuthenticationSoap {
    return &authenticationSoap{cli}
}

// AuthenticationSoap was auto-generated from WSDL
// and defines interface for the remote service. Useful for testing.
type AuthenticationSoap interface {
    // Login was auto-generated from WSDL.
    Login(α *Login) (β *LoginResponse, err error)

    // Mode was auto-generated from WSDL.
    Mode(α *Mode) (β *ModeResponse, err error)
}

// AuthenticationMode was auto-generated from WSDL.
type AuthenticationMode string

// Validate validates AuthenticationMode.
func (v AuthenticationMode) Validate() bool {
    for _, vv := range []string{
        ""None"",
        ""Windows"",
        ""Passport"",
        ""Forms"",
    } {
        if reflect.DeepEqual(v, vv) {
            return true
        }
    }
    return false
}

// LoginErrorCode was auto-generated from WSDL.
type LoginErrorCode string

// Validate validates LoginErrorCode.
func (v LoginErrorCode) Validate() bool {
    for _, vv := range []string{
        ""NoError"",
        ""NotInFormsAuthenticationMode"",
        ""PasswordNotMatch"",
    } {
        if reflect.DeepEqual(v, vv) {
            return true
        }
    }
    return false
}

// Login was auto-generated from WSDL.
type Login struct {
    XMLName  xml.Name `xml:""http://schemas.microsoft.com/sharepoint/soap/ Login"" json:""-"" yaml:""-""`
    Username string   `xml:""username,omitempty"" json:""username,omitempty"" yaml:""username,omitempty""`
    Password string   `xml:""password,omitempty"" json:""password,omitempty"" yaml:""password,omitempty""`
}

// LoginResponse was auto-generated from WSDL.
type LoginResponse struct {
    LoginResult *LoginResult `xml:""LoginResult"" json:""LoginResult"" yaml:""LoginResult""`
}

// LoginResult was auto-generated from WSDL.
type LoginResult struct {
    CookieName     string         `xml:""CookieName,omitempty"" json:""CookieName,omitempty"" yaml:""CookieName,omitempty""`
    ErrorCode      LoginErrorCode `xml:""ErrorCode"" json:""ErrorCode"" yaml:""ErrorCode""`
    TimeoutSeconds int            `xml:""TimeoutSeconds"" json:""TimeoutSeconds"" yaml:""TimeoutSeconds""`
    Sprequestguid  string
}

// Mode was auto-generated from WSDL.
type Mode struct{}

// ModeResponse was auto-generated from WSDL.
type ModeResponse struct {
    ModeResult AuthenticationMode `xml:""ModeResult"" json:""ModeResult"" yaml:""ModeResult""`
}

// authenticationSoap implements the AuthenticationSoap interface.
type authenticationSoap struct {
    cli *soap.Client
}

// Login was auto-generated from WSDL.
func (p *authenticationSoap) Login(α *Login) (β *LoginResponse, err error) {
    fmt.Println(""inside authenticationSoap"", α.Username, α.Password)
    γ := struct {
        XMLName xml.Name `xml:""Envelope""`
        Body    struct {
            M LoginResponse `xml:""LoginResponse""`
        }
    }{}
    if err = p.cli.RoundTripSoap12(""http://schemas.microsoft.com/sharepoint/soap/Login"", α, &γ); err != nil {
        return nil, err
    }
    return &γ.Body.M, nil
}

// Mode was auto-generated from WSDL.
func (p *authenticationSoap) Mode(α *Mode) (β *ModeResponse, err error) {
    γ := struct {
        XMLName xml.Name `xml:""Envelope""`
        Body    struct {
            M ModeResponse `xml:""ModeResponse""`
        }
    }{}
    if err = p.cli.RoundTripSoap12(""http://schemas.microsoft.com/sharepoint/soap/Mode"", α, &γ); err != nil {
        return nil, err
    }
    return &γ.Body.M, nil
}
func main() {

}",3754
45846743,1741,CreateHandler,13