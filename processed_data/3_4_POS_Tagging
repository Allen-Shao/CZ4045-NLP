sweaters := Inventory{"wool", 17}
['sweaters', ':=', 'Inventory', '{', '"wool"', ',', '17', '}']
['IDENTIFIER', 'ASSIGNMENT_OPERATOR', 'IDENTIFIER', 'PUNCTUATION', 'STRING_LITERAL', 'PUNCTUATION', 'DECIMAL_LITERAL']

panic(err)
['panic(err)']
['FUNCTION_CALL']

A successful call returns err == nil, not err == EOF.
['A', 'successful', 'call', 'returns', 'err', '==',' 'nil', ',', 'not', 'err', '==', 'EOF', '.']
['DT', 'JJ', 'NN', 'VBZ', 'NN', 'SYM', 'NN', ',', 'RB', 'NN', 'SYM', 'NN', '.']

os.Args[1] = "-conf=my.conf"
['os', '.', 'Args', '[', '1', ']', '=', '"-conf=my.conf"']
['IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'PUNCTUATION', 'DECIMAL_LITERAL', 'PUNCTUATION', 'ASSIGNMENT_OPERATOR', 'STRING_LITERAL']

You could use the PortAudio Go bindings (go get github.com/gordonklaus/portaudio) for this.
['You', 'could', 'use', 'the', 'PortAudio', 'Go', 'bindings', '(', 'go', 'get', 'github.com/gordonklaus/portaudio', ')', 'for', 'this', '.']
['PRP', 'MD', 'VB', 'DT', 'NNP', 'NNP', 'NNS', '(', 'VB', 'VB', 'NN', ')', 'IN', 'DT', '.']

The problem is that your first assigning i to 15 when your calling closure1() And then closure two you print it.
['The', 'problem', 'is', 'that', 'your', 'first', 'assigning', 'i', 'to', '15', 'when', 'your', 'calling', 'closure1()', 'And', 'then', 'closure', 'two', 'you', 'print', 'it', '.']
['DT', 'NN', 'VBZ', 'WDT', 'PRP$', 'JJ', 'VBG', 'NN', 'TO', 'CD', 'WRB', 'PRP$', 'VBG', 'NN', 'DT', 'RB', 'NN', 'CD', 'PRP', 'VBP', 'PRP', '.']


if flag.Lookup("test.v") == nil {
['if', 'flag', '.', 'Lookup', '(', '"test.v"', ')', '==',  'nil', '{',]
['KEYWORD', 'IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'PUNCTUATION', 'STRING_LITERAL', 'PUNCTUATION', 'RELATION_OPERATOR', 'RESERVED', 'PUNCTUATION']

fmt.Println(err.Error())
['fmt.Println(err.Error())']
['FUNCTION_CALL']

In net/rpc godoc example it just shows how to use global defaults.
['In', 'net/rpc', 'godoc', 'example', 'it', 'just', 'shows', 'how', 'to', 'use', 'global', 'defaults', '.']
['IN', 'NN', 'NN', 'NN', 'PRP', 'RB', 'VBZ', 'WRB', 'TO', 'VB', 'JJ', 'NNS', '.']

byteSlice := *(*[]byte)(unsafe.Pointer(&mySliceR))
['byteSlice', ':=', '*', '(', '*', '[]', 'byte', ')', '(','unsafe.Pointer(&mySliceR)', ')']
['IDENTIFIER', 'ASSIGNMENT_OPERATOR', 'POINTER_OPERATOR', 'PUNCTUATION', 'POINTER_OPERATOR', 'PUNCTUATION', 'IDENTIFIER', 'PUNCTUATION', 'PUNCUATION', 'FUNCTION_CALL', 'PUNCTUATION']
