,text,token,annotation
0,"First, as has been commented, are you sure you can't use
the go/build package directly rather than running go list?

I Wouldn't use println (or fmt.Println) inside HTTP handlers. It's much better to use log.Println and/or get the error into the ResponseWriter. Also, it's a good idea to wrap your ListenAndServe call with log.Fatal.

When printing/logging error values you can just use err, no need to have err.Error().

Further, when you actually want to do something more detailed than just reporting/logging the error message you can look at it's type and other info. For example, ","['First,', 'as', 'has', 'been', 'commented,', 'are', 'you', 'sure', 'you', ""can't"", 'use', 'the', 'go/build', 'package', 'directly', 'rather', 'than', 'running', 'go', 'list?', 'I', ""Wouldn't"", 'use', 'println', '(or', 'fmt.Println)', 'inside', 'HTTP', 'handlers.', ""It's"", 'much', 'better', 'to', 'use', 'log.Println', 'and/or', 'get', 'the', 'error', 'into', 'the', 'ResponseWriter.', 'Also,', ""it's"", 'a', 'good', 'idea', 'to', 'wrap', 'your', 'ListenAndServe', 'call', 'with', 'log.Fatal.', 'When', 'printing/logging', 'error', 'values', 'you', 'can', 'just', 'use', 'err,', 'no', 'need', 'to', 'have', 'err.Error().', 'Further,', 'when', 'you', 'actually', 'want', 'to', 'do', 'something', 'more', 'detailed', 'than', 'just', 'reporting/logging', 'the', 'error', 'message', 'you', 'can', 'look', 'at', ""it's"", 'type', 'and', 'other', 'info.', 'For', 'example,']","['NNP', 'IN', 'VBZ', 'VBN', 'VBN', 'VBP', 'PRP', 'JJ', 'PRP', 'VBP', 'VB', 'DT', 'JJ', 'NN', 'RB', 'RB', 'IN', 'VBG', 'VB', 'JJ', 'PRP', 'VBP', 'VB', 'JJ', 'NNP', 'NN', 'IN', 'NNP', 'VBD', 'NNP', 'RB', 'JJR', 'TO', 'VB', 'JJ', 'NN', 'VB', 'DT', 'NN', 'IN', 'DT', 'NNP', 'NNP', 'VBZ', 'DT', 'JJ', 'NN', 'TO', 'VB', 'PRP$', 'NNP', 'NN', 'IN', 'NN', 'WRB', 'VBG', 'NN', 'NNS', 'PRP', 'MD', 'RB', 'VB', 'JJ', 'DT', 'NN', 'TO', 'VB', 'VBN', 'NNP', 'WRB', 'PRP', 'RB', 'VBP', 'TO', 'VB', 'NN', 'JJR', 'JJ', 'IN', 'RB', 'VBG', 'DT', 'NN', 'NN', 'PRP', 'MD', 'VB', 'IN', 'JJ', 'NN', 'CC', 'JJ', 'NN', 'IN', 'NN']"
1,"log.Printf(""verbose error info: %#v"", err)","['log.Printf(""verbose error info: %#v"", err)']",['FUNCTION_CALL']
2," gives:

",['gives:'],['NN']
3,"&json.SyntaxError{msg:""invalid character ',' looking for beginning of value"", Offset:0}","['&', 'json', '.', 'SyntaxError', '{', 'msg', ':', '""invalid character \',\' looking for beginning of value""', ',', 'Offset', ':', '0', '}']","['POINTER_OPERATOR', 'IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'PUNCTUATION', 'STRING_LITERAL', 'PUNCTUATION', 'IDENTIFIER', 'PUNCTUATION', 'OCTAL_LITERAL', 'PUNCTUATION']"
4,"

I tried this because I know the json package returns various error types with additional info and I was hoping the offset value would be of help. If it had been then something like this might have been helpful:

","['I', 'tried', 'this', 'because', 'I', 'know', 'the', 'json', 'package', 'returns', 'various', 'error', 'types', 'with', 'additional', 'info', 'and', 'I', 'was', 'hoping', 'the', 'offset', 'value', 'would', 'be', 'of', 'help.', 'If', 'it', 'had', 'been', 'then', 'something', 'like', 'this', 'might', 'have', 'been', 'helpful:']","['PRP', 'VBD', 'DT', 'IN', 'PRP', 'VBP', 'DT', 'NN', 'NN', 'VBZ', 'JJ', 'NN', 'NNS', 'IN', 'JJ', 'NN', 'CC', 'PRP', 'VBD', 'VBG', 'DT', 'NN', 'NN', 'MD', 'VB', 'IN', 'NN', 'IN', 'PRP', 'VBD', 'VBN', 'RB', 'NN', 'IN', 'DT', 'MD', 'VB', 'VBN', 'JJ']"
5,if err := json.Compact(…) {,"['if', 'err', ':=', 'json.Compact(…)', '{']","['KEYWORD', 'IDENTIFIER', 'ASSIGNMENT_OPERATOR', 'FUNCTION_CALL', 'PUNCTUATION']"
6,    if err != nil {,"['if', 'err', '!=', 'nil', '{']","['KEYWORD', 'IDENTIFIER', 'RELATION_OPERATOR', 'IDENTIFIER', 'PUNCTUATION']"
7,"        log.Println(""json.Compact:"", err)","['log.Println(""json.Compact:"", err)']",['FUNCTION_CALL']
8,"        if serr, ok := err.(*json.SyntaxError); ok {","['if', 'serr', ',', 'ok', ':=', 'err', '.(*', 'json', '.', 'SyntaxError', ');', 'ok', '{']","['KEYWORD', 'IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'ASSIGNMENT_OPERATOR', 'IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'PUNCTUATION']"
9,"            log.Println(""Occurred at offset:"", serr.Offset)","['log.Println(""Occurred at offset:"", serr.Offset)']",['FUNCTION_CALL']
10,            // … something to show the data in buff around that offset …,"['//', '…', 'something', 'to', 'show', 'the', 'data', 'in', 'buff', 'around', 'that', 'offset', '…']","['COMMENT', 'RB', 'NN', 'TO', 'VB', 'DT', 'NNS', 'IN', 'NN', 'IN', 'DT', 'NN', 'NN']"
11,        },['}'],['PUNCTUATION']
12,    },['}'],['PUNCTUATION']
13,},['}'],['PUNCTUATION']
14,"

But offset zero isn't helpful :(

So although this doesn't identify you problem hopefully
it can be of some help to your further investigation.

Edit:

So after adding:

","['But', 'offset', 'zero', ""isn't"", 'helpful', ':(', 'So', 'although', 'this', ""doesn't"", 'identify', 'you', 'problem', 'hopefully', 'it', 'can', 'be', 'of', 'some', 'help', 'to', 'your', 'further', 'investigation.', 'Edit:', 'So', 'after', 'adding:']","['CC', 'PRP', 'VBP', 'JJ', 'JJ', 'NNS', 'RB', 'IN', 'DT', 'NN', 'VB', 'PRP', 'NN', 'RB', 'PRP', 'MD', 'VB', 'IN', 'DT', 'NN', 'TO', 'PRP$', 'JJ', 'NN', 'NNP', 'NNP', 'IN', 'NN']"
15,"log.Println(""Write file:"", ioutil.WriteFile(""data.json"", buff.Bytes(), 0600))","['log.Println(""Write file:"", ioutil.WriteFile(""data.json"", buff.Bytes(), 0600))']",['FUNCTION_CALL']
16,"

to the above error handling block I then ran a JSON validator on the resultant file and it identified this piece:

","['to', 'the', 'above', 'error', 'handling', 'block', 'I', 'then', 'ran', 'a', 'JSON', 'validator', 'on', 'the', 'resultant', 'file', 'and', 'it', 'identified', 'this', 'piece:']","['TO', 'DT', 'JJ', 'NN', 'VBG', 'NN', 'PRP', 'RB', 'VBD', 'DT', 'NNP', 'NN', 'IN', 'DT', 'NN', 'NN', 'CC', 'PRP', 'VBD', 'DT', 'NN']"
17,"        ""XTestImports"": [","['""XTestImports""', ':', '[']","['STRING_LITERAL', 'PUNCTUATION', 'PUNCTUATION']"
18,"                ""io"",","['""io""', ',']","['STRING_LITERAL', 'PUNCTUATION']"
19,"                ""log"",","['""log""', ',']","['STRING_LITERAL', 'PUNCTUATION']"
20,"                ""net""","['""net""']",['STRING_LITERAL']
21,        ],[']'],['PUNCTUATION']
22,"},,{","['},,{']",['PUNCTUATION']
23,"        ""Dir"": ""/usr/local/go/src/mime"",","['""Dir""', ':', '""/usr/local/go/src/mime""', ',']","['STRING_LITERAL', 'PUNCTUATION', 'STRING_LITERAL', 'PUNCTUATION']"
24,"        ""ImportPath"": ""mime"",","['""ImportPath""', ':', '""mime""', ',']","['STRING_LITERAL', 'PUNCTUATION', 'STRING_LITERAL', 'PUNCTUATION']"
25,"        ""Name"": ""mime"",","['""Name""', ':', '""mime""', ',']","['STRING_LITERAL', 'PUNCTUATION', 'STRING_LITERAL', 'PUNCTUATION']"
26,"

Note the double ,,.

That should tell you whete the error in your code is.
But if not, you need to skip empty entries, either when processing t.J or when you build it. The later is better and just involves:

","['Note', 'the', 'double', ',,.', 'That', 'should', 'tell', 'you', 'whete', 'the', 'error', 'in', 'your', 'code', 'is.', 'But', 'if', 'not,', 'you', 'need', 'to', 'skip', 'empty', 'entries,', 'either', 'when', 'processing', 't.J', 'or', 'when', 'you', 'build', 'it.', 'The', 'later', 'is', 'better', 'and', 'just', 'involves:']","['VB', 'DT', 'JJ', 'NN', 'WDT', 'MD', 'VB', 'PRP', 'VBP', 'DT', 'NN', 'IN', 'PRP$', 'NN', 'NN', 'CC', 'IN', 'JJ', 'PRP', 'VBP', 'TO', 'VB', 'JJ', 'NN', 'CC', 'WRB', 'VBG', 'NN', 'CC', 'WRB', 'PRP', 'VBP', 'VB', 'DT', 'NN', 'VBZ', 'RBR', 'CC', 'RB', 'VB']"
27,    if len(newj) > 0 {,"['if', 'len', '(', 'newj', ')', '>', '0', '{']","['KEYWORD', 'IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'PUNCTUATION', 'RELATION_OPERATOR', 'OCTAL_LITERAL', 'PUNCTUATION']"
28,"        myObj.J = append(myObj.J, newj)","['myObj', '.', 'J', '=', 'append', '(', 'myObj', '.', 'J', ',', 'newj', ')']","['IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'ASSIGNMENT_OPERATOR', 'IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'PUNCTUATION']"
29,    },['}'],['PUNCTUATION']
30,"

(where btw you don't check for errors from json.Unmarshal so it's not clear if that is supposed to ever be empty or if it's empty due to a preceeding error. Never ignore error returns!)
","['(where', 'btw', 'you', ""don't"", 'check', 'for', 'errors', 'from', 'json.Unmarshal', 'so', ""it's"", 'not', 'clear', 'if', 'that', 'is', 'supposed', 'to', 'ever', 'be', 'empty', 'or', 'if', ""it's"", 'empty', 'due', 'to', 'a', 'preceeding', 'error.', 'Never', 'ignore', 'error', 'returns!)']","['RB', 'NN', 'PRP', 'VBP', 'VB', 'IN', 'NNS', 'IN', 'NN', 'RB', 'JJ', 'RB', 'JJ', 'IN', 'DT', 'VBZ', 'VBN', 'TO', 'RB', 'VB', 'JJ', 'CC', 'IN', 'JJ', 'JJ', 'JJ', 'TO', 'DT', 'NN', 'NN', 'NNP', 'VBP', 'NN', 'NN']"
