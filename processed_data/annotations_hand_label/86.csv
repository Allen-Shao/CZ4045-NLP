,text,token,annotation
0,"A reminder that security is unusually treacherous territory, and if there's a way to call on other well-tested code even more of your toplevel task than just what Go's OpenPGP package is handling for you, consider it. It's good that at least low-level details are outsourced to openpgp because they're nasty and so so easy to get wrong. But tiny mistakes at any level can make crypto features worse than useless; if there's a way to write less security-critical code, that's one of the best things anyone can do for security.

On the specific question: you have to Close() the writer to get everything flushed out (a trait OpenPGP's writer shares with, say, compress/gzip's). 

Unrelated changes: the way you're printing things is a better fit log.Println, which just lets you pass a bunch of values you want printed with spaces in between (like, say, Python print), rather than needing format specifiers like ""%s"" or ""%d"". (The ""EXTRA"" in your initial output is what Go's Printf emits when you pass more things than you had format specifiers for.) It's also best practice to check errors (I dropped if err != nils where I saw a need, but inelegantly and without much thought, and I may not have gotten all the calls) and to run go fmt on your code. 

Again, I can't testify to the seaworthiness of this code or anything like that. But now it round-trips all the text. I wound up with:

","['A', 'reminder', 'that', 'security', 'is', 'unusually', 'treacherous', 'territory,', 'and', 'if', ""there's"", 'a', 'way', 'to', 'call', 'on', 'other', 'well-tested', 'code', 'even', 'more', 'of', 'your', 'toplevel', 'task', 'than', 'just', 'what', ""Go's"", 'OpenPGP', 'package', 'is', 'handling', 'for', 'you,', 'consider', 'it.', ""It's"", 'good', 'that', 'at', 'least', 'low-level', 'details', 'are', 'outsourced', 'to', 'openpgp', 'because', ""they're"", 'nasty', 'and', 'so', 'so', 'easy', 'to', 'get', 'wrong.', 'But', 'tiny', 'mistakes', 'at', 'any', 'level', 'can', 'make', 'crypto', 'features', 'worse', 'than', 'useless;', 'if', ""there's"", 'a', 'way', 'to', 'write', 'less', 'security-critical', 'code,', ""that's"", 'one', 'of', 'the', 'best', 'things', 'anyone', 'can', 'do', 'for', 'security.', 'On', 'the', 'specific', 'question:', 'you', 'have', 'to', 'Close()', 'the', 'writer', 'to', 'get', 'everything', 'flushed', 'out', '(a', 'trait', ""OpenPGP's"", 'writer', 'shares', 'with,', 'say,', ""compress/gzip's)."", 'Unrelated', 'changes:', 'the', 'way', ""you're"", 'printing', 'things', 'is', 'a', 'better', 'fit', 'log.Println,', 'which', 'just', 'lets', 'you', 'pass', 'a', 'bunch', 'of', 'values', 'you', 'want', 'printed', 'with', 'spaces', 'in', 'between', '(like,', 'say,', 'Python', 'print),', 'rather', 'than', 'needing', 'format', 'specifiers', 'like', '""%s""', 'or', '""%d"".', '(The', '""EXTRA""', 'in', 'your', 'initial', 'output', 'is', 'what', ""Go's"", 'Printf', 'emits', 'when', 'you', 'pass', 'more', 'things', 'than', 'you', 'had', 'format', 'specifiers', 'for.)', ""It's"", 'also', 'best', 'practice', 'to', 'check', 'errors', '(I', 'dropped', 'if', 'err', '!=', 'nils', 'where', 'I', 'saw', 'a', 'need,', 'but', 'inelegantly', 'and', 'without', 'much', 'thought,', 'and', 'I', 'may', 'not', 'have', 'gotten', 'all', 'the', 'calls)', 'and', 'to', 'run', 'go', 'fmt', 'on', 'your', 'code.', 'Again,', 'I', ""can't"", 'testify', 'to', 'the', 'seaworthiness', 'of', 'this', 'code', 'or', 'anything', 'like', 'that.', 'But', 'now', 'it', 'round-trips', 'all', 'the', 'text.', 'I', 'wound', 'up', 'with:']","['DT', 'NN', 'IN', 'NN', 'VBZ', 'RB', 'JJ', 'NN', 'CC', 'IN', 'VBN', 'DT', 'NN', 'TO', 'VB', 'IN', 'JJ', 'JJ', 'NN', 'RB', 'JJR', 'IN', 'PRP$', 'NN', 'NN', 'IN', 'RB', 'WP', 'NNP', 'NNP', 'NN', 'VBZ', 'VBG', 'IN', 'NN', 'NN', 'NN', 'NNP', 'VBD', 'DT', 'IN', 'JJS', 'JJ', 'NNS', 'VBP', 'VBN', 'TO', 'VB', 'IN', 'NN', 'JJ', 'CC', 'RB', 'RB', 'JJ', 'TO', 'VB', 'JJ', 'CC', 'JJ', 'NNS', 'IN', 'DT', 'NN', 'MD', 'VB', 'NN', 'NNS', 'JJR', 'IN', 'JJ', 'IN', 'EX', 'DT', 'NN', 'TO', 'VB', 'JJR', 'JJ', 'NN', 'IN', 'CD', 'IN', 'DT', 'JJS', 'NNS', 'NN', 'MD', 'VB', 'IN', 'NN', 'IN', 'DT', 'JJ', 'NN', 'PRP', 'VBP', 'TO', 'VB', 'DT', 'NN', 'TO', 'VB', 'NN', 'VBN', 'RP', 'JJ', 'NN', 'NNP', 'NN', 'NNS', 'VBP', 'JJ', 'NN', 'NNP', 'VBD', 'DT', 'NN', 'IN', 'VBG', 'NNS', 'VBZ', 'DT', 'JJR', 'NN', 'NN', 'WDT', 'RB', 'VBZ', 'PRP', 'VB', 'DT', 'NN', 'IN', 'NNS', 'PRP', 'VBP', 'VBN', 'IN', 'NNS', 'IN', 'IN', 'NNP', 'VBD', 'NNP', 'NN', 'RB', 'IN', 'VBG', 'JJ', 'NNS', 'IN', 'NN', 'CC', 'VB', 'JJ', 'NN', 'IN', 'PRP$', 'JJ', 'NN', 'VBZ', 'WP', 'NNP', 'NNP', 'VBZ', 'WRB', 'PRP', 'VBP', 'JJR', 'NNS', 'IN', 'PRP', 'VBD', 'VBN', 'NNS', 'VBP', 'NNP', 'RB', 'RB', 'NN', 'TO', 'VB', 'NNS', 'NNP', 'VBD', 'IN', 'JJ', 'NN', 'NNS', 'WRB', 'PRP', 'VBD', 'DT', 'NN', 'CC', 'RB', 'CC', 'IN', 'JJ', 'NN', 'CC', 'PRP', 'MD', 'RB', 'VB', 'VBN', 'PDT', 'DT', 'NN', 'CC', 'TO', 'VB', 'VB', 'RB', 'IN', 'PRP$', 'NN', 'NNP', 'PRP', 'VBP', 'VB', 'TO', 'DT', 'NN', 'IN', 'DT', 'NN', 'CC', 'NN', 'IN', 'NNS', 'CC', 'RB', 'PRP', 'VBZ', 'PDT', 'DT', 'NN', 'PRP', 'VBD', 'RP', 'NN']"
1,package main,"['package', 'main']","['KEYWORD', 'IDENTIFIER']"
2,import (,"['import', '(']","['KEYWORD', 'PUNCTUATION']"
3,"    ""bytes""","['""bytes""']",['STRING_LITERAL']
4,"    ""code.google.com/p/go.crypto/openpgp""","['""code.google.com/p/go.crypto/openpgp""']",['STRING_LITERAL']
5,"    ""encoding/base64""","['""encoding/base64""']",['STRING_LITERAL']
6,"    ""io/ioutil""","['""io/ioutil""']",['STRING_LITERAL']
7,"    ""log""","['""log""']",['STRING_LITERAL']
8,"    ""os""","['""os""']",['STRING_LITERAL']
9,),[')'],['PUNCTUATION']
10,// create gpg keys with,"['//', 'create', 'gpg', 'keys', 'with']","['COMMENT', 'NN', 'NNS', 'NNS', 'IN']"
11,// $ gpg --gen-key,"['//', '$', 'gpg', '--gen-key']","['COMMENT', '$', 'CD', 'NN']"
12,// ensure you correct paths and passphrase,"['//', 'ensure', 'you', 'correct', 'paths', 'and', 'passphrase']","['COMMENT', 'VB', 'PRP', 'JJ', 'NNS', 'CC', 'NN']"
13,"const mysecretstring = ""this is so very secret!""","['const', 'mysecretstring', '=', '""this is so very secret!""']","['KEYWORD', 'IDENTIFIER', 'ASSIGNMENT_OPERATOR', 'STRING_LITERAL']"
14,"const prefix, passphrase = ""/Users/stuart-warren/"", ""1234""","['const', 'prefix', ',', 'passphrase', '=', '""/Users/stuart-warren/""', ',', '""1234""']","['KEYWORD', 'IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'ASSIGNMENT_OPERATOR', 'STRING_LITERAL', 'PUNCTUATION', 'STRING_LITERAL']"
15,"const secretKeyring = prefix + "".gnupg/secring.gpg""","['const', 'secretKeyring', '=', 'prefix', '+', '"".gnupg/secring.gpg""']","['KEYWORD', 'IDENTIFIER', 'ASSIGNMENT_OPERATOR', 'IDENTIFIER', 'ARITHMETIC_OPERATOR', 'STRING_LITERAL']"
16,"const publicKeyring = prefix + "".gnupg/pubring.gpg""","['const', 'publicKeyring', '=', 'prefix', '+', '"".gnupg/pubring.gpg""']","['KEYWORD', 'IDENTIFIER', 'ASSIGNMENT_OPERATOR', 'IDENTIFIER', 'ARITHMETIC_OPERATOR', 'STRING_LITERAL']"
17,func encTest() error {,"['func', 'encTest', '()', 'error', '{']","['KEYWORD', 'IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'PUNCTUATION']"
18,"    log.Println(""Secret:"", mysecretstring)","['log.Println(""Secret:"", mysecretstring)']",['FUNCTION_CALL']
19,"    log.Println(""Secret Keyring:"", secretKeyring)","['log.Println(""Secret Keyring:"", secretKeyring)']",['FUNCTION_CALL']
20,"    log.Println(""Public Keyring:"", publicKeyring)","['log.Println(""Public Keyring:"", publicKeyring)']",['FUNCTION_CALL']
21,"    log.Println(""Passphrase:"", passphrase)","['log.Println(""Passphrase:"", passphrase)']",['FUNCTION_CALL']
22,    // Read in public key,"['//', 'Read', 'in', 'public', 'key']","['COMMENT', 'VBN', 'IN', 'JJ', 'NN']"
23,"    keyringFileBuffer, _ := os.Open(publicKeyring)","['keyringFileBuffer', ',', '_', ':=', 'os.Open(publicKeyring)']","['IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'ASSIGNMENT_OPERATOR', 'FUNCTION_CALL']"
24,    defer keyringFileBuffer.Close(),"['defer', 'keyringFileBuffer.Close()']","['IDENTIFIER', 'FUNCTION_CALL']"
25,"    entitylist, err := openpgp.ReadKeyRing(keyringFileBuffer)","['entitylist', ',', 'err', ':=', 'openpgp.ReadKeyRing(keyringFileBuffer)']","['IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'ASSIGNMENT_OPERATOR', 'FUNCTION_CALL']"
26,    if err != nil {,"['if', 'err', '!=', 'nil', '{']","['KEYWORD', 'IDENTIFIER', 'RELATION_OPERATOR', 'IDENTIFIER', 'PUNCTUATION']"
27,        return err,"['return', 'err']","['KEYWORD', 'IDENTIFIER']"
28,    },['}'],['PUNCTUATION']
29,    // encrypt string,"['//', 'encrypt', 'string']","['COMMENT', 'NN', 'NN']"
30,    buf := new(bytes.Buffer),"['buf', ':=', 'new', '(', 'bytes', '.', 'Buffer', ')']","['IDENTIFIER', 'ASSIGNMENT_OPERATOR', 'IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'PUNCTUATION']"
31,"    w, err := openpgp.Encrypt(buf, entitylist, nil, nil, nil)","['w', ',', 'err', ':=', 'openpgp.Encrypt(buf, entitylist, nil, nil, nil)']","['IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'ASSIGNMENT_OPERATOR', 'FUNCTION_CALL']"
32,    if err != nil {,"['if', 'err', '!=', 'nil', '{']","['KEYWORD', 'IDENTIFIER', 'RELATION_OPERATOR', 'IDENTIFIER', 'PUNCTUATION']"
33,        return err,"['return', 'err']","['KEYWORD', 'IDENTIFIER']"
34,    },['}'],['PUNCTUATION']
35,"    _, err = w.Write([]byte(mysecretstring))","['_', ',', 'err', '=', 'w.Write([]byte(mysecretstring))']","['IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'ASSIGNMENT_OPERATOR', 'FUNCTION_CALL']"
36,    if err != nil {,"['if', 'err', '!=', 'nil', '{']","['KEYWORD', 'IDENTIFIER', 'RELATION_OPERATOR', 'IDENTIFIER', 'PUNCTUATION']"
37,        return err,"['return', 'err']","['KEYWORD', 'IDENTIFIER']"
38,    },['}'],['PUNCTUATION']
39,    err = w.Close(),"['err', '=', 'w.Close()']","['IDENTIFIER', 'ASSIGNMENT_OPERATOR', 'FUNCTION_CALL']"
40,    if err != nil {,"['if', 'err', '!=', 'nil', '{']","['KEYWORD', 'IDENTIFIER', 'RELATION_OPERATOR', 'IDENTIFIER', 'PUNCTUATION']"
41,        return err,"['return', 'err']","['KEYWORD', 'IDENTIFIER']"
42,    },['}'],['PUNCTUATION']
43,    // Encode to base64,"['//', 'Encode', 'to', 'base64']","['COMMENT', 'NN', 'TO', 'VB']"
44,"    bytesp, err := ioutil.ReadAll(buf)","['bytesp', ',', 'err', ':=', 'ioutil.ReadAll(buf)']","['IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'ASSIGNMENT_OPERATOR', 'FUNCTION_CALL']"
45,    if err != nil {,"['if', 'err', '!=', 'nil', '{']","['KEYWORD', 'IDENTIFIER', 'RELATION_OPERATOR', 'IDENTIFIER', 'PUNCTUATION']"
46,        return err,"['return', 'err']","['KEYWORD', 'IDENTIFIER']"
47,    },['}'],['PUNCTUATION']
48,    encstr := base64.StdEncoding.EncodeToString(bytesp),"['encstr', ':=', 'base64', '.', 'StdEncoding.EncodeToString(bytesp)']","['IDENTIFIER', 'ASSIGNMENT_OPERATOR', 'IDENTIFIER', 'PUNCTUATION', 'FUNCTION_CALL']"
49,    // Output encrypted/encoded string,"['//', 'Output', 'encrypted/encoded', 'string']","['COMMENT', 'NNP', 'VBD', 'NN']"
50,"    log.Println(""Encrypted Secret:"", encstr)","['log.Println(""Encrypted Secret:"", encstr)']",['FUNCTION_CALL']
51,    // Here is where I would transfer the encrypted string to someone else,"['//', 'Here', 'is', 'where', 'I', 'would', 'transfer', 'the', 'encrypted', 'string', 'to', 'someone', 'else']","['COMMENT', 'RB', 'VBZ', 'WRB', 'PRP', 'MD', 'VB', 'DT', 'JJ', 'NN', 'TO', 'NN', 'RB']"
52,    // but we'll just decrypt it in the same code,"['//', 'but', ""we'll"", 'just', 'decrypt', 'it', 'in', 'the', 'same', 'code']","['COMMENT', 'CC', 'NN', 'RB', 'VB', 'PRP', 'IN', 'DT', 'JJ', 'NN']"
53,    // init some vars,"['//', 'init', 'some', 'vars']","['COMMENT', 'VB', 'DT', 'NNS']"
54,    var entity2 *openpgp.Entity,"['var', 'entity2', '*', 'openpgp', '.', 'Entity']","['KEYWORD', 'IDENTIFIER', 'ARITHMETIC_OPERATOR', 'IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER']"
55,    var entitylist2 openpgp.EntityList,"['var', 'entitylist2', 'openpgp', '.', 'EntityList']","['KEYWORD', 'IDENTIFIER', 'IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER']"
56,    // Open the private key file,"['//', 'Open', 'the', 'private', 'key', 'file']","['COMMENT', 'VB', 'DT', 'JJ', 'NN', 'NN']"
57,"    keyringFileBuffer2, err := os.Open(secretKeyring)","['keyringFileBuffer2', ',', 'err', ':=', 'os.Open(secretKeyring)']","['IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'ASSIGNMENT_OPERATOR', 'FUNCTION_CALL']"
58,    if err != nil {,"['if', 'err', '!=', 'nil', '{']","['KEYWORD', 'IDENTIFIER', 'RELATION_OPERATOR', 'IDENTIFIER', 'PUNCTUATION']"
59,        return err,"['return', 'err']","['KEYWORD', 'IDENTIFIER']"
60,    },['}'],['PUNCTUATION']
61,    defer keyringFileBuffer2.Close(),"['defer', 'keyringFileBuffer2.Close()']","['IDENTIFIER', 'FUNCTION_CALL']"
62,"    entitylist2, err = openpgp.ReadKeyRing(keyringFileBuffer2)","['entitylist2', ',', 'err', '=', 'openpgp.ReadKeyRing(keyringFileBuffer2)']","['IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'ASSIGNMENT_OPERATOR', 'FUNCTION_CALL']"
63,    if err != nil {,"['if', 'err', '!=', 'nil', '{']","['KEYWORD', 'IDENTIFIER', 'RELATION_OPERATOR', 'IDENTIFIER', 'PUNCTUATION']"
64,        return err,"['return', 'err']","['KEYWORD', 'IDENTIFIER']"
65,    },['}'],['PUNCTUATION']
66,    entity2 = entitylist2[0],"['entity2', '=', 'entitylist2', '[', '0', ']']","['IDENTIFIER', 'ASSIGNMENT_OPERATOR', 'IDENTIFIER', 'PUNCTUATION', 'OCTAL_LITERAL', 'PUNCTUATION']"
67,    // Get the passphrase and read the private key.,"['//', 'Get', 'the', 'passphrase', 'and', 'read', 'the', 'private', 'key.']","['COMMENT', 'VB', 'DT', 'NN', 'CC', 'VB', 'DT', 'JJ', 'NN']"
68,    // Have not touched the encrypted string yet,"['//', 'Have', 'not', 'touched', 'the', 'encrypted', 'string', 'yet']","['COMMENT', 'NNP', 'RB', 'VBD', 'DT', 'JJ', 'NN', 'RB']"
69,    passphrasebyte := []byte(passphrase),"['passphrasebyte', ':=', '[]', 'byte', '(', 'passphrase', ')']","['IDENTIFIER', 'ASSIGNMENT_OPERATOR', 'PUNCTUATION', 'IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'PUNCTUATION']"
70,"    log.Println(""Decrypting private key using passphrase"")","['log.Println(""Decrypting private key using passphrase"")']",['FUNCTION_CALL']
71,    entity2.PrivateKey.Decrypt(passphrasebyte),"['entity2', '.', 'PrivateKey.Decrypt(passphrasebyte)']","['IDENTIFIER', 'PUNCTUATION', 'FUNCTION_CALL']"
72,"    for _, subkey := range entity2.Subkeys {","['for', '_', ',', 'subkey', ':=', 'range', 'entity2', '.', 'Subkeys', '{']","['KEYWORD', 'IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'ASSIGNMENT_OPERATOR', 'KEYWORD', 'IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'PUNCTUATION']"
73,        subkey.PrivateKey.Decrypt(passphrasebyte),"['subkey', '.', 'PrivateKey.Decrypt(passphrasebyte)']","['IDENTIFIER', 'PUNCTUATION', 'FUNCTION_CALL']"
74,    },['}'],['PUNCTUATION']
75,"    log.Println(""Finished decrypting private key using passphrase"")","['log.Println(""Finished decrypting private key using passphrase"")']",['FUNCTION_CALL']
76,    // Decode the base64 string,"['//', 'Decode', 'the', 'base64', 'string']","['COMMENT', 'NNP', 'DT', 'NN', 'NN']"
77,"    dec, err := base64.StdEncoding.DecodeString(encstr)","['dec', ',', 'err', ':=', 'base64', '.', 'StdEncoding.DecodeString(encstr)']","['IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'ASSIGNMENT_OPERATOR', 'IDENTIFIER', 'PUNCTUATION', 'FUNCTION_CALL']"
78,    if err != nil {,"['if', 'err', '!=', 'nil', '{']","['KEYWORD', 'IDENTIFIER', 'RELATION_OPERATOR', 'IDENTIFIER', 'PUNCTUATION']"
79,        return err,"['return', 'err']","['KEYWORD', 'IDENTIFIER']"
80,    },['}'],['PUNCTUATION']
81,    // Decrypt it with the contents of the private key,"['//', 'Decrypt', 'it', 'with', 'the', 'contents', 'of', 'the', 'private', 'key']","['COMMENT', 'VB', 'PRP', 'IN', 'DT', 'NNS', 'IN', 'DT', 'JJ', 'NN']"
82,"    md, err := openpgp.ReadMessage(bytes.NewBuffer(dec), entitylist2, nil, nil)","['md', ',', 'err', ':=', 'openpgp.ReadMessage(bytes.NewBuffer(dec), entitylist2, nil, nil)']","['IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'ASSIGNMENT_OPERATOR', 'FUNCTION_CALL']"
83,    if err != nil {,"['if', 'err', '!=', 'nil', '{']","['KEYWORD', 'IDENTIFIER', 'RELATION_OPERATOR', 'IDENTIFIER', 'PUNCTUATION']"
84,        return err,"['return', 'err']","['KEYWORD', 'IDENTIFIER']"
85,    },['}'],['PUNCTUATION']
86,"    bytess, err := ioutil.ReadAll(md.UnverifiedBody)","['bytess', ',', 'err', ':=', 'ioutil.ReadAll(md.UnverifiedBody)']","['IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'ASSIGNMENT_OPERATOR', 'FUNCTION_CALL']"
87,    if err != nil {,"['if', 'err', '!=', 'nil', '{']","['KEYWORD', 'IDENTIFIER', 'RELATION_OPERATOR', 'IDENTIFIER', 'PUNCTUATION']"
88,        return err,"['return', 'err']","['KEYWORD', 'IDENTIFIER']"
89,    },['}'],['PUNCTUATION']
90,    decstr := string(bytess),"['decstr', ':=', 'string', '(', 'bytess', ')']","['IDENTIFIER', 'ASSIGNMENT_OPERATOR', 'IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'PUNCTUATION']"
91,    // should be done,"['//', 'should', 'be', 'done']","['COMMENT', 'MD', 'VB', 'VBN']"
92,"    log.Println(""Decrypted Secret:"", decstr)","['log.Println(""Decrypted Secret:"", decstr)']",['FUNCTION_CALL']
93,    return nil,"['return', 'nil']","['KEYWORD', 'IDENTIFIER']"
94,},['}'],['PUNCTUATION']
95,func main() {,"['func', 'main', '()', '{']","['KEYWORD', 'IDENTIFIER', 'PUNCTUATION', 'PUNCTUATION']"
96,    err := encTest(),"['err', ':=', 'encTest', '()']","['IDENTIFIER', 'ASSIGNMENT_OPERATOR', 'IDENTIFIER', 'PUNCTUATION']"
97,    if err != nil {,"['if', 'err', '!=', 'nil', '{']","['KEYWORD', 'IDENTIFIER', 'RELATION_OPERATOR', 'IDENTIFIER', 'PUNCTUATION']"
98,        log.Fatal(err),['log.Fatal(err)'],['FUNCTION_CALL']
99,    },['}'],['PUNCTUATION']
100,},['}'],['PUNCTUATION']
