,text,token,annotation
0,"It turned out that I had to restart the listener not only to close the connection. I've modified the broker function to reset the destNet listener if it can't write (i.e. writes 0 bytes) to src. I'm still not sure if this is the right way to do it (i.e. closing the listener seems bad in a multi-connections scenario as I guess I reset all the client connections dialing on that address) but so far this is the best I could do to fix it.

","['It', 'turned', 'out', 'that', 'I', 'had', 'to', 'restart', 'the', 'listener', 'not', 'only', 'to', 'close', 'the', 'connection.', ""I've"", 'modified', 'the', 'broker', 'function', 'to', 'reset', 'the', 'destNet', 'listener', 'if', 'it', ""can't"", 'write', '(i.e.', 'writes', '0', 'bytes)', 'to', 'src.', ""I'm"", 'still', 'not', 'sure', 'if', 'this', 'is', 'the', 'right', 'way', 'to', 'do', 'it', '(i.e.', 'closing', 'the', 'listener', 'seems', 'bad', 'in', 'a', 'multi-connections', 'scenario', 'as', 'I', 'guess', 'I', 'reset', 'all', 'the', 'client', 'connections', 'dialing', 'on', 'that', 'address)', 'but', 'so', 'far', 'this', 'is', 'the', 'best', 'I', 'could', 'do', 'to', 'fix', 'it.']","['PRP', 'VBD', 'RP', 'IN', 'PRP', 'VBD', 'TO', 'VB', 'DT', 'NN', 'RB', 'RB', 'TO', 'VB', 'DT', 'NN', 'NNP', 'VBD', 'DT', 'NN', 'NN', 'TO', 'VB', 'DT', 'NN', 'NN', 'IN', 'PRP', 'VBZ', 'JJ', 'NN', 'VBZ', 'CD', 'NN', 'TO', 'VB', 'NNP', 'RB', 'RB', 'JJ', 'IN', 'DT', 'VBZ', 'DT', 'JJ', 'NN', 'TO', 'VB', 'PRP', 'VB', 'VBG', 'DT', 'NN', 'VBZ', 'JJ', 'IN', 'DT', 'NNS', 'NN', 'IN', 'PRP', 'VBP', 'PRP', 'VBP', 'PDT', 'DT', 'NN', 'NNS', 'VBG', 'IN', 'DT', 'NN', 'CC', 'RB', 'RB', 'DT', 'VBZ', 'DT', 'JJS', 'PRP', 'MD', 'VB', 'TO', 'VB', 'NN']"
1, if n == 0 {,"['if', 'n', '==', '0', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'OCTAL_LITERAL', 'OPERATOR']"
2,        lrNewCh <- 1,"['lrNewCh', '<-', '1']","['IDENTIFIER', 'OPERATOR', 'DECIMAL_LITERAL']"
3,    },['}'],['OPERATOR']
4,"

Here is all the code. All the credit goes to @JimB

","['Here', 'is', 'all', 'the', 'code.', 'All', 'the', 'credit', 'goes', 'to', '@JimB']","['RB', 'VBZ', 'PDT', 'DT', 'NN', 'PDT', 'DT', 'NN', 'VBZ', 'TO', 'VB']"
5,// Make a bridge between dstNet which is,"['//', 'Make', 'a', 'bridge', 'between', 'dstNet', 'which', 'is']","['COMMENT', 'VB', 'DT', 'NN', 'IN', 'NN', 'WDT', 'VBZ']"
6,// usually behind NAT and srcNet which is usually a client,"['//', 'usually', 'behind', 'NAT', 'and', 'srcNet', 'which', 'is', 'usually', 'a', 'client']","['COMMENT', 'RB', 'IN', 'NNP', 'CC', 'NN', 'WDT', 'VBZ', 'RB', 'DT', 'NN']"
7,// which wants to route the traffic though the NAT machine.,"['//', 'which', 'wants', 'to', 'route', 'the', 'traffic', 'though', 'the', 'NAT', 'machine.']","['COMMENT', 'WDT', 'VBZ', 'TO', 'VB', 'DT', 'NN', 'IN', 'DT', 'NNP', 'NN']"
8,package main,"['package', 'main']","['KEYWORD', 'IDENTIFIER']"
9,import (,"['import', '(']","['KEYWORD', 'OPERATOR']"
10,"    log ""github.com/golang/glog""","['log', '""github.com/golang/glog""']","['IDENTIFIER', 'STRING_LITERAL']"
11,"    ""io""","['""io""']",['STRING_LITERAL']
12,"    ""net""","['""net""']",['STRING_LITERAL']
13,),[')'],['OPERATOR']
14,// listen on the dstNet so that we can,"['//', 'listen', 'on', 'the', 'dstNet', 'so', 'that', 'we', 'can']","['COMMENT', 'VBN', 'IN', 'DT', 'NN', 'RB', 'IN', 'PRP', 'MD']"
15,// create a connection with the NAT client,"['//', 'create', 'a', 'connection', 'with', 'the', 'NAT', 'client']","['COMMENT', 'VB', 'DT', 'NN', 'IN', 'DT', 'NNP', 'NN']"
16,"var dstNet *net.TCPAddr = &net.TCPAddr{IP: net.ParseIP(""0.0.0.0""), Port: 9000}","['var', 'dstNet', '*', 'net', '.', 'TCPAddr', '=', '&', 'net', '.', 'TCPAddr', '{', 'IP', ':', 'net.ParseIP(""0.0.0.0"")', ',', 'Port', ':', '9000', '}']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'FUNCTION_CALL', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'DECIMAL_LITERAL', 'OPERATOR']"
17,// listen on srcNet so that we can get traffic,"['//', 'listen', 'on', 'srcNet', 'so', 'that', 'we', 'can', 'get', 'traffic']","['COMMENT', 'VBN', 'IN', 'NN', 'RB', 'IN', 'PRP', 'MD', 'VB', 'NN']"
18,// to forward to dstNet,"['//', 'to', 'forward', 'to', 'dstNet']","['COMMENT', 'TO', 'VB', 'TO', 'VB']"
19,"var srcNet *net.TCPAddr = &net.TCPAddr{IP: net.ParseIP(""0.0.0.0""), Port: 9001}","['var', 'srcNet', '*', 'net', '.', 'TCPAddr', '=', '&', 'net', '.', 'TCPAddr', '{', 'IP', ':', 'net.ParseIP(""0.0.0.0"")', ',', 'Port', ':', '9001', '}']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'FUNCTION_CALL', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'DECIMAL_LITERAL', 'OPERATOR']"
20,"var errCh = make(chan error, 1)","['var', 'errCh', '=', 'make', '(', 'chan', 'error', ',', '1', ')']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'KEYWORD', 'IDENTIFIER', 'OPERATOR', 'DECIMAL_LITERAL', 'OPERATOR']"
21,// make a channel to send the reverse connections,"['//', 'make', 'a', 'channel', 'to', 'send', 'the', 'reverse', 'connections']","['COMMENT', 'VB', 'DT', 'NN', 'TO', 'VB', 'DT', 'NN', 'NNS']"
22,"var lrCh = make(chan *net.TCPConn, 1)","['var', 'lrCh', '=', 'make', '(', 'chan', '*', 'net', '.', 'TCPConn', ',', '1', ')']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'KEYWORD', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'DECIMAL_LITERAL', 'OPERATOR']"
23,"var lrNewCh = make(chan int, 1)","['var', 'lrNewCh', '=', 'make', '(', 'chan', 'int', ',', '1', ')']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'KEYWORD', 'IDENTIFIER', 'OPERATOR', 'DECIMAL_LITERAL', 'OPERATOR']"
24,func listenDst() {,"['func', 'listenDst', '()', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'OPERATOR']"
25,    // Listen on the dstNet,"['//', 'Listen', 'on', 'the', 'dstNet']","['COMMENT', 'VBN', 'IN', 'DT', 'NN']"
26,"    lr, err := net.ListenTCP(""tcp"", dstNet)","['lr', ',', 'err', ':=', 'net.ListenTCP(""tcp"", dstNet)']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'FUNCTION_CALL']"
27,    if err != nil {,"['if', 'err', '!=', 'nil', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
28,        log.Error(err),['log.Error(err)'],['FUNCTION_CALL']
29,        errCh <- err,"['errCh', '<-', 'err']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER']"
30,        return,['return'],['KEYWORD']
31,    },['}'],['OPERATOR']
32,    // accept the connection,"['//', 'accept', 'the', 'connection']","['COMMENT', 'IN', 'DT', 'NN']"
33,    for {,"['for', '{']","['KEYWORD', 'OPERATOR']"
34,"        lrConn, err := lr.AcceptTCP()","['lrConn', ',', 'err', ':=', 'lr.AcceptTCP()']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'FUNCTION_CALL']"
35,        if err != nil {,"['if', 'err', '!=', 'nil', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
36,                log.Error(err),['log.Error(err)'],['FUNCTION_CALL']
37,                //errCh <- err,"['//', 'errCh', '<-', 'err']","['COMMENT', 'JJ', 'JJ', 'NN']"
38,                //return,"['//', 'return']","['COMMENT', 'NN']"
39,        },['}'],['OPERATOR']
40,        status := <-lrNewCh,"['status', ':=', '<-', 'lrNewCh']","['IDENTIFIER', 'OPERATOR', 'OPERATOR', 'IDENTIFIER']"
41,"            log.Errorf(""status request is %v"", status)","['log.Errorf(""status request is %v"", status)']",['FUNCTION_CALL']
42,            if status == 1{,"['if', 'status', '==', '1', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'DECIMAL_LITERAL', 'OPERATOR']"
43,"                log.Errorf(""we close and restart the listener and the connection"")","['log.Errorf(""we close and restart the listener and the connection"")']",['FUNCTION_CALL']
44,                if err =  lrConn.Close(); err !=nil{,"['if', 'err', '=', 'lrConn.Close()', ';', 'err', '!=', 'nil', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'FUNCTION_CALL', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
45,                    log.Error(err),['log.Error(err)'],['FUNCTION_CALL']
46,                },['}'],['OPERATOR']
47,                if err =  lr.Close(); err !=nil{,"['if', 'err', '=', 'lr.Close()', ';', 'err', '!=', 'nil', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'FUNCTION_CALL', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
48,                    log.Error(err),['log.Error(err)'],['FUNCTION_CALL']
49,                },['}'],['OPERATOR']
50,"                    lr, err = net.ListenTCP(""tcp"", dstNet)","['lr', ',', 'err', '=', 'net.ListenTCP(""tcp"", dstNet)']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'FUNCTION_CALL']"
51,                    if err != nil {,"['if', 'err', '!=', 'nil', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
52,                        log.Error(err),['log.Error(err)'],['FUNCTION_CALL']
53,                        errCh <- err,"['errCh', '<-', 'err']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER']"
54,                        return,['return'],['KEYWORD']
55,                    },['}'],['OPERATOR']
56,"                lrConn, err = lr.AcceptTCP()","['lrConn', ',', 'err', '=', 'lr.AcceptTCP()']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'FUNCTION_CALL']"
57,                if err !=nil{,"['if', 'err', '!=', 'nil', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
58,                    log.Error(err),['log.Error(err)'],['FUNCTION_CALL']
59,                    errCh <- err,"['errCh', '<-', 'err']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER']"
60,                },['}'],['OPERATOR']
61,            }else{,"['}', 'else', '{']","['OPERATOR', 'KEYWORD', 'OPERATOR']"
62,"                log.Errorf(""new connection on its way"")","['log.Errorf(""new connection on its way"")']",['FUNCTION_CALL']
63,                lrCh <- lrConn,"['lrCh', '<-', 'lrConn']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER']"
64,            },['}'],['OPERATOR']
65,    //  default:,"['//', 'default:']","['COMMENT', 'NN']"
66,"            // log.Errorf(""accepting new connections"")","['//', 'log.Errorf(""accepting', 'new', 'connections"")']","['COMMENT', 'VBG', 'JJ', 'NN']"
67,    },['}'],['OPERATOR']
68,},['}'],['OPERATOR']
69,func main() {,"['func', 'main', '()', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'OPERATOR']"
70,    go func() {,"['go', 'func', '()', '{']","['KEYWORD', 'KEYWORD', 'OPERATOR', 'OPERATOR']"
71,        for err := range errCh {,"['for', 'err', ':=', 'range', 'errCh', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'KEYWORD', 'IDENTIFIER', 'OPERATOR']"
72,            if err != nil {,"['if', 'err', '!=', 'nil', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
73,                panic(err),"['panic', '(', 'err', ')']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
74,            },['}'],['OPERATOR']
75,        },['}'],['OPERATOR']
76,    }(),['}()'],['OPERATOR']
77,    // listen for the nat server,"['//', 'listen', 'for', 'the', 'nat', 'server']","['COMMENT', 'NN', 'IN', 'DT', 'NN', 'NN']"
78,    go listenDst(),"['go', 'listenDst', '()']","['KEYWORD', 'IDENTIFIER', 'OPERATOR']"
79,    // listen for clients to connect,"['//', 'listen', 'for', 'clients', 'to', 'connect']","['COMMENT', 'NN', 'IN', 'NNS', 'TO', 'VB']"
80,"    l, err := net.ListenTCP(""tcp"", srcNet)","['l', ',', 'err', ':=', 'net.ListenTCP(""tcp"", srcNet)']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'FUNCTION_CALL']"
81,    if err != nil {,"['if', 'err', '!=', 'nil', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
82,        log.Error(err),['log.Error(err)'],['FUNCTION_CALL']
83,        panic(err),"['panic', '(', 'err', ')']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
84,    },['}'],['OPERATOR']
85,    // accept the connection,"['//', 'accept', 'the', 'connection']","['COMMENT', 'IN', 'DT', 'NN']"
86,    for {,"['for', '{']","['KEYWORD', 'OPERATOR']"
87,"        conn, err := l.AcceptTCP()","['conn', ',', 'err', ':=', 'l.AcceptTCP()']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'FUNCTION_CALL']"
88,        if err != nil {,"['if', 'err', '!=', 'nil', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
89,            log.Error(err),['log.Error(err)'],['FUNCTION_CALL']
90,            panic(err),"['panic', '(', 'err', ')']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
91,        },['}'],['OPERATOR']
92,        // serve the connection,"['//', 'serve', 'the', 'connection']","['COMMENT', 'VB', 'DT', 'NN']"
93,        go func(conn *net.TCPConn) {,"['go', 'func', '(', 'conn', '*', 'net', '.', 'TCPConn', ')', '{']","['KEYWORD', 'KEYWORD', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'OPERATOR']"
94,            defer conn.Close(),"['defer', 'conn.Close()']","['IDENTIFIER', 'FUNCTION_CALL']"
95,            lrNewCh <- 0,"['lrNewCh', '<-', '0']","['IDENTIFIER', 'OPERATOR', 'OCTAL_LITERAL']"
96,            dst := <-lrCh,"['dst', ':=', '<-', 'lrCh']","['IDENTIFIER', 'OPERATOR', 'OPERATOR', 'IDENTIFIER']"
97,            defer dst.Close(),"['defer', 'dst.Close()']","['IDENTIFIER', 'FUNCTION_CALL']"
98,"            proxy(dst, conn)","['proxy', '(', 'dst', ',', 'conn', ')']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
99,        }(conn),"['}(', 'conn', ')']","['OPERATOR', 'IDENTIFIER', 'OPERATOR']"
100,    },['}'],['OPERATOR']
101,},['}'],['OPERATOR']
102,"func proxy(srvConn, cliConn *net.TCPConn) {","['func', 'proxy', '(', 'srvConn', ',', 'cliConn', '*', 'net', '.', 'TCPConn', ')', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'OPERATOR']"
103,    // channels to wait on the close event for each connection,"['//', 'channels', 'to', 'wait', 'on', 'the', 'close', 'event', 'for', 'each', 'connection']","['COMMENT', 'NNS', 'TO', 'VB', 'IN', 'DT', 'JJ', 'NN', 'IN', 'DT', 'NN']"
104,"    serverClosed := make(chan struct{}, 1)","['serverClosed', ':=', 'make', '(', 'chan', 'struct', '{},', '1', ')']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'KEYWORD', 'KEYWORD', 'OPERATOR', 'DECIMAL_LITERAL', 'OPERATOR']"
105,"    clientClosed := make(chan struct{}, 1)","['clientClosed', ':=', 'make', '(', 'chan', 'struct', '{},', '1', ')']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'KEYWORD', 'KEYWORD', 'OPERATOR', 'DECIMAL_LITERAL', 'OPERATOR']"
106,"    go broker(srvConn, cliConn, clientClosed)","['go', 'broker', '(', 'srvConn', ',', 'cliConn', ',', 'clientClosed', ')']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
107,"    go broker(cliConn, srvConn, serverClosed)","['go', 'broker', '(', 'cliConn', ',', 'srvConn', ',', 'serverClosed', ')']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
108,"    // wait for one half of the proxy to exit, then trigger a shutdown of the","['//', 'wait', 'for', 'one', 'half', 'of', 'the', 'proxy', 'to', 'exit,', 'then', 'trigger', 'a', 'shutdown', 'of', 'the']","['COMMENT', 'NN', 'IN', 'CD', 'NN', 'IN', 'DT', 'NN', 'TO', 'VB', 'RB', 'VB', 'DT', 'NN', 'IN', 'DT']"
109,    // other half by calling CloseRead(). This will break the read loop in the,"['//', 'other', 'half', 'by', 'calling', 'CloseRead().', 'This', 'will', 'break', 'the', 'read', 'loop', 'in', 'the']","['COMMENT', 'JJ', 'NN', 'IN', 'VBG', 'NNP', 'DT', 'MD', 'VB', 'DT', 'JJ', 'NN', 'IN', 'DT']"
110,    // broker and allow us to fully close the connection cleanly without a,"['//', 'broker', 'and', 'allow', 'us', 'to', 'fully', 'close', 'the', 'connection', 'cleanly', 'without', 'a']","['COMMENT', 'NN', 'CC', 'VB', 'PRP', 'TO', 'RB', 'VB', 'DT', 'NN', 'RB', 'IN', 'DT']"
111,"    // ""use of closed network connection"" error.","['//', '""use', 'of', 'closed', 'network', 'connection""', 'error.']","['COMMENT', 'NN', 'IN', 'JJ', 'NN', 'NN', 'NN']"
112,    var waitFor chan struct{},"['var', 'waitFor', 'chan', 'struct', '{}']","['KEYWORD', 'IDENTIFIER', 'KEYWORD', 'KEYWORD', 'OPERATOR']"
113,    select {,"['select', '{']","['KEYWORD', 'OPERATOR']"
114,    case <-clientClosed:,"['case', '<-', 'clientClosed', ':']","['KEYWORD', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
115,        // the client closed first and any more packets from the server aren't,"['//', 'the', 'client', 'closed', 'first', 'and', 'any', 'more', 'packets', 'from', 'the', 'server', ""aren't""]","['COMMENT', 'DT', 'NN', 'VBD', 'RB', 'CC', 'DT', 'JJR', 'NNS', 'IN', 'DT', 'NN', 'NN']"
116,"        // useful, so we can optionally SetLinger(0) here to recycle the port","['//', 'useful,', 'so', 'we', 'can', 'optionally', 'SetLinger(0)', 'here', 'to', 'recycle', 'the', 'port']","['COMMENT', 'RB', 'IN', 'PRP', 'MD', 'RB', 'VB', 'RB', 'TO', 'VB', 'DT', 'NN']"
117,        // faster.,"['//', 'faster.']","['COMMENT', 'NN']"
118,        srvConn.SetLinger(0),['srvConn.SetLinger(0)'],['FUNCTION_CALL']
119,        srvConn.CloseRead(),['srvConn.CloseRead()'],['FUNCTION_CALL']
120,        waitFor = serverClosed,"['waitFor', '=', 'serverClosed']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER']"
121,    case <-serverClosed:,"['case', '<-', 'serverClosed', ':']","['KEYWORD', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
122,        cliConn.CloseRead(),['cliConn.CloseRead()'],['FUNCTION_CALL']
123,        waitFor = clientClosed,"['waitFor', '=', 'clientClosed']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER']"
124,    },['}'],['OPERATOR']
125,    // Wait for the other connection to close.,"['//', 'Wait', 'for', 'the', 'other', 'connection', 'to', 'close.']","['COMMENT', 'NNP', 'IN', 'DT', 'JJ', 'NN', 'TO', 'VB']"
126,"    // This ""waitFor"" pattern isn't required, but gives us a way to track the","['//', 'This', '""waitFor""', 'pattern', ""isn't"", 'required,', 'but', 'gives', 'us', 'a', 'way', 'to', 'track', 'the']","['COMMENT', 'DT', 'JJ', 'NN', 'NN', 'NN', 'CC', 'VBZ', 'PRP', 'DT', 'NN', 'TO', 'VB', 'DT']"
127,    // connection and ensure all copies terminate correctly; we can trigger,"['//', 'connection', 'and', 'ensure', 'all', 'copies', 'terminate', 'correctly;', 'we', 'can', 'trigger']","['COMMENT', 'NN', 'CC', 'VB', 'DT', 'NNS', 'VBP', 'NN', 'PRP', 'MD', 'VB']"
128,    // stats on entry and deferred exit of this function.,"['//', 'stats', 'on', 'entry', 'and', 'deferred', 'exit', 'of', 'this', 'function.']","['COMMENT', 'NNS', 'IN', 'NN', 'CC', 'JJ', 'NN', 'IN', 'DT', 'NN']"
129,    <-waitFor,"['<-', 'waitFor']","['OPERATOR', 'IDENTIFIER']"
130,},['}'],['OPERATOR']
131,// This does the actual data transfer.,"['//', 'This', 'does', 'the', 'actual', 'data', 'transfer.']","['COMMENT', 'DT', 'VBZ', 'DT', 'JJ', 'NNS', 'NN']"
132,// The broker only closes the Read side.,"['//', 'The', 'broker', 'only', 'closes', 'the', 'Read', 'side.']","['COMMENT', 'DT', 'NN', 'RB', 'VBZ', 'DT', 'NNP', 'NN']"
133,"func broker(dst, src net.Conn, srcClosed chan struct{}) {","['func', 'broker', '(', 'dst', ',', 'src', 'net', '.', 'Conn', ',', 'srcClosed', 'chan', 'struct', '{})', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'KEYWORD', 'KEYWORD', 'OPERATOR', 'OPERATOR']"
134,    // We can handle errors in a finer-grained manner by inlining io.Copy (it's,"['//', 'We', 'can', 'handle', 'errors', 'in', 'a', 'finer-grained', 'manner', 'by', 'inlining', 'io.Copy', ""(it's""]","['COMMENT', 'PRP', 'MD', 'VB', 'NNS', 'IN', 'DT', 'JJ', 'NN', 'IN', 'VBG', 'NN', 'NN']"
135,"    // simple, and we drop the ReaderFrom or WriterTo checks for","['//', 'simple,', 'and', 'we', 'drop', 'the', 'ReaderFrom', 'or', 'WriterTo', 'checks', 'for']","['COMMENT', 'NN', 'CC', 'PRP', 'VBP', 'DT', 'NNP', 'CC', 'NNP', 'NNS', 'IN']"
136,"    // net.Conn->net.Conn transfers, which aren't needed). This would also let","['//', 'net.Conn->net.Conn', 'transfers,', 'which', ""aren't"", 'needed).', 'This', 'would', 'also', 'let']","['COMMENT', 'JJ', 'NN', 'WDT', 'VBZ', 'NN', 'DT', 'MD', 'RB', 'VB']"
137,    // us adjust buffersize.,"['//', 'us', 'adjust', 'buffersize.']","['COMMENT', 'PRP', 'VBP', 'VB']"
138,"    n, err := io.Copy(dst, src)","['n', ',', 'err', ':=', 'io.Copy(dst, src)']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'FUNCTION_CALL']"
139,"    log.Errorf("" %v bytes copied"", n)","['log.Errorf("" %v bytes copied"", n)']",['FUNCTION_CALL']
140,    if err != nil {,"['if', 'err', '!=', 'nil', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
141,"        log.Errorf(""Copy error: %s"", err)","['log.Errorf(""Copy error: %s"", err)']",['FUNCTION_CALL']
142,        // errCh <- err,"['//', 'errCh', '<-', 'err']","['COMMENT', 'JJ', 'JJ', 'NN']"
143,    },['}'],['OPERATOR']
144,    if err := src.Close(); err != nil {,"['if', 'err', ':=', 'src.Close()', ';', 'err', '!=', 'nil', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'FUNCTION_CALL', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
145,"        log.Errorf(""Close error: %s"", err)","['log.Errorf(""Close error: %s"", err)']",['FUNCTION_CALL']
146,        errCh <- err,"['errCh', '<-', 'err']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER']"
147,    },['}'],['OPERATOR']
148,    if n == 0 {,"['if', 'n', '==', '0', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'OCTAL_LITERAL', 'OPERATOR']"
149,        lrNewCh <- 1,"['lrNewCh', '<-', '1']","['IDENTIFIER', 'OPERATOR', 'DECIMAL_LITERAL']"
150,    },['}'],['OPERATOR']
151,    srcClosed <- struct{}{},"['srcClosed', '<-', 'struct', '{}{}']","['IDENTIFIER', 'OPERATOR', 'KEYWORD', 'OPERATOR']"
152,},['}'],['OPERATOR']
