,text,token,annotation
0,"In looking at Go and Erlang's approach to concurrency, I noticed that they both rely on message passing.

This approach obviously alleviates the need for complex locks because there is no shared state.

However, consider the case of many clients wanting parallel read-only access to a single large data structure in memory -- like a suffix array.

My questions:


Will using shared state be faster and use less memory than message passing, as locks will mostly be unnecessary because the data is read-only, and only needs to exist in a single location?
How would this problem be approached in a message passing context? Would there be a single process with access to the data structure and clients would simply need to sequentially request data from it? Or, if possible, would the data be chunked to create several processes that hold chunks?
Given the architecture of modern CPUs & memory, is there much difference between the two solutions -- i.e., can shared memory be read in parallel by multiple cores -- meaning there is no hardware bottleneck that would otherwise make both implementations roughly perform the same?

","['In', 'looking', 'at', 'Go', 'and', ""Erlang's"", 'approach', 'to', 'concurrency,', 'I', 'noticed', 'that', 'they', 'both', 'rely', 'on', 'message', 'passing.', 'This', 'approach', 'obviously', 'alleviates', 'the', 'need', 'for', 'complex', 'locks', 'because', 'there', 'is', 'no', 'shared', 'state.', 'However,', 'consider', 'the', 'case', 'of', 'many', 'clients', 'wanting', 'parallel', 'read-only', 'access', 'to', 'a', 'single', 'large', 'data', 'structure', 'in', 'memory', '--', 'like', 'a', 'suffix', 'array.', 'My', 'questions:', 'Will', 'using', 'shared', 'state', 'be', 'faster', 'and', 'use', 'less', 'memory', 'than', 'message', 'passing,', 'as', 'locks', 'will', 'mostly', 'be', 'unnecessary', 'because', 'the', 'data', 'is', 'read-only,', 'and', 'only', 'needs', 'to', 'exist', 'in', 'a', 'single', 'location?', 'How', 'would', 'this', 'problem', 'be', 'approached', 'in', 'a', 'message', 'passing', 'context?', 'Would', 'there', 'be', 'a', 'single', 'process', 'with', 'access', 'to', 'the', 'data', 'structure', 'and', 'clients', 'would', 'simply', 'need', 'to', 'sequentially', 'request', 'data', 'from', 'it?', 'Or,', 'if', 'possible,', 'would', 'the', 'data', 'be', 'chunked', 'to', 'create', 'several', 'processes', 'that', 'hold', 'chunks?', 'Given', 'the', 'architecture', 'of', 'modern', 'CPUs', '&', 'memory,', 'is', 'there', 'much', 'difference', 'between', 'the', 'two', 'solutions', '--', 'i.e.,', 'can', 'shared', 'memory', 'be', 'read', 'in', 'parallel', 'by', 'multiple', 'cores', '--', 'meaning', 'there', 'is', 'no', 'hardware', 'bottleneck', 'that', 'would', 'otherwise', 'make', 'both', 'implementations', 'roughly', 'perform', 'the', 'same?']","['IN', 'VBG', 'IN', 'NNP', 'CC', 'NNP', 'NN', 'TO', 'VB', 'PRP', 'VBD', 'IN', 'PRP', 'DT', 'VBP', 'IN', 'NN', 'NN', 'DT', 'NN', 'RB', 'VBZ', 'DT', 'NN', 'IN', 'JJ', 'NNS', 'IN', 'EX', 'VBZ', 'DT', 'JJ', 'NN', 'NNP', 'VB', 'DT', 'NN', 'IN', 'JJ', 'NNS', 'VBG', 'JJ', 'JJ', 'NN', 'TO', 'DT', 'JJ', 'JJ', 'NNS', 'NN', 'IN', 'NN', ':', 'IN', 'DT', 'NN', 'NN', 'NNP', 'NN', 'NNP', 'VBG', 'VBN', 'NN', 'VB', 'RBR', 'CC', 'VB', 'JJR', 'NN', 'IN', 'NN', 'NN', 'IN', 'NNS', 'MD', 'RB', 'VB', 'JJ', 'IN', 'DT', 'NN', 'VBZ', 'JJ', 'CC', 'RB', 'VBZ', 'TO', 'VB', 'IN', 'DT', 'JJ', 'NN', 'NNP', 'MD', 'DT', 'NN', 'VB', 'VBN', 'IN', 'DT', 'NN', 'NN', 'NN', 'NNP', 'RB', 'VB', 'DT', 'JJ', 'NN', 'IN', 'NN', 'TO', 'DT', 'NN', 'NN', 'CC', 'NNS', 'MD', 'RB', 'VB', 'TO', 'RB', 'VB', 'NNS', 'IN', 'NN', 'NNP', 'IN', 'NN', 'MD', 'DT', 'NNS', 'VB', 'VBN', 'TO', 'VB', 'JJ', 'NNS', 'WDT', 'VBP', 'VB', 'NNP', 'DT', 'NN', 'IN', 'JJ', 'NNP', 'CC', 'NN', 'VBZ', 'RB', 'JJ', 'NN', 'IN', 'DT', 'CD', 'NNS', ':', 'NN', 'MD', 'VB', 'NN', 'VB', 'VBN', 'IN', 'JJ', 'IN', 'JJ', 'NNS', ':', 'VBG', 'EX', 'VBZ', 'DT', 'NN', 'NN', 'WDT', 'MD', 'RB', 'VB', 'DT', 'NNS', 'RB', 'VBP', 'DT', 'NN']"
