,text,token,annotation
0,"You are squandering memory. Here's how to rectify it.

You give the sample input a.txt, 48 bytes.

","['You', 'are', 'squandering', 'memory.', ""Here's"", 'how', 'to', 'rectify', 'it.', 'You', 'give', 'the', 'sample', 'input', 'a.txt,', '48', 'bytes.']","['PRP', 'VBP', 'VBG', 'NNS', 'NNP', 'WRB', 'TO', 'VB', 'NN', 'PRP', 'VBP', 'DT', 'NN', 'NN', 'RB', 'CD', 'NN']"
1,"# 3072441,117185083","['3072441', ',', '117185083']","['DECIMAL_LITERAL', 'OPERATOR', 'DECIMAL_LITERAL']"
2,"1,2","['1', ',', '2']","['DECIMAL_LITERAL', 'OPERATOR', 'DECIMAL_LITERAL']"
3,"1,3","['1', ',', '3']","['DECIMAL_LITERAL', 'OPERATOR', 'DECIMAL_LITERAL']"
4,"1,4","['1', ',', '4']","['DECIMAL_LITERAL', 'OPERATOR', 'DECIMAL_LITERAL']"
5,"1,5","['1', ',', '5']","['DECIMAL_LITERAL', 'OPERATOR', 'DECIMAL_LITERAL']"
6,"

On http://snap.stanford.edu/data/com-Orkut.html, I found http://snap.stanford.edu/data/bigdata/communities/","['On', 'http://snap.stanford.edu/data/com-Orkut.html,', 'I', 'found', 'http://snap.stanford.edu/data/bigdata/communities/']","['IN', 'NN', 'PRP', 'VBD', 'NN']"
7,com-orkut.ungraph.txt,"['com', '-', 'orkut', '.', 'ungraph', '.', 'txt']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER']"
8,".gz, 1.8 GB uncompressed, 117,185,083 edges.

","['.gz,', '1.8', 'GB', 'uncompressed,', '117,185,083', 'edges.']","['RB', 'CD', 'NNP', 'JJ', 'CD', 'NN']"
9,# Undirected graph: ../../data/output/orkut.txt,"['Undirected', 'graph', ':', '../../data/output/orkut.txt']","['IDENTIFIER', 'IDENTIFIER', 'OPERATOR', 'DIRECTORY']"
10,# Orkut,['Orkut'],['IDENTIFIER']
11,# Nodes: 3072441 Edges: 117185083,"['Nodes', ':', '3072441', 'Edges', ':', '117185083']","['IDENTIFIER', 'OPERATOR', 'DECIMAL_LITERAL', 'IDENTIFIER', 'OPERATOR', 'DECIMAL_LITERAL']"
12,# FromNodeId    ToNodeId,"['FromNodeId', 'ToNodeId']","['IDENTIFIER', 'IDENTIFIER']"
13,1   2,"['1', '2']","['DECIMAL_LITERAL', 'DECIMAL_LITERAL']"
14,1   3,"['1', '3']","['DECIMAL_LITERAL', 'DECIMAL_LITERAL']"
15,1   4,"['1', '4']","['DECIMAL_LITERAL', 'DECIMAL_LITERAL']"
16,1   5,"['1', '5']","['DECIMAL_LITERAL', 'DECIMAL_LITERAL']"
17,"

On http://socialnetworks.mpi-sws.org/data-imc2007.html, I found http://socialnetworks.mpi-sws.mpg.de/data/orkut-links.txt.gz, 3.4 GB uncompressed, 223,534,301 edges.

","['On', 'http://socialnetworks.mpi-sws.org/data-imc2007.html,', 'I', 'found', 'http://socialnetworks.mpi-sws.mpg.de/data/orkut-links.txt.gz,', '3.4', 'GB', 'uncompressed,', '223,534,301', 'edges.']","['IN', 'NN', 'PRP', 'VBD', 'RB', 'CD', 'NNP', 'JJ', 'CD', 'NN']"
18,1   2,"['1', '2']","['DECIMAL_LITERAL', 'DECIMAL_LITERAL']"
19,1   3,"['1', '3']","['DECIMAL_LITERAL', 'DECIMAL_LITERAL']"
20,1   4,"['1', '4']","['DECIMAL_LITERAL', 'DECIMAL_LITERAL']"
21,1   5,"['1', '5']","['DECIMAL_LITERAL', 'DECIMAL_LITERAL']"
22,"

Since they are similar, one program can handle all formats.

Your Edge type is

","['Since', 'they', 'are', 'similar,', 'one', 'program', 'can', 'handle', 'all', 'formats.', 'Your', 'Edge', 'type', 'is']","['IN', 'PRP', 'VBP', 'JJ', 'CD', 'NN', 'MD', 'VB', 'DT', 'VB', 'NNP', 'NNP', 'NN', 'VBZ']"
23,type Edge struct {,"['type', 'Edge', 'struct', '{']","['KEYWORD', 'IDENTIFIER', 'KEYWORD', 'OPERATOR']"
24,"    u, v int","['u', ',', 'v', 'int']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'IDENTIFIER']"
25,},['}'],['OPERATOR']
26,"

which is 16 bytes on a 64-bit architecture.

Use

","['which', 'is', '16', 'bytes', 'on', 'a', '64-bit', 'architecture.', 'Use']","['WDT', 'VBZ', 'CD', 'NNS', 'IN', 'DT', 'JJ', 'NN', 'NNP']"
27,type Edge struct {,"['type', 'Edge', 'struct', '{']","['KEYWORD', 'IDENTIFIER', 'KEYWORD', 'OPERATOR']"
28,"    U, V uint32","['U', ',', 'V', 'uint32']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'IDENTIFIER']"
29,},['}'],['OPERATOR']
30,"

which is 8 bytes, it is adequate.

If the capacity of a slice is not large enough to fit the additional values, append allocates a new, sufficiently large underlying array that fits both the existing slice elements and the additional values. Otherwise, append re-uses the underlying array. For a large slice, the new array is 1.25 times the size of the old array. While the old array is being copied to the new array, 1 + 1.25 = 2.25 times the memory for the old array is required. Therefore, allocate the underlying array so that all values fit.

make(T, n) initializes map of type T with initial space for n elements. Provide a value for n to limit the cost of reorganization and fragmentation as elements are added. Hashing functions are often imperfect which leads to wasted space. Eliminate the map as it's unneccesary. To eliminate duplicates, sort the slice in place and move the unique elements down.

A string is immutable, therefore a new string is allocated for scanner.Text() to convert from a byte slice buffer. To parse numbers we use strconv. To minimize temporary allocations, use scanner.Bytes() and adapt strconv.ParseUint to accept a byte array argument (bytconv).

For example,

orkut.go

","['which', 'is', '8', 'bytes,', 'it', 'is', 'adequate.', 'If', 'the', 'capacity', 'of', 'a', 'slice', 'is', 'not', 'large', 'enough', 'to', 'fit', 'the', 'additional', 'values,', 'append', 'allocates', 'a', 'new,', 'sufficiently', 'large', 'underlying', 'array', 'that', 'fits', 'both', 'the', 'existing', 'slice', 'elements', 'and', 'the', 'additional', 'values.', 'Otherwise,', 'append', 're-uses', 'the', 'underlying', 'array.', 'For', 'a', 'large', 'slice,', 'the', 'new', 'array', 'is', '1.25', 'times', 'the', 'size', 'of', 'the', 'old', 'array.', 'While', 'the', 'old', 'array', 'is', 'being', 'copied', 'to', 'the', 'new', 'array,', '1', '+', '1.25', '=', '2.25', 'times', 'the', 'memory', 'for', 'the', 'old', 'array', 'is', 'required.', 'Therefore,', 'allocate', 'the', 'underlying', 'array', 'so', 'that', 'all', 'values', 'fit.', 'make(T,', 'n)', 'initializes', 'map', 'of', 'type', 'T', 'with', 'initial', 'space', 'for', 'n', 'elements.', 'Provide', 'a', 'value', 'for', 'n', 'to', 'limit', 'the', 'cost', 'of', 'reorganization', 'and', 'fragmentation', 'as', 'elements', 'are', 'added.', 'Hashing', 'functions', 'are', 'often', 'imperfect', 'which', 'leads', 'to', 'wasted', 'space.', 'Eliminate', 'the', 'map', 'as', ""it's"", 'unneccesary.', 'To', 'eliminate', 'duplicates,', 'sort', 'the', 'slice', 'in', 'place', 'and', 'move', 'the', 'unique', 'elements', 'down.', 'A', 'string', 'is', 'immutable,', 'therefore', 'a', 'new', 'string', 'is', 'allocated', 'for', 'scanner.Text()', 'to', 'convert', 'from', 'a', 'byte', 'slice', 'buffer.', 'To', 'parse', 'numbers', 'we', 'use', 'strconv.', 'To', 'minimize', 'temporary', 'allocations,', 'use', 'scanner.Bytes()', 'and', 'adapt', 'strconv.ParseUint', 'to', 'accept', 'a', 'byte', 'array', 'argument', '(bytconv).', 'For', 'example,', 'orkut.go']","['WDT', 'VBZ', 'CD', 'NN', 'PRP', 'VBZ', 'JJ', 'IN', 'DT', 'NN', 'IN', 'DT', 'NN', 'VBZ', 'RB', 'JJ', 'RB', 'TO', 'VB', 'DT', 'JJ', 'NN', 'VBP', 'VBZ', 'DT', 'NN', 'RB', 'JJ', 'VBG', 'NN', 'WDT', 'VBZ', 'DT', 'DT', 'VBG', 'NN', 'NNS', 'CC', 'DT', 'JJ', 'NN', 'NNP', 'VBP', 'VBZ', 'DT', 'JJ', 'NN', 'IN', 'DT', 'JJ', 'NN', 'DT', 'JJ', 'NN', 'VBZ', 'CD', 'NNS', 'DT', 'NN', 'IN', 'DT', 'JJ', 'NN', 'IN', 'DT', 'JJ', 'NN', 'VBZ', 'VBG', 'VBN', 'TO', 'DT', 'JJ', 'NN', 'CD', 'NN', 'CD', 'NN', 'CD', 'NNS', 'DT', 'NN', 'IN', 'DT', 'JJ', 'NN', 'VBZ', 'JJ', 'NNP', 'VBP', 'DT', 'JJ', 'NN', 'IN', 'IN', 'DT', 'NNS', 'VBP', 'JJ', 'NN', 'VBZ', 'NN', 'IN', 'NN', 'NNP', 'IN', 'JJ', 'NN', 'IN', 'JJ', 'NN', 'NNP', 'DT', 'NN', 'IN', 'JJ', 'TO', 'VB', 'DT', 'NN', 'IN', 'NN', 'CC', 'NN', 'IN', 'NNS', 'VBP', 'JJ', 'NNP', 'NNS', 'VBP', 'RB', 'JJ', 'WDT', 'VBZ', 'TO', 'VB', 'JJ', 'NNP', 'DT', 'NN', 'IN', 'JJ', 'NN', 'TO', 'VB', 'JJ', 'NN', 'DT', 'NN', 'IN', 'NN', 'CC', 'VB', 'DT', 'JJ', 'NNS', 'VBP', 'DT', 'NN', 'VBZ', 'JJ', 'RB', 'DT', 'JJ', 'NN', 'VBZ', 'VBN', 'IN', 'NN', 'TO', 'VB', 'IN', 'DT', 'NN', 'NN', 'NN', 'TO', 'VB', 'NNS', 'PRP', 'VBP', 'JJ', 'TO', 'VB', 'JJ', 'NN', 'NN', 'NN', 'CC', 'JJ', 'NN', 'TO', 'VB', 'DT', 'JJ', 'NN', 'NN', 'NN', 'IN', 'NN', 'NN']"
31,package main,"['package', 'main']","['KEYWORD', 'IDENTIFIER']"
32,import (,"['import', '(']","['KEYWORD', 'OPERATOR']"
33,"    ""bufio""","['""bufio""']",['STRING_LITERAL']
34,"    ""bytes""","['""bytes""']",['STRING_LITERAL']
35,"    ""errors""","['""errors""']",['STRING_LITERAL']
36,"    ""fmt""","['""fmt""']",['STRING_LITERAL']
37,"    ""os""","['""os""']",['STRING_LITERAL']
38,"    ""runtime""","['""runtime""']",['STRING_LITERAL']
39,"    ""sort""","['""sort""']",['STRING_LITERAL']
40,"    ""strconv""","['""strconv""']",['STRING_LITERAL']
41,),[')'],['OPERATOR']
42,type Edge struct {,"['type', 'Edge', 'struct', '{']","['KEYWORD', 'IDENTIFIER', 'KEYWORD', 'OPERATOR']"
43,"    U, V uint32","['U', ',', 'V', 'uint32']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'IDENTIFIER']"
44,},['}'],['OPERATOR']
45,func (e Edge) String() string {,"['func', '(', 'e', 'Edge', ')', 'String', '()', 'string', '{']","['KEYWORD', 'OPERATOR', 'IDENTIFIER', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
46,"    return fmt.Sprintf(""%d,%d"", e.U, e.V)","['return', 'fmt.Sprintf(""%d,%d"", e.U, e.V)']","['KEYWORD', 'FUNCTION_CALL']"
47,},['}'],['OPERATOR']
48,type ByKey []Edge,"['type', 'ByKey', '[]', 'Edge']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER']"
49,func (a ByKey) Len() int      { return len(a) },"['func', '(', 'a', 'ByKey', ')', 'Len', '()', 'int', '{', 'return', 'len', '(', 'a', ')', '}']","['KEYWORD', 'OPERATOR', 'IDENTIFIER', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'OPERATOR']"
50,"func (a ByKey) Swap(i, j int) { a[i], a[j] = a[j], a[i] }","['func', '(', 'a', 'ByKey', ')', 'Swap', '(', 'i', ',', 'j', 'int', ')', '{', 'a', '[', 'i', '],', 'a', '[', 'j', ']', '=', 'a', '[', 'j', '],', 'a', '[', 'i', ']', '}']","['KEYWORD', 'OPERATOR', 'IDENTIFIER', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'IDENTIFIER', 'OPERATOR', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'OPERATOR']"
51,"func (a ByKey) Less(i, j int) bool {","['func', '(', 'a', 'ByKey', ')', 'Less', '(', 'i', ',', 'j', 'int', ')', 'bool', '{']","['KEYWORD', 'OPERATOR', 'IDENTIFIER', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
52,    if a[i].U < a[j].U {,"['if', 'a', '[', 'i', '].', 'U', '<', 'a', '[', 'j', '].', 'U', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
53,        return true,"['return', 'true']","['KEYWORD', 'IDENTIFIER']"
54,    },['}'],['OPERATOR']
55,    if a[i].U == a[j].U && a[i].V < a[j].V {,"['if', 'a', '[', 'i', '].', 'U', '==', 'a', '[', 'j', '].', 'U', '&&', 'a', '[', 'i', '].', 'V', '<', 'a', '[', 'j', '].', 'V', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
56,        return true,"['return', 'true']","['KEYWORD', 'IDENTIFIER']"
57,    },['}'],['OPERATOR']
58,    return false,"['return', 'false']","['KEYWORD', 'IDENTIFIER']"
59,},['}'],['OPERATOR']
60,func countEdges(scanner *bufio.Scanner) int {,"['func', 'countEdges', '(', 'scanner', '*', 'bufio', '.', 'Scanner', ')', 'int', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
61,"    var nNodes, nEdges int","['var', 'nNodes', ',', 'nEdges', 'int']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'IDENTIFIER']"
62,    for scanner.Scan() {,"['for', 'scanner.Scan()', '{']","['KEYWORD', 'FUNCTION_CALL', 'OPERATOR']"
63,        line := scanner.Bytes(),"['line', ':=', 'scanner.Bytes()']","['IDENTIFIER', 'OPERATOR', 'FUNCTION_CALL']"
64,        if !(len(line) > 0 && line[0] == '#') {,"['if', '!(', 'len', '(', 'line', ')', '>', '0', '&&', 'line', '[', '0', ']', '==', ""'#'"", ')', '{']","['KEYWORD', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'OPERATOR', 'OCTAL_LITERAL', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'OCTAL_LITERAL', 'OPERATOR', 'OPERATOR', 'STRING_LITERAL', 'OPERATOR', 'OPERATOR']"
65,            nEdges++,"['nEdges', '++']","['IDENTIFIER', 'OPERATOR']"
66,            continue,['continue'],['KEYWORD']
67,        },['}'],['OPERATOR']
68,"        n, err := fmt.Sscanf(string(line), ""# Nodes: %d Edges: %d"", &nNodes, &nEdges)","['n', ',', 'err', ':=', 'fmt.Sscanf(string(line), ""# Nodes: %d Edges: %d"", &nNodes, &nEdges)']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'FUNCTION_CALL']"
69,        if err != nil || n != 2 {,"['if', 'err', '!=', 'nil', '||', 'n', '!=', '2', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'DECIMAL_LITERAL', 'OPERATOR']"
70,"            n, err = fmt.Sscanf(string(line), ""# %d,%d"", &nNodes, &nEdges)","['n', ',', 'err', '=', 'fmt.Sscanf(string(line), ""# %d,%d"", &nNodes, &nEdges)']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'FUNCTION_CALL']"
71,            if err != nil || n != 2 {,"['if', 'err', '!=', 'nil', '||', 'n', '!=', '2', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'DECIMAL_LITERAL', 'OPERATOR']"
72,                continue,['continue'],['KEYWORD']
73,            },['}'],['OPERATOR']
74,        },['}'],['OPERATOR']
75,        fmt.Println(string(line)),['fmt.Println(string(line))'],['FUNCTION_CALL']
76,        break,['break'],['KEYWORD']
77,    },['}'],['OPERATOR']
78,    if err := scanner.Err(); err != nil {,"['if', 'err', ':=', 'scanner.Err()', ';', 'err', '!=', 'nil', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'FUNCTION_CALL', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
79,        panic(err.Error()),"['panic', '(', 'err.Error())']","['IDENTIFIER', 'OPERATOR', 'FUNCTION_CALL']"
80,    },['}'],['OPERATOR']
81,    fmt.Println(nEdges),['fmt.Println(nEdges)'],['FUNCTION_CALL']
82,    return nEdges,"['return', 'nEdges']","['KEYWORD', 'IDENTIFIER']"
83,},['}'],['OPERATOR']
84,func loadEdges(filename string) []Edge {,"['func', 'loadEdges', '(', 'filename', 'string', ')', '[]', 'Edge', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'IDENTIFIER', 'OPERATOR', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
85,"    file, err := os.Open(filename)","['file', ',', 'err', ':=', 'os.Open(filename)']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'FUNCTION_CALL']"
86,    if err != nil {,"['if', 'err', '!=', 'nil', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
87,        panic(err.Error()),"['panic', '(', 'err.Error())']","['IDENTIFIER', 'OPERATOR', 'FUNCTION_CALL']"
88,    },['}'],['OPERATOR']
89,    defer file.Close(),"['defer', 'file.Close()']","['IDENTIFIER', 'FUNCTION_CALL']"
90,    scanner := bufio.NewScanner(file),"['scanner', ':=', 'bufio.NewScanner(file)']","['IDENTIFIER', 'OPERATOR', 'FUNCTION_CALL']"
91,    nEdges := countEdges(scanner),"['nEdges', ':=', 'countEdges', '(', 'scanner', ')']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
92,"    edges := make([]Edge, 0, nEdges)","['edges', ':=', 'make', '([]', 'Edge', ',', '0', ',', 'nEdges', ')']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'OCTAL_LITERAL', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
93,"    offset, err := file.Seek(0, os.SEEK_SET)","['offset', ',', 'err', ':=', 'file.Seek(0, os.SEEK_SET)']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'FUNCTION_CALL']"
94,    if err != nil || offset != 0 {,"['if', 'err', '!=', 'nil', '||', 'offset', '!=', '0', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'OCTAL_LITERAL', 'OPERATOR']"
95,        panic(err.Error()),"['panic', '(', 'err.Error())']","['IDENTIFIER', 'OPERATOR', 'FUNCTION_CALL']"
96,    },['}'],['OPERATOR']
97,    var sep byte = '\t',"['var', 'sep', 'byte', '=', ""'\\t'""]","['KEYWORD', 'IDENTIFIER', 'IDENTIFIER', 'OPERATOR', 'STRING_LITERAL']"
98,    scanner = bufio.NewScanner(file),"['scanner', '=', 'bufio.NewScanner(file)']","['IDENTIFIER', 'OPERATOR', 'FUNCTION_CALL']"
99,    for scanner.Scan() {,"['for', 'scanner.Scan()', '{']","['KEYWORD', 'FUNCTION_CALL', 'OPERATOR']"
100,        line := scanner.Bytes(),"['line', ':=', 'scanner.Bytes()']","['IDENTIFIER', 'OPERATOR', 'FUNCTION_CALL']"
101,        if len(line) > 0 && line[0] == '#' {,"['if', 'len', '(', 'line', ')', '>', '0', '&&', 'line', '[', '0', ']', '==', ""'#'"", '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'OPERATOR', 'OCTAL_LITERAL', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'OCTAL_LITERAL', 'OPERATOR', 'OPERATOR', 'STRING_LITERAL', 'OPERATOR']"
102,            continue,['continue'],['KEYWORD']
103,        },['}'],['OPERATOR']
104,"        i := bytes.IndexByte(line, sep)","['i', ':=', 'bytes.IndexByte(line, sep)']","['IDENTIFIER', 'OPERATOR', 'FUNCTION_CALL']"
105,        if i = len(line) {,"['if', 'i', '=', 'len', '(', 'line', ')', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'OPERATOR']"
106,"            sep = ','","['sep', '=', ""','""]","['IDENTIFIER', 'OPERATOR', 'STRING_LITERAL']"
107,"            i = bytes.IndexByte(line, sep)","['i', '=', 'bytes.IndexByte(line, sep)']","['IDENTIFIER', 'OPERATOR', 'FUNCTION_CALL']"
108,            if i = len(line) {,"['if', 'i', '=', 'len', '(', 'line', ')', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'OPERATOR']"
109,"                err := errors.New(""Invalid line format: "" + string(line))","['err', ':=', 'errors.New(""Invalid line format: "" + string(line))']","['IDENTIFIER', 'OPERATOR', 'FUNCTION_CALL']"
110,                panic(err.Error()),"['panic', '(', 'err.Error())']","['IDENTIFIER', 'OPERATOR', 'FUNCTION_CALL']"
111,            },['}'],['OPERATOR']
112,        },['}'],['OPERATOR']
113,"        u, err := ParseUint(line[:i], 10, 32)","['u', ',', 'err', ':=', 'ParseUint', '(', 'line', '[:', 'i', '],', '10', ',', '32', ')']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'DECIMAL_LITERAL', 'OPERATOR', 'DECIMAL_LITERAL', 'OPERATOR']"
114,        if err != nil {,"['if', 'err', '!=', 'nil', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
115,            panic(err.Error()),"['panic', '(', 'err.Error())']","['IDENTIFIER', 'OPERATOR', 'FUNCTION_CALL']"
116,        },['}'],['OPERATOR']
117,"        v, err := ParseUint(line[i+1:], 10, 32)","['v', ',', 'err', ':=', 'ParseUint', '(', 'line', '[', 'i', '+', '1', ':],', '10', ',', '32', ')']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'DECIMAL_LITERAL', 'OPERATOR', 'DECIMAL_LITERAL', 'OPERATOR', 'DECIMAL_LITERAL', 'OPERATOR']"
118,        if err != nil {,"['if', 'err', '!=', 'nil', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
119,            panic(err.Error()),"['panic', '(', 'err.Error())']","['IDENTIFIER', 'OPERATOR', 'FUNCTION_CALL']"
120,        },['}'],['OPERATOR']
121,        if u > v {,"['if', 'u', '>', 'v', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
122,"            u, v = v, u","['u', ',', 'v', '=', 'v', ',', 'u']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER']"
123,        },['}'],['OPERATOR']
124,"        edges = append(edges, Edge{uint32(u), uint32(v)})","['edges', '=', 'append', '(', 'edges', ',', 'Edge', '{', 'uint32', '(', 'u', '),', 'uint32', '(', 'v', ')})']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
125,    },['}'],['OPERATOR']
126,    if err := scanner.Err(); err != nil {,"['if', 'err', ':=', 'scanner.Err()', ';', 'err', '!=', 'nil', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'FUNCTION_CALL', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
127,        panic(err.Error()),"['panic', '(', 'err.Error())']","['IDENTIFIER', 'OPERATOR', 'FUNCTION_CALL']"
128,    },['}'],['OPERATOR']
129,    if len(edges) <= 1 {,"['if', 'len', '(', 'edges', ')', '<=', '1', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'OPERATOR', 'DECIMAL_LITERAL', 'OPERATOR']"
130,        return edges,"['return', 'edges']","['KEYWORD', 'IDENTIFIER']"
131,    },['}'],['OPERATOR']
132,    sort.Sort(ByKey(edges)),['sort.Sort(ByKey(edges))'],['FUNCTION_CALL']
133,    j := 0,"['j', ':=', '0']","['IDENTIFIER', 'OPERATOR', 'OCTAL_LITERAL']"
134,    i := j + 1,"['i', ':=', 'j', '+', '1']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'DECIMAL_LITERAL']"
135,"    for ; i < len(edges); i, j = i+1, j+1 {","['for', ';', 'i', '<', 'len', '(', 'edges', ');', 'i', ',', 'j', '=', 'i', '+', '1', ',', 'j', '+', '1', '{']","['KEYWORD', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'DECIMAL_LITERAL', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'DECIMAL_LITERAL', 'OPERATOR']"
136,        if edges[i] == edges[j] {,"['if', 'edges', '[', 'i', ']', '==', 'edges', '[', 'j', ']', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'OPERATOR']"
137,            break,['break'],['KEYWORD']
138,        },['}'],['OPERATOR']
139,    },['}'],['OPERATOR']
140,    for ; i < len(edges); i++ {,"['for', ';', 'i', '<', 'len', '(', 'edges', ');', 'i', '++', '{']","['KEYWORD', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'OPERATOR']"
141,        if edges[i] != edges[j] {,"['if', 'edges', '[', 'i', ']', '!=', 'edges', '[', 'j', ']', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'OPERATOR']"
142,            j++,"['j', '++']","['IDENTIFIER', 'OPERATOR']"
143,            edges[j] = edges[i],"['edges', '[', 'j', ']', '=', 'edges', '[', 'i', ']']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
144,        },['}'],['OPERATOR']
145,    },['}'],['OPERATOR']
146,    edges = edges[:j+1],"['edges', '=', 'edges', '[:', 'j', '+', '1', ']']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'DECIMAL_LITERAL', 'OPERATOR']"
147,    return edges,"['return', 'edges']","['KEYWORD', 'IDENTIFIER']"
148,},['}'],['OPERATOR']
149,func main() {,"['func', 'main', '()', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'OPERATOR']"
150,    if len(os.Args) <= 1 {,"['if', 'len', '(', 'os', '.', 'Args', ')', '<=', '1', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'OPERATOR', 'DECIMAL_LITERAL', 'OPERATOR']"
151,"        err := errors.New(""Missing file name"")","['err', ':=', 'errors.New(""Missing file name"")']","['IDENTIFIER', 'OPERATOR', 'FUNCTION_CALL']"
152,        panic(err.Error()),"['panic', '(', 'err.Error())']","['IDENTIFIER', 'OPERATOR', 'FUNCTION_CALL']"
153,    },['}'],['OPERATOR']
154,    filename := os.Args[1],"['filename', ':=', 'os', '.', 'Args', '[', '1', ']']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'DECIMAL_LITERAL', 'OPERATOR']"
155,    fmt.Println(filename),['fmt.Println(filename)'],['FUNCTION_CALL']
156,    edges := loadEdges(filename),"['edges', ':=', 'loadEdges', '(', 'filename', ')']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
157,    var ms runtime.MemStats,"['var', 'ms', 'runtime', '.', 'MemStats']","['KEYWORD', 'IDENTIFIER', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER']"
158,    runtime.ReadMemStats(&ms),['runtime.ReadMemStats(&ms)'],['FUNCTION_CALL']
159,"    fmt.Println(ms.Alloc, ms.TotalAlloc, ms.Sys, ms.Mallocs, ms.Frees)","['fmt.Println(ms.Alloc, ms.TotalAlloc, ms.Sys, ms.Mallocs, ms.Frees)']",['FUNCTION_CALL']
160,"    fmt.Println(len(edges), cap(edges))","['fmt.Println(len(edges), cap(edges))']",['FUNCTION_CALL']
161,"    for i, e := range edges {","['for', 'i', ',', 'e', ':=', 'range', 'edges', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'KEYWORD', 'IDENTIFIER', 'OPERATOR']"
162,        fmt.Println(e),['fmt.Println(e)'],['FUNCTION_CALL']
163,        if i >= 10 {,"['if', 'i', '>=', '10', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'DECIMAL_LITERAL', 'OPERATOR']"
164,            break,['break'],['KEYWORD']
165,        },['}'],['OPERATOR']
166,    },['}'],['OPERATOR']
167,},['}'],['OPERATOR']
168,// bytconv from strconv,"['//', 'bytconv', 'from', 'strconv']","['COMMENT', 'NN', 'IN', 'NN']"
169,// Return the first number n such that n*base >= 1<<64.,"['//', 'Return', 'the', 'first', 'number', 'n', 'such', 'that', 'n*base', '>=', '1<<64.']","['COMMENT', 'VB', 'DT', 'JJ', 'NN', 'NNS', 'JJ', 'IN', 'JJ', '$', 'CD']"
170,func cutoff64(base int) uint64 {,"['func', 'cutoff64', '(', 'base', 'int', ')', 'uint64', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
171,    if base < 2 {,"['if', 'base', '<', '2', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'DECIMAL_LITERAL', 'OPERATOR']"
172,        return 0,"['return', '0']","['KEYWORD', 'OCTAL_LITERAL']"
173,    },['}'],['OPERATOR']
174,    return (1<<64-1)/uint64(base) + 1,"['return', '(1<<64-1)/uint64(base)', '+', '1']","['KEYWORD', 'DIRECTORY', 'OPERATOR', 'DECIMAL_LITERAL']"
175,},['}'],['OPERATOR']
176,// ParseUint is like ParseInt but for unsigned numbers.,"['//', 'ParseUint', 'is', 'like', 'ParseInt', 'but', 'for', 'unsigned', 'numbers.']","['COMMENT', 'NN', 'VBZ', 'IN', 'NNP', 'CC', 'IN', 'JJ', 'NNS']"
177,"func ParseUint(s []byte, base int, bitSize int) (n uint64, err error) {","['func', 'ParseUint', '(', 's', '[]', 'byte', ',', 'base', 'int', ',', 'bitSize', 'int', ')', '(', 'n', 'uint64', ',', 'err', 'error', ')', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'IDENTIFIER', 'OPERATOR', 'OPERATOR', 'IDENTIFIER', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'IDENTIFIER', 'OPERATOR', 'OPERATOR']"
178,"    var cutoff, maxVal uint64","['var', 'cutoff', ',', 'maxVal', 'uint64']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'IDENTIFIER']"
179,    if bitSize == 0 {,"['if', 'bitSize', '==', '0', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'OCTAL_LITERAL', 'OPERATOR']"
180,        bitSize = int(strconv.IntSize),"['bitSize', '=', 'int', '(', 'strconv', '.', 'IntSize', ')']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
181,    },['}'],['OPERATOR']
182,    s0 := s,"['s0', ':=', 's']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER']"
183,    switch {,"['switch', '{']","['IDENTIFIER', 'OPERATOR']"
184,    case len(s) < 1:,"['case', 'len', '(', 's', ')', '<', '1', ':']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'OPERATOR', 'DECIMAL_LITERAL', 'OPERATOR']"
185,        err = strconv.ErrSyntax,"['err', '=', 'strconv', '.', 'ErrSyntax']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER']"
186,        goto Error,"['go', 'to', 'Error']","['KEYWORD', 'IDENTIFIER', 'IDENTIFIER']"
187,    case 2 <= base && base <= 36:,"['case', '2', '<=', 'base', '&&', 'base', '<=', '36', ':']","['KEYWORD', 'DECIMAL_LITERAL', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'DECIMAL_LITERAL', 'OPERATOR']"
188,        // valid base; nothing to do,"['//', 'valid', 'base;', 'nothing', 'to', 'do']","['COMMENT', 'JJ', 'NN', 'NN', 'TO', 'VB']"
189,    case base == 0:,"['case', 'base', '==', '0', ':']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'OCTAL_LITERAL', 'OPERATOR']"
190,"        // Look for octal, hex prefix.","['//', 'Look', 'for', 'octal,', 'hex', 'prefix.']","['COMMENT', 'NN', 'IN', 'JJ', 'NN', 'NN']"
191,        switch {,"['switch', '{']","['IDENTIFIER', 'OPERATOR']"
192,        case s[0] == '0' && len(s) > 1 && (s[1] == 'x' || s[1] == 'X'):,"['case', 's', '[', '0', ']', '==', ""'0'"", '&&', 'len', '(', 's', ')', '>', '1', '&&', '(', 's', '[', '1', ']', '==', ""'x'"", '||', 's', '[', '1', ']', '==', ""'X'"", '):']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'OCTAL_LITERAL', 'OPERATOR', 'OPERATOR', 'STRING_LITERAL', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'OPERATOR', 'DECIMAL_LITERAL', 'OPERATOR', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'DECIMAL_LITERAL', 'OPERATOR', 'OPERATOR', 'STRING_LITERAL', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'DECIMAL_LITERAL', 'OPERATOR', 'OPERATOR', 'STRING_LITERAL', 'OPERATOR']"
193,            base = 16,"['base', '=', '16']","['IDENTIFIER', 'OPERATOR', 'DECIMAL_LITERAL']"
194,            s = s[2:],"['s', '=', 's', '[', '2', ':]']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'DECIMAL_LITERAL', 'OPERATOR']"
195,            if len(s) < 1 {,"['if', 'len', '(', 's', ')', '<', '1', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'OPERATOR', 'DECIMAL_LITERAL', 'OPERATOR']"
196,                err = strconv.ErrSyntax,"['err', '=', 'strconv', '.', 'ErrSyntax']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER']"
197,                goto Error,"['go', 'to', 'Error']","['KEYWORD', 'IDENTIFIER', 'IDENTIFIER']"
198,            },['}'],['OPERATOR']
199,        case s[0] == '0':,"['case', 's', '[', '0', ']', '==', ""'0'"", ':']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'OCTAL_LITERAL', 'OPERATOR', 'OPERATOR', 'STRING_LITERAL', 'OPERATOR']"
200,            base = 8,"['base', '=', '8']","['IDENTIFIER', 'OPERATOR', 'DECIMAL_LITERAL']"
201,        default:,"['default', ':']","['KEYWORD', 'OPERATOR']"
202,            base = 10,"['base', '=', '10']","['IDENTIFIER', 'OPERATOR', 'DECIMAL_LITERAL']"
203,        },['}'],['OPERATOR']
204,    default:,"['default', ':']","['KEYWORD', 'OPERATOR']"
205,"        err = errors.New(""invalid base "" + strconv.Itoa(base))","['err', '=', 'errors.New(""invalid base "" + strconv.Itoa(base))']","['IDENTIFIER', 'OPERATOR', 'FUNCTION_CALL']"
206,        goto Error,"['go', 'to', 'Error']","['KEYWORD', 'IDENTIFIER', 'IDENTIFIER']"
207,    },['}'],['OPERATOR']
208,    n = 0,"['n', '=', '0']","['IDENTIFIER', 'OPERATOR', 'OCTAL_LITERAL']"
209,    cutoff = cutoff64(base),"['cutoff', '=', 'cutoff64', '(', 'base', ')']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
210,    maxVal = 1<<uint(bitSize) - 1,"['maxVal', '=', '1', '<<', 'uint', '(', 'bitSize', ')', '-', '1']","['IDENTIFIER', 'OPERATOR', 'DECIMAL_LITERAL', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'OPERATOR', 'DECIMAL_LITERAL']"
211,    for i := 0; i < len(s); i++ {,"['for', 'i', ':=', '0', ';', 'i', '<', 'len', '(', 's', ');', 'i', '++', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'OCTAL_LITERAL', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'OPERATOR']"
212,        var v byte,"['var', 'v', 'byte']","['KEYWORD', 'IDENTIFIER', 'IDENTIFIER']"
213,        d := s[i],"['d', ':=', 's', '[', 'i', ']']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
214,        switch {,"['switch', '{']","['IDENTIFIER', 'OPERATOR']"
215,        case '0' <= d && d <= '9':,"['case', ""'0'"", '<=', 'd', '&&', 'd', '<=', ""'9'"", ':']","['KEYWORD', 'STRING_LITERAL', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'STRING_LITERAL', 'OPERATOR']"
216,            v = d - '0',"['v', '=', 'd', '-', ""'0'""]","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'STRING_LITERAL']"
217,        case 'a' <= d && d <= 'z':,"['case', ""'a'"", '<=', 'd', '&&', 'd', '<=', ""'z'"", ':']","['KEYWORD', 'STRING_LITERAL', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'STRING_LITERAL', 'OPERATOR']"
218,            v = d - 'a' + 10,"['v', '=', 'd', '-', ""'a'"", '+', '10']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'STRING_LITERAL', 'OPERATOR', 'DECIMAL_LITERAL']"
219,        case 'A' <= d && d <= 'Z':,"['case', ""'A'"", '<=', 'd', '&&', 'd', '<=', ""'Z'"", ':']","['KEYWORD', 'STRING_LITERAL', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'STRING_LITERAL', 'OPERATOR']"
220,            v = d - 'A' + 10,"['v', '=', 'd', '-', ""'A'"", '+', '10']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'STRING_LITERAL', 'OPERATOR', 'DECIMAL_LITERAL']"
221,        default:,"['default', ':']","['KEYWORD', 'OPERATOR']"
222,            n = 0,"['n', '=', '0']","['IDENTIFIER', 'OPERATOR', 'OCTAL_LITERAL']"
223,            err = strconv.ErrSyntax,"['err', '=', 'strconv', '.', 'ErrSyntax']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER']"
224,            goto Error,"['go', 'to', 'Error']","['KEYWORD', 'IDENTIFIER', 'IDENTIFIER']"
225,        },['}'],['OPERATOR']
226,        if int(v) >= base {,"['if', 'int', '(', 'v', ')', '>=', 'base', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
227,            n = 0,"['n', '=', '0']","['IDENTIFIER', 'OPERATOR', 'OCTAL_LITERAL']"
228,            err = strconv.ErrSyntax,"['err', '=', 'strconv', '.', 'ErrSyntax']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER']"
229,            goto Error,"['go', 'to', 'Error']","['KEYWORD', 'IDENTIFIER', 'IDENTIFIER']"
230,        },['}'],['OPERATOR']
231,        if n >= cutoff {,"['if', 'n', '>=', 'cutoff', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
232,            // n*base overflows,"['//', 'n*base', 'overflows']","['COMMENT', 'NN', 'NNS']"
233,            n = 1<<64 - 1,"['n', '=', '1', '<<', '64', '-', '1']","['IDENTIFIER', 'OPERATOR', 'DECIMAL_LITERAL', 'OPERATOR', 'DECIMAL_LITERAL', 'OPERATOR', 'DECIMAL_LITERAL']"
234,            err = strconv.ErrRange,"['err', '=', 'strconv', '.', 'ErrRange']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER']"
235,            goto Error,"['go', 'to', 'Error']","['KEYWORD', 'IDENTIFIER', 'IDENTIFIER']"
236,        },['}'],['OPERATOR']
237,        n *= uint64(base),"['n', '*=', 'uint64', '(', 'base', ')']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
238,        n1 := n + uint64(v),"['n1', ':=', 'n', '+', 'uint64', '(', 'v', ')']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
239,        if n1  maxVal {,"['if', 'n1', 'maxVal', '{']","['KEYWORD', 'IDENTIFIER', 'IDENTIFIER', 'OPERATOR']"
240,            // n+v overflows,"['//', 'n+v', 'overflows']","['COMMENT', 'NN', 'NNS']"
241,            n = 1<<64 - 1,"['n', '=', '1', '<<', '64', '-', '1']","['IDENTIFIER', 'OPERATOR', 'DECIMAL_LITERAL', 'OPERATOR', 'DECIMAL_LITERAL', 'OPERATOR', 'DECIMAL_LITERAL']"
242,            err = strconv.ErrRange,"['err', '=', 'strconv', '.', 'ErrRange']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER']"
243,            goto Error,"['go', 'to', 'Error']","['KEYWORD', 'IDENTIFIER', 'IDENTIFIER']"
244,        },['}'],['OPERATOR']
245,        n = n1,"['n', '=', 'n1']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER']"
246,    },['}'],['OPERATOR']
247,"    return n, nil","['return', 'n', ',', 'nil']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER']"
248,Error:,"['Error', ':']","['IDENTIFIER', 'OPERATOR']"
249,"    return n, &strconv.NumError{""ParseUint"", string(s0), err}","['return', 'n', ',', '&', 'strconv', '.', 'NumError', '{', '""ParseUint""', ',', 'string', '(', 's0', '),', 'err', '}']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'STRING_LITERAL', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
250,},['}'],['OPERATOR']
251,"

Output:

",['Output:'],['NN']
252,$ go build orkut.go,"['$', 'go', 'build', 'orkut', '.', 'go']","['OPERATOR', 'KEYWORD', 'IDENTIFIER', 'IDENTIFIER', 'OPERATOR', 'KEYWORD']"
253,$ time ./orkut ~/release-orkut-links.txt,"['$', 'time', './orkut', '~/release-orkut-links.txt']","['OPERATOR', 'IDENTIFIER', 'DIRECTORY', 'DIRECTORY']"
254,/home/peter/release-orkut-links.txt,['/home/peter/release-orkut-links.txt'],['DIRECTORY']
255,223534301,['223534301'],['DECIMAL_LITERAL']
256,1788305680 1788327856 1904683256 135 50,"['1788305680', '1788327856', '1904683256', '135', '50']","['DECIMAL_LITERAL', 'DECIMAL_LITERAL', 'DECIMAL_LITERAL', 'DECIMAL_LITERAL', 'DECIMAL_LITERAL']"
257,117185083 223534301,"['117185083', '223534301']","['DECIMAL_LITERAL', 'DECIMAL_LITERAL']"
258,"1,2","['1', ',', '2']","['DECIMAL_LITERAL', 'OPERATOR', 'DECIMAL_LITERAL']"
259,"1,3","['1', ',', '3']","['DECIMAL_LITERAL', 'OPERATOR', 'DECIMAL_LITERAL']"
260,"1,4","['1', ',', '4']","['DECIMAL_LITERAL', 'OPERATOR', 'DECIMAL_LITERAL']"
261,"1,5","['1', ',', '5']","['DECIMAL_LITERAL', 'OPERATOR', 'DECIMAL_LITERAL']"
262,"1,6","['1', ',', '6']","['DECIMAL_LITERAL', 'OPERATOR', 'DECIMAL_LITERAL']"
263,"1,7","['1', ',', '7']","['DECIMAL_LITERAL', 'OPERATOR', 'DECIMAL_LITERAL']"
264,"1,8","['1', ',', '8']","['DECIMAL_LITERAL', 'OPERATOR', 'DECIMAL_LITERAL']"
265,"1,9","['1', ',', '9']","['DECIMAL_LITERAL', 'OPERATOR', 'DECIMAL_LITERAL']"
266,"1,10","['1', ',', '10']","['DECIMAL_LITERAL', 'OPERATOR', 'DECIMAL_LITERAL']"
267,"1,11","['1', ',', '11']","['DECIMAL_LITERAL', 'OPERATOR', 'DECIMAL_LITERAL']"
268,"1,12","['1', ',', '12']","['DECIMAL_LITERAL', 'OPERATOR', 'DECIMAL_LITERAL']"
269,real    2m53.203s,"['real', '2', 'm53', '.', '203', 's']","['IDENTIFIER', 'DECIMAL_LITERAL', 'IDENTIFIER', 'OPERATOR', 'DECIMAL_LITERAL', 'IDENTIFIER']"
270,user    2m51.584s,"['user', '2', 'm51', '.', '584', 's']","['IDENTIFIER', 'DECIMAL_LITERAL', 'IDENTIFIER', 'OPERATOR', 'DECIMAL_LITERAL', 'IDENTIFIER']"
271,sys 0m1.628s,"['sys', '0', 'm1', '.', '628', 's']","['IDENTIFIER', 'OCTAL_LITERAL', 'IDENTIFIER', 'OPERATOR', 'DECIMAL_LITERAL', 'IDENTIFIER']"
272,$,['$'],['OPERATOR']
273,"

The orkut.go program with the ","['The', 'orkut.go', 'program', 'with', 'the']","['DT', 'JJ', 'NN', 'IN', 'DT']"
274,release-orkut-links.txt,"['release', '-', 'orkut', '-', 'links', '.', 'txt']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER']"
275," file (3,372,855,860 (3.4 GB) bytes with 223,534,301 edges) uses about 1.8 GiB of memory. After eliminating duplicates, 117,185,083 unique edges remain. This matches the 117,185,083 unique edge com-orkut.ungraph.txt file.

With 8 GB of memory on your machine, you can load much larger files.
","['file', '(3,372,855,860', '(3.4', 'GB)', 'bytes', 'with', '223,534,301', 'edges)', 'uses', 'about', '1.8', 'GiB', 'of', 'memory.', 'After', 'eliminating', 'duplicates,', '117,185,083', 'unique', 'edges', 'remain.', 'This', 'matches', 'the', '117,185,083', 'unique', 'edge', 'com-orkut.ungraph.txt', 'file.', 'With', '8', 'GB', 'of', 'memory', 'on', 'your', 'machine,', 'you', 'can', 'load', 'much', 'larger', 'files.']","['NN', 'NN', 'NNP', 'NNP', 'VBZ', 'IN', 'CD', 'JJ', 'NNS', 'IN', 'CD', 'NNP', 'IN', 'NN', 'IN', 'VBG', 'RB', 'CD', 'JJ', 'NNS', 'VBP', 'DT', 'VBZ', 'DT', 'CD', 'JJ', 'NN', 'JJ', 'NN', 'IN', 'CD', 'NNP', 'IN', 'NN', 'IN', 'PRP$', 'NN', 'PRP', 'MD', 'VB', 'RB', 'JJR', 'NN']"
