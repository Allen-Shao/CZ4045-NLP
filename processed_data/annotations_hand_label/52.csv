,text,token,annotation
0,"You missed one point only: you need to export the fields of your struct:

","['You', 'missed', 'one', 'point', 'only:', 'you', 'need', 'to', 'export', 'the', 'fields', 'of', 'your', 'struct:']","['PRP', 'VBD', 'CD', 'NN', 'NN', 'PRP', 'VBP', 'TO', 'VB', 'DT', 'NNS', 'IN', 'PRP$', 'NN']"
1,type PublicKey struct {,"['type', 'PublicKey', 'struct', '{']","['KEYWORD', 'IDENTIFIER', 'KEYWORD', 'PUNCTUATION']"
2,    Name  string,"['Name', 'string']","['IDENTIFIER', 'IDENTIFIER']"
3,    Price string,"['Price', 'string']","['IDENTIFIER', 'IDENTIFIER']"
4,},['}'],['PUNCTUATION']
5,"

And it will work (try it on the Go Playground):

","['And', 'it', 'will', 'work', '(try', 'it', 'on', 'the', 'Go', 'Playground):']","['CC', 'PRP', 'MD', 'VB', 'NN', 'PRP', 'IN', 'DT', 'NNP', 'NNP']"
6,[{Name:Galaxy Nexus Price:3460.00} {Name:Galaxy Nexus Price:3460.00}],"['[{', 'Name', ':', 'Galaxy', 'Nexus', 'Price', ':', '3460', '.', '0', '0', '}', '{', 'Name', ':', 'Galaxy', 'Nexus', 'Price', ':', '3460', '.', '0', '0', '}]']","['PUNCTUATION', 'IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'IDENTIFIER', 'IDENTIFIER', 'PUNCTUATION', 'DECIMAL_LITERAL', 'PUNCTUATION', 'OCTAL_LITERAL', 'OCTAL_LITERAL', 'PUNCTUATION', 'PUNCTUATION', 'IDENTIFIER', 'PUNCTUATION', 'IDENTIFIER', 'IDENTIFIER', 'IDENTIFIER', 'PUNCTUATION', 'DECIMAL_LITERAL', 'PUNCTUATION', 'OCTAL_LITERAL', 'OCTAL_LITERAL', 'PUNCTUATION']"
7,"

Note that the JSON text contains the field names with lowercased text, but the json package is ""clever"" enough to match them. If they would be completely different, you could use struct tags to tell the json package how they are found (or how they should be marshaled) in the JSON text, e.g.:

","['Note', 'that', 'the', 'JSON', 'text', 'contains', 'the', 'field', 'names', 'with', 'lowercased', 'text,', 'but', 'the', 'json', 'package', 'is', '""clever""', 'enough', 'to', 'match', 'them.', 'If', 'they', 'would', 'be', 'completely', 'different,', 'you', 'could', 'use', 'struct', 'tags', 'to', 'tell', 'the', 'json', 'package', 'how', 'they', 'are', 'found', '(or', 'how', 'they', 'should', 'be', 'marshaled)', 'in', 'the', 'JSON', 'text,', 'e.g.:']","['NN', 'IN', 'DT', 'NNP', 'NN', 'VBZ', 'DT', 'NN', 'RB', 'IN', 'JJ', 'NN', 'CC', 'DT', 'NN', 'NN', 'VBZ', 'JJ', 'RB', 'TO', 'VB', 'NN', 'IN', 'PRP', 'MD', 'VB', 'RB', 'IN', 'PRP', 'MD', 'VB', 'NN', 'NNS', 'TO', 'VB', 'DT', 'NN', 'VB', 'WRB', 'PRP', 'VBP', 'VBN', 'IN', 'WRB', 'PRP', 'MD', 'VB', 'VBN', 'IN', 'DT', 'NNP', 'NN', 'NN']"
8,type PublicKey struct {,"['type', 'PublicKey', 'struct', '{']","['KEYWORD', 'IDENTIFIER', 'KEYWORD', 'PUNCTUATION']"
9,"    Name  string `json:""some_name""`","['Name', 'string', 'json', ':', '""some_name""']","['IDENTIFIER', 'IDENTIFIER', 'IDENTIFIER', 'PUNCTUATION', 'STRING_LITERAL']"
10,"    Price string `json:""JsonPrice""`","['Price', 'string', 'json', ':', '""JsonPrice""']","['IDENTIFIER', 'IDENTIFIER', 'IDENTIFIER', 'PUNCTUATION', 'STRING_LITERAL']"
11,},['}'],['PUNCTUATION']
12,"

To parse your other JSON text, create a Go struct that models the JSON data. I suggest to format the JSON to see the real structure, e.g. you can use this online JSON formatter/validator. Then you can unmarshal into a slice of this struct.

Or simply unmarshal into a slice of maps, e.g. ","['To', 'parse', 'your', 'other', 'JSON', 'text,', 'create', 'a', 'Go', 'struct', 'that', 'models', 'the', 'JSON', 'data.', 'I', 'suggest', 'to', 'format', 'the', 'JSON', 'to', 'see', 'the', 'real', 'structure,', 'e.g.', 'you', 'can', 'use', 'this', 'online', 'JSON', 'formatter/validator.', 'Then', 'you', 'can', 'unmarshal', 'into', 'a', 'slice', 'of', 'this', 'struct.', 'Or', 'simply', 'unmarshal', 'into', 'a', 'slice', 'of', 'maps,', 'e.g.']","['TO', 'VB', 'PRP$', 'JJ', 'NNP', 'NN', 'NN', 'DT', 'NNP', 'NN', 'WDT', 'NNS', 'DT', 'NNP', 'NN', 'PRP', 'VBP', 'TO', 'VB', 'DT', 'NNP', 'TO', 'VB', 'DT', 'JJ', 'NN', 'IN', 'PRP', 'MD', 'VB', 'DT', 'NN', 'NNP', 'NN', 'RB', 'PRP', 'MD', 'VB', 'IN', 'DT', 'NN', 'IN', 'DT', 'NN', 'CC', 'RB', 'JJ', 'IN', 'DT', 'NN', 'IN', 'NN', 'NN']"
13,[]map[string]interface{},"['[]', 'map', '[', 'string', ']', 'interface', '{}']","['PUNCTUATION', 'KEYWORD', 'PUNCTUATION', 'IDENTIFIER', 'PUNCTUATION', 'KEYWORD', 'PUNCTUATION']"
14,", but then you need to index the map to get the different values, and you also need to use type assertion to get ""typed"" values.
","[',', 'but', 'then', 'you', 'need', 'to', 'index', 'the', 'map', 'to', 'get', 'the', 'different', 'values,', 'and', 'you', 'also', 'need', 'to', 'use', 'type', 'assertion', 'to', 'get', '""typed""', 'values.']","[',', 'CC', 'RB', 'PRP', 'VBP', 'TO', 'NN', 'DT', 'NN', 'TO', 'VB', 'DT', 'JJ', 'NN', 'CC', 'PRP', 'RB', 'VBP', 'TO', 'VB', 'JJ', 'NN', 'TO', 'VB', 'JJ', 'NN']"
