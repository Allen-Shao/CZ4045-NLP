,text,token,annotation
0,"UTF16, UTF8, and Byte Order Marks are defined by the Unicode Consortium: UTF-16 FAQ, UTF-8 FAQ, and Byte Order Mark (BOM) FAQ.




  Issue 4802: bufio: reading lines is too cumbersome
  
  Reading lines from a file is too cumbersome in Go.
  
  People are often drawn to bufio.Reader.ReadLine because of its name,
  but it has a weird signature, returning (line []byte, isPrefix bool,
  err error), and requires a lot of work.
  
  ReadSlice and ReadString require a delimiter byte, which is almost
  always the obvious and unsightly '\n', and also can return both a line
  and an EOF





  Revision: f685026a2d38
  
  bufio: new Scanner interface
  
  Add a new, simple interface for scanning (probably textual) data,
  based on a new type called Scanner. It does its own internal
  buffering, so should be plausibly efficient even without injecting a
  bufio.Reader. The format of the input is defined by a ""split
  function"", by default splitting into lines.





  go1.1beta1 released
  
  You can download binary and source distributions from the usual place:
      https://code.google.com/p/go/downloads/list?q=go1.1beta1




Here's a program which uses the Unicode rules to convert UTF16 text file lines to Go UTF8 encoded strings. The code has been revised to take advantage of the new bufio.Scanner interface in Go 1.1.

","['UTF16,', 'UTF8,', 'and', 'Byte', 'Order', 'Marks', 'are', 'defined', 'by', 'the', 'Unicode', 'Consortium:', 'UTF-16', 'FAQ,', 'UTF-8', 'FAQ,', 'and', 'Byte', 'Order', 'Mark', '(BOM)', 'FAQ.', 'Issue', '4802:', 'bufio:', 'reading', 'lines', 'is', 'too', 'cumbersome', 'Reading', 'lines', 'from', 'a', 'file', 'is', 'too', 'cumbersome', 'in', 'Go.', 'People', 'are', 'often', 'drawn', 'to', 'bufio.Reader.ReadLine', 'because', 'of', 'its', 'name,', 'but', 'it', 'has', 'a', 'weird', 'signature,', 'returning', '(line', '[]byte,', 'isPrefix', 'bool,', 'err', 'error),', 'and', 'requires', 'a', 'lot', 'of', 'work.', 'ReadSlice', 'and', 'ReadString', 'require', 'a', 'delimiter', 'byte,', 'which', 'is', 'almost', 'always', 'the', 'obvious', 'and', 'unsightly', ""'\\n',"", 'and', 'also', 'can', 'return', 'both', 'a', 'line', 'and', 'an', 'EOF', 'Revision:', 'f685026a2d38', 'bufio:', 'new', 'Scanner', 'interface', 'Add', 'a', 'new,', 'simple', 'interface', 'for', 'scanning', '(probably', 'textual)', 'data,', 'based', 'on', 'a', 'new', 'type', 'called', 'Scanner.', 'It', 'does', 'its', 'own', 'internal', 'buffering,', 'so', 'should', 'be', 'plausibly', 'efficient', 'even', 'without', 'injecting', 'a', 'bufio.Reader.', 'The', 'format', 'of', 'the', 'input', 'is', 'defined', 'by', 'a', '""split', 'function"",', 'by', 'default', 'splitting', 'into', 'lines.', 'go1.1beta1', 'released', 'You', 'can', 'download', 'binary', 'and', 'source', 'distributions', 'from', 'the', 'usual', 'place:', 'https://code.google.com/p/go/downloads/list?q=go1.1beta1', ""Here's"", 'a', 'program', 'which', 'uses', 'the', 'Unicode', 'rules', 'to', 'convert', 'UTF16', 'text', 'file', 'lines', 'to', 'Go', 'UTF8', 'encoded', 'strings.', 'The', 'code', 'has', 'been', 'revised', 'to', 'take', 'advantage', 'of', 'the', 'new', 'bufio.Scanner', 'interface', 'in', 'Go', '1.1.']","['NNP', 'NNP', 'CC', 'NNP', 'NNP', 'NNS', 'VBP', 'VBN', 'IN', 'DT', 'NNP', 'NNP', 'NNP', 'NNP', 'NNP', 'NNP', 'CC', 'NNP', 'NNP', 'NNP', 'NNP', 'NNP', 'NNP', 'CD', 'NN', 'NN', 'NNS', 'VBZ', 'RB', 'JJ', 'NNP', 'NNS', 'IN', 'DT', 'NN', 'VBZ', 'RB', 'JJ', 'IN', 'NNP', 'NNP', 'VBP', 'RB', 'VBN', 'TO', 'VB', 'IN', 'IN', 'PRP$', 'NN', 'CC', 'PRP', 'VBZ', 'DT', 'JJ', 'NN', 'VBG', 'JJ', 'NNP', 'NN', 'NN', 'NN', 'NN', 'CC', 'VBZ', 'DT', 'NN', 'IN', 'JJ', 'NNP', 'CC', 'NNP', 'VBP', 'DT', 'NN', 'NN', 'WDT', 'VBZ', 'RB', 'RB', 'DT', 'JJ', 'CC', 'RB', 'NNS', 'CC', 'RB', 'MD', 'VB', 'DT', 'DT', 'NN', 'CC', 'DT', 'NNP', 'NNP', 'VBD', 'JJ', 'JJ', 'NNP', 'NN', 'NNP', 'DT', 'JJ', 'JJ', 'NN', 'IN', 'VBG', 'RB', 'VB', 'NNS', 'VBN', 'IN', 'DT', 'JJ', 'NN', 'VBN', 'NNP', 'PRP', 'VBZ', 'PRP$', 'JJ', 'JJ', 'NN', 'RB', 'MD', 'VB', 'RB', 'JJ', 'RB', 'IN', 'VBG', 'DT', 'NN', 'DT', 'NN', 'IN', 'DT', 'NN', 'VBZ', 'VBN', 'IN', 'DT', 'JJ', 'NN', 'IN', 'NN', 'VBG', 'IN', 'JJ', 'NN', 'VBN', 'PRP', 'MD', 'VB', 'JJ', 'CC', 'NN', 'NNS', 'IN', 'DT', 'JJ', 'NN', 'NN', 'NNP', 'DT', 'NN', 'WDT', 'VBZ', 'DT', 'NNP', 'NNS', 'TO', 'VB', 'NNP', 'NN', 'NN', 'NNS', 'TO', 'VB', 'NNP', 'VBD', 'PDT', 'DT', 'NN', 'VBZ', 'VBN', 'VBN', 'TO', 'VB', 'NN', 'IN', 'DT', 'JJ', 'NN', 'NN', 'IN', 'NNP', 'CD']"
1,package main,"['package', 'main']","['KEYWORD', 'IDENTIFIER']"
2,import (,"['import', '(']","['KEYWORD', 'OPERATOR']"
3,"    ""bufio""","['""bufio""']",['STRING_LITERAL']
4,"    ""bytes""","['""bytes""']",['STRING_LITERAL']
5,"    ""encoding/binary""","['""encoding/binary""']",['STRING_LITERAL']
6,"    ""fmt""","['""fmt""']",['STRING_LITERAL']
7,"    ""os""","['""os""']",['STRING_LITERAL']
8,"    ""runtime""","['""runtime""']",['STRING_LITERAL']
9,"    ""unicode/utf16""","['""unicode/utf16""']",['STRING_LITERAL']
10,"    ""unicode/utf8""","['""unicode/utf8""']",['STRING_LITERAL']
11,),[')'],['OPERATOR']
12,"// UTF16BytesToString converts UTF-16 encoded bytes, in big or little endian byte order,","['//', 'UTF16BytesToString', 'converts', 'UTF-16', 'encoded', 'bytes,', 'in', 'big', 'or', 'little', 'endian', 'byte', 'order,']","['COMMENT', 'VBG', 'NNS', 'NNP', 'VBD', 'NN', 'IN', 'JJ', 'CC', 'JJ', 'JJ', 'NN', 'NN']"
13,// to a UTF-8 encoded string.,"['//', 'to', 'a', 'UTF-8', 'encoded', 'string.']","['COMMENT', 'TO', 'DT', 'NNP', 'VBD', 'NN']"
14,"func UTF16BytesToString(b []byte, o binary.ByteOrder) string {","['func', 'UTF16BytesToString', '(', 'b', '[]', 'byte', ',', 'o', 'binary', '.', 'ByteOrder', ')', 'string', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
15,"    utf := make([]uint16, (len(b)+(2-1))/2)","['utf', ':=', 'make', '([]', 'uint16', ',', '(', 'len', '(', 'b', ')+(', '2', '-', '1', '))', '2', ')']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'DECIMAL_LITERAL', 'OPERATOR', 'DECIMAL_LITERAL', 'OPERATOR', 'DECIMAL_LITERAL', 'OPERATOR']"
16,    for i := 0; i+(2-1) < len(b); i += 2 {,"['for', 'i', ':=', '0', ';', 'i', '+(', '2', '-', '1', ')', '<', 'len', '(', 'b', ');', 'i', '+=', '2', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'DECIMAL_LITERAL', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'DECIMAL_LITERAL', 'OPERATOR', 'DECIMAL_LITERAL', 'OPERATOR', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'DECIMAL_LITERAL', 'OPERATOR']"
17,        utf[i/2] = o.Uint16(b[i:]),"['utf', '[', 'i', '2', ']', '=', 'o', '.', 'Uint16', '(', 'b', '[', 'i', ':])']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'DECIMAL_LITERAL', 'OPERATOR', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
18,    },['}'],['OPERATOR']
19,    if len(b)/2 < len(utf) {,"['if', 'len', '(', 'b', ')', '2', '<', 'len', '(', 'utf', ')', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'DECIMAL_LITERAL', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'OPERATOR']"
20,        utf[len(utf)-1] = utf8.RuneError,"['utf', '[', 'len', '(', 'utf', ')-', '1', ']', '=', 'utf8', '.', 'RuneError']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'DECIMAL_LITERAL', 'OPERATOR', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER']"
21,    },['}'],['OPERATOR']
22,    return string(utf16.Decode(utf)),"['return', 'string', '(', 'utf16', '.', 'Decode', '(', 'utf', '))']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
23,},['}'],['OPERATOR']
24,// UTF-16 endian byte order,"['//', 'UTF-16', 'endian', 'byte', 'order']","['COMMENT', 'JJ', 'JJ', 'NN', 'NN']"
25,const (,"['const', '(']","['KEYWORD', 'OPERATOR']"
26,    unknownEndian = iota,"['unknownEndian', '=', 'iota']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER']"
27,    bigEndian,['bigEndian'],['IDENTIFIER']
28,    littleEndian,['littleEndian'],['IDENTIFIER']
29,),[')'],['OPERATOR']
30,// dropCREndian drops a terminal \r from the endian data.,"['//', 'dropCREndian', 'drops', 'a', 'terminal', '\\r', 'from', 'the', 'endian', 'data.']","['COMMENT', 'JJ', 'VBZ', 'DT', 'JJ', 'NN', 'IN', 'DT', 'JJ', 'NN']"
31,"func dropCREndian(data []byte, t1, t2 byte) []byte {","['func', 'dropCREndian', '(', 'data', '[]', 'byte', ',', 't1', ',', 't2', 'byte', ')', '[]', 'byte', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'IDENTIFIER', 'OPERATOR', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
32,    if len(data) > 1 {,"['if', 'len', '(', 'data', ')', '>', '1', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'OPERATOR', 'DECIMAL_LITERAL', 'OPERATOR']"
33,        if data[len(data)-2] == t1 && data[len(data)-1] == t2 {,"['if', 'data', '[', 'len', '(', 'data', ')-', '2', ']', '==', 't1', '&&', 'data', '[', 'len', '(', 'data', ')-', '1', ']', '==', 't2', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'DECIMAL_LITERAL', 'OPERATOR', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'DECIMAL_LITERAL', 'OPERATOR', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
34,            return data[0 : len(data)-2],"['return', 'data', '[', '0', ':', 'len', '(', 'data', ')-', '2', ']']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'DECIMAL_LITERAL', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'DECIMAL_LITERAL', 'OPERATOR']"
35,        },['}'],['OPERATOR']
36,    },['}'],['OPERATOR']
37,    return data,"['return', 'data']","['KEYWORD', 'IDENTIFIER']"
38,},['}'],['OPERATOR']
39,// dropCRBE drops a terminal \r from the big endian data.,"['//', 'dropCRBE', 'drops', 'a', 'terminal', '\\r', 'from', 'the', 'big', 'endian', 'data.']","['COMMENT', 'NN', 'VBZ', 'DT', 'JJ', 'NN', 'IN', 'DT', 'JJ', 'JJ', 'NN']"
40,func dropCRBE(data []byte) []byte {,"['func', 'dropCRBE', '(', 'data', '[]', 'byte', ')', '[]', 'byte', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
41,"    return dropCREndian(data, '\x00', '\r')","['return', 'dropCREndian', '(', 'data', ',', 'x00', ',', 'r', ')']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
42,},['}'],['OPERATOR']
43,// dropCRLE drops a terminal \r from the little endian data.,"['//', 'dropCRLE', 'drops', 'a', 'terminal', '\\r', 'from', 'the', 'little', 'endian', 'data.']","['COMMENT', 'NN', 'VBZ', 'DT', 'JJ', 'NN', 'IN', 'DT', 'JJ', 'JJ', 'NN']"
44,func dropCRLE(data []byte) []byte {,"['func', 'dropCRLE', '(', 'data', '[]', 'byte', ')', '[]', 'byte', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
45,"    return dropCREndian(data, '\r', '\x00')","['return', 'dropCREndian', '(', 'data', ',', 'r', ',', 'x00', ')']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
46,},['}'],['OPERATOR']
47,// dropCR drops a terminal \r from the data.,"['//', 'dropCR', 'drops', 'a', 'terminal', '\\r', 'from', 'the', 'data.']","['COMMENT', 'NN', 'VBZ', 'DT', 'JJ', 'NN', 'IN', 'DT', 'NN']"
48,"func dropCR(data []byte) ([]byte, int) {","['func', 'dropCR', '(', 'data', '[]', 'byte', ')', '([]', 'byte', ',', 'int', ')', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'OPERATOR']"
49,    var endian = unknownEndian,"['var', 'endian', '=', 'unknownEndian']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER']"
50,    switch ld := len(data); {,"['switch', 'ld', ':=', 'len', '(', 'data', ');', '{']","['IDENTIFIER', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'OPERATOR']"
51,    case ld != len(dropCRLE(data)):,"['case', 'ld', '!=', 'len', '(', 'dropCRLE', '(', 'data', ')):']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
52,        endian = littleEndian,"['endian', '=', 'littleEndian']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER']"
53,    case ld != len(dropCRBE(data)):,"['case', 'ld', '!=', 'len', '(', 'dropCRBE', '(', 'data', ')):']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
54,        endian = bigEndian,"['endian', '=', 'bigEndian']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER']"
55,    },['}'],['OPERATOR']
56,"    return data, endian","['return', 'data', ',', 'endian']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER']"
57,},['}'],['OPERATOR']
58,// SplitFunc is a split function for a Scanner that returns each line of,"['//', 'SplitFunc', 'is', 'a', 'split', 'function', 'for', 'a', 'Scanner', 'that', 'returns', 'each', 'line', 'of']","['COMMENT', 'NNP', 'VBZ', 'DT', 'NN', 'NN', 'IN', 'DT', 'NNP', 'IN', 'VBZ', 'DT', 'NN', 'IN']"
59,"// text, stripped of any trailing end-of-line marker. The returned line may","['//', 'text,', 'stripped', 'of', 'any', 'trailing', 'end-of-line', 'marker.', 'The', 'returned', 'line', 'may']","['COMMENT', 'NN', 'VBD', 'IN', 'DT', 'VBG', 'JJ', 'NN', 'DT', 'VBN', 'NN', 'MD']"
60,// be empty. The end-of-line marker is one optional carriage return followed,"['//', 'be', 'empty.', 'The', 'end-of-line', 'marker', 'is', 'one', 'optional', 'carriage', 'return', 'followed']","['COMMENT', 'VB', 'VBN', 'DT', 'JJ', 'NN', 'VBZ', 'CD', 'JJ', 'NN', 'NN', 'VBD']"
61,"// by one mandatory newline. In regular expression notation, it is `\r?\n`.","['//', 'by', 'one', 'mandatory', 'newline.', 'In', 'regular', 'expression', 'notation,', 'it', 'is', '`\\r?\\n`.']","['COMMENT', 'IN', 'CD', 'NN', 'NN', 'IN', 'JJ', 'NN', 'IN', 'PRP', 'VBZ', 'JJ']"
62,// The last non-empty line of input will be returned even if it has no,"['//', 'The', 'last', 'non-empty', 'line', 'of', 'input', 'will', 'be', 'returned', 'even', 'if', 'it', 'has', 'no']","['COMMENT', 'DT', 'JJ', 'JJ', 'NN', 'IN', 'NN', 'MD', 'VB', 'VBN', 'RB', 'IN', 'PRP', 'VBZ', 'DT']"
63,// newline.,"['//', 'newline.']","['COMMENT', 'NN']"
64,"func ScanUTF16LinesFunc(byteOrder binary.ByteOrder) (bufio.SplitFunc, func() binary.ByteOrder) {","['func', 'ScanUTF16LinesFunc', '(', 'byteOrder', 'binary', '.', 'ByteOrder', ')', '(', 'bufio', '.', 'SplitFunc', ',', 'func', '()', 'binary', '.', 'ByteOrder', ')', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'KEYWORD', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'OPERATOR']"
65,    // Function closure variables,"['//', 'Function', 'closure', 'variables']","['COMMENT', 'NNP', 'NN', 'NNS']"
66,    var endian = unknownEndian,"['var', 'endian', '=', 'unknownEndian']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER']"
67,    switch byteOrder {,"['switch', 'byteOrder', '{']","['IDENTIFIER', 'IDENTIFIER', 'OPERATOR']"
68,    case binary.BigEndian:,"['case', 'binary', '.', 'BigEndian', ':']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
69,        endian = bigEndian,"['endian', '=', 'bigEndian']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER']"
70,    case binary.LittleEndian:,"['case', 'binary', '.', 'LittleEndian', ':']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
71,        endian = littleEndian,"['endian', '=', 'littleEndian']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER']"
72,    },['}'],['OPERATOR']
73,    const bom = 0xFEFF,"['const', 'bom', '=', '0', 'xFEFF']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'DECIMAL_LITERAL', 'IDENTIFIER']"
74,    var checkBOM bool = endian == unknownEndian,"['var', 'checkBOM', 'bool', '=', 'endian', '==', 'unknownEndian']","['KEYWORD', 'IDENTIFIER', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER']"
75,    // Scanner split function,"['//', 'Scanner', 'split', 'function']","['COMMENT', 'NNP', 'NN', 'NN']"
76,"    splitFunc := func(data []byte, atEOF bool) (advance int, token []byte, err error) {","['splitFunc', ':=', 'func', '(', 'data', '[]', 'byte', ',', 'atEOF', 'bool', ')', '(', 'advance', 'int', ',', 'token', '[]', 'byte', ',', 'err', 'error', ')', '{']","['IDENTIFIER', 'OPERATOR', 'KEYWORD', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'IDENTIFIER', 'OPERATOR', 'OPERATOR', 'IDENTIFIER', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'IDENTIFIER', 'OPERATOR', 'OPERATOR']"
77,        if atEOF && len(data) == 0 {,"['if', 'atEOF', '&&', 'len', '(', 'data', ')', '==', '0', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'OPERATOR', 'DECIMAL_LITERAL', 'OPERATOR']"
78,"            return 0, nil, nil","['return', '0', ',', 'nil', ',', 'nil']","['KEYWORD', 'DECIMAL_LITERAL', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER']"
79,        },['}'],['OPERATOR']
80,        if checkBOM {,"['if', 'checkBOM', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR']"
81,            checkBOM = false,"['checkBOM', '=', 'false']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER']"
82,            if len(data) > 1 {,"['if', 'len', '(', 'data', ')', '>', '1', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'OPERATOR', 'DECIMAL_LITERAL', 'OPERATOR']"
83,                switch uint16(bom) {,"['switch', 'uint16', '(', 'bom', ')', '{']","['IDENTIFIER', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'OPERATOR']"
84,                case uint16(data[0])<<8 | uint16(data[1]):,"['case', 'uint16', '(', 'data', '[', '0', '])<<', '8', '|', 'uint16', '(', 'data', '[', '1', ']):']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'DECIMAL_LITERAL', 'OPERATOR', 'DECIMAL_LITERAL', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'DECIMAL_LITERAL', 'OPERATOR']"
85,                    endian = bigEndian,"['endian', '=', 'bigEndian']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER']"
86,"                    return 2, nil, nil","['return', '2', ',', 'nil', ',', 'nil']","['KEYWORD', 'DECIMAL_LITERAL', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER']"
87,                case uint16(data[1])<<8 | uint16(data[0]):,"['case', 'uint16', '(', 'data', '[', '1', '])<<', '8', '|', 'uint16', '(', 'data', '[', '0', ']):']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'DECIMAL_LITERAL', 'OPERATOR', 'DECIMAL_LITERAL', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'DECIMAL_LITERAL', 'OPERATOR']"
88,                    endian = littleEndian,"['endian', '=', 'littleEndian']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER']"
89,"                    return 2, nil, nil","['return', '2', ',', 'nil', ',', 'nil']","['KEYWORD', 'DECIMAL_LITERAL', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER']"
90,                },['}'],['OPERATOR']
91,            },['}'],['OPERATOR']
92,        },['}'],['OPERATOR']
93,        // Scan for newline-terminated lines.,"['//', 'Scan', 'for', 'newline-terminated', 'lines.']","['COMMENT', 'JJ', 'IN', 'JJ', 'NN']"
94,        i := 0,"['i', ':=', '0']","['IDENTIFIER', 'OPERATOR', 'DECIMAL_LITERAL']"
95,        for {,"['for', '{']","['KEYWORD', 'OPERATOR']"
96,"            j := bytes.IndexByte(data[i:], '\n')","['j', ':=', 'bytes', '.', 'IndexByte', '(', 'data', '[', 'i', ':],', 'n', ')']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
97,            if j < 0 {,"['if', 'j', '<', '0', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'DECIMAL_LITERAL', 'OPERATOR']"
98,                break,['break'],['KEYWORD']
99,            },['}'],['OPERATOR']
100,            i += j,"['i', '+=', 'j']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER']"
101,            switch e := i % 2; e {,"['switch', 'e', ':=', 'i', '2', ';', 'e', '{']","['IDENTIFIER', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'DECIMAL_LITERAL', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
102,            case 1: // UTF-16BE,"['//', 'UTF-16BE']","['KEYWORD', 'DECIMAL_LITERAL', 'OPERATOR', 'COMMENT', 'JJ']"
103,                if endian != littleEndian {,"['if', 'endian', '!=', 'littleEndian', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
104,                    if i > 1 {,"['if', 'i', '>', '1', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'DECIMAL_LITERAL', 'OPERATOR']"
105,                        if data[i-1] == '\x00' {,"['if', 'data', '[', 'i', '-', '1', ']', '==', 'x00', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'DECIMAL_LITERAL', 'OPERATOR', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
106,                            endian = bigEndian,"['endian', '=', 'bigEndian']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER']"
107,                            // We have a full newline-terminated line.,"['//', 'We', 'have', 'a', 'full', 'newline-terminated', 'line.']","['COMMENT', 'PRP', 'VBP', 'DT', 'JJ', 'JJ', 'NN']"
108,"                            return i + 1, dropCRBE(data[0 : i-1]), nil","['return', 'i', '+', '1', ',', 'dropCRBE', '(', 'data', '[', '0', ':', 'i', '-', '1', ']),', 'nil']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'DECIMAL_LITERAL', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'DECIMAL_LITERAL', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'DECIMAL_LITERAL', 'OPERATOR', 'IDENTIFIER']"
109,                        },['}'],['OPERATOR']
110,                    },['}'],['OPERATOR']
111,                },['}'],['OPERATOR']
112,            case 0: // UTF-16LE,"['//', 'UTF-16LE']","['KEYWORD', 'DECIMAL_LITERAL', 'OPERATOR', 'COMMENT', 'JJ']"
113,                if endian != bigEndian {,"['if', 'endian', '!=', 'bigEndian', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
114,                    if i+1 < len(data) {,"['if', 'i', '+', '1', '<', 'len', '(', 'data', ')', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'DECIMAL_LITERAL', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'OPERATOR']"
115,                        i++,"['i', '++']","['IDENTIFIER', 'OPERATOR']"
116,                        if data[i] == '\x00' {,"['if', 'data', '[', 'i', ']', '==', 'x00', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
117,                            endian = littleEndian,"['endian', '=', 'littleEndian']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER']"
118,                            // We have a full newline-terminated line.,"['//', 'We', 'have', 'a', 'full', 'newline-terminated', 'line.']","['COMMENT', 'PRP', 'VBP', 'DT', 'JJ', 'JJ', 'NN']"
119,"                            return i + 1, dropCRLE(data[0 : i-1]), nil","['return', 'i', '+', '1', ',', 'dropCRLE', '(', 'data', '[', '0', ':', 'i', '-', '1', ']),', 'nil']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'DECIMAL_LITERAL', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'DECIMAL_LITERAL', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'DECIMAL_LITERAL', 'OPERATOR', 'IDENTIFIER']"
120,                        },['}'],['OPERATOR']
121,                    },['}'],['OPERATOR']
122,                },['}'],['OPERATOR']
123,            },['}'],['OPERATOR']
124,            i++,"['i', '++']","['IDENTIFIER', 'OPERATOR']"
125,        },['}'],['OPERATOR']
126,"        // If we're at EOF, we have a final, non-terminated line. Return it.","['//', 'If', ""we're"", 'at', 'EOF,', 'we', 'have', 'a', 'final,', 'non-terminated', 'line.', 'Return', 'it.']","['COMMENT', 'IN', 'VBN', 'IN', 'NNP', 'PRP', 'VBP', 'DT', 'JJ', 'JJ', 'NN', 'NNP', 'NN']"
127,        if atEOF {,"['if', 'atEOF', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR']"
128,            // drop CR.,"['//', 'drop', 'CR.']","['COMMENT', 'NN', 'NNP']"
129,            advance = len(data),"['advance', '=', 'len', '(', 'data', ')']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
130,            switch endian {,"['switch', 'endian', '{']","['IDENTIFIER', 'IDENTIFIER', 'OPERATOR']"
131,            case bigEndian:,"['case', 'bigEndian', ':']","['KEYWORD', 'IDENTIFIER', 'OPERATOR']"
132,                data = dropCRBE(data),"['data', '=', 'dropCRBE', '(', 'data', ')']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
133,            case littleEndian:,"['case', 'littleEndian', ':']","['KEYWORD', 'IDENTIFIER', 'OPERATOR']"
134,                data = dropCRLE(data),"['data', '=', 'dropCRLE', '(', 'data', ')']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
135,            default:,"['default', ':']","['KEYWORD', 'OPERATOR']"
136,"                data, endian = dropCR(data)","['data', ',', 'endian', '=', 'dropCR', '(', 'data', ')']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
137,            },['}'],['OPERATOR']
138,            if endian == unknownEndian {,"['if', 'endian', '==', 'unknownEndian', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
139,"                if runtime.GOOS == ""windows"" {","['if', 'runtime', '.', 'GOOS', '==', '""windows""', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'STRING_LITERAL', 'OPERATOR']"
140,                    endian = littleEndian,"['endian', '=', 'littleEndian']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER']"
141,                } else {,"['}', 'else', '{']","['OPERATOR', 'KEYWORD', 'OPERATOR']"
142,                    endian = bigEndian,"['endian', '=', 'bigEndian']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER']"
143,                },['}'],['OPERATOR']
144,            },['}'],['OPERATOR']
145,"            return advance, data, nil","['return', 'advance', ',', 'data', ',', 'nil']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER']"
146,        },['}'],['OPERATOR']
147,        // Request more data.,"['//', 'Request', 'more', 'data.']","['COMMENT', 'NNP', 'JJR', 'NN']"
148,"        return 0, nil, nil","['return', '0', ',', 'nil', ',', 'nil']","['KEYWORD', 'DECIMAL_LITERAL', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER']"
149,    },['}'],['OPERATOR']
150,    // Endian byte order function,"['//', 'Endian', 'byte', 'order', 'function']","['COMMENT', 'JJ', 'NN', 'NN', 'NN']"
151,    orderFunc := func() (byteOrder binary.ByteOrder) {,"['orderFunc', ':=', 'func', '()', '(', 'byteOrder', 'binary', '.', 'ByteOrder', ')', '{']","['IDENTIFIER', 'OPERATOR', 'KEYWORD', 'OPERATOR', 'OPERATOR', 'IDENTIFIER', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'OPERATOR']"
152,        switch endian {,"['switch', 'endian', '{']","['IDENTIFIER', 'IDENTIFIER', 'OPERATOR']"
153,        case bigEndian:,"['case', 'bigEndian', ':']","['KEYWORD', 'IDENTIFIER', 'OPERATOR']"
154,            byteOrder = binary.BigEndian,"['byteOrder', '=', 'binary', '.', 'BigEndian']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER']"
155,        case littleEndian:,"['case', 'littleEndian', ':']","['KEYWORD', 'IDENTIFIER', 'OPERATOR']"
156,            byteOrder = binary.LittleEndian,"['byteOrder', '=', 'binary', '.', 'LittleEndian']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER']"
157,        },['}'],['OPERATOR']
158,        return byteOrder,"['return', 'byteOrder']","['KEYWORD', 'IDENTIFIER']"
159,    },['}'],['OPERATOR']
160,"    return splitFunc, orderFunc","['return', 'splitFunc', ',', 'orderFunc']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER']"
161,},['}'],['OPERATOR']
162,func main() {,"['func', 'main', '()', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'OPERATOR']"
163,"    file, err := os.Open(""utf16.le.txt"")","['file', ',', 'err', ':=', 'os', '.', 'Open', '(', '""utf16.le.txt""', ')']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'STRING_LITERAL', 'OPERATOR']"
164,    if err != nil {,"['if', 'err', '!=', 'nil', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
165,        fmt.Println(err),"['fmt', '.', 'Println', '(', 'err', ')']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
166,        os.Exit(1),"['os', '.', 'Exit', '(', '1', ')']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'DECIMAL_LITERAL', 'OPERATOR']"
167,    },['}'],['OPERATOR']
168,    defer file.Close(),"['defer', 'file', '.', 'Close', '()']","['IDENTIFIER', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
169,    fmt.Println(file.Name()),"['fmt', '.', 'Println', '(', 'file', '.', 'Name', '())']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
170,    rdr := bufio.NewReader(file),"['rdr', ':=', 'bufio', '.', 'NewReader', '(', 'file', ')']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
171,    scanner := bufio.NewScanner(rdr),"['scanner', ':=', 'bufio', '.', 'NewScanner', '(', 'rdr', ')']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
172,"    var bo binary.ByteOrder // unknown, infer from data","['//', 'unknown,', 'infer', 'from', 'data']","['KEYWORD', 'IDENTIFIER', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'COMMENT', 'JJ', 'NN', 'IN', 'NNS']"
173,    // bo = binary.LittleEndian // windows,"['//', 'bo', '=', 'binary.LittleEndian', 'windows']","['COMMENT', 'NN', 'NN', 'JJ', 'NNS']"
174,"    splitFunc, orderFunc := ScanUTF16LinesFunc(bo)","['splitFunc', ',', 'orderFunc', ':=', 'ScanUTF16LinesFunc', '(', 'bo', ')']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
175,    scanner.Split(splitFunc),"['scanner', '.', 'Split', '(', 'splitFunc', ')']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
176,    for scanner.Scan() {,"['for', 'scanner', '.', 'Scan', '()', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'OPERATOR']"
177,        b := scanner.Bytes(),"['b', ':=', 'scanner', '.', 'Bytes', '()']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
178,"        s := UTF16BytesToString(b, orderFunc())","['s', ':=', 'UTF16BytesToString', '(', 'b', ',', 'orderFunc', '())']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
179,"        fmt.Println(len(s), s)","['fmt', '.', 'Println', '(', 'len', '(', 's', '),', 's', ')']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
180,"        fmt.Println(len(b), b)","['fmt', '.', 'Println', '(', 'len', '(', 'b', '),', 'b', ')']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
181,    },['}'],['OPERATOR']
182,    fmt.Println(orderFunc()),"['fmt', '.', 'Println', '(', 'orderFunc', '())']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
183,    if err := scanner.Err(); err != nil {,"['if', 'err', ':=', 'scanner', '.', 'Err', '();', 'err', '!=', 'nil', '{']","['KEYWORD', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
184,        fmt.Println(err),"['fmt', '.', 'Println', '(', 'err', ')']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR']"
185,    },['}'],['OPERATOR']
186,},['}'],['OPERATOR']
187,"

Output:

",['Output:'],['NN']
188,utf16.le.txt,"['utf16', '.', 'le', '.', 'txt']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER']"
189,"15 ""Hello, 世界""","['15', '""Hello, 世界""']","['DECIMAL_LITERAL', 'STRING_LITERAL']"
190,22 [34 0 72 0 101 0 108 0 108 0 111 0 44 0 32 0 22 78 76 117 34 0],"['22', '[', '34', '0', '72', '0', '101', '0', '108', '0', '108', '0', '111', '0', '44', '0', '32', '0', '22', '78', '76', '117', '34', '0', ']']","['DECIMAL_LITERAL', 'OPERATOR', 'DECIMAL_LITERAL', 'DECIMAL_LITERAL', 'DECIMAL_LITERAL', 'DECIMAL_LITERAL', 'DECIMAL_LITERAL', 'DECIMAL_LITERAL', 'DECIMAL_LITERAL', 'DECIMAL_LITERAL', 'DECIMAL_LITERAL', 'DECIMAL_LITERAL', 'DECIMAL_LITERAL', 'DECIMAL_LITERAL', 'DECIMAL_LITERAL', 'DECIMAL_LITERAL', 'DECIMAL_LITERAL', 'DECIMAL_LITERAL', 'DECIMAL_LITERAL', 'DECIMAL_LITERAL', 'DECIMAL_LITERAL', 'DECIMAL_LITERAL', 'DECIMAL_LITERAL', 'DECIMAL_LITERAL', 'OPERATOR']"
191,0 ,['0'],['DECIMAL_LITERAL']
192,0 [],"['0', '[]']","['DECIMAL_LITERAL', 'OPERATOR']"
193,"15 ""Hello, 世界""","['15', '""Hello, 世界""']","['DECIMAL_LITERAL', 'STRING_LITERAL']"
194,22 [34 0 72 0 101 0 108 0 108 0 111 0 44 0 32 0 22 78 76 117 34 0],"['22', '[', '34', '0', '72', '0', '101', '0', '108', '0', '108', '0', '111', '0', '44', '0', '32', '0', '22', '78', '76', '117', '34', '0', ']']","['DECIMAL_LITERAL', 'OPERATOR', 'DECIMAL_LITERAL', 'DECIMAL_LITERAL', 'DECIMAL_LITERAL', 'DECIMAL_LITERAL', 'DECIMAL_LITERAL', 'DECIMAL_LITERAL', 'DECIMAL_LITERAL', 'DECIMAL_LITERAL', 'DECIMAL_LITERAL', 'DECIMAL_LITERAL', 'DECIMAL_LITERAL', 'DECIMAL_LITERAL', 'DECIMAL_LITERAL', 'DECIMAL_LITERAL', 'DECIMAL_LITERAL', 'DECIMAL_LITERAL', 'DECIMAL_LITERAL', 'DECIMAL_LITERAL', 'DECIMAL_LITERAL', 'DECIMAL_LITERAL', 'DECIMAL_LITERAL', 'DECIMAL_LITERAL', 'OPERATOR']"
195,LittleEndian,['LittleEndian'],['IDENTIFIER']
196,utf16.be.txt,"['utf16', '.', 'be', '.', 'txt']","['IDENTIFIER', 'OPERATOR', 'IDENTIFIER', 'OPERATOR', 'IDENTIFIER']"
197,"15 ""Hello, 世界""","['15', '""Hello, 世界""']","['DECIMAL_LITERAL', 'STRING_LITERAL']"
198,22 [0 34 0 72 0 101 0 108 0 108 0 111 0 44 0 32 78 22 117 76 0 34],"['22', '[', '0', '34', '0', '72', '0', '101', '0', '108', '0', '108', '0', '111', '0', '44', '0', '32', '78', '22', '117', '76', '0', '34', ']']","['DECIMAL_LITERAL', 'OPERATOR', 'DECIMAL_LITERAL', 'DECIMAL_LITERAL', 'DECIMAL_LITERAL', 'DECIMAL_LITERAL', 'DECIMAL_LITERAL', 'DECIMAL_LITERAL', 'DECIMAL_LITERAL', 'DECIMAL_LITERAL', 'DECIMAL_LITERAL', 'DECIMAL_LITERAL', 'DECIMAL_LITERAL', 'DECIMAL_LITERAL', 'DECIMAL_LITERAL', 'DECIMAL_LITERAL', 'DECIMAL_LITERAL', 'DECIMAL_LITERAL', 'DECIMAL_LITERAL', 'DECIMAL_LITERAL', 'DECIMAL_LITERAL', 'DECIMAL_LITERAL', 'DECIMAL_LITERAL', 'DECIMAL_LITERAL', 'OPERATOR']"
199,0 ,['0'],['DECIMAL_LITERAL']
200,0 [],"['0', '[]']","['DECIMAL_LITERAL', 'OPERATOR']"
201,"15 ""Hello, 世界""","['15', '""Hello, 世界""']","['DECIMAL_LITERAL', 'STRING_LITERAL']"
202,22 [0 34 0 72 0 101 0 108 0 108 0 111 0 44 0 32 78 22 117 76 0 34],"['22', '[', '0', '34', '0', '72', '0', '101', '0', '108', '0', '108', '0', '111', '0', '44', '0', '32', '78', '22', '117', '76', '0', '34', ']']","['DECIMAL_LITERAL', 'OPERATOR', 'DECIMAL_LITERAL', 'DECIMAL_LITERAL', 'DECIMAL_LITERAL', 'DECIMAL_LITERAL', 'DECIMAL_LITERAL', 'DECIMAL_LITERAL', 'DECIMAL_LITERAL', 'DECIMAL_LITERAL', 'DECIMAL_LITERAL', 'DECIMAL_LITERAL', 'DECIMAL_LITERAL', 'DECIMAL_LITERAL', 'DECIMAL_LITERAL', 'DECIMAL_LITERAL', 'DECIMAL_LITERAL', 'DECIMAL_LITERAL', 'DECIMAL_LITERAL', 'DECIMAL_LITERAL', 'DECIMAL_LITERAL', 'DECIMAL_LITERAL', 'DECIMAL_LITERAL', 'DECIMAL_LITERAL', 'OPERATOR']"
203,BigEndian,['BigEndian'],['IDENTIFIER']
