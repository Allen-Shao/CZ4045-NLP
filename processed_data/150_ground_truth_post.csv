PostId,Body
24159413,"Recently I started writing some tests for sending emails in my Google App Engine Go application. Part of the email sending process is saving the email in the datastore with this function:

func PutInDatastoreFull(c appengine.Context, kind, stringID string, intID int64, parent *datastore.Key, variable interface{}) (*datastore.Key, error) {
    k := datastore.NewKey(c, kind, stringID, intID, parent)
    key, err := datastore.Put(c, k, variable)
    return key, err
}


My tests query the datastore with this function:

func QueryGetAllWithLimit(c appengine.Context, kind string, limit int, dst interface{}) ([]*datastore.Key, error) {
    q := datastore.NewQuery(kind).Limit(limit)
    return q.GetAll(c, dst)
}


When I run it in development environment, it returns last emails without a problem. However, when I run it with goapp test, it returns no error and no data. Is this an expected behaviour for the testing environment, or did I just find some bug?

EDIT:

The test is:

//Testing file
func TestEmails(t *testing.T) {
    c, err := aetest.NewContext(nil)
    if err != nil {
        t.Fatal(err)
    }
    defer c.Close()

    err := NotifyAdminOfLowBalance(c, []string{""WARNING1"", ""WARNING2""})
    if err != nil {
        t.Fatal(err)
    }
    emails, err := Data.LoadLastEmails(c, 100)
    if err != nil {
        t.Fatal(err)
    }
    if len(emails) == 0 { //test fails here
        t.Fatal(""len(emails)==0"")
    }
}

//Production code
func NotifyAdminOfLowBalance(c appengine.Context, warnings []string) error {
    not := Notification{}
    not.Warnings = warnings

    buff := new(bytes.Buffer)
    err := LowBalanceTemplate.Execute(buff, not);
    if err != nil {
        c.Errorf(""Backend Notifications - NotifyAdminOfLowBalance - error 1 - %v"", err)
        return err
    }
    emailBody := buff.String()
    c.Debugf(""Backend Notifications - emailBody - %v"", emailBody)
    emailSubject := ""Low balance!""
    err = Email.SendHTMLEmail(c, emailSubject, DEFINE.AdminEmails, DEFINE.EmailSender, emailBody)
    if err != nil {
        c.Errorf(""Backend Notifications - NotifyAdminOfLowBalance - error 2 - %v"", err)
        return err
    }
    err = Data.CreateAndSaveEmail(c, emailBody, emailSubject, ""ADMIN"", """", """", """")
    if err != nil {
        c.Errorf(""Backend Notifications - NotifyAdminOfLowBalance - error 3 - %v"", err)
        return err
    }
    return nil
}



//Data/Email.go file:
var EmailStr string = ""Email""

type Email struct {
    //Class for handling Emails of what is happening in the system
    EmailID           string //ISO date?
    Timestamp         time.Time
    Body              string `datastore:""-""`
    BodyByte          []byte
    Subject           string
    UserEmail         string
    RippleTxID        string
    CoinTxID          string
    Currency          string
}

func (l *Email) LoadStrings() {
    l.Body = mymath.Hex2ASCII(l.BodyByte)
}

func CreateAndSaveEmail(c appengine.Context, body, subject, userEmail, rippleTx, coinTx, currency string) error {
    email := new(Email)
    email.Timestamp = time.Now()
    email.EmailID = email.Timestamp.Format(""2006-01-02T15:04:05:"")+mymath.Int2Str(email.Timestamp.Nanosecond())
    email.Body = body
    email.BodyByte = mymath.ASCII2Hex(body)
    email.Subject = subject
    email.UserEmail = userEmail
    email.RippleTxID = rippleTx
    email.CoinTxID = coinTx
    email.Currency = currency

    keys, err := Datastore.PutInDatastoreFull(c, EmailStr, email.EmailID, 0, nil, email)
    c.Debugf(""keys - %v, err - %v"", keys, err)
    if err != nil {
        c.Errorf(""Email - CreateAndSaveEmail error 1 - %v"", err)
        return err
    }
    return nil
}

func LoadLastEmails(c appengine.Context, count int) ([]Email, error) {
    c.Debugf(""LoadLastEmails - %v"", count)
    dst := []Email{}
    keys, err := Datastore.QueryGetAllWithLimit(c, EmailStr, count, &dst)
    c.Debugf(""keys - %v, err - %v"", keys, err)
    if err != nil {
        c.Errorf(""Email - LoadLastEmails error 1 - %v"", err)
        return nil, err
    }
    c.Debugf(""dst - %v"", dst)
    return dst, nil
}


And the Datastore functions were already included above
"
39333942,"How do you fix empty package path error? It's unclear to me which package has the issue or how to fix. 

vendor/vendor.json json file.

{
    ""comment"": """",
    ""heroku"": {
        ""goVersion"": ""go1.6"",
        ""install"": [
            "".""
        ]
    },
    ""ignore"": ""test"",
    ""package"": [
        {
            ""path"": ""context"",
            ""revision"": """"
        },
        {
            ""checksumSHA1"": ""eJQuyvuWx82bVvH0+b7a1AOQGqs="",
            ""path"": ""github.com/ChimeraCoder/anaconda"",
            ""revision"": ""00ecb7b4510497dc28cd46a598007ab8fe01f889"",
            ""revisionTime"": ""2016-06-04T23:38:44Z""
        },
        {
            ""checksumSHA1"": ""xE9Zo5ubzdEVBeRf+yD/ZjLALHk="",
            ""path"": ""github.com/ChimeraCoder/tokenbucket"",
            ""revision"": ""c5a927568de7aad8a58127d80bcd36ca4e71e454"",
            ""revisionTime"": ""2013-12-01T22:36:12Z""
        },
        {
            ""checksumSHA1"": ""3RgReu+42CU1EQ6afDsVSvBuPyk="",
            ""path"": ""github.com/azr/backoff"",
            ""revision"": ""53511d3c733003985b0b76f733df1f4d0095ee6a"",
            ""revisionTime"": ""2016-01-15T11:51:03Z""
        },
        {
            ""checksumSHA1"": ""bO0ErJXuVJ7s7DS4AJlN55op8cM="",
            ""path"": ""github.com/dghubble/oauth1"",
            ""revision"": ""d9f485600d309576dfa9764424f537e1f254d9a1"",
            ""revisionTime"": ""2016-08-21T06:27:25Z""
        },
        {
            ""checksumSHA1"": ""ycg56E+pTPAHToKMIj8C5SZ+WYQ="",
            ""path"": ""github.com/dustin/go-jsonpointer"",
            ""revision"": ""ba0abeacc3dcca5b9b20f31509c46794edbc9965"",
            ""revisionTime"": ""2016-08-14T07:29:49Z""
        },
        {
            ""checksumSHA1"": ""2138MttIW/b+UkA4YMYcTc6yzOU="",
            ""path"": ""github.com/dustin/gojson"",
            ""revision"": ""2e71ec9dd5adce3b168cd0dbde03b5cc04951c30"",
            ""revisionTime"": ""2016-03-07T16:12:27Z""
        },
        {
            ""checksumSHA1"": ""PYBCaIzh3RFkxtkkP8x4XCEYLCg="",
            ""path"": ""github.com/garyburd/go-oauth/oauth"",
            ""revision"": ""719b069913e1151a73ea30d2ea4f90deda3ce234"",
            ""revisionTime"": ""2016-04-12T16:13:20Z""
        },
        {
            ""checksumSHA1"": ""mOUDsWfYLlh8f6ekwyIUo3+4xJI="",
            ""path"": ""goji.io"",
            ""revision"": ""e355964ac565b94cf0fc7f218346626529125086"",
            ""revisionTime"": ""2016-05-07T21:13:57Z""
        },
        {
            ""checksumSHA1"": ""Jf3C/refSMB2wVYGp1pssKXVNcI="",
            ""path"": ""goji.io/internal"",
            ""revision"": ""e355964ac565b94cf0fc7f218346626529125086"",
            ""revisionTime"": ""2016-05-07T21:13:57Z""
        },
        {
            ""checksumSHA1"": ""gHp/Mv7vgZWs7iq/F0YHnWgEotQ="",
            ""path"": ""goji.io/pat"",
            ""revision"": ""e355964ac565b94cf0fc7f218346626529125086"",
            ""revisionTime"": ""2016-05-07T21:13:57Z""
        },
        {
            ""checksumSHA1"": ""z2zVlHamw4ufyuSaf49reuusrmg="",
            ""path"": ""goji.io/pattern"",
            ""revision"": ""e355964ac565b94cf0fc7f218346626529125086"",
            ""revisionTime"": ""2016-05-07T21:13:57Z""
        },
        {
            ""checksumSHA1"": ""9jjO5GjLa0XF/nfWihF02RoH4qc="",
            ""path"": ""golang.org/x/net/context"",
            ""revision"": ""6c89f9617983ee917132513a791d8b5850fe90c5"",
            ""revisionTime"": ""2016-08-24T21:03:21Z""
        }
    ],
    ""rootPath"": ""thinkwire.com/thw1""
}


Full stack trace.

$ govendor fetch lib/pq
panic: Empty package path

goroutine 1 [running]:
panic(0x4b9c20, 0xc8200123e0)
    /usr/local/Cellar/go/1.6.2/libexec/src/runtime/panic.go:481 +0x3e6
github.com/kardianos/govendor/context.(*Context).setPackage(0xc820122000, 0xc820326420, 0x26, 0xc82029d5a0, 0x0, 0xc82029d5a0, 0x0, 0xc820112060, 0x26, 0x10201, ...)
    $GOPATH/src/github.com/kardianos/govendor/context/resolve.go:335 +0x8ba
github.com/kardianos/govendor/context.(*Context).addSingleImport(0xc820122000, 0xc8203189c0, 0x2b, 0xc82029d5a0, 0x0, 0x0, 0x0, 0x0, 0x0)
    $GOPATH/src/github.com/kardianos/govendor/context/resolve.go:383 +0x457
github.com/kardianos/govendor/context.(*Context).addFileImports(0xc820122000, 0xc8203189c0, 0x30, 0xc820118080, 0x15, 0x27, 0x0, 0x0)
    $GOPATH/src/github.com/kardianos/govendor/context/resolve.go:251 +0x13e8
github.com/kardianos/govendor/context.(*Context).loadPackage.func1(0xc8203189c0, 0x30, 0xda5950, 0xc820312820, 0x0, 0x0, 0x0, 0x0)
    $GOPATH/src/github.com/kardianos/govendor/context/resolve.go:55 +0x150
github.com/kardianos/govendor/internal/vfilepath.walk(0xc8203189c0, 0x30, 0xda5950, 0xc820312820, 0xc820118780, 0x0, 0x0)
    $GOPATH/src/github.com/kardianos/govendor/internal/vfilepath/walk.go:19 +0x80
github.com/kardianos/govendor/internal/vfilepath.walk(0xc8203188a0, 0x2a, 0xda5950, 0xc820312680, 0xc820118780, 0x0, 0x0)
    $GOPATH/src/github.com/kardianos/govendor/internal/vfilepath/walk.go:44 +0x4f5
github.com/kardianos/govendor/internal/vfilepath.walk(0xc820112990, 0x27, 0xda5950, 0xc820134680, 0xc820118780, 0x0, 0x0)
    $GOPATH/src/github.com/kardianos/govendor/internal/vfilepath/walk.go:44 +0x4f5
github.com/kardianos/govendor/internal/vfilepath.Walk(0xc820112990, 0x27, 0xc820118780, 0x0, 0x0)
    $GOPATH/src/github.com/kardianos/govendor/internal/vfilepath/walk.go:82 +0xe1
github.com/kardianos/govendor/context.(*Context).loadPackage(0xc820122000, 0x0, 0x0)
    $GOPATH/src/github.com/kardianos/govendor/context/resolve.go:72 +0x19a
github.com/kardianos/govendor/context.(*Context).modify(0xc820122000, 0xc820120140, 0x7fff5fbff804, 0xc8200f77e5, 0x0, 0x3, 0x0, 0x0)
    $GOPATH/src/github.com/kardianos/govendor/context/modify.go:232 +0xfcf
github.com/kardianos/govendor/context.(*Context).ModifyImport(0xc820122000, 0xc820120140, 0xc82000a204, 0xc8200f77e5, 0x0, 0x3, 0x0, 0x0)
    $GOPATH/src/github.com/kardianos/govendor/context/modify.go:183 +0x23b
github.com/kardianos/govendor/run.(*runner).Modify(0xc8200f7d50, 0xda51c0, 0xc82002a010, 0xc82000a260, 0x1, 0x1, 0x81de04, 0xda5808, 0xc8200f7db7, 0x12ec8, ...)
    $GOPATH/src/github.com/kardianos/govendor/run/modify.go:105 +0x9e7
github.com/kardianos/govendor/run.(*runner).run(0xc8200f7d50, 0xda51c0, 0xc82002a010, 0xc82000a240, 0x3, 0x3, 0xda5808, 0xc8200f7db7, 0xda5808, 0x0, ...)
    $GOPATH/src/github.com/kardianos/govendor/run/run.go:83 +0x662
github.com/kardianos/govendor/run.Run(0xda51c0, 0xc82002a010, 0xc82000a240, 0x3, 0x3, 0xda5808, 0xc8200f7db7, 0x0, 0x0, 0x0)
    $GOPATH/src/github.com/kardianos/govendor/run/run.go:41 +0x95
main.main()
    $GOPATH/src/github.com/kardianos/govendor/main.go:35 +0x453

"
10369513,"(Very detailed problem report -- tl;dr at the bottom!)

I really prefer GLFW to Glut and want to get its Golang binding working under Windows 64-bit with Go 1.0.1 64-bit. Under Linux, the binding it works flawlessly. This is in principle doable under Windows -- GitHub user chsc has managed to do so, but he's on Win32 and his tips didn't resolve my issues yet. However I do have a complete and clean Mingw64 set up based on tdm64-gcc-4.6.1.

Now here's the strange thing -- getting the freeglut binding to work under 64-bit Windows, 64-bit Go 1.0.1 works -- the glfw binding fails for me. I want to figure out why, as they essentially both use the same cgo features and techniques.

Note I currently have a self-made half-baked but essentially working replacement package in place that uses LoadLibrary/GetProcAddress calls to expose glfw.dll in Go. This works but I think a hard-linked compiled-in CGO binding would be more desirable than countless Syscall(), Syscall6(), Syscall9(), Syscall12() etc Go func invocations. If Win32 and Linux gophers can have this, why not us Win64 folks?

So here's my setup so far:


I have a Golang build with three patches to make lib linking work with cgo applied
I have successfully compiled the newest freeglut and GLFW libraries as 64-bit DLLs using MinGW64.
Header files glut.h, freeglut*.h and glfw.h are placed in \MinGW64\x86_64-w64-mingw32\include\GL (next to gl.h, glaux.h, glu.h)
Lib files libfreeglut.a and libglfwdll.a are placed in \MinGW64\x86_64-w64-mingw32\lib (next to libglu32.a, libopengl32.a)
64-bit DLLs glfw.dll and freeglut64.dll are placed in \windows and \windows\system32 (next to opengl32.dll, glu32.dll)
freeglut64.dll and glfw.dll both work, I believe -- at least most of their example programs do after installing the DLLs.


Everything should be in place, right? Now first for the successful binding (that I don't need), freeglut -- when I go get -x github.com/zombiezen/Go-GLUT/glut, all is built just fine and I can successfully create a glut window and show a triangle in a Windows test.exe compiled from a .go source file. Thanks to -x, go get shows what it does to build:

WORK=C:\Users\roxor\AppData\Local\Temp\go-build292908674
mkdir -p $WORK\github.com\zombiezen\Go-GLUT\glut\_obj\
cd C:\Go\src\pkg\github.com\zombiezen\Go-GLUT\glut
C:\Go\pkg\tool\windows_amd64\cgo.exe -objdir $WORK\github.com\zombiezen\Go-GLUT\glut\_obj\ -- -I $WORK\github.com\zombiezen\Go-GLUT\glut\_obj\ glut.go
C:\Go\pkg\tool\windows_amd64\6c.exe -FVw -I $WORK\github.com\zombiezen\Go-GLUT\glut\_obj\ -I C:\Go\pkg\windows_amd64 -o $WORK\github.com\zombiezen\Go-GLUT\glut\_obj\_cgo_defun.6 -DGOOS_windows -DGOARCH_amd64 $WORK\github.com\zombiezen\Go-GLUT\glut\_obj\_cgo_defun.c
gcc -I . -g -O2 -m64 -mthreads -I $WORK\github.com\zombiezen\Go-GLUT\glut\_obj\ -o $WORK\github.com\zombiezen\Go-GLUT\glut\_obj\_cgo_main.o -c $WORK\github.com\zombiezen\Go-GLUT\glut\_obj\_cgo_main.c
gcc -I . -g -O2 -m64 -mthreads -I $WORK\github.com\zombiezen\Go-GLUT\glut\_obj\ -o $WORK\github.com\zombiezen\Go-GLUT\glut\_obj\_cgo_export.o -c $WORK\github.com\zombiezen\Go-GLUT\glut\_obj\_cgo_export.c
gcc -I . -g -O2 -m64 -mthreads -I $WORK\github.com\zombiezen\Go-GLUT\glut\_obj\ -o $WORK\github.com\zombiezen\Go-GLUT\glut\_obj\glut.cgo2.o -c $WORK\github.com\zombiezen\Go-GLUT\glut\_obj\glut.cgo2.c
gcc -I . -g -O2 -m64 -mthreads -I $WORK\github.com\zombiezen\Go-GLUT\glut\_obj\ -o $WORK\github.com\zombiezen\Go-GLUT\glut\_obj\support.o -c .\support.c
gcc -I . -g -O2 -m64 -mthreads -o $WORK\github.com\zombiezen\Go-GLUT\glut\_obj\_cgo_.o $WORK\github.com\zombiezen\Go-GLUT\glut\_obj\_cgo_main.o $WORK\github.com\zombiezen\Go-GLUT\glut\_obj\_cgo_export.o $WORK\github.com\zombiezen\Go-GLUT\glut\_obj\glut.cgo2.o $WORK\github.com\zombiezen\Go-GLUT\glut\_obj\support.o -lfreeglut
C:\Go\pkg\tool\windows_amd64\cgo.exe -objdir $WORK\github.com\zombiezen\Go-GLUT\glut\_obj\ -dynimport $WORK\github.com\zombiezen\Go-GLUT\glut\_obj\_cgo_.o -dynout $WORK\github.com\zombiezen\Go-GLUT\glut\_obj\_cgo_import.c
C:\Go\pkg\tool\windows_amd64\6c.exe -FVw -I $WORK\github.com\zombiezen\Go-GLUT\glut\_obj\ -I C:\Go\pkg\windows_amd64 -o $WORK\github.com\zombiezen\Go-GLUT\glut\_obj\_cgo_import.6 -DGOOS_windows -DGOARCH_amd64 $WORK\github.com\zombiezen\Go-GLUT\glut\_obj\_cgo_import.c
gcc -I . -g -O2 -m64 -mthreads -o $WORK\github.com\zombiezen\Go-GLUT\glut\_obj\_all.o $WORK\github.com\zombiezen\Go-GLUT\glut\_obj\_cgo_export.o $WORK\github.com\zombiezen\Go-GLUT\glut\_obj\glut.cgo2.o $WORK\github.com\zombiezen\Go-GLUT\glut\_obj\support.o -Wl,-r -nostdlib -lgcc -lmingwex -lmingw32
C:\Go\pkg\tool\windows_amd64\6g.exe -o $WORK\github.com\zombiezen\Go-GLUT\glut\_obj\_go_.6 -p github.com/zombiezen/Go-GLUT/glut -D _/C_/Go/src/pkg/github.com/zombiezen/Go-GLUT/glut -I $WORK $WORK\github.com\zombiezen\Go-GLUT\glut\_obj\_cgo_gotypes.go $WORK\github.com\zombiezen\Go-GLUT\glut\_obj\glut.cgo1.go
C:\Go\pkg\tool\windows_amd64\pack.exe grc $WORK\github.com\zombiezen\Go-GLUT\glut.a $WORK\github.com\zombiezen\Go-GLUT\glut\_obj\_go_.6 $WORK\github.com\zombiezen\Go-GLUT\glut\_obj\_cgo_import.6 $WORK\github.com\zombiezen\Go-GLUT\glut\_obj\_cgo_defun.6 $WORK\github.com\zombiezen\Go-GLUT\glut\_obj\_all.o
mkdir -p C:\Go\pkg\windows_amd64\github.com\zombiezen\Go-GLUT\
cp $WORK\github.com\zombiezen\Go-GLUT\glut.a C:\Go\pkg\windows_amd64\github.com\zombiezen\Go-GLUT\glut.a


To get to this point, I had to slightly modify glut.go as follows:

// # include 
// #cgo windows LDFLAGS: -lfreeglut
// #include 
// #include ""support.h""
import ""C""


So, to summarize, this builds fine, can be imported and linked from Go and used in code.

Now for GLFW. The GO file reads extremely similar to glut.go:

//#cgo windows LDFLAGS: -lglfwdll -lglu32 -lopengl32
//#include 
//#define GLFW_DLL
//#include 
import ""C""


The #define GLFW_DLL is so that no static linking happens. Here's the output of go get -x github.com/jteeuwen/glfw however:

WORK=C:\Users\roxor\AppData\Local\Temp\go-build499107422
mkdir -p $WORK\github.com\jteeuwen\glfw\_obj\
cd C:\Go\src\pkg\github.com\jteeuwen\glfw
C:\Go\pkg\tool\windows_amd64\cgo.exe -objdir $WORK\github.com\jteeuwen\glfw\_obj\ -- -I $WORK\github.com\jteeuwen\glfw\_obj\ callback.go glfw.go image.go vidmode.go
C:\Go\pkg\tool\windows_amd64\6c.exe -FVw -I $WORK\github.com\jteeuwen\glfw\_obj\ -I C:\Go\pkg\windows_amd64 -o $WORK\github.com\jteeuwen\glfw\_obj\_cgo_defun.6 -DGOOS_windows -DGOARCH_amd64 $WORK\github.com\jteeuwen\glfw\_obj\_cgo_defun.c
gcc -I . -g -O2 -m64 -mthreads -I $WORK\github.com\jteeuwen\glfw\_obj\ -o $WORK\github.com\jteeuwen\glfw\_obj\_cgo_main.o -c $WORK\github.com\jteeuwen\glfw\_obj\_cgo_main.c
gcc -I . -g -O2 -m64 -mthreads -I $WORK\github.com\jteeuwen\glfw\_obj\ -o $WORK\github.com\jteeuwen\glfw\_obj\_cgo_export.o -c $WORK\github.com\jteeuwen\glfw\_obj\_cgo_export.c
gcc -I . -g -O2 -m64 -mthreads -I $WORK\github.com\jteeuwen\glfw\_obj\ -o $WORK\github.com\jteeuwen\glfw\_obj\callback.cgo2.o -c $WORK\github.com\jteeuwen\glfw\_obj\callback.cgo2.c
gcc -I . -g -O2 -m64 -mthreads -I $WORK\github.com\jteeuwen\glfw\_obj\ -o $WORK\github.com\jteeuwen\glfw\_obj\glfw.cgo2.o -c $WORK\github.com\jteeuwen\glfw\_obj\glfw.cgo2.c
gcc -I . -g -O2 -m64 -mthreads -I $WORK\github.com\jteeuwen\glfw\_obj\ -o $WORK\github.com\jteeuwen\glfw\_obj\image.cgo2.o -c $WORK\github.com\jteeuwen\glfw\_obj\image.cgo2.c
gcc -I . -g -O2 -m64 -mthreads -I $WORK\github.com\jteeuwen\glfw\_obj\ -o $WORK\github.com\jteeuwen\glfw\_obj\vidmode.cgo2.o -c $WORK\github.com\jteeuwen\glfw\_obj\vidmode.cgo2.c
gcc -I . -g -O2 -m64 -mthreads -I $WORK\github.com\jteeuwen\glfw\_obj\ -o $WORK\github.com\jteeuwen\glfw\_obj\callback.o -c .\callback.c
gcc -I . -g -O2 -m64 -mthreads -o $WORK\github.com\jteeuwen\glfw\_obj\_cgo_.o $WORK\github.com\jteeuwen\glfw\_obj\_cgo_main.o $WORK\github.com\jteeuwen\glfw\_obj\_cgo_export.o $WORK\github.com\jteeuwen\glfw\_obj\callback.cgo2.o $WORK\github.com\jteeuwen\glfw\_obj\glfw.cgo2.o $WORK\github.com\jteeuwen\glfw\_obj\image.cgo2.o $WORK\github.com\jteeuwen\glfw\_obj\vidmode.cgo2.o $WORK\github.com\jteeuwen\glfw\_obj\callback.o -lglfwdll -lglu32 -lopengl32
# github.com/jteeuwen/glfw
$WORK\github.com\jteeuwen\glfw\_obj\glfw.cgo2.o: In function `_cgo_680190d759a2_Cfunc_glfwGetNumberOfProcessors':
C:\Go\src\pkg\github.com\jteeuwen\glfw/glfw.go:39: undefined reference to `__imp_glfwGetNumberOfProcessors'
$WORK\github.com\jteeuwen\glfw\_obj\glfw.cgo2.o: In function `_cgo_680190d759a2_Cfunc_glfwGetKey':
C:\Go\src\pkg\github.com\jteeuwen\glfw/glfw.go:51: undefined reference to `__imp_glfwGetKey'
$WORK\github.com\jteeuwen\glfw\_obj\glfw.cgo2.o: In function `_cgo_680190d759a2_Cfunc_glfwSetTime':
C:\Go\src\pkg\github.com\jteeuwen\glfw/glfw.go:60: undefined reference to `__imp_glfwSetTime'
$WORK\github.com\jteeuwen\glfw\_obj\glfw.cgo2.o: In function `_cgo_680190d759a2_Cfunc_glfwExtensionSupported':
C:\Go\src\pkg\github.com\jteeuwen\glfw/glfw.go:71: undefined reference to `__imp_glfwExtensionSupported'
$WORK\github.com\jteeuwen\glfw\_obj\glfw.cgo2.o: In function `_cgo_680190d759a2_Cfunc_glfwPollEvents':
C:\Go\src\pkg\github.com\jteeuwen\glfw/glfw.go:80: undefined reference to `__imp_glfwPollEvents'
$WORK\github.com\jteeuwen\glfw\_obj\glfw.cgo2.o: In function `_cgo_680190d759a2_Cfunc_glfwGetMousePos':
C:\Go\src\pkg\github.com\jteeuwen\glfw/glfw.go:90: undefined reference to `__imp_glfwGetMousePos'
$WORK\github.com\jteeuwen\glfw\_obj\glfw.cgo2.o: In function `_cgo_680190d759a2_Cfunc_glfwGetJoystickParam':
C:\Go\src\pkg\github.com\jteeuwen\glfw/glfw.go:102: undefined reference to `__imp_glfwGetJoystickParam'
$WORK\github.com\jteeuwen\glfw\_obj\glfw.cgo2.o: In function `_cgo_680190d759a2_Cfunc_glfwGetProcAddress':
C:\Go\src\pkg\github.com\jteeuwen\glfw/glfw.go:112: undefined reference to `__imp_glfwGetProcAddress'
$WORK\github.com\jteeuwen\glfw\_obj\glfw.cgo2.o: In function `_cgo_680190d759a2_Cfunc_glfwGetGLVersion':
C:\Go\src\pkg\github.com\jteeuwen\glfw/glfw.go:123: undefined reference to `__imp_glfwGetGLVersion'
$WORK\github.com\jteeuwen\glfw\_obj\glfw.cgo2.o: In function `_cgo_680190d759a2_Cfunc_glfwSetMouseWheel':
C:\Go\src\pkg\github.com\jteeuwen\glfw/glfw.go:133: undefined reference to `__imp_glfwSetMouseWheel'
$WORK\github.com\jteeuwen\glfw\_obj\glfw.cgo2.o: In function `_cgo_680190d759a2_Cfunc_glfwGetJoystickPos':
C:\Go\src\pkg\github.com\jteeuwen\glfw/glfw.go:148: undefined reference to `__imp_glfwGetJoystickPos'
$WORK\github.com\jteeuwen\glfw\_obj\glfw.cgo2.o: In function `_cgo_680190d759a2_Cfunc_glfwOpenWindow':
C:\Go\src\pkg\github.com\jteeuwen\glfw/glfw.go:168: undefined reference to `__imp_glfwOpenWindow'
$WORK\github.com\jteeuwen\glfw\_obj\glfw.cgo2.o: In function `_cgo_680190d759a2_Cfunc_glfwSetMousePos':
C:\Go\src\pkg\github.com\jteeuwen\glfw/glfw.go:178: undefined reference to `__imp_glfwSetMousePos'
$WORK\github.com\jteeuwen\glfw\_obj\glfw.cgo2.o: In function `_cgo_680190d759a2_Cfunc_glfwSwapInterval':
C:\Go\src\pkg\github.com\jteeuwen\glfw/glfw.go:188: undefined reference to `__imp_glfwSwapInterval'
$WORK\github.com\jteeuwen\glfw\_obj\glfw.cgo2.o: In function `_cgo_680190d759a2_Cfunc_glfwGetMouseButton':
C:\Go\src\pkg\github.com\jteeuwen\glfw/glfw.go:209: undefined reference to `__imp_glfwGetMouseButton'
$WORK\github.com\jteeuwen\glfw\_obj\glfw.cgo2.o: In function `_cgo_680190d759a2_Cfunc_glfwSetWindowTitle':
C:\Go\src\pkg\github.com\jteeuwen\glfw/glfw.go:218: undefined reference to `__imp_glfwSetWindowTitle'
$WORK\github.com\jteeuwen\glfw\_obj\glfw.cgo2.o: In function `_cgo_680190d759a2_Cfunc_glfwGetVideoModes':
C:\Go\src\pkg\github.com\jteeuwen\glfw/glfw.go:231: undefined reference to `__imp_glfwGetVideoModes'
$WORK\github.com\jteeuwen\glfw\_obj\glfw.cgo2.o: In function `_cgo_680190d759a2_Cfunc_glfwGetJoystickButtons':
C:\Go\src\pkg\github.com\jteeuwen\glfw/glfw.go:246: undefined reference to `__imp_glfwGetJoystickButtons'
$WORK\github.com\jteeuwen\glfw\_obj\glfw.cgo2.o: In function `_cgo_680190d759a2_Cfunc_glfwRestoreWindow':
C:\Go\src\pkg\github.com\jteeuwen\glfw/glfw.go:255: undefined reference to `__imp_glfwRestoreWindow'
$WORK\github.com\jteeuwen\glfw\_obj\glfw.cgo2.o: In function `_cgo_680190d759a2_Cfunc_glfwInit':
C:\Go\src\pkg\github.com\jteeuwen\glfw/glfw.go:265: undefined reference to `__imp_glfwInit'
$WORK\github.com\jteeuwen\glfw\_obj\glfw.cgo2.o: In function `_cgo_680190d759a2_Cfunc_glfwSwapBuffers':
C:\Go\src\pkg\github.com\jteeuwen\glfw/glfw.go:274: undefined reference to `__imp_glfwSwapBuffers'
$WORK\github.com\jteeuwen\glfw\_obj\glfw.cgo2.o: In function `_cgo_680190d759a2_Cfunc_glfwGetMouseWheel':
C:\Go\src\pkg\github.com\jteeuwen\glfw/glfw.go:284: undefined reference to `__imp_glfwGetMouseWheel'
$WORK\github.com\jteeuwen\glfw\_obj\glfw.cgo2.o: In function `_cgo_680190d759a2_Cfunc_glfwIconifyWindow':
C:\Go\src\pkg\github.com\jteeuwen\glfw/glfw.go:293: undefined reference to `__imp_glfwIconifyWindow'
$WORK\github.com\jteeuwen\glfw\_obj\glfw.cgo2.o: In function `_cgo_680190d759a2_Cfunc_glfwWaitEvents':
C:\Go\src\pkg\github.com\jteeuwen\glfw/glfw.go:302: undefined reference to `__imp_glfwWaitEvents'
$WORK\github.com\jteeuwen\glfw\_obj\glfw.cgo2.o: In function `_cgo_680190d759a2_Cfunc_glfwSetWindowPos':
C:\Go\src\pkg\github.com\jteeuwen\glfw/glfw.go:312: undefined reference to `__imp_glfwSetWindowPos'
$WORK\github.com\jteeuwen\glfw\_obj\glfw.cgo2.o: In function `_cgo_680190d759a2_Cfunc_glfwGetWindowSize':
C:\Go\src\pkg\github.com\jteeuwen\glfw/glfw.go:322: undefined reference to `__imp_glfwGetWindowSize'
$WORK\github.com\jteeuwen\glfw\_obj\glfw.cgo2.o: In function `_cgo_680190d759a2_Cfunc_glfwDisable':
C:\Go\src\pkg\github.com\jteeuwen\glfw/glfw.go:332: undefined reference to `__imp_glfwDisable'
$WORK\github.com\jteeuwen\glfw\_obj\glfw.cgo2.o: In function `_cgo_680190d759a2_Cfunc_glfwGetWindowParam':
C:\Go\src\pkg\github.com\jteeuwen\glfw/glfw.go:344: undefined reference to `__imp_glfwGetWindowParam'
$WORK\github.com\jteeuwen\glfw\_obj\glfw.cgo2.o: In function `_cgo_680190d759a2_Cfunc_glfwCloseWindow':
C:\Go\src\pkg\github.com\jteeuwen\glfw/glfw.go:353: undefined reference to `__imp_glfwCloseWindow'
$WORK\github.com\jteeuwen\glfw\_obj\glfw.cgo2.o: In function `_cgo_680190d759a2_Cfunc_glfwOpenWindowHint':
C:\Go\src\pkg\github.com\jteeuwen\glfw/glfw.go:363: undefined reference to `__imp_glfwOpenWindowHint'
$WORK\github.com\jteeuwen\glfw\_obj\glfw.cgo2.o: In function `_cgo_680190d759a2_Cfunc_glfwSleep':
C:\Go\src\pkg\github.com\jteeuwen\glfw/glfw.go:372: undefined reference to `__imp_glfwSleep'
$WORK\github.com\jteeuwen\glfw\_obj\glfw.cgo2.o: In function `_cgo_680190d759a2_Cfunc_glfwEnable':
C:\Go\src\pkg\github.com\jteeuwen\glfw/glfw.go:382: undefined reference to `__imp_glfwEnable'
$WORK\github.com\jteeuwen\glfw\_obj\glfw.cgo2.o: In function `_cgo_680190d759a2_Cfunc_glfwSetWindowSize':
C:\Go\src\pkg\github.com\jteeuwen\glfw/glfw.go:392: undefined reference to `__imp_glfwSetWindowSize'
$WORK\github.com\jteeuwen\glfw\_obj\glfw.cgo2.o: In function `_cgo_680190d759a2_Cfunc_glfwTerminate':
C:\Go\src\pkg\github.com\jteeuwen\glfw/glfw.go:411: undefined reference to `__imp_glfwTerminate'
$WORK\github.com\jteeuwen\glfw\_obj\glfw.cgo2.o: In function `_cgo_680190d759a2_Cfunc_glfwGetDesktopMode':
C:\Go\src\pkg\github.com\jteeuwen\glfw/glfw.go:420: undefined reference to `__imp_glfwGetDesktopMode'
$WORK\github.com\jteeuwen\glfw\_obj\glfw.cgo2.o: In function `_cgo_680190d759a2_Cfunc_glfwGetTime':
C:\Go\src\pkg\github.com\jteeuwen\glfw/glfw.go:429: undefined reference to `__imp_glfwGetTime'
$WORK\github.com\jteeuwen\glfw\_obj\image.cgo2.o: In function `_cgo_680190d759a2_Cfunc_glfwFreeImage':
C:\Go\src\pkg\github.com\jteeuwen\glfw/image.go:38: undefined reference to `__imp_glfwFreeImage'
$WORK\github.com\jteeuwen\glfw\_obj\image.cgo2.o: In function `_cgo_680190d759a2_Cfunc_glfwReadImage':
C:\Go\src\pkg\github.com\jteeuwen\glfw/image.go:52: undefined reference to `__imp_glfwReadImage'
$WORK\github.com\jteeuwen\glfw\_obj\image.cgo2.o: In function `_cgo_680190d759a2_Cfunc_glfwLoadTextureImage2D':
C:\Go\src\pkg\github.com\jteeuwen\glfw/image.go:65: undefined reference to `__imp_glfwLoadTextureImage2D'
$WORK\github.com\jteeuwen\glfw\_obj\image.cgo2.o: In function `_cgo_680190d759a2_Cfunc_glfwLoadMemoryTexture2D':
C:\Go\src\pkg\github.com\jteeuwen\glfw/image.go:78: undefined reference to `__imp_glfwLoadMemoryTexture2D'
$WORK\github.com\jteeuwen\glfw\_obj\image.cgo2.o: In function `_cgo_680190d759a2_Cfunc_glfwLoadTexture2D':
C:\Go\src\pkg\github.com\jteeuwen\glfw/image.go:91: undefined reference to `__imp_glfwLoadTexture2D'
$WORK\github.com\jteeuwen\glfw\_obj\image.cgo2.o: In function `_cgo_680190d759a2_Cfunc_glfwReadMemoryImage':
C:\Go\src\pkg\github.com\jteeuwen\glfw/image.go:107: undefined reference to `__imp_glfwReadMemoryImage'
$WORK\github.com\jteeuwen\glfw\_obj\callback.o: In function `setWindowSizeCB':
C:/Go/src/pkg/github.com/jteeuwen/glfw/callback.c:9: undefined reference to `__imp_glfwSetWindowSizeCallback'
$WORK\github.com\jteeuwen\glfw\_obj\callback.o: In function `setWindowCloseCB':
C:/Go/src/pkg/github.com/jteeuwen/glfw/callback.c:14: undefined reference to `__imp_glfwSetWindowCloseCallback'
$WORK\github.com\jteeuwen\glfw\_obj\callback.o: In function `setWindowRefreshCB':
C:/Go/src/pkg/github.com/jteeuwen/glfw/callback.c:19: undefined reference to `__imp_glfwSetWindowRefreshCallback'
$WORK\github.com\jteeuwen\glfw\_obj\callback.o: In function `setMouseButtonCB':
C:/Go/src/pkg/github.com/jteeuwen/glfw/callback.c:24: undefined reference to `__imp_glfwSetMouseButtonCallback'
$WORK\github.com\jteeuwen\glfw\_obj\callback.o: In function `setMousePosCB':
C:/Go/src/pkg/github.com/jteeuwen/glfw/callback.c:29: undefined reference to `__imp_glfwSetMousePosCallback'
$WORK\github.com\jteeuwen\glfw\_obj\callback.o: In function `setMouseWheelCB':
C:/Go/src/pkg/github.com/jteeuwen/glfw/callback.c:34: undefined reference to `__imp_glfwSetMouseWheelCallback'
$WORK\github.com\jteeuwen\glfw\_obj\callback.o: In function `setKeyCB':
C:/Go/src/pkg/github.com/jteeuwen/glfw/callback.c:39: undefined reference to `__imp_glfwSetKeyCallback'
$WORK\github.com\jteeuwen\glfw\_obj\callback.o: In function `setCharCB':
C:/Go/src/pkg/github.com/jteeuwen/glfw/callback.c:44: undefined reference to `__imp_glfwSetCharCallback'
collect2: ld returned 1 exit status


Yes, it's a mouthful -- but essentially just always the same error, and fairly late in the build procedure. Notice if #define GLFW_DLL isn't defined, I get essentially the same output except without the __imp_ prefixes -- and static linking is neither encourage for Go nor is it desirable for this particular use-case.

Now, when gcc complains about ""undefined reference to"", from what I google there could be various reasons...


it cannot be failure to find the DLL's -- they're in the appropriate places and for freeglut64.dll it works
it cannot be failure to find the .a libs -- they're in the appropriate places, and libfreeglut.a works, and if I change -lglfwdll to -lblafoobar then gcc fails much earlier and rightly complains ""blafoobar not found"" -- so it does find libglfwdll.a.
order of lib dependencies? I tried -lglfwdll as the first lib (before -lglu32 -lopengl32) and as the last (after those two), no difference.
is the Golang glfw binding faulty? Don't think so, works for others, including under Windows for chsc (32-bit though)


TL;DR -- under Windows 64-bit, Go 1.0.1 64-bit fully patched, CGO successfully generates stuff to feed into GCC for both freeglut and glfw. GCC then happily eats that stuff to build the freeglut binding, but rejects it for building the glfw binding, with ""undefined reference to"" for all C.funcs(). Both libfreeglut and libglfwdll are correctly built and installed as 64-bit DLLs and .h/.a libs correctly located. What could be the cause?
"
13777298,"I have just seen an implementation of a priority queue in a generic kind of way in which any
type satisfying an interface can be put into the queue. Is this the way to go with go or does this introduces any issues?

// Copyright 2012 Stefan Nilsson
//
// Licensed under the Apache License, Version 2.0 (the ""License"");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an ""AS IS"" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package prio provides a priority queue.
// The queue can hold elements that implement the two methods of prio.Interface.
package prio

/*
A type that implements prio.Interface can be inserted into a priority queue.

The simplest use case looks like this:

        type myInt int

        func (x myInt) Less(y prio.Interface) bool { return x < y.(myInt) }
        func (x myInt) Index(i int)                {}

To use the Remove method you need to keep track of the index of elements
in the heap, e.g. like this:

        type myType struct {
                value int
                index int // index in heap
        }

        func (x *myType) Less(y prio.Interface) bool { return x.value < y.(*myType).value }
        func (x *myType) Index(i int)                { x.index = i }
*/
type Interface interface {
        // Less returns whether this element should sort before element x.
        Less(x Interface) bool
        // Index is called by the priority queue when this element is moved to index i.
        Index(i int)
}

// Queue represents a priority queue.
// The zero value for Queue is an empty queue ready to use.
type Queue struct {
        h []Interface
}

// New returns an initialized priority queue with the given elements.
// A call of the form New(x...) uses the underlying array of x to implement
// the queue and hence might change the elements of x.
// The complexity is O(n), where n = len(x).
func New(x ...Interface) Queue {
        q := Queue{x}
        heapify(q.h)
        return q
}

// Push pushes the element x onto the queue.
// The complexity is O(log(n)) where n = q.Len().
func (q *Queue) Push(x Interface) {
        n := len(q.h)
        q.h = append(q.h, x)
        up(q.h, n) // x.Index(n) is done by up.
}

// Pop removes a minimum element (according to Less) from the queue and returns it.
// The complexity is O(log(n)), where n = q.Len().
func (q *Queue) Pop() Interface {
        h := q.h
        n := len(h) - 1
        x := h[0]
        h[0], h[n] = h[n], nil
        h = h[:n]
        if n > 0 {
                down(h, 0) // h[0].Index(0) is done by down.
        }
        q.h = h
        x.Index(-1) // for safety
        return x
}

// Peek returns, but does not remove, a minimum element (according to Less) of the queue.
func (q *Queue) Peek() Interface {
        return q.h[0]
}

// Remove removes the element at index i from the queue and returns it.
// The complexity is O(log(n)), where n = q.Len().
func (q *Queue) Remove(i int) Interface {
        h := q.h
        n := len(h) - 1
        x := h[i]
        h[i], h[n] = h[n], nil
        h = h[:n]
        if i < n {
                down(h, i) // h[i].Index(i) is done by down.
                up(h, i)
        }
        q.h = h
        x.Index(-1) // for safety
        return x
}

// Len returns the number of elements in the queue.
func (q *Queue) Len() int {
        return len(q.h)
}

// Establishes the heap invariant in O(n) time.
func heapify(h []Interface) {
        n := len(h)
        for i := n - 1; i >= n/2; i-- {
                h[i].Index(i)
        }
        for i := n/2 - 1; i >= 0; i-- { // h[i].Index(i) is done by down.
                down(h, i)
        }
}

// Moves element at position i towards top of heap to restore invariant.
func up(h []Interface, i int) {
        for {
                parent := (i - 1) / 2
                if i == 0 || h[parent].Less(h[i]) {
                        h[i].Index(i)
                        break
                }
                h[parent], h[i] = h[i], h[parent]
                h[i].Index(i)
                i = parent
        }
}

// Moves element at position i towards bottom of heap to restore invariant.
func down(h []Interface, i int) {
        for {
                n := len(h)
                left := 2*i + 1
                if left >= n {
                        h[i].Index(i)
                        break
                }
                j := left
                if right := left + 1; right < n && h[right].Less(h[left]) {
                        j = right
                }
                if h[i].Less(h[j]) {
                        h[i].Index(i)
                        break
                }
                h[i], h[j] = h[j], h[i]
                h[i].Index(i)
                i = j
        }
}

"
27615149,"You can convert the http.Handler h to a http.HandlerFunc using the method expression:

h.ServeHTTP


Instead of converting to a HandlerFunc, you can register the Handler directly using the route Handler method:

router.Methods(""GET"").Path(""/captcha/"").Handler(captcha.Server(captcha.StdWidth, captcha.StdHeight))


Based on your comments and edits, I think you want a prefix match instead of an exact match:

router.Methods(""GET"").PathPrefix(""/captcha/"").Handler(captcha.Server(captcha.StdWidth, captcha.StdHeight))

"
44870303,"Although (as mentioned above) this works:


err := collection.Find(nil).Select(bson.M{""categories"": bson.M{""$elemMatch"": bson.M{""slug"": ""general""}}}).One(&result)


but I think this will query all docments inside the collection, and then it choose the right one. Hence I think the solution that comes below is more efficent.


err := collection.Find(bson.M{""categories"": bson.M{""$elemMatch"": bson.M{""slug"": ""general""}}}).One(&result)

"
42841793,"I have issue when using cgo with c struct array.

My program as follow:

I have struct in c  and contain a pointer to a c struct array. 

In C, I provide a initialize function (take two parameter: the pointer to the variable, the length of the array inside the variable)  to malloc the memory of the variable. 

Then In go, I assign the value to this variable and assign value to the array in variable.  And in go , I call another C function to using this variable. 

After the C function handle it.  Go pick up the variable again and return to other Go function. 

When I coded like this, I go a array like.  type *C.struct does not support indexing. 

My code like follow.

C:

test.h

typedef struct
{
    int     profileCnt;
    _profile   *profile;                      //pointer to profile array
}_profiles;
// variable using in Go


typedef struct
{
    int     profileId;              
    _name   userName;               
    char         *dateOfBirth;          
    int     stateFipsId;            
}_profile;

typedef struct
{
    char    first[32];
    char    last[32];
} _name;


void initializeProfiles(_profiles *profiles, int profileCount, bool create);
int doSomething _In_C( _profiles *profiles, int log);


test.c

void initializeProfiles(_profiles *profiles, int profileCount, bool create)
{

    profiles->profileCnt = profileCount;                                                
//  initialize profiles struct & profile[] Array

    if (profileCount > 0)
    {
        if (create == true)
            profiles->profile = malloc(profileCount * sizeof *profiles->profile + 1);           //  allocate memory for profiles[numProfiles]

            for (int i = 0; i profileCnt; i++)
            initializeProfile(&profiles->profile[i], create);

        if (create == false)
        {
            free(profiles->profile);
            profiles->profileCnt = 0;
        }
    }
    else
        profiles->profile = NULL;

} 

void initializeProfile(_profile *profile, bool create)
{
    if (create == true)
    {       
        profile->dateOfBirth = NULL;            
    }

    profile->profileId = 0;                 
    memset(profile->userName.first, '\0', sizeof(profile->userName.first));     
    memset(profile->userName.last, '\0', sizeof(profile->userName.last));       

    if (create == false)
    {
        if (profile->dateOfBirth != NULL)
            free(profile->dateOfBirth);
    }
}



int doSomething _In_C( _profiles *profiles, int log)
{

    /*  ===========================================



    */  ====   did something to that variable============================

    if (errStatus.code == _SUCCESS)
        return(_SUCCESS);
    else
        return(FAILURE);
}


My GO code 

package main
//#cgo CFLAGS: -std=c99 -ggdb3 -O0 -Wall
//#cgo CFLAGS: -I../../include/common
//#cgo LDFLAGS: -L string.h
//#cgo LDFLAGS: -lstdc++ -lpthread -lm -lc -lssl -lcrypto
//#include 
//#include 
//#include ""test.h""
import ""C""


//import ""unsafe""

func Test() {

    log := 1 // sets logging level
    numProfiles := 3

    var profiles C._profiles

    C.initializeProfiles(&profiles, C.int(numProfiles), C.bool(true))


    profiles.profile[0].profileId = C.int(2)
    profiles.profile[0].stateFipsId = C.int(1)
    profiles.profile[0].userName.first = C.CString(""test"")
    profiles.profile[0].userName.last = C.CString（""test""）

    C.dosomething_In_C( &profiles,C.int(3))

    C.initializeProfiles(&profiles, C.int(numProfiles), C.bool(false))


    fmt.Println(int(""get c variable and  return"")
}


When I compile  in like this
            profiles.profile[0].profileId = C.int(2) 

I got error message : 
    invalid operation: profiles.profile[0] (type *C.struct___6 does not support indexing)  

So, I try another solution.  Transfer the c struct array form c to go. like this 

    profile.profikes = (*[1 << 30]C._profile)(unsafe.Pointer(&profiles.profile))[:numProfiles:numProfiles]


But get error like   cannot use (*[1073741824]C.struct___6)(unsafe.Pointer(&profiles.profile))[:numProfiles:numProfiles] (type []C.struct___6) as type *C.struct___6 in assignment    

and I afraid It create another piece of memory,  when I call in dosomething_In_C function, it can not get the data. 

Is anyone know how to fix this?

Thank you 
"
45227060,"I was trying to refactor some Go code and ran into an issue. My original server was just one file similar to this. 

package main

import (
    ""net/http""
    ""strings""

    ""google.golang.org/appengine""
    ""google.golang.org/appengine/urlfetch""
    ""github.com/tdewolff/minify/json""
    ""github.com/tdewolff/minify""
)

func reactFileServer(fs http.Handler) http.Handler {
    fn := func(w http.ResponseWriter, req *http.Request) {

        staticPaths := [...]string{
            ""/static/"",
            ""/img/"",
        }

        var isStaticPath bool = false
        for _, path := range staticPaths {
            if strings.HasPrefix(req.URL.Path, path) {
                isStaticPath = true
                break
            }
        }

        if isStaticPath {
            fs.ServeHTTP(w, req)
        } else {
            fsHandler := http.StripPrefix(req.URL.Path, fs)
            fsHandler.ServeHTTP(w, req)
        }
    }
    return http.HandlerFunc(fn)
}
func getGooglePlaceInfo() http.Handler {
    fn := func(w http.ResponseWriter, req *http.Request) {
        ctx := appengine.NewContext(req)
        client := urlfetch.Client(ctx)
        resp, err := client.Get(
            ""https://maps.googleapis.com/maps/api/place/details/json"" +
                ""?placeid=[REMOVED]"" +
                ""&key=[REMOVED]"")
        if err != nil {
            http.Error(w, err.Error(), http.StatusInternalServerError)
            return
        }

        w.Header().Set(""Content-Type"", ""application/json"")

        m := minify.New()
        json.Minify(m, w, resp.Body, nil)
    }

    return http.HandlerFunc(fn)
}

func init() {
    fs := http.FileServer(http.Dir(""web""))
    http.Handle(""/"", reactFileServer(fs))
    http.Handle(""/services/google-places-info/"", getGooglePlaceInfo())
}


I tried to refactor the code by moving the getGooglePlaceInfo function into it's own file. When I do that I get the following error.

ERROR: (gcloud.app.deploy) Error Response: [9] Deployment contains files that cannot be compiled: Compile failed:
2017/07/20 17:01:47 go-app-builder: build timing: 2├ùcompile (213ms total), 0├ùlink (0s total)
2017/07/20 17:01:47 go-app-builder: failed running compile: exit status 2

services/google-places-info.go:5: can't find import: ""google.golang.org/appengine""


Here's the code that's getting the error

/main.go

package main

import (
    ""net/http""
    ""strings""
)

func reactFileServer(fs http.Handler) http.Handler {
    fn := func(w http.ResponseWriter, req *http.Request) {

        staticPaths := [...]string{
            ""/static/"",
            ""/img/"",
        }

        var isStaticPath bool = false
        for _, path := range staticPaths {
            if strings.HasPrefix(req.URL.Path, path) {
                isStaticPath = true
                break
            }
        }

        if isStaticPath {
            fs.ServeHTTP(w, req)
        } else {
            fsHandler := http.StripPrefix(req.URL.Path, fs)
            fsHandler.ServeHTTP(w, req)
        }
    }
    return http.HandlerFunc(fn)
}

func init() {
    fs := http.FileServer(http.Dir(""web""))
    http.Handle(""/"", reactFileServer(fs))
}


/services/google-places-info.go

package services

import (
    ""net/http""
    ""google.golang.org/appengine""
    ""google.golang.org/appengine/urlfetch""
    ""github.com/tdewolff/minify""
    ""github.com/tdewolff/minify/json""
)

func getGooglePlaceInfo() http.Handler {
    fn := func(w http.ResponseWriter, req *http.Request) {
        ctx := appengine.NewContext(req)
        client := urlfetch.Client(ctx)
        resp, err := client.Get(
            ""https://maps.googleapis.com/maps/api/place/details/json"" +
                ""?placeid=[REMOVED]"" +
                ""&key=[REMOVED]"")
        if err != nil {
            http.Error(w, err.Error(), http.StatusInternalServerError)
            return
        }

        w.Header().Set(""Content-Type"", ""application/json"")

        m := minify.New()
        json.Minify(m, w, resp.Body, nil)
    }

    return http.HandlerFunc(fn)
}

func init() {
    http.Handle(""/services/google-places-info/"", getGooglePlaceInfo())
}


I've put up the example on github.

https://github.com/bensisson/google-app-engine-bug-example
"
44488526,"I have been playing around with the Golang json package, and been running into a issue, i am simply trying to unmarshal a map[string]string into map[Priority]string the easiest way, but it seems like my UnmarshalJSON isn't even running, the following is my code, i would've like to made a playground where it could run, but i am using the OS package so:

import (
    ""encoding/json""
    ""fmt""
    ""os""
)

type Priority int

const (
    VERYLOW = Priority(iota)
    LOW
    MEDIUM
    HIGH
    VERYHIGH
)

const (
    verylow  = ""verylow""
    low      = ""low""
    medium   = ""medium""
    high     = ""high""
    veryhigh = ""veryhigh""

    // ANSI color constants.
    RESET      = ""\x1b[0m""
    BRIGHT     = ""\x1b[1m""
    DIM        = ""\x1b[2m""
    UNDERSCORE = ""\x1b[4m""
    BLINK      = ""\x1b[5m""
    REVERSE    = ""\x1b[7m""
    HIDDEN     = ""\x1b[8m""
    FGBLACK    = ""\x1b[30m""
    FGRED      = ""\x1b[31m""
    FGGREEN    = ""\x1b[32m""
    FGYELLOW   = ""\x1b[33m""
    FGBLUE     = ""\x1b[34m""
    FGMAGENTA  = ""\x1b[35m""
    FGCYAN     = ""\x1b[36m""
    FGWHITE    = ""\x1b[37m""
    BGBLACK    = ""\x1b[40m""
    BGRED      = ""\x1b[41m""
    BGGREEN    = ""\x1b[42m""
    BGYELLOW   = ""\x1b[43m""
    BGBLUE     = ""\x1b[44m""
    BGMAGENTA  = ""\x1b[45m""
    BGCYAN     = ""\x1b[46m""
    BGWHITE    = ""\x1b[47m""

    TITLE_COLOUR = BRIGHT + FGGREEN
    NUMBER_COLOR = FGGREEN

    //color constants
    BLACK         = ""BLACK""
    RED           = ""RED""
    GREEN         = ""GREEN""
    YELLOW        = ""YELLOW""
    BLUE          = ""BLUE""
    MAGENTA       = ""MAGENTA""
    CYAN          = ""CYAN""
    WHITE         = ""WHITE""
    BRIGHTBLACK   = ""BRIGHTBLACK""
    BRIGHTRED     = ""BRIGHTRED""
    BRIGHTGREEN   = ""BRIGHTGREEN""
    BRIGHTYELLOW  = ""BRIGHTYELLOW""
    BRIGHTBLUE    = ""BRIGHTBLUE""
    BRIGHTMAGENTA = ""BRIGHTMAGENTA""
    BRIGHTCYAN    = ""BRIGHTCYAN""
    BRIGHTWHITE   = ""BRIGHTWHITE""
    NOCOLOR       = """"
)

type Config struct {
    Name     string
    FGColors map[Priority]string
}

type MarshalableConfig struct {
    Name     string
    FGColors map[string]string
}

var priorityMapFromString = map[string]Priority{
    veryhigh: VERYHIGH,
    high:     HIGH,
    medium:   MEDIUM,
    low:      LOW,
    verylow:  VERYLOW,
}

var priorityToString = map[Priority]string{
    VERYHIGH: veryhigh,
    HIGH:     high,
    MEDIUM:   medium,
    VERYLOW:  verylow,
    LOW:      low,
}

func (p Priority) String() string {
    return priorityToString[p]
}

func PriorityFromString(priority string) Priority {
    if p, ok := priorityMapFromString[priority]; ok {
        return p
    }
    return MEDIUM
}

func (priority *Priority) UnmarshalJSON(data []byte) error {
    var s string
    if err := json.Unmarshal(data, &s); err != nil {
        return err
    }
    *priority = PriorityFromString(s)
    return nil
}

func main() {
    fgColors := map[string]string{
        verylow:  RED,
        low:      BLUE,
        medium:   GREEN,
        high:     BRIGHTBLUE,
        veryhigh: BRIGHTMAGENTA,
    }

    m := MarshalableConfig{""Alice"", fgColors}
    b, err := json.Marshal(m)
    if err != nil {
        panic(err)
    }
    file, err := os.Create(""testfile.json"")
    if err != nil {
        panic(err)
    }
    file.Write(b)

    emptyConfig := Config{}
    err = json.Unmarshal(b, &emptyConfig)
    if err != nil {
        fmt.Printf(""Got a error from unmarshalling: %+v \n"", err)
        panic(err)
    }
    fmt.Printf(""%+v \n"", emptyConfig)
    var x interface{} = emptyConfig.FGColors[VERYHIGH]
    fmt.Println(x.(string))

}


I get the error:

json: cannot unmarshal number high into Go value of type main.Priority  


So the impression i get is that it never calls my UnmarshalJSON method on the priority, and i don't know if thats the way its suppose to work anyway now that i have nested the Priority type inside of the map. 

So i thouth maybe i have to do a alias type for the whole map like:

type FGColor map[Priority]string 


and implement unmarshal on that instead, but that doesn't seem logical, because nested structs would be a nightmare to unmarshal  i would think. 

What am i doing wrong??
"
30774681,"I'm trying to retrieve a record from mysql table and marshal it to json.
But i gotted the error that says : "".\main.go:67: no new variables on left sife of :=""
I'm new in Golang Plz! help me to solve out this error!
My Code is :

func GetUser(w http.ResponseWriter, r *http.Request) {

  urlParams   := mux.Vars(r)
  id       := urlParams[""id""]
  ReadUser := User{}
  con, err := sql.Open(""mysql"", ""root:YES@/social_network?charset=utf8"")

  err := con.QueryRow(""select * from users where user_id=?"",id).Scan(&ReadUser.ID, &ReadUser.Name, &ReadUser.First, &ReadUser.Last, &ReadUser.Email )
  switch {
      case err == sql.ErrNoRows:
              fmt.Fprintf(w,""No such user"")
      case err != nil:
              log.Fatal(err)
      default:
        output, _ := json.Marshal(ReadUser)
        fmt.Fprintf(w,string(output))
  }
}


and Routes in main:

func main() {

  gorillaRoute := mux.NewRouter()
  gorillaRoute.HandleFunc(""/api/user/create"", CreateUser)
  gorillaRoute.HandleFunc(""/api/user/read/:id"", GetUser)
  http.Handle(""/"", gorillaRoute)
  http.ListenAndServe("":8080"", nil)
}


Here is my new Code , but again not able to get record from database table, plz help me to figure out the error OR what things i do wrong?
package main

import (
    ""database/sql""
    ""encoding/json""
    ""fmt""
    ""log""
    ""net/http""

    _ ""github.com/go-sql-driver/mysql""
    ""github.com/gorilla/mux""
)

type API struct {
    Message string ""json:message""
}
type User struct {
    ID    int    ""json:id""
    Name  string ""json:username""
    Email string ""json:email""
    First string ""json:first""
    Last  string ""json:last""
}

func Hello(w http.ResponseWriter, r *http.Request) {

    // urlParams := mux.Vars(r)
    // name := urlParams[""user""]
    HelloMessage := ""User Creation page""

    message := API{HelloMessage}
    output, err := json.Marshal(message)

    if err != nil {
        fmt.Println(""Something went wrong!"")
    }

    fmt.Fprintf(w, string(output))

}

//POST A USER INTO DB
func CreateUser(w http.ResponseWriter, r *http.Request) {
    NewUser := User{}
    NewUser.Name = r.FormValue(""user"")
    NewUser.Email = r.FormValue(""email"")
    NewUser.First = r.FormValue(""first"")
    NewUser.Last = r.FormValue(""last"")
    output, err := json.Marshal(NewUser)
    fmt.Println(string(output))
    if err != nil {
        fmt.Println(""Something went wrong!"")
    }
    con, err := sql.Open(""mysql"", ""root:YES@/social_network?charset=utf8"")
    sqlQuery := ""INSERT INTO users set user_nickname='"" + NewUser.Name + ""', user_first='"" + NewUser.First + ""', user_last='"" + NewUser.Last + ""', user_email='"" + NewUser.Email + ""'""
    q, err := con.Exec(sqlQuery)
    if err != nil {
        fmt.Println(err)
    }
    fmt.Println(q)
}

//GET USERS FROM DB
func GetUsers(w http.ResponseWriter, r *http.Request) {

    db, err := sql.Open(""mysql"", ""root:YES@/social_network?charset=utf8"")
    if err != nil {
        panic(err)
    }
    err = db.Ping()
    if err != nil {
        panic(err)
    }
    defer db.Close()
    rows, err := db.Query(""select * from users "")
    if err != nil {
        log.Fatal(err)
    }
    defer rows.Close()
    var rowBuf, _ = rows.Columns()
    var cols = make([]string, len(rowBuf))
    copy(cols, rowBuf)
    fmt.Println(rowBuf)
    var vals = make([]interface{}, len(rowBuf))
    for i, _ := range rowBuf {
        vals[i] = &rowBuf[i]
    }
    for rows.Next() {
        err := rows.Scan(vals...)
        if err != nil {
            log.Fatal(err)
        }
        var m = map[string]interface{}{}
        for i, col := range cols {
            m[col] = vals[i]
        }
        obj, _ := json.Marshal(m)
        //
        fmt.Fprintf(w, string(obj))
    }
    err = rows.Err()
    if err != nil {
        log.Fatal(err)
    }
}
func GetUser(w http.ResponseWriter, r *http.Request) {
    urlParams := mux.Vars(r)
    id := urlParams[""id""]
    ReadUser := User{}
    db, err := sql.Open(""mysql"", ""root:YES@/social_network?charset=utf8"")
    stmt := db.QueryRow(""select * from users where id = ?"", id)
    if err != nil {
        log.Fatal(err)
    }

    err = stmt.Scan(&ReadUser.ID, &ReadUser.Name, &ReadUser.First, &ReadUser.Last, &ReadUser.Email)
    if err != nil {
        log.Fatal(err)
    }

    result, err := json.Marshal(ReadUser)
    fmt.Fprintf(w, string(result))
}
func main() {

    gorillaRoute := mux.NewRouter()
    gorillaRoute.HandleFunc(""/api/user/create"", CreateUser)
    gorillaRoute.HandleFunc(""/api/user/read"", GetUsers)
    gorillaRoute.HandleFunc(""/api/user/:id"", GetUser)
    http.Handle(""/"", gorillaRoute)
    http.ListenAndServe("":8080"", nil)
}

"
35678560,"Using Windows DLLs is (in my opinion) the best way to directly use the Win32 API.

If you look in the src/syscall directory of your Go installation, you can find a file called mksyscall_windows.go. This seems to be how the Go team manages all their DLL wrappers.

Use go generate to generate your code

Take a look at how syscall_windows.go uses it. Specifically it has the following go generate command:


  //go:generate go run mksyscall_windows.go -output zsyscall_windows.go syscall_windows.go security_windows.go


Define the Win32 API types

They then define their types. You will need to do this yourself manually.

It is a challenge sometimes because it is vital you preserve the size and alignment of the struct fields. I use Visual Studio Community Edition to poke around at the plethora of Microsoft's defined basic types in an effort to determine their Go equivalents.

Windows uses UTF16 for strings. So you will be representing these as a *uint16. Use syscall.UTF16PtrFromString to generate one from a Go string.

Annotate Win32 API functions to export

The whole point of mksyscall_windows.go is to generate all the boilerplate code so you end up with a Go function that calls the DLL for you.

This is accomplished by adding annotations (Go comments).

For example, in syscall_windows.go you have these annotations:

//sys   GetLastError() (lasterr error)
//...
//sys   CreateHardLink(filename *uint16, existingfilename *uint16, reserved uintptr) (err error) [failretval&0xff==0] = CreateHardLinkW


mksyscall_windows.go has doc comments to help you figure out how this works. You can also look at the go-generated code in zsyscall_windows.go.

Run go generate

Its easy, just run:

go generate


Example:

For your example, create a file called win32_windows.go:

package win32

//go generate go run mksyscall_windows.go -output zwin32_windows.go win32_windows.go

type (
    LPVOID         uintptr
    LMSTR          *uint16
    DWORD          uint32
    LPBYTE         *byte
    LPDWORD        *uint32
    LPWSTR         *uint16
    NET_API_STATUS DWORD

    USER_INFO_1 struct {
        Usri1_name         LPWSTR
        Usri1_password     LPWSTR
        Usri1_password_age DWORD
        Usri1_priv         DWORD
        Usri1_home_dir     LPWSTR
        Usri1_comment      LPWSTR
        Usri1_flags        DWORD
        Usri1_script_path  LPWSTR
    }

    GROUP_USERS_INFO_0 struct {
        Grui0_name LPWSTR
    }

    USER_INFO_1003 struct {
        Usri1003_password LPWSTR
    }
)

const (
    // from LMaccess.h

    USER_PRIV_GUEST = 0
    USER_PRIV_USER  = 1
    USER_PRIV_ADMIN = 2

    UF_SCRIPT                          = 0x0001
    UF_ACCOUNTDISABLE                  = 0x0002
    UF_HOMEDIR_REQUIRED                = 0x0008
    UF_LOCKOUT                         = 0x0010
    UF_PASSWD_NOTREQD                  = 0x0020
    UF_PASSWD_CANT_CHANGE              = 0x0040
    UF_ENCRYPTED_TEXT_PASSWORD_ALLOWED = 0x0080

    UF_TEMP_DUPLICATE_ACCOUNT    = 0x0100
    UF_NORMAL_ACCOUNT            = 0x0200
    UF_INTERDOMAIN_TRUST_ACCOUNT = 0x0800
    UF_WORKSTATION_TRUST_ACCOUNT = 0x1000
    UF_SERVER_TRUST_ACCOUNT      = 0x2000

    UF_ACCOUNT_TYPE_MASK = UF_TEMP_DUPLICATE_ACCOUNT |
        UF_NORMAL_ACCOUNT |
        UF_INTERDOMAIN_TRUST_ACCOUNT |
        UF_WORKSTATION_TRUST_ACCOUNT |
        UF_SERVER_TRUST_ACCOUNT

    UF_DONT_EXPIRE_PASSWD                     = 0x10000
    UF_MNS_LOGON_ACCOUNT                      = 0x20000
    UF_SMARTCARD_REQUIRED                     = 0x40000
    UF_TRUSTED_FOR_DELEGATION                 = 0x80000
    UF_NOT_DELEGATED                          = 0x100000
    UF_USE_DES_KEY_ONLY                       = 0x200000
    UF_DONT_REQUIRE_PREAUTH                   = 0x400000
    UF_PASSWORD_EXPIRED                       = 0x800000
    UF_TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION = 0x1000000
    UF_NO_AUTH_DATA_REQUIRED                  = 0x2000000
    UF_PARTIAL_SECRETS_ACCOUNT                = 0x4000000
    UF_USE_AES_KEYS                           = 0x8000000

    UF_SETTABLE_BITS = UF_SCRIPT |
        UF_ACCOUNTDISABLE |
        UF_LOCKOUT |
        UF_HOMEDIR_REQUIRED |
        UF_PASSWD_NOTREQD |
        UF_PASSWD_CANT_CHANGE |
        UF_ACCOUNT_TYPE_MASK |
        UF_DONT_EXPIRE_PASSWD |
        UF_MNS_LOGON_ACCOUNT |
        UF_ENCRYPTED_TEXT_PASSWORD_ALLOWED |
        UF_SMARTCARD_REQUIRED |
        UF_TRUSTED_FOR_DELEGATION |
        UF_NOT_DELEGATED |
        UF_USE_DES_KEY_ONLY |
        UF_DONT_REQUIRE_PREAUTH |
        UF_PASSWORD_EXPIRED |
        UF_TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION |
        UF_NO_AUTH_DATA_REQUIRED |
        UF_USE_AES_KEYS |
        UF_PARTIAL_SECRETS_ACCOUNT

    FILTER_TEMP_DUPLICATE_ACCOUNT    = (0x0001)
    FILTER_NORMAL_ACCOUNT            = (0x0002)
    FILTER_INTERDOMAIN_TRUST_ACCOUNT = (0x0008)
    FILTER_WORKSTATION_TRUST_ACCOUNT = (0x0010)
    FILTER_SERVER_TRUST_ACCOUNT      = (0x0020)

    LG_INCLUDE_INDIRECT = (0x0001)

    // etc...
)

//sys NetApiBufferFree(Buffer LPVOID) (status NET_API_STATUS) = netapi32.NetApiBufferFree
//sys NetUserAdd(servername LMSTR, level DWORD, buf LPBYTE, parm_err LPDWORD) (status NET_API_STATUS) = netapi32.NetUserAdd
//sys NetUserChangePassword(domainname LPCWSTR, username LPCWSTR, oldpassword LPCWSTR, newpassword LPCWSTR) (status NET_API_STATUS) = netapi32.NetUserChangePassword
//sys NetUserDel(servername LPCWSTR, username LPCWSTR) (status NET_API_STATUS) = netapi32.NetUserDel
//sys NetUserEnum(servername LPCWSTR, level DWORD, filter DWORD, bufptr *LPBYTE, prefmaxlen DWORD, entriesread LPDWORD, totalentries LPDWORD, resume_handle LPDWORD) (status NET_API_STATUS) = netapi32.NetUserEnum
//sys NetUserGetGroups(servername LPCWSTR, username LPCWSTR, level DWORD, bufptr *LPBYTE, prefmaxlen DWORD, entriesread LPDWORD, totalentries LPDWORD) (status NET_API_STATUS) = netapi32.NetUserGetGroups
//sys NetUserSetGroups(servername LPCWSTR, username LPCWSTR, level DWORD, buf LPBYTE, num_entries DWORD) (status NET_API_STATUS) = netapi32.NetUserSetGroups
//sys NetUserSetInfo(servername LPCWSTR, username LPCWSTR, level DWORD, buf LPBYTE, parm_err LPDWORD) (status NET_API_STATUS) = netapi32.NetUserSetInfo


After running go generate (so long as you copied mksyscall_windows.go to the same directory) you will have a file called ""zwin32_windows.go"" (something like this):

// MACHINE GENERATED BY 'go generate' COMMAND; DO NOT EDIT

package win32

import ""unsafe""
import ""syscall""

var _ unsafe.Pointer

var (
    modnetapi32 = syscall.NewLazyDLL(""netapi32.dll"")

    procNetApiBufferFree      = modnetapi32.NewProc(""NetApiBufferFree"")
    procNetUserAdd            = modnetapi32.NewProc(""NetUserAdd"")
    procNetUserChangePassword = modnetapi32.NewProc(""NetUserChangePassword"")
    procNetUserDel            = modnetapi32.NewProc(""NetUserDel"")
    procNetUserEnum           = modnetapi32.NewProc(""NetUserEnum"")
    procNetUserGetGroups      = modnetapi32.NewProc(""NetUserGetGroups"")
    procNetUserSetGroups      = modnetapi32.NewProc(""NetUserSetGroups"")
    procNetUserSetInfo        = modnetapi32.NewProc(""NetUserSetInfo"")
)

func NetApiBufferFree(Buffer LPVOID) (status NET_API_STATUS) {
    r0, _, _ := syscall.Syscall(procNetApiBufferFree.Addr(), 1, uintptr(Buffer), 0, 0)
    status = NET_API_STATUS(r0)
    return
}

func NetUserAdd(servername LMSTR, level DWORD, buf LPBYTE, parm_err LPDWORD) (status NET_API_STATUS) {
    r0, _, _ := syscall.Syscall6(procNetUserAdd.Addr(), 4, uintptr(servername), uintptr(level), uintptr(buf), uintptr(parm_err), 0, 0)
    status = NET_API_STATUS(r0)
    return
}

func NetUserChangePassword(domainname LPCWSTR, username LPCWSTR, oldpassword LPCWSTR, newpassword LPCWSTR) (status NET_API_STATUS) {
    r0, _, _ := syscall.Syscall6(procNetUserChangePassword.Addr(), 4, uintptr(domainname), uintptr(username), uintptr(oldpassword), uintptr(newpassword), 0, 0)
    status = NET_API_STATUS(r0)
    return
}

func NetUserDel(servername LPCWSTR, username LPCWSTR) (status NET_API_STATUS) {
    r0, _, _ := syscall.Syscall(procNetUserDel.Addr(), 2, uintptr(servername), uintptr(username), 0)
    status = NET_API_STATUS(r0)
    return
}

func NetUserEnum(servername LPCWSTR, level DWORD, filter DWORD, bufptr *LPBYTE, prefmaxlen DWORD, entriesread LPDWORD, totalentries LPDWORD, resume_handle LPDWORD) (status NET_API_STATUS) {
    r0, _, _ := syscall.Syscall9(procNetUserEnum.Addr(), 8, uintptr(servername), uintptr(level), uintptr(filter), uintptr(unsafe.Pointer(bufptr)), uintptr(prefmaxlen), uintptr(entriesread), uintptr(totalentries), uintptr(resume_handle), 0)
    status = NET_API_STATUS(r0)
    return
}

func NetUserGetGroups(servername LPCWSTR, username LPCWSTR, level DWORD, bufptr *LPBYTE, prefmaxlen DWORD, entriesread LPDWORD, totalentries LPDWORD) (status NET_API_STATUS) {
    r0, _, _ := syscall.Syscall9(procNetUserGetGroups.Addr(), 7, uintptr(servername), uintptr(username), uintptr(level), uintptr(unsafe.Pointer(bufptr)), uintptr(prefmaxlen), uintptr(entriesread), uintptr(totalentries), 0, 0)
    status = NET_API_STATUS(r0)
    return
}

func NetUserSetGroups(servername LPCWSTR, username LPCWSTR, level DWORD, buf LPBYTE, num_entries DWORD) (status NET_API_STATUS) {
    r0, _, _ := syscall.Syscall6(procNetUserSetGroups.Addr(), 5, uintptr(servername), uintptr(username), uintptr(level), uintptr(buf), uintptr(num_entries), 0)
    status = NET_API_STATUS(r0)
    return
}

func NetUserSetInfo(servername LPCWSTR, username LPCWSTR, level DWORD, buf LPBYTE, parm_err LPDWORD) (status NET_API_STATUS) {
    r0, _, _ := syscall.Syscall6(procNetUserSetInfo.Addr(), 5, uintptr(servername), uintptr(username), uintptr(level), uintptr(buf), uintptr(parm_err), 0)
    status = NET_API_STATUS(r0)
    return
}


Obviously most of the work is in translating the Win32 types to their Go equivalents.

Feel free to poke around in the syscall package - they often have already defined structs you may be interested in.

ZOMG sriously??1! 2 much work!

Its better than writing that code by hand. And no CGo required!

Disclamer: I have not tested the above code to verify it actually does what you want. Working with the Win32 API is its own barrel of fun.
"
35561849,"The slices temp and input share the same backing array. Modifications through one slice are visible through the other. The line containing ""INPUT END7"" is not the same as the line with ""INPUT END1"" because the backing array of the slices is modified on this line:

asdf := append(header, e...)


You can copy the backing array using this line of code:

temp := append([]byte(nil), input...)

"
42685397,"This random error shows up, looks like it's related to go, but I don't even have that version of go installed and the file being referenced does not exist.

I've tried uninstalling and reinstalling go through homebrew but nothing seems to change.  It happens randomly and shows up after I've executed a command (maybe 1/50 times).

failed MSpanList_Insert 0x2d6000 0x1e03e6f2951c 0x0
fatal error: MSpanList_Insert

runtime stack:
runtime.throw(0x279a4b)
    /usr/local/Cellar/go/1.4.2/libexec/src/runtime/panic.go:491 +0xad fp=0x7fff5fbff690 sp=0x7fff5fbff660
runtime.MSpanList_Insert(0x298e28, 0x2d6000)
    /usr/local/Cellar/go/1.4.2/libexec/src/runtime/mheap.c:692 +0x8f fp=0x7fff5fbff6b8 sp=0x7fff5fbff690
MHeap_FreeSpanLocked(0x295a20, 0x2d6000, 0x100)
    /usr/local/Cellar/go/1.4.2/libexec/src/runtime/mheap.c:583 +0x163 fp=0x7fff5fbff6f8 sp=0x7fff5fbff6b8
MHeap_Grow(0x295a20, 0x8, 0x0)
    /usr/local/Cellar/go/1.4.2/libexec/src/runtime/mheap.c:420 +0x1a8 fp=0x7fff5fbff738 sp=0x7fff5fbff6f8
MHeap_AllocSpanLocked(0x295a20, 0x1, 0x0)
    /usr/local/Cellar/go/1.4.2/libexec/src/runtime/mheap.c:298 +0x365 fp=0x7fff5fbff778 sp=0x7fff5fbff738
mheap_alloc(0x295a20, 0x1, 0x12, 0x0)
    /usr/local/Cellar/go/1.4.2/libexec/src/runtime/mheap.c:190 +0x121 fp=0x7fff5fbff7a0 sp=0x7fff5fbff778
runtime.MHeap_Alloc(0x295a20, 0x1, 0x10000000012, 0x1f2e9)
    /usr/local/Cellar/go/1.4.2/libexec/src/runtime/mheap.c:240 +0x66 fp=0x7fff5fbff7d8 sp=0x7fff5fbff7a0
MCentral_Grow(0x29d798, 0x0)
    /usr/local/Cellar/go/1.4.2/libexec/src/runtime/mcentral.c:197 +0x8b fp=0x7fff5fbff840 sp=0x7fff5fbff7d8
runtime.MCentral_CacheSpan(0x29d798, 0x0)
    /usr/local/Cellar/go/1.4.2/libexec/src/runtime/mcentral.c:85 +0x167 fp=0x7fff5fbff878 sp=0x7fff5fbff840
runtime.MCache_Refill(0x2d2000, 0x12, 0x0)
    /usr/local/Cellar/go/1.4.2/libexec/src/runtime/mcache.c:90 +0xa0 fp=0x7fff5fbff8a0 sp=0x7fff5fbff878
runtime.mcacheRefill_m()
    /usr/local/Cellar/go/1.4.2/libexec/src/runtime/malloc.c:368 +0x57 fp=0x7fff5fbff8c0 sp=0x7fff5fbff8a0
runtime.onM(0x1f3ff8)
    /usr/local/Cellar/go/1.4.2/libexec/src/runtime/asm_amd64.s:273 +0x9a fp=0x7fff5fbff8c8 sp=0x7fff5fbff8c0
runtime.mallocgc(0x120, 0x198de0, 0x0, 0x0)
    /usr/local/Cellar/go/1.4.2/libexec/src/runtime/malloc.go:178 +0x849 fp=0x7fff5fbff978 sp=0x7fff5fbff8c8
runtime.newobject(0x198de0, 0x2d2000)
    /usr/local/Cellar/go/1.4.2/libexec/src/runtime/malloc.go:353 +0x49 fp=0x7fff5fbff9a0 sp=0x7fff5fbff978
runtime.newG(0x3645a)
    /usr/local/Cellar/go/1.4.2/libexec/src/runtime/proc.go:233 +0x2a fp=0x7fff5fbff9b8 sp=0x7fff5fbff9a0
allocg(0x288380)
    /usr/local/Cellar/go/1.4.2/libexec/src/runtime/proc.c:925 +0x1f fp=0x7fff5fbff9c8 sp=0x7fff5fbff9b8
runtime.malg(0x8000, 0x288420)
    /usr/local/Cellar/go/1.4.2/libexec/src/runtime/proc.c:2106 +0x1f fp=0x7fff5fbff9f8 sp=0x7fff5fbff9c8
runtime.mpreinit(0x2887e0)
    /usr/local/Cellar/go/1.4.2/libexec/src/runtime/os_darwin.c:137 +0x27 fp=0x7fff5fbffa10 sp=0x7fff5fbff9f8
mcommoninit(0x2887e0)
    /usr/local/Cellar/go/1.4.2/libexec/src/runtime/proc.c:201 +0xc9 fp=0x7fff5fbffa38 sp=0x7fff5fbffa10
runtime.schedinit()
    /usr/local/Cellar/go/1.4.2/libexec/src/runtime/proc.c:138 +0x55 fp=0x7fff5fbffa60 sp=0x7fff5fbffa38
runtime.rt0_go(0x7fff5fbffa90, 0x3, 0x7fff5fbffa90, 0x0, 0x3, 0x7fff5fbffbd0, 0x7fff5fbffbd7, 0x7fff5fbffbdc, 0x0, 0x7fff5fbffbe1, ...)
    /usr/local/Cellar/go/1.4.2/libexec/src/runtime/asm_amd64.s:95 +0x116 fp=0x7fff5fbffa68 sp=0x7fff5fbffa60

"
10522892,"I'm getting the following response, when trying to upload data to BigQuery using the Google API Client libraries for Go.

{
 ""error"": {
  ""errors"": [
   {
    ""domain"": ""global"",
    ""reason"": ""badRequest"",
    ""message"": ""Invalid Upload Request""
   }
  ],
  ""code"": 400,
  ""message"": ""Invalid Upload Request""
 }
}


My job descriptor looks like this:

j := &bigquery.Job{
    Configuration: &bigquery.JobConfiguration{
        Load: &bigquery.JobConfigurationLoad{
            DestinationTable: &bigquery.TableReference{
                projectId,
                ""xyz"",
                name + ""_"" + yyyymmdd,
            },
            SkipLeadingRows: 1,
            FieldDelimiter:  ""|"",
            MaxBadRecords:   3,
            Schema: &bigquery.TableSchema{
                []*bigquery.TableFieldSchema{
                    {Name: ""f1"", Type: ""STRING""},
                    {Name: ""f2"", Type: ""STRING""},
                    {Name: ""f3"", Type: ""STRING""},
                    {Name: ""f4"", Type: ""STRING""},
                    {Name: ""f5"", Type: ""STRING""},
                    {Name: ""f6"", Type: ""STRING""},
                    {Name: ""f7"", Type: ""STRING""},
                    {Name: ""f8"", Type: ""STRING""},
                    {Name: ""f9"", Type: ""STRING""},
                    {Name: ""f10"", Type: ""STRING""},
                    {Name: ""f11"", Type: ""STRING""},
                    {Name: ""f12"", Type: ""STRING""},
                    {Name: ""f13"", Type: ""STRING""},
                    {Name: ""f14"", Type: ""STRING""},
                    {Name: ""f15"", Type: ""STRING""},
                    {Name: ""f16"", Type: ""STRING""},
                    {Name: ""f17"", Type: ""STRING""},
                },
            },
        },
    },
}


FWIW, other calls using this library work fine, so I have ruled out oauth problems, etc.

EDIT: I captured the request before it went out.  Please note that this is before the http.Client is able to add the oauth headers.  The actual request is large, so I have shortened it and removed the identifiers.

POST /upload/bigquery/v2/projects/.../jobs HTTP/1.1
Host: www.googleapis.com
User-Agent: google-api-go-client/0.5
Content-Length: 56369074
Content-Type: multipart/related; boundary=2220cacc03485c8143026fe3f0c40dcb1aaec8c8c2426e69adf620fc12cf

--2220cacc03485c8143026fe3f0c40dcb1aaec8c8c2426e69adf620fc12cf
Content-Type: application/json

{""configuration"":{""load"":{""destinationTable"":{""projectId"":""..."",""datasetId"":""..."",""tableId"":""...""},""skipLeadingRows"":1,""fieldDelimiter"":""|"",""maxBadRecords"":3,""schema"":{""fields"":[{""name"":""..."",""type"":""STRING""},{""name"":""..."",""type"":""STRING""},{""name"":""..."",""type"":""STRING""},{""name"":""..."",""type"":""STRING""},{""name"":""..."",""type"":""STRING""},{""name"":""..."",""type"":""STRING""},{""name"":""..."",""type"":""STRING""},{""name"":""..."",""type"":""STRING""},{""name"":""..."",""type"":""STRING""},{""name"":""..."",""type"":""STRING""},{""name"":""..."",""type"":""STRING""},{""name"":""..."",""type"":""STRING""},{""name"":""..."",""type"":""STRING""},{""name"":""..."",""type"":""STRING""},{""name"":""..."",""type"":""STRING""},{""name"":""..."",""type"":""STRING""},{""name"":""..."",""type"":""STRING""}]}}}}

--2220cacc03485c8143026fe3f0c40dcb1aaec8c8c2426e69adf620fc12cf
Content-Type: text/plain; charset=utf-8

H0|H1|H2|H3|H4|H5|H6|H7|H8|H9|H10|H11|H12|H13|H14|H15|H16
f0_0|f0_1|f0_2|f0_3|f0_4|f0_5|f0_6|f0_7|f0_8|f0_9|f0_10|f0_11|f0_12|f0_13|f0_14|f0_15|f0_16
f1_0|f1_1|f1_2|f1_3|f1_4|f1_5|f1_6|f1_7|f1_8|f1_9|f1_10|f1_11|f1_12|f1_13|f1_14|f1_15|f1_16
# Three lines
# of comments
# in the trailer

--2220cacc03485c8143026fe3f0c40dcb1aaec8c8c2426e69adf620fc12cf--

"
32415803,"In this example below the UPDATE command doesn't work. Why ?

See the updateDate method for details.

package main

import (
    ""database/sql""
    ""fmt""
    ""log""

    _ ""github.com/go-sql-driver/mysql""
)

type ConnData struct {
    // para usar conexão via socket veja '/etc/mysql/my.cnf'
    // para usar conexão via tcp confira a porta com 'ps -ef | grep mysqld'
    dbuser, dbpasswd, dbname, tcp, socket string
}

var myConnData = ConnData{dbuser: ""soma"", dbpasswd: ""secret1000"",
    dbname: ""test"",
    tcp:    ""tcp(127.0.0.1:3307)"",
    socket: ""unix(/tmp/mysql.sock)""}

// CREATE TABLE userinfo
// (
//     uid serial NOT NULL,
//     username character varying(20) NOT NULL,
//     depto character varying(10)  NULL,
//     Created date,
//     CONSTRAINT userinfo_pkey PRIMARY KEY (uid)
// )
func main() {
    _ = ConnectToMySQLAndRunCmd(myConnData).(string)
}
func ConnectToMySQLAndRunCmd(connData ConnData) interface{} {
    myConnStr := connData.dbuser + "":"" + connData.dbpasswd +
        ""@"" + connData.tcp + ""/"" + connData.dbname
    log.Printf(""Connecting to MySQL Server using %s\n"", myConnStr)
    db, err := sql.Open(""mysql"", myConnStr)
    // myConnStr := connData.dbuser + "":"" + connData.dbpasswd +
    //  ""@"" + connData.tcp + ""/"" + connData.dbname

    defer db.Close()
    checkErr(err)
    // Open doesn't open a connection. Validate DSN data:
    err = db.Ping()
    checkErr(err)
    // Limpando a tabela
    _, err = db.Exec(""DELETE FROM userinfo"")
    checkErr(err)
    // Consultando
    selectAll(db)
    // Inserindo
    stmt, err := db.Prepare(""INSERT INTO userinfo (username, depto, created) VALUES(?,?,?)"")
    // db.Prepare(""INSERT INTO users(name) VALUES(?)"")
    checkErr(err)
    res, err := stmt.Exec(""Pedro"", ""TI"", ""2015-09-01"")
    checkErr(err)
    lastId, err := res.LastInsertId()
    checkErr(err)
    rowCnt, err := res.RowsAffected()
    checkErr(err)
    log.Printf(""ID = %d, affected = %d\n"", lastId, rowCnt)
    // Verificando
    selectAll(db)
    // Atualizando
    updateDate(db, lastId)
    // Verificando Novamente
    selectAll(db)
    return ""OK""
}

func selectAll(mydb *sql.DB) {
    // Consultando todos
    var (
        id    int
        name  string
        depto string
        date  string
    )
    rows, err := mydb.Query(""select uid, username, depto, created from userinfo"")
    checkErr(err)
    defer rows.Close()
    for rows.Next() {
        err := rows.Scan(&id, &name, &depto, &date)
        checkErr(err)
        log.Println(id, name, depto, date)
    }
    err = rows.Err()
    checkErr(err)
}

func updateDate(mydb *sql.DB, lastId int64) {
    // Atualizando a data
    tx, err := mydb.Begin()
    checkErr(err)
    //...
    cmd := ""UPDATE userinfo SET created = ? WHERE uid = ?""
    updateDate, err := tx.Prepare(cmd)
    checkErr(err)
    //...
    log.Println(""•••• Updating record"", lastId)
    res, err := updateDate.Exec(lastId, ""2015-09-02"")
    checkErr(err)
    // log.Println(""•••• >>> "", res)
    updateDate.Close()
    err = tx.Commit()
    checkErr(err)
    affect, err := res.RowsAffected()
    checkErr(err)

    fmt.Println(""Records affected"", affect)
}

func checkErr(err error) {
    if err != nil {
        log.Fatal(err)
        panic(err)
    }
}


What is going wrong ?

See below the result when I run the main programa.

$ ./main
2015/09/05 14:04:34 Connecting to MySQL Server using soma:soma@tcp(127.0.0.1:3307)/test
2015/09/05 14:04:34 ID = 3, affected = 1
2015/09/05 14:04:34 3 Pedro TI 2015-09-01
2015/09/05 14:04:34 •••• Updating record 3
Records affected 0
2015/09/05 14:04:34 3 Pedro TI 2015-09-01


I'm using go build -a -installsuffix cgo -o main . to build the main program
"
27614932,"I am making a captcha and am following the example given here. I need to modify the example to use gorilla mux's routing as the rest of my app uses that. For the life of me I can't figure out how to correctly route the path for line 47 of that example. What I have below results in no captcha generated...(the example itself works fine). For shits & giggles I've even tried ""http.HandleFunc(""/captcha/"", captchaHandler)"" but that doesn't work either. Any suggestions?  

package main

import (
    ""github.com/dchest/captcha""
    ""github.com/gorilla/mux""
    ""io""
    ""log""
    ""net/http""
    ""text/template""
)

var formTemplate = template.Must(template.New(""example"").Parse(formTemplateSrc))

func showFormHandler(w http.ResponseWriter, r *http.Request) {
    if r.URL.Path != ""/"" {
        http.NotFound(w, r)
        return
    }
    d := struct {
        CaptchaId string
    }{
        captcha.New(),
    }
    if err := formTemplate.Execute(w, &d); err != nil {
        http.Error(w, err.Error(), http.StatusInternalServerError)
    }
}

func processFormHandler(w http.ResponseWriter, r *http.Request) {
    w.Header().Set(""Content-Type"", ""text/html; charset=utf-8"")
    if !captcha.VerifyString(r.FormValue(""captchaId""), r.FormValue(""captchaSolution"")) {
        io.WriteString(w, ""Wrong captcha solution! No robots allowed!\n"")
    } else {
        io.WriteString(w, ""Great job, human! You solved the captcha.\n"")
    }
    io.WriteString(w, ""Try another one"")
}

func captchaHandler(w http.ResponseWriter, r *http.Request) {
    captcha.Server(captcha.StdWidth, captcha.StdHeight)
}

type Routes []Route
type Route struct {
    Method      string
    Pattern     string
    HandlerFunc http.HandlerFunc
}

func main() {
    /*
        http.HandleFunc(""/"", showFormHandler)
        http.HandleFunc(""/process"", processFormHandler)
        //http.HandleFunc(""/captcha/"", captchaHandler) // doesn't work
        http.Handle(""/captcha/"", captcha.Server(captcha.StdWidth, captcha.StdHeight))
        fmt.Println(""Server is at localhost:8666"")
        if err := http.ListenAndServe("":8666"", nil); err != nil {
            log.Fatal(err)
        }
    */
    var routes = Routes{
        Route{""GET"", ""/"", showFormHandler},
        Route{""POST"", ""/process"", processFormHandler},
        Route{""GET"", ""/captcha/"", captchaHandler},
    }
    router := mux.NewRouter().StrictSlash(true)
    for _, route := range routes {
        var handler http.Handler
        handler = route.HandlerFunc
        router.Methods(route.Method).Path(route.Pattern).Handler(handler)
    }
    //router.Methods(""GET"").Path(""/captcha/"").HandlerFunc(captcha.Server(captcha.StdWidth, captcha.StdHeight))

    port := "":8666""
    log.Println(""Listening at"", port)
    log.Fatal(http.ListenAndServe(port, router))
}

const formTemplateSrc = `
Captcha Example


function setSrcQuery(e, q) {
    var src  = e.src;
    var p = src.indexOf('?');
    if (p >= 0) {
        src = src.substr(0, p);
    }
    e.src = src + ""?"" + q
}
function playAudio() {
    var le = document.getElementById(""lang"");
    var lang = le.options[le.selectedIndex].value;
    var e = document.getElementById('audio')
    setSrcQuery(e, ""lang="" + lang)
    e.style.display = 'block';
    e.autoplay = 'true';
    return false;
}
function changeLang() {
    var e = document.getElementById('audio')
    if (e.style.display == 'block') {
        playAudio();
    }
}
function reload() {
    setSrcQuery(document.getElementById('image'), ""reload="" + (new Date()).getTime());
    setSrcQuery(document.getElementById('audio'), (new Date()).getTime());
    return false;
}


    English
    Russian
    Chinese


Type the numbers you see in the picture below:

Reload | Play Audio

  You browser doesn't support audio.
  Download file to play it in the external player.





`


EDIT #1:
To be clearer ""doesn't work"" isn't helpful. It returns a 404 error.

EDIT #2:
The example on github works fine....its only when I modify the route that it returns a 404 when I try to generate a captcha.
"
38420925,"I am unmarshalling Youtube json response into Go struct by using the data received from Youtube API as follows:-

{
 ""kind"": ""youtube#searchListResponse"",
 ""etag"": ""\""5g01s4-wS2b4VpScndqCYc5Y-8k/5xHRkUxevhiDF1huCnKw2ybduyo\"""",
 ""nextPageToken"": ""CBQQAA"",
 ""regionCode"": ""TH"",
 ""pageInfo"": {
  ""totalResults"": 36,
  ""resultsPerPage"": 20
 },
 ""items"": [
  {
   ""kind"": ""youtube#searchResult"",
   ""etag"": ""\""5g01s4-wS2b4VpScndqCYc5Y-8k/aMbszoNudZchce3BIjZC_YemugE\"""",
   ""id"": {
    ""kind"": ""youtube#video"",
    ""videoId"": ""fvh6CQ7FxZE""
   },
   ""snippet"": {
    ""publishedAt"": ""2016-07-16T14:42:36.000Z"",
    ""channelId"": ""UCuX4iswo8acMxDNcbrceRYQ"",
    ""title"": ""Japan อร่อยสุดๆ:การประชันของ 2 สาวกับราเมงดังจากโอซาก้า#ramen"",
    ""description"": ""Ramen Kio ราเมนชื่อดังของโอซาก้าอัดแน่นด้วยเนื้อหมูชาชูแบบเต็มๆเส้นเหนีย..."",
    ""thumbnails"": {
     ""default"": {
      ""url"": ""https://i.ytimg.com/vi/fvh6CQ7FxZE/default.jpg"",
      ""width"": 120,
      ""height"": 90
     },
     ""medium"": {
      ""url"": ""https://i.ytimg.com/vi/fvh6CQ7FxZE/mqdefault.jpg"",
      ""width"": 320,
      ""height"": 180
     },
     ""high"": {
      ""url"": ""https://i.ytimg.com/vi/fvh6CQ7FxZE/hqdefault.jpg"",
      ""width"": 480,
      ""height"": 360
     }
    },
    ""channelTitle"": ""Japan aroi sudsud TV"",
    ""liveBroadcastContent"": ""none""
   }
  }
 ]
}


To do so, I have created a struct for this in Go

type YoutubeData struct {
    Kind          string `json:""kind""`
    Etag          string `json:""etag""`
    NextPageToken string `json:""nextPageToken""`
    RegionCode    string `json:""regionCode""`
    PageInfo      struct {
        TotalResults   string `json:""totalResults""`
        ResultsPerPage string `json:""resultsPerPage""`
    } `json:""pageInfo""`
    Items []struct {
        Kind string `json:""kind""`
        Etag string `json:""etag""`
        Id   struct {
            Kind    string `json:""kind""`
            VideoId string `json:""videoId""`
        } `json:""id""`
        Snippet struct {
            PublishedAt string `json:""publishedAt""`
            ChannelId   string `json:""channelId""`
            Title       string `json:""title""`
            Description string `json:""description""`
            Thumbnails  struct {
                Default struct {
                    Url    string `json:""url""`
                    Width  string `json:""width""`
                    Height string `json:""height""`
                } `json:""default""`
                Medium struct {
                    Url    string `json:""url""`
                    Width  string `json:""width""`
                    Height string `json:""height""`
                } `json:""medium""`
                High struct {
                    Url    string `json:""url""`
                    Width  string `json:""width""`
                    Height string `json:""height""`
                } `json:""high""`
            } `json:""thumbnails""`
            ChannelTitle         string `json:""channelTitle""`
            LiveBroadcastContent string `json:""liveBroadcastContent""`
        } `json:""snippet""`
    } `json:""items""`
}


I unmarshaled it by using this method

youtubeData := YoutubeData{}

if json.Unmarshal(b, &youtubeData); err != nil {

} else {

} 


In which b is the byte data received from Youtube API. I successfully got all data in the byte object as I printed it out to my console, however, once I unmarshaled it and tried to output it on the template by using {{.}}, I received

{youtube#searchListResponse ""5g01s4-wS2b4VpScndqCYc5Y-8k/JwGY0TWwWswjZ9LOvemaF5yxsMo"" CBQQAA TH { } []}


All data are unmarshaled except for the data in json object and array which are pageInfo and items. There are simply blank. I believe I exported them all correctly. Are there some additional steps to get the data into slice or struct nested inside another struct in Go when it comes to json unmarshalling?
"
32061649,"If you want to fan out then aggregate results and you want specific timeout behavior the net/http package isn't giving you, then you may want to use goroutines and channels.  

I just watched this video today and it will walk you through exactly those scenarios using the concurrency features of Go.  Plus, the speaker Rob Pike is quite the authority -- he explains it much better than I could.

https://www.youtube.com/watch?v=f6kdp27TYZs
"
39736804,"This is what i normally do. 

package mongo

import (
    ""time""

    ""gopkg.in/mgo.v2""
)

// DataStore containing a pointer to a mgo session
type DataStore struct {
    Session *mgo.Session
}

// ConnectToTagserver is a helper method that connections to pubgears' tagserver
// database
func (ds *DataStore) ConnectToTagserver() {
    mongoDBDialInfo := &mgo.DialInfo{
        Addrs:    []string{""some IP""},
        Timeout:  60 * time.Second,
        Database: ""some db"",
    }
    sess, err := mgo.DialWithInfo(mongoDBDialInfo)
    if err != nil {
        panic(err)
    }
    sess.SetMode(mgo.Monotonic, true)
    ds.Session = sess
}

// Close is a helper method that ensures the session is properly terminated
func (ds *DataStore) Close() {
    ds.Session.Close()
}


Then in my models package I do something like this

package models

import (
    ""./mongo""
    ""gopkg.in/mgo.v2/bson""
)

// AdSize represents the data object stucture that is returned by querying
// mongo's account collection
type AdSize struct {
    ID        bson.ObjectId `bson:""_id,omitempty""`
    Providers []string      `bson:""providers""`
    Size      string        `bson:""size""`
}

// GetAllAdsizes is a helper function designed to retrieve all the objects in the
// adsize collection
func GetAllAdsizes() ([]AdSize, error) {
    ds := mongo.DataStore{}
    ds.ConnectToTagserver()
    defer ds.Close()
    adSizes := []AdSize{}
    adSizeCollection := ds.Session.DB(""some database"").C(""some collection"")
    err := adSizeCollection.Find(bson.M{}).Sort(""name"").All(&adSizes)
    return adSizes, err
}


So I created a session wrapper in the mongo file, then create a session object in the models file, then lastly in some route file i call the method GetAllAdsizes(), which handled my mongo session.  The session is keep alive until the the end of the GetAllAdsizes() method, as it was closed on defer. However something like this can be modified, where you handle all the user stuff and then close the session if user logs out. Also take a look here Best practice to maintain a mgo session, where you can see a similar type of logic.
"
35464839,"If you're certain that the server only accepts insecure cipher suites and can't be updated, go does have some RC4 ciphers included, but disabled.

The smtp.SendMail convenience function doesn't have a way to change the tls.Config, but it's easy to take the body of that function and use the smtp.Client manually.

You can create a tls.Config with the CipherSuites you want, and pass it to Client.StartTLS

config := &tls.Config{
    ServerName:   serverName,
    CipherSuites: []uint16{tls.TLS_RSA_WITH_RC4_128_SHA},
}

// c is an smtp.Client
if err = c.StartTLS(config); err != nil {
    return err
}

"
34455925,"I am starting to learn OpenGL now, using the Go programming language (I just couldn't get working with C/C++ on my Windows machine), and so far I've managed to display some rotating cubes in the screen with textures mainly copying and pasting code from tutorials. I've learned a lot, though, but I just can't get some text on the screen with this code that I wrote on my own. I've looked up many tutorials and questions but nothing seems to work, and I suspect there is something wrong with the vertices because I'm pretty sure the textures coordinates are correct and still there's nothing showing up in the screen. Here's the code:

package game

import (
  ""fmt""
  ""io/ioutil""
  ""image""
  ""image/draw""
  ""github.com/go-gl/gl/v3.3-core/gl""
  mgl ""github.com/go-gl/mathgl/mgl32""
  ""github.com/golang/freetype/truetype""
  ""golang.org/x/image/font""
  ""golang.org/x/image/math/fixed""
)

type GameFont struct {
  loaded bool
  vao uint32
  vbo VBOData
  pix float32
  Texture *Texture
  Shader ShaderProgram
}


// Load a TrueType font from a file and generate a texture 
// with all important characters.
func (f *GameFont) Load(path string, pix float32) {
  contents, err := ioutil.ReadFile(path)
  if err != nil {
    fmt.Println(""Could not read font file: "" + path)
    panic(err)
  }
  fontFace, err := truetype.Parse(contents)
  if err != nil {
    fmt.Println(""Could not parse font file: "" + path)
    panic(err)
  }

  // Create a texture for the characters
  // Find the next power of 2 for the texture size
  size := nextP2(int(pix * 16))
  fg, bg := image.White, image.Black
  rgba := image.NewRGBA(image.Rect(0, 0, size, size))

  draw.Draw(rgba, rgba.Bounds(), bg, image.ZP, draw.Src)
  d := &font.Drawer{
    Dst: rgba,
    Src: fg,
    Face: truetype.NewFace(fontFace, &truetype.Options{
      Size: float64(pix),
      DPI: 72,
      Hinting: font.HintingNone,
    }),
  }

  // Some GL preps
  gl.GenVertexArrays(1, &f.vao)
  gl.BindVertexArray(f.vao)
  f.vbo.Create()
  f.vbo.Bind()

  f.Shader = newShaderProgram(""data/shaders/font.vert"", ""data/shaders/font.frag"")
  f.Shader.Use()
  f.Shader.SetUniform(""tex"", 0)

  // Create vertex data (and coordinates in the texture) for each character
  // All characters below 32 are useless
  for i := 32; i < 128; i++ {
    c := string(rune(i))
    x, y := i % 16, i / 16

    // Draw the character on the texture
    d.Dot = fixed.P(x * int(pix), y * int(pix))
    d.DrawString(c)

    // Vertices
    quads := []float32{
      0,    0,
      0,    pix,
      pix,  0,
      pix,  pix,
    }

    norm := func(n int) float32 {
      return float32(n) / 16.0
    }

    // Texture coordinates (normalized)
    texQuads := []float32{
      norm(x),      1.0 - norm(y + 1),
      norm(x),      1.0 - norm(y),
      norm(x + 1),  1.0 - norm(y + 1),
      norm(x + 1),  1.0 - norm(y),
    }

    for v := 0; v < 8; v += 2 {
      vQuads, vTexQuads := quads[v:(v+2)], texQuads[v:(v+2)]

      // Data is like (X, Y, U, V)
      f.vbo.AppendData(vQuads, 2)
      f.vbo.AppendData(vTexQuads, 2)
    }
  }

  // Upload data to GPU and we're done
  f.Texture = newTextureFromRGBA(rgba)
  f.Texture.Bind()
  f.Texture.SetGLParam(gl.TEXTURE_MIN_FILTER, gl.LINEAR)
  f.Texture.SetGLParam(gl.TEXTURE_MAG_FILTER, gl.LINEAR)
  f.Texture.Upload()

  f.vbo.UploadData(gl.STATIC_DRAW)

  gl.EnableVertexAttribArray(0)
  gl.VertexAttribPointer(0, 2, gl.FLOAT, false, 4*4, gl.PtrOffset(0))
  gl.EnableVertexAttribArray(1)
  gl.VertexAttribPointer(1, 2, gl.FLOAT, false, 4*4, gl.PtrOffset(2*4))

  f.loaded = true
}

// Render a text using the font
func (f *GameFont) Render(text string, x, y int, pix float32, color mgl.Vec4) {
  if !f.loaded {
    return
  }

  gl.Disable(gl.DEPTH_TEST)
  gl.Enable(gl.BLEND)
  gl.BlendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA)
  gl.BindVertexArray(f.vao)

  f.Shader.Use()
  f.Shader.SetUniform(""projection"", mgl.Ortho2D(0, _screen.Width, 0, _screen.Height))
  f.Shader.SetUniform(""color"", color)

  f.Texture.Bind()

  scale := pix / f.pix
  for i := 0; i < len(text); i++ {
    index := rune(text[i])
    model := mgl.Ident4().Mul4(mgl.Scale3D(scale, scale, 0))
    model = model.Add(mgl.Translate3D(float32(x) + float32(i) * pix, float32(y), 0))
    f.Shader.SetUniform(""model"", model)
    gl.DrawArrays(gl.TRIANGLE_STRIP, (32-index)*4, 4)
  }

  gl.Enable(gl.DEPTH_TEST)
  gl.Disable(gl.BLEND)
}


Here's the shaders:

Vertex shader

#version 330
uniform mat4 projection;
uniform mat4 model;

layout (location = 0) in vec2 vert;
layout (location = 1) in vec2 vertTexCoord;

out vec2 fragTexCoord;

void main() {
  fragTexCoord = vertTexCoord;
  gl_Position = projection * model * vec4(vert, 0, 1);
}


Fragment shader

#version 330

uniform sampler2D tex;
uniform vec4 color;

in vec2 fragTexCoord;
out vec4 outputColor;

void main() {
  outputColor = color * texture(tex, fragTexCoord);
}


Every ""component"" of the GameFont struct is working properly (I've used them with the rotating cubes), so every function calls the GL corresponding one.

Also the texture is being drawed correctly, I've saved it to the disk and it looks like this:



And still, there's no text on the screen.
"
26948480,"The go-sqlite3 package has been fixed:

https://github.com/mattn/go-sqlite3/commit/e63d2546a03e8591c61871c4e494587cc28bdd79
"
35804927,"Even if you're you're only going to be sending UDP packets from the connection, you generally want to use ListenUDP to create the connection, and use the ReadFromUDP and WriteToUDP methods.

When you use DialUDP, it creates a ""connected"" UDP socket, with an implicit remote endpoint, which will filter incoming packets. From the Linux connect man page:


  If the socket sockfd is of type SOCK_DGRAM then addr is the address to which datagrams are sent by default, and the only address from which datagrams are received.

"
37407476,"I tried to push some data in nested array using $push. Here is my json file

{
    ""_id"" : ObjectId(""57307906f051147d5317984e""),
    ""user"" : [
        {
            ""firstName"" : ""chetan"",
            ""lastName"" : ""kumar"",
            ""age"" : 23,
            ""sales"" : [
                {
            ""firstName"" : ""ashu"",
            ""lastName"" : ""jha"",
            ""age"" : 27
                }
            ],
        },
        {
            ""firstName"" : ""nepolean"",
            ""lastName"" : ""dang"",
            ""age"" : 26
        },
        {
            ""firstName"" : ""Raj"",
            ""lastname"" : ""kumar"",
            ""age"" : 26
        }
    ],

}


Now here is my golang code which I tried here to execute

package main

import(
    ""fmt""
    ""log""
    ""net/http""
        //""encoding/json""
    ""github.com/gorilla/mux""
        ""gopkg.in/mgo.v2""
        ""gopkg.in/mgo.v2/bson""
)
type User struct{
    SALES       []Sales     `json:""sales"" bson:""sales""`
    FIRSTNAME   string      `json:""firstName"" bson:""firstName""`
    LASTNAME    string      `json:""lastName"" bson:""lastName""`
    AGE     int     `json:""age"" bson:""age""`
}
type Sales struct{
    FIRSTNAME   string      `json:""firstName"" bson:""firstName""`
    LASTNAME    string      `json:""lastName"" bson:""lastName""`
    AGE     int     `json:""age"" bson:""age""`
}

type Details struct{
    ID  bson.ObjectId   `json:""_id"" bson:""_id""`
    USER    []User      `json:""user"" bson:""user""`

}


func detail(w http.ResponseWriter, r *http.Request){
    session, err := mgo.Dial(""127.0.0.1"")
        if err != nil {
                panic(err)
        }else{
                fmt.Println(""dial"")
        }
        defer session.Close()


        session.SetMode(mgo.Monotonic, true)

        c := session.DB(""userdb"").C(""user"")
        addsales:= []Sales{Sales{
            FIRSTNAME : ""chetan"",
            LASTNAME : ""kumar"",
            AGE : 24,
            },
        }
    fmt.Println(addsales)
    match := bson.M{""firstName"" : ""nepolean""}
    change := bson.M{""$push"":bson.M{""user.$.sales"":addsales}}
    err = c.Update(match,change)
    if err !=nil{
        panic(err)      
    }else{
    fmt.Println(""success"")
    }
}

func main(){
    router := mux.NewRouter().StrictSlash(true)
    router.HandleFunc(""/detail"",detail)
    log.Fatal(http.ListenAndServe("":9080"", router))

}


Here, is my OutPut after executing

/Desktop$ go run arrayupdate.go dial [{chetan kumar 24}] 2016/05/24
 12:39:48 http: panic serving 127.0.0.1:43928: not found goroutine 5
 [running]: net/http.(*conn).serve.func1(0xc820082200)
    /usr/local/go/src/net/http/server.go:1389 +0xc1 panic(0x7c6bc0,
 0xc82000b080)  /usr/local/go/src/runtime/panic.go:426 +0x4e9
 main.detail(0x7f4a62bf9900, 0xc8200735f0, 0xc8200d6000)
    /home/joybynature/Desktop/arrayupdate.go:93 +0x7a6
 net/http.HandlerFunc.ServeHTTP(0x91d9f0, 0x7f4a62bf9900, 0xc8200735f0,
 0xc8200d6000)  /usr/local/go/src/net/http/server.go:1618 +0x3a
 github.com/gorilla/mux.(*Router).ServeHTTP(0xc820012550,
 0x7f4a62bf9900, 0xc8200735f0, 0xc8200d6000)
    /home/joybynature/src/github.com/gorilla/mux/mux.go:107 +0x285
 net/http.serverHandler.ServeHTTP(0xc820082180, 0x7f4a62bf9900,
 0xc8200735f0, 0xc8200d6000)    /usr/local/go/src/net/http/server.go:2081
 +0x19e net/http.(*conn).serve(0xc820082200)    /usr/local/go/src/net/http/server.go:1472 +0xf2e created by
 net/http.(*Server).Serve   /usr/local/go/src/net/http/server.go:2137
 +0x44e

"
37408597,"You are pushing an array of Sales with syntax for a single item.
It should be either a single Sales object to push:

addsales:= Sales{
    FIRSTNAME : ""chetan"",
    LASTNAME : ""kumar"",
    AGE : 24,
},
change := bson.M{""$push"":bson.M{""user.$.sales"":addsales}}


or use $each modifier to push multiple items:

addsales:= []Sales{Sales{
    FIRSTNAME : ""chetan"",
    LASTNAME : ""kumar"",
    AGE : 24,
    },
}
change := bson.M{""$push"":bson.M{""user.$.sales"":bson.M{""$each"":addsales}}}

"
37216896,"I am working with Redigo Redis library and trying to json.Marshal the result I get from a sorted set but I get results such as this:

""eyJmcm9tSWQiOjEsInRvSWQiOjUsInR5cGUiOjMsInBvc3RJZCI6MSwiY29tbWVudElkIjo0NCwiY3JlYXRlZFRpbWUiOjE0NjMxNTY0ODQsImlzVmlld2VkIjpmYWxzZSwidXNlcm5hbWUiOiJBZG1pbiIsImltYWdlIjoiaHc2ZE5EQlQtMzZ4MzYuanBnIn0=""


When I should be getting this:

""{""fromId"":5,""toId"":1,""type"":3,""postId"":4,""commentId"":49,""createdTime"":1463161736,""isViewed"":false,""username"":""Alexander"",""image"":""JZIfHp8i-36x36.png""}""


I have a Notification struct

type Notification struct {
    FromId int64 `json:""fromId""`
    ToId   int64 `json:""toId""`
    OfType int64 `json:""type""`

    PostId       int64  `json:""postId""`
    CommentId    int64  `json:""commentId""`
    CreatedTime  int64  `json:""createdTime""`
    IsViewed     bool   `json:""isViewed""`
    FromUsername string `json:""username""`
    FromImage    string `json:""image""`
}

func New() *Notification {
    return &Notification{
        CreatedTime: time.Now().Unix(),
    }
}


It has a method that saves a string of json into a Redis sorted set.

func (n *Notification) Create(pool *redis.Pool, multicast chan<- []byte) error {
    var err error
    n.FromUsername, err = validation.FilterUsername(n.FromUsername)
    if err != nil {
        return err
    }
    // We can use the same validation as for a username here.
    n.FromImage, err = validation.FilterUsername(n.FromImage)
    if err != nil {
        return err
    }
    key := fmt.Sprintf(""user:%d:notification"", n.ToId)
    b, err := json.Marshal(n)
    if err != nil {
        return err
    }
    c := pool.Get()
    defer c.Close()
    c.Send(""ZADD"", key, n.CreatedTime, string(b))
    // Limiting to the top ranked 50 items.
    c.Send(""ZREMRANGEBYRANK"", key, 0, -50)
    if err := c.Flush(); err != nil {
        return err
    }
    multicast <- b
    return nil
}


This works all good. But then I want to fetch those results and send then to the client side as an array of json formatted strings. The same json formatted strings that I save in the sorted set.

I am doing something simple like this.

func ByUserId(userId int64, pool *redis.Pool) (interface{}, error) {
    key := fmt.Sprintf(""user:%d:notification"", userId)
    c := pool.Get()
    defer c.Close()
    c.Send(""ZREVRANGE"", key, 0, -1)
    c.Flush()
    return c.Receive()
}


But it does not work.

When I json.Marshal the result I get an array of strings like this:

""eyJmcm9tSWQiOjEsInRvSWQiOjUsInR5cGUiOjMsInBvc3RJZCI6MSwiY29tbWVudElkIjo0NCwiY3JlYXRlZFRpbWUiOjE0NjMxNTY0ODQsImlzVmlld2VkIjpmYWxzZSwidXNlcm5hbWUiOiJBZG1pbiIsImltYWdlIjoiaHc2ZE5EQlQtMzZ4MzYuanBnIn0=""


If I spew.Dump() the results I get this output:

([]interface {}) (len=1 cap=1) {
 ([]uint8) (len=149 cap=149) {
  00000000  7b 22 66 72 6f 6d 49 64  22 3a 35 2c 22 74 6f 49  |{""fromId"":5,""toI|
  00000010  64 22 3a 31 2c 22 74 79  70 65 22 3a 33 2c 22 70  |d"":1,""type"":3,""p|
  00000020  6f 73 74 49 64 22 3a 34  2c 22 63 6f 6d 6d 65 6e  |ostId"":4,""commen|
  00000030  74 49 64 22 3a 34 39 2c  22 63 72 65 61 74 65 64  |tId"":49,""created|
  00000040  54 69 6d 65 22 3a 31 34  36 33 31 36 31 37 33 36  |Time"":1463161736|
  00000050  2c 22 69 73 56 69 65 77  65 64 22 3a 66 61 6c 73  |,""isViewed"":fals|
  00000060  65 2c 22 75 73 65 72 6e  61 6d 65 22 3a 22 53 74  |e,""username"":""Al|
  00000070  61 72 64 75 73 6b 22 2c  22 69 6d 61 67 65 22 3a  |exander"",""image"":|
  00000080  22 4a 5a 49 66 48 70 38  69 2d 33 36 78 33 36 2e  |""JZIfHp8i-36x36.|
  00000090  70 6e 67 22 7d                                    |png""}|
 }
}


What can I do?

EDIT:

This is what I did in the end but it feels like alot of unnecessary conversion.

func ByUserId(userId int64, pool *redis.Pool) ([]string, error) {
    key := fmt.Sprintf(""user:%d:notification"", userId)
    c := pool.Get()
    defer c.Close()
    c.Send(""ZREVRANGE"", key, 0, -1)
    c.Flush()
    reply, err := c.Receive()
    if err != nil {
        return nil, nil
    }
    arr, ok := reply.([]interface{})
    if !ok {
        return nil, err
    }
    ss := []string{}
    for _, v := range arr {
        b, ok := v.([]byte)
        if !ok {
            return nil, nil
        }
        ss = append(ss, string(b))
    }
    return ss, nil
}


And on the handle:

func notifications(w http.ResponseWriter, r *http.Request, _ httprouter.Params) error {
    userId, err := user.LoggedIn(r)
    if err != nil {
        return unauthorized
    }
    jsonResp := make(map[string]interface{})
    jsonResp[""notifications""], err = notification.ByUserId(userId, redisPool)
    if err != nil {
        return err
    }
    jsonResp[""success""] = true
    b, err := json.Marshal(jsonResp)
    if err != nil {
        return err
    }
    w.Write(b)
    return nil
}

"
36474438,"I'm trying to extract match data from whoscored.com. When I view the source on firefox, I find on line 816 a big json string with the data I want for that matchid. My goal is to eventually get this json.

In doing this, I've tried to download every page of https://www.whoscored.com/Matches/ID/Live where ID is the id of the match. I wrote a little Go program to GET request each ID up to a certain point:

package main

import (
    ""fmt""
    ""io/ioutil""
    ""net/http""
    ""os""
)

// http://www.whoscored.com/Matches/614052/Live is the match for
// Eveton vs Manchester
const match_address = ""http://www.whoscored.com/Matches/""

// the max id we get
const max_id = 300
const num_workers = 10

// function that get the bytes of the match id from the website
func match_fetch(matchid int) {
    url := fmt.Sprintf(""%s%d/Live"", match_address, matchid)

    resp, err := http.Get(url)
    if err != nil {
        fmt.Println(err)
        return
    }

    // if we sucessfully got a response, store the
    // body in memory
    defer resp.Body.Close()
    body, err := ioutil.ReadAll(resp.Body)
    if err != nil {
        fmt.Println(err)
        return
    }

    // write the body to memory
    pwd, _ := os.Getwd()
    filepath := fmt.Sprintf(""%s/match_data/%d"", pwd, matchid)
    err = ioutil.WriteFile(filepath, body, 0644)
    if err != nil {
        fmt.Println(err)
        return
    }
}

// data type to send to the workers,
// last means this job is the last one
// matchid is the match id to be fetched
// a matchid of -1 means don't fetch a match
type job struct {
    last    bool
    matchid int
}

func create_worker(jobs chan job) {
    for {
        next_job := <-jobs
        if next_job.matchid != -1 {
            match_fetch(next_job.matchid)
        }
        if next_job.last {
            return
        }
    }
}

func main() {
    // do the eveton match as a reference
    match_fetch(614052)

    var joblist [num_workers]chan job
    var v int

    for i := 0; i < num_workers; i++ {
        job_chan := make(chan job)
        joblist[i] = job_chan
        go create_worker(job_chan)
    }
    for i := 0; i < max_id; i = i + num_workers {
        for index, c := range joblist {
            if i+index < max_id {
                v = i + index
            } else {
                v = -1
            }
            c <- job{false, v}
        }
    }
    for _, c := range joblist {
        c <- job{true, -1}
    }
}


The code seems to work in that it fills a directory called match_data with html. The problem is that this html is completely different to what I get in the browser! Here is the section which I think does this: (from the body of the GET request of http://www.whoscored.com/Matches/614052/Live.

(function() { 

var z="""";var b=""7472797B766172207868723B76617220743D6E6577204461746528292E67657454696D6528293B766172207374617475733D227374617274223B7661722074696D696E673D6E65772041727261792833293B77696E646F772E6F6E756E6C6F61643D66756E6374696F6E28297B74696D696E675B325D3D22723A222B286E6577204461746528292E67657454696D6528292D74293B646F63756D656E742E637265617465456C656D656E742822696D6722292E7372633D222F5F496E63617073756C615F5265736F757263653F4553324C555243543D363726743D373826643D222B656E636F6465555249436F6D706F6E656E74287374617475732B222028222B74696D696E672E6A6F696E28292B222922297D3B69662877696E646F772E584D4C4874747052657175657374297B7868723D6E657720584D4C48747470526571756573747D656C73657B7868723D6E657720416374697665584F626A65637428224D6963726F736F66742E584D4C4854545022297D7868722E6F6E726561647973746174656368616E67653D66756E6374696F6E28297B737769746368287868722E72656164795374617465297B6361736520303A7374617475733D6E6577204461746528292E67657454696D6528292D742B223A2072657175657374206E6F7420696E697469616C697A656420223B627265616B3B6361736520313A7374617475733D6E6577204461746528292E67657454696D6528292D742B223A2073657276657220636F6E6E656374696F6E2065737461626C6973686564223B627265616B3B6361736520323A7374617475733D6E6577204461746528292E67657454696D6528292D742B223A2072657175657374207265636569766564223B627265616B3B6361736520333A7374617475733D6E6577204461746528292E67657454696D6528292D742B223A2070726F63657373696E672072657175657374223B627265616B3B6361736520343A7374617475733D22636F6D706C657465223B74696D696E675B315D3D22633A222B286E6577204461746528292E67657454696D6528292D74293B6966287868722E7374617475733D3D323030297B706172656E742E6C6F636174696F6E2E72656C6F616428297D627265616B7D7D3B74696D696E675B305D3D22733A222B286E6577204461746528292E67657454696D6528292D74293B7868722E6F70656E2822474554222C222F5F496E63617073756C615F5265736F757263653F535748414E45444C3D313536343032333530343538313538333938362C31373139363833393832313930303534313833392C31333935303737313737393531363432383234342C3132363636222C66616C7365293B7868722E73656E64286E756C6C297D63617463682863297B7374617475732B3D6E6577204461746528292E67657454696D6528292D742B2220696E6361705F6578633A20222B633B646F63756D656E742E637265617465456C656D656E742822696D6722292E7372633D222F5F496E63617073756C615F5265736F757263653F4553324C555243543D363726743D373826643D222B656E636F6465555249436F6D706F6E656E74287374617475732B222028222B74696D696E672E6A6F696E28292B222922297D3B"";for (var i=0;i<b.length;i+=2){z=z+parseInt(b.substring(i, i+2), 16)+"","";}z = z.substring(0,z.length-1); eval(eval('String.fromCharCode('+z+')'));})();


The reason I think this is the case is that the javascript in the page fetches and edits the DOM to what I see on view source. How can I get golang to run the javascript? Is there are library to do this? Better still, could I directly grab the JSON from the servers?
"
27525423,"Simply updating from Go 1.4 from 1.3 solved the issue for me on OS X Mavericks. The Go installer at golang.org will remove any older versions of Go when installing 1.4
"
41674894,"In Go, an unbuffered channel is a ""synchronisation point"". That is, if you have a channel c, and do c , the goroutine blocks until someone is ready to do v =  (and the converse holds, receiving from a blocking channel without something to receive blocks until the value is available, but this is possibly less surprising). Specifically, for a blocking channel, the receive completes before the send completes.

Since you only have a single goroutine, it will be unable to loop back to reading from the channel and the write will block until something can read.

You could, in theory, get around this by doing something like: go func() { msg , so essentially spawning a short-lived goroutine to do the write.
"
21920887,"Use struct tags to map JSON field names to struct field names.

Many of your struct fields are lowercase and therefore unexported, which means the encoding/json package cannot access/marshal into them. Take a look at http://golang.org/pkg/reflect/#StructTag (the JSON package will match ""Description"" with ""description"", though - i.e. lower-case is already a match)

You are also better off (for readability/ability to add tags) splitting your structs into separate items, and then embedding them. You have cases where you're repeating Rank_items, whereas you could define it once and then embed it as needed:

e.g.

   Basic_attack struct {
        ItemDescription ItemDesc `json:""itemDescription""`
        Menu []MenuItems `json:""menuitems""`
        Rank []RankItems  `json:""rankitems""`
   }

   ItemDesc struct {
        Cooldown    string `json:""cooldown""`
        Cost        string `json:""cost""`
        Description string `json:""description""`
        Menu        []MenuItems `json:""menuitems""`
        ...
   }

   MenuItems  struct {
            Description string 
            Value       string
  }

   RankItems struct {
                Description string
                Value       string
   }

"
27493027,"That exception is only triggered in one place, which is during a Get Index API call.  Which means your vehicle ID must be null here:

fetch, err := client.Get().
        Index(vehicleIndex).
        Type(""vehicle"").
        Id(vehicle.Id).       //<-- this
        Do()


You are trying to do a Get Document API, which follows the format of GET /{index}/{type}/{id}.  However, your client doesn't make a distinction between Get Document and Get Index API calls...and it doesn't validate that your parameters are non-null.

So if a null vehicle.Id is passed to the Get method, your final URL will actually be GET /{index}/{type}/

From Elasticsearch's point of view, this is no longer a Get Document API call...it's actually a Get Index call, which has the following format:  GET /{index}/{feature}.  Feature can be one of: _settings, _mappings, _aliases or _warmers.  

Because vehicle is not one of those features, ES is throwing an exception and spewing.  You can verify this from the console:

curl -XGET localhost:9200/my_index/vehicle/
"
28237806,"I cannot get value from session this way, it is nil:

session := initSession(r)
valWithOutType := session.Values[key]


Full code:

package main

import (
    ""fmt""
    ""github.com/gorilla/mux""
    ""github.com/gorilla/sessions""
    ""log""
    ""net/http""
)

func main() {
    rtr := mux.NewRouter()
    rtr.HandleFunc(""/setSession"", handler1).Methods(""GET"")
    rtr.HandleFunc(""/getSession"", handler2).Methods(""GET"")
    http.Handle(""/"", rtr)
    log.Println(""Listening..."")
    http.ListenAndServe("":3000"", http.DefaultServeMux)
}

func handler1(w http.ResponseWriter, r *http.Request) {
    SetSessionValue(w, r, ""key"", ""value"")
    w.Write([]byte(""setSession""))
}

func handler2(w http.ResponseWriter, r *http.Request) {
    w.Write([]byte(""getSession""))
    value := GetSessionValue(w, r, ""key"")
    fmt.Println(""value from session"")
    fmt.Println(value)
}

var authKey = []byte(""secret"") // Authorization Key

var encKey = []byte(""encKey"") // Encryption Key

var store = sessions.NewCookieStore(authKey, encKey)

func initSession(r *http.Request) *sessions.Session {
    store.Options = &sessions.Options{
        MaxAge:   3600 * 1, // 1 hour
        HttpOnly: true,
    }
    session, err := store.Get(r, ""golang_cookie"")
    if err != nil {
        panic(err)
    }

    return session
}

func SetSessionValue(w http.ResponseWriter, r *http.Request, key, value string) {
    session := initSession(r)
    session.Values[key] = value
    fmt.Printf(""set session with key %s and value %s\n"", key, value)
    session.Save(r, w)
}

func GetSessionValue(w http.ResponseWriter, r *http.Request, key string) string {
    session := initSession(r)
    valWithOutType := session.Values[key]
    fmt.Printf(""valWithOutType: %s\n"", valWithOutType)
    value, ok := valWithOutType.(string)
    if !ok {
        fmt.Println(""cannot get session value by key: "" + key)
    }
    return value
}


Output:

myMac ~/forStack/session $ go run ./session.go
2015/01/30 16:47:26 Listening...


First I open url http://localhost:3000/setSession and get output:

set session with key key and value value


Then I open url http://localhost:3000/getSession and get output:

valWithOutType: %!s()
cannot get session value by key: key
value from session


Why valWithOutType is nil, although I set it requesting /setSession?

Update

I changed code according to @isza answer, but session value is still nil.

package main

import (
    ""fmt""
    ""github.com/gorilla/mux""
    ""github.com/gorilla/sessions""
    ""log""
    ""net/http""
)

func main() {
    rtr := mux.NewRouter()
    rtr.HandleFunc(""/setSession"", handler1).Methods(""GET"")
    rtr.HandleFunc(""/getSession"", handler2).Methods(""GET"")
    http.Handle(""/"", rtr)
    log.Println(""Listening..."")
    store.Options = &sessions.Options{
        MaxAge:   3600 * 1, // 1 hour
        HttpOnly: true,
        Path:     ""/"", // to match all requests
    }
    http.ListenAndServe("":3000"", http.DefaultServeMux)

}

func handler1(w http.ResponseWriter, r *http.Request) {
    SetSessionValue(w, r, ""key"", ""value"")
    w.Write([]byte(""setSession""))
}

func handler2(w http.ResponseWriter, r *http.Request) {
    w.Write([]byte(""getSession""))
    value := GetSessionValue(w, r, ""key"")
    fmt.Println(""value from session"")
    fmt.Println(value)
}

var authKey = []byte(""secret"") // Authorization Key

var encKey = []byte(""encKey"") // Encryption Key

var store = sessions.NewCookieStore(authKey, encKey)

func initSession(r *http.Request) *sessions.Session {
    session, err := store.Get(r, ""golang_cookie"")
    if err != nil {
        panic(err)
    }
    return session
}

func SetSessionValue(w http.ResponseWriter, r *http.Request, key, value string) {
    session := initSession(r)
    session.Values[key] = value
    fmt.Printf(""set session with key %s and value %s\n"", key, value)
    session.Save(r, w)
}

func GetSessionValue(w http.ResponseWriter, r *http.Request, key string) string {
    session := initSession(r)
    valWithOutType := session.Values[key]
    fmt.Printf(""valWithOutType: %s\n"", valWithOutType)
    value, ok := valWithOutType.(string)
    if !ok {
        fmt.Println(""cannot get session value by key: "" + key)
    }
    return value
}

"
24385371,"The answer is unfortunately pretty simple, goroutine stacks can't currently be released. 

Since you're connecting 10k clients at once, you need 10k goroutines to handle them. Each goroutine has an 8k stack, and even if only the first page is faulted in, you still need at least 40M of permanent memory to handle your max connections.

There are some pending changes that may help in go1.4 (like 4k stacks), but it's a fact we have to live with for now. 
"
33278946,"After a lot of trial and error, I present to you this fully functional solution:

package main

import (
    ""encoding/json""
    ""fmt""
    ""log""
    ""time""
)

type Clip struct {
    Value []InfoClip `json:value`
}

type customTime struct {
    time.Time
}

const ctLayout = ""2006-01-02 15:04:05""

func (ct *customTime) UnmarshalJSON(b []byte) (err error) {
    if b[0] == '""' && b[len(b)-1] == '""' {
        b = b[1 : len(b)-1]
    }
    ct.Time, err = time.Parse(ctLayout, string(b))
    return
}

type InfoClip struct {
    Id                string     `json:""clipId""`
    CreatedAt         customTime `json:""createdAt""`
    StartTimeCode     string     `json:""startTimeCode""` //if you want ints here, you'll have to decode manually, or fix the json beforehand
    EndTimeCode       string     `json:""endTimeCode""`   //same for this one
    Metas             metas      `json:""-""`
    MetasString       string     `json:""metas""`
    Tags              []string   `json:""tags""`
    Categories        []string   `json:""categories""`
    UserId            string     `json:""userId""`
    SourceId          string     `json:""sourceId""`
    ProviderName      string     `json:""providerName""`
    ProviderReference string     `json:""providerReference""`
    PublicationStatus string     `json:""publicationStatus""`
    Name              string     `json:""name""`
    FacebookPage      string     `json:""facebookPage""`
    TwitterHandle     string     `json:""twitterHandle""`
    PermaLinkUrl      string     `json:""permalinkBaseURL""`
    Logo              string     `json:""logo""`
    Link              string     `json:""link""`
    Views             int        `json:""views""`
}

type metas struct {
    Title      string   `json:""title""`
    Tags       []string `json:""tags""`
    Categories []string `json:""categories""`
    PermaLink  string   `json:""permalink""`
}

var jsonString = `{  
   ""clipId"":""9b2ea9bb-e54b-4291-ba16-9211fa3c755f"",
   ""streamUrl"":""https:///asset-32e43a5d-1500-80c3-cc6b-f1e4fe2b5c44\/6c53fbf5-dbe9-4617-9692-78e8d76a7b6e_H264_500kbps_AAC_und_ch2_128kbps.mp4?sv=2012-02-12&sr=c&si=17ed71e8-5176-4432-8092-ee64928a55f6&sig=KHyToRlqvwQxWZXVvRYOkBOBOF0SuBLVmKiGp4joBpw%3D&st=2015-05-18T13%3A32%3A41Z&se=2057-05-07T13%3A32%3A41Z"",
   ""startTimecode"":""6"",
   ""endTimecode"":""16"",
   ""createdAt"":""2015-05-19 13:31:32"",
   ""metas"":""{\""title\"":\""Zapping : Obama, Marine Le Pen et Michael Jackson\"",\""tags\"":[\""actualite\""],\""categories\"":[\""actualite\""],\""permalink\"":\""http:\/\/videos.lexpress.fr\/actualite\/zapping-obama-marine-le-pen-et-michael-jackson_910357.html\""}"",
   ""sourceId"":""6c53fbf5-dbe9-4617-9692-78e8d76a7b6e"",
   ""providerName"":""dailymotion"",
   ""providerReference"":""x1xmnxq"",
   ""publicationStatus"":""1"",
   ""userId"":""b373400a-bd7e-452a-af68-36992b0323a5"",
   ""name"":""LEXPRESS.fr"",
   ""facebookPage"":""https:\/\/www.facebook.com\/LExpress"",
   ""twitterHandle"":""https:\/\/twitter.com\/lexpress"",
   ""permalinkBaseURL"":""https:\/\/tym.net\/fr\/{CLIP_ID}"",
   ""logo"":""lexpress-120px.png"",
   ""link"":""http:\/\/videos.lexpress.fr\/""
}`

func main() {
    res := parseJson(jsonString)
    fmt.Printf(""%+v\n"",res)
}

func parseJson(theJson string) InfoClip {
    toParseInto := struct {
        InfoClip
        MetasString string `json:""metas""`
    }{
        InfoClip:    InfoClip{},
        MetasString: """"}

    err := json.Unmarshal([]byte(jsonString), &toParseInto)
    if err != nil {
        log.Panic(err)
    }

    err = json.Unmarshal([]byte(toParseInto.MetasString), &toParseInto.InfoClip.Metas)
    if err != nil {
        log.Panic(err)
    }

    return toParseInto.InfoClip
}


What are we doing in the parseJson function?

We create a new struct and assign that to the toParseInto variable. We design the struct in a way that it contains all of the fields from InfoClip via embedding, and We add a field to temporarily hold the JSON string metas.

We then unmarshal into that struct, which, after fixing the issues listed below, works fine.

After that, we unmarshal that inner JSON into the correct field in the embedded InfoClip.

We can now easily return that embedded InfoClip to get what we really wanted.

Now, all the issues I have identified in your original solution:


The time format in your JSON is not the standard time format to be used in JSON. That is defined in some RFC, but anyways: because of that, we have to use our own type customTime to parse that. It handles just like a normal time.Time, because that is embedded within.
All your json tags were wrong. All of them had missing quotes, and some were just not even correct.
startTimeCode and endTimeCode are strings in the JSON, not ints


Left to you to improve:


Error handling: Don't just panic in the parseJson function, but rather return the error somehow
If you want startTimecode and endTimecode to be available as ints, parse them manually. You can employ a ""hack"" similar to the one I used to parse the inner JSON.


One final note, not related to this answer but rather to your question: If you had provided both your code and the JSON with your original question, you would have had an answer in probably less than an hour. Please, please don't make this harder than it needs to be.

EDIT: I forgot to provide my sources, I used this question to parse your time format.
"
36578109,"I tried to modify standard sorting approach and add certain randomness to sorting Less interface.
when 

if (u[i] - u[j]) <= 0


or

if u[i] < u[j]


it works as expected
But 

if (u[i] - u[j]) <= rv


condition produces panic after several executions

package main
import ( 
    ""crypto/rand""
    ""fmt""
    ""math/big""
    ""sort""
)

type FuzzySorter []float64

func (u FuzzySorter) Len() int {
    return len(u)
}
func (u FuzzySorter) Swap(i, j int) {
    u[i], u[j] = u[j], u[i]
}
func (u FuzzySorter) Less(i, j int) bool {
    pom, _ := rand.Int(rand.Reader, big.NewInt(int64(2)))
    rv := float64(pom.Int64())
    if (u[i] - u[j]) <= rv {
        return true
    } else {
        return false
    }

}
func (u FuzzySorter) Sort() FuzzySorter {
    sort.Sort(u)
    return u
}

func main() {
    unsorted := FuzzySorter{
        0,
        1,
        1,
        1,
        1,
        6,
        0,
        4,
        6,
        1,
        1,
        1,
        0,
        2,
        8,
        1,
        5,
        4,
        6,
        6,
        6,
        16,
        12,
        6,
        1,
        1,
        1,
        0,
        0,
        11,
        2,
        14,
        16,
        6,
        12,
        0,
        4,
        1,
        0,
        16,
        2,
        6,
        0,
        0,
        0,
        0,
        1,
        11,
        1,
        0,
        2,
        1,
        1,
        1,
        1,
        0,
        1,
        12,
        10,
        1,
        5,
        2,
        6,
        4,
        1,
        0,
        0,
        11,
        1,
        1,
        2,
        2,
        1,
        0,
        0,
        1,
        0,
        1,
        17,
        2,
        1,
        1,
        2,
        0,
        3,
        7,
        1,
        5,
        1,
        0,
        1,
        0,
        0,
        0,
        1,
        3,
        1,
        1,
        1,
        2,
        1,
        0,
        3,
        1,
        6,
        1,
        1,
        0,
        1,
        12,
        0,
        1,
        1,
        0,
        1,
        0,
        0,
        6,
        1,
        2,
        2,
        0,
        0,
        2,
        1,
        1,
        0,
        4,
        4,
        1,
        1,
        1,
        0,
        1,
        1,
        1,
        2,
        0,
        0,
        1,
        0,
        1,
        2,
        1,
        2,
        1,
        1,
        0,
        0,
        4,
        1,
        0,
        1,
        0,
        1,
        1,
        3,
        1,
        0,
    }
    unsorted.Sort()
    fmt.Println(unsorted)

}


https://play.golang.org/p/4AxNRN4VD7

panic message

panic: runtime error: index out of range

goroutine 1 [running]:
panic(0x176ba0, 0x1040a010)
    /usr/local/go/src/runtime/panic.go:464 +0x700
main.FuzzySorter.Less(0x10456000, 0x9f, 0x9f, 0x19, 0xffffffff, 0x4, 0x1, 0xd)
    /tmp/sandbox201242525/main.go:21 +0x140
main.(*FuzzySorter).Less(0x10434140, 0x19, 0xffffffff, 0x5c, 0x1, 0x10434140)
    :3 +0xc0
sort.doPivot(0xfef741b0, 0x10434140, 0x19, 0x9f, 0x7, 0x19)
    /usr/local/go/src/sort/sort.go:128 +0x280
sort.quickSort(0xfef741b0, 0x10434140, 0x19, 0x9f, 0xe, 0xfef741b0)
    /usr/local/go/src/sort/sort.go:195 +0xa0
sort.Sort(0xfef741b0, 0x10434140)
    /usr/local/go/src/sort/sort.go:229 +0x80
main.FuzzySorter.Sort(0x10456000, 0x9f, 0x9f, 0x1, 0x0, 0x0, 0x0, 0x1777a0)
    /tmp/sandbox201242525/main.go:29 +0xa0
main.main()
    /tmp/sandbox201242525/main.go:195 +0xc0

"
35973890,"I have a simple GO server that I am trying to push to cloud foundry on Bosh lite ( Vagrant + Virtual box.)

Here is the source code setup from my go application:


~/workspace/src/github.com/me/ ( parent directory)

-Godeps

-weight
weight.go 

manifest.yml

Procfile


My weight.go is a simple server that listens on 9000.

1) manifest.yml looks like this.

applications:
- name: weight
  memory: 128MB
  instances: 1


2 ) Procfile looks like this.

worker: bin/weight


3 ) I use the default buildpack.

4 ) When I push my app with cf push weight -c ""./bin/weight;sleep 1d"" I get:

a-424e-b509-6df11fb32cc7 ({""state""=>""STOPPED""})
2016-03-13T11:02:45.70-0700 [DEA/0]      OUT Got staging request for app with id 16d3795a-8cda-424e-b509-6df11fb32cc7
2016-03-13T11:02:46.84-0700 [API/0]      OUT Updated app with guid 16d3795a-8cda-424e-b509-6df11fb32cc7 ({""state""=>""STARTED""})
2016-03-13T11:02:46.89-0700 [STG/0]      OUT -----> Downloaded app package (12K)
2016-03-13T11:02:48.76-0700 [STG/0]      OUT -----> Downloaded app buildpack cache (78M)
2016-03-13T11:02:48.82-0700 [STG/0]      ERR Cloning into '/tmp/buildpacks/go-buildpack'...
2016-03-13T11:03:05.66-0700 [STG/0]      OUT Submodule 'compile-extensions' (https://github.com/cloudfoundry/compile-extensions.git) registered for path 'compile-extensions'
2016-03-13T11:03:05.68-0700 [STG/0]      ERR Cloning into 'compile-extensions'...
2016-03-13T11:03:07.59-0700 [STG/0]      OUT Submodule path 'compile-extensions': checked out '26a578c06a62c763205833561fec1c5c6d34deb6'
2016-03-13T11:03:07.61-0700 [STG/0]      OUT -------> Buildpack version 1.7.3
2016-03-13T11:03:09.81-0700 [STG/0]      OUT https://pivotal-buildpacks.s3.amazonaws.com/concourse-binaries/godep/godep-v55-linux-x64.tgz
2016-03-13T11:03:09.88-0700 [STG/0]      OUT -----> Checking Godeps/Godeps.json file.
2016-03-13T11:03:09.92-0700 [STG/0]      OUT -----> Using go1.5.3
2016-03-13T11:03:09.92-0700 [STG/0]      OUT -----> Running: godep go install -tags cloudfoundry .
2016-03-13T11:03:11.19-0700 [STG/0]      OUT -----> Uploading droplet (2.0M)
2016-03-13T11:03:25.11-0700 [DEA/0]      OUT Starting app instance (index 0) with guid 16d3795a-8cda-424e-b509-6df11fb32cc7
2016-03-13T11:03:34.93-0700 [DEA/0]      OUT Removing crash for app with id 16d3795a-8cda-424e-b509-6df11fb32cc7
2016-03-13T11:03:34.93-0700 [DEA/0]      OUT Stopping app instance (index 0) with guid 16d3795a-8cda-424e-b509-6df11fb32cc7
2016-03-13T11:03:34.93-0700 [DEA/0]      OUT Stopped app instance (index 0) with guid 16d3795a-8cda-424e-b509-6df11fb32cc7
2016-03-13T11:03:56.81-0700 [DEA/0]      OUT Starting app instance (index 0) with guid 16d3795a-8cda-424e-b509-6df11fb32cc7
**2016-03-13T11:03:57.79-0700 [DEA/0]      ERR Instance (index 0) failed to start accepting connections**
2016-03-13T11:03:57.80-0700 [API/0]      OUT App instance exited with guid 16d3795a-8cda-424e-b509-6df11fb32cc7 payload: {""cc_partition""=>""default"", ""droplet""=>""16d3795a-8cda-424e-b509-6df11fb32cc7"", ""version""=>""2eeebbf8-e84e-412a-aeba-2adc0cffea6b"", ""instance""=>""910eba711c6e414bb7c6324565d0a9af"", ""index""=>0, ""reason""=>""CRASHED"", ""exit_status""=>127, ""exit_description""=>""failed to accept connections within health check timeout"", ""crash_timestamp""=>1457892237}


I have tried setting 

cf set-env weight PORT 9000


No success,
Am I doing something funky with the manifest and yaml ?

The weight.go runs locally.

Code :

func main (){
    http.HandleFunc(""/weight"", weightHandler)
    err:=http.ListenAndServe(""localhost:""+getPort(), nil)
    if err != nil {
        fmt.Println(""got an err "")
        log.Fatalln(err)
    }else{
        fmt.Println(""Apparently it works ?"")
    }
    //fmt.Println(""Hi"")
    //time.Sleep(1*time.Hour)
}

func getPort() string {
    var port string
    if port = os.Getenv(""PORT""); len(port) == 0 {
        fmt.Println(""Didn't Found it"")
        fmt.Println(port)
        port = DEFAULT_PORT
    }else{
        fmt.Println(""Gotim"")
        fmt.Println(port)
    }
    return port
}


I do get the Log for the random PORT CF assigns, still stuck at 

2016-03-13T16:58:40.90-0700 [API/0]      OUT App instance exited with guid e5d417bd-c38d-4239-aa61-e9ca67fce79a payload: {""cc_partition""=>""default"", ""droplet""=>""e5d417bd-c38d-4239-aa61-e9ca67fce79a"", ""version""=>""8d7e80b3-69d5-4c83-9d37-1159d5deeba8"", ""instance""=>""14223d325c204406b87a131c065c16cc"", ""index""=>0, ""reason""=>""CRASHED"", ""exit_status""=>-1, ""exit_description""=>""failed to accept connections within health check timeout"", ""crash_timestamp""=>1457913520}


*FIXED IT : The problem was listening on localhost, I didn't specify the IP and I was good to go *
"
21926254,"Have you ever tried docker 0.8.1?  It solved tty problem on run 'tmux'. Maybe it can solve your problem too.
"
36775769,"I made a regex that might work for you:

^\s*\|\s*([^\s]+)\s*=\s*(\{\{Plainlist\|(?:\n\s*\*.*)*|.*)

Explanation


This part: ^\s*\|\s*([^\s]+)\s*=\s* matches the start of lines like:

    |  = 

Continuing on the same line, this part: (\{\{Plainlist\|(?:\n\s*\*.*)*|.*) will match lists:

                     {{Plainlist|
* [[Ernst G. Straus]]
* [[Nathan Rosen]]
* [[Leó Szilárd]]



(Note that it may omit the final }}. Oh well.)


If there is no list, it matches until the end of the line.

"
17766821,"I did not check if it's the culprit, but on the ""technical analysis"" side I noticed one error in your code: You're passing a copy of a sync.Workgroup to echo_srv. Any changes made to the copy are not effective to the original instance.

Change the signature of echo to:

func echo_srv(c net.Conn, wg *sync.WaitGroup)


and then call it like:

go echo_srv(conn, &wg)


On a side note: Underscores (_) are not used in the middle of idiomatic Go code names. The idiomatic name would be eg. echoSrv instead.
"
37313862,"If you need to import  different packages of the same name in Golang, this is the way(just name it):

import (
    ""text/template""
    ht ""html/template""
)


but in case of ""golang.org/x/tools/cmd/oracle""
it is not a package , it has just main.go and you need to build/install it. it   is a command line tool:

Run 'oracle -help' for more information.
Go source code oracle.
Usage: oracle [ ...]   ...

The -format flag controls the output format:
        plain   an editor-friendly format in which every line of output
                is of the form ""pos: text"", where pos is ""-"" if unknown.
        json    structured data in JSON syntax.
        xml     structured data in XML syntax.

"
42123532,"I'm trying to understand how to get client's certificates in Go web server. Here is a server code:

package main

import (
    ""log""
    ""net/http""
    ""net/http/httputil""
)

func defaultHandler(w http.ResponseWriter, r *http.Request) {
    dump, err := httputil.DumpRequest(r, true)
    log.Println(""HTTP request"", r, string(dump), err)
    log.Println(""HTTP TLS"", r.TLS, string(r.TLS.TLSUnique))
    certs := r.TLS.PeerCertificates
    log.Println(""HTTP CERTS"", certs)
    w.WriteHeader(http.StatusMethodNotAllowed)
    w.Write([]byte(""Hello""))
}

func main() {
    http.HandleFunc(""/"", defaultHandler)
    http.ListenAndServeTLS("":8080"", ""server.crt"", ""server.key"", nil)
}


and here is client code

package main

import (
    ""crypto/tls""
    ""io/ioutil""
    ""log""
    ""net/http""
    ""os""
)

func HttpClient() (client *http.Client) {
    uckey := os.Getenv(""X509_USER_KEY"")
    ucert := os.Getenv(""X509_USER_CERT"")
    x509cert, err := tls.LoadX509KeyPair(ucert, uckey)
    if err != nil {
        panic(err.Error())
    }
    certs := []tls.Certificate{x509cert}
    if len(certs) == 0 {
       client = &http.Client{}
       return
    }
    tr := &http.Transport{
        TLSClientConfig: &tls.Config{Certificates: certs,
        InsecureSkipVerify: true},
    }
    client = &http.Client{Transport: tr}
    return
}

func main() {
    rurl := ""https://localhost:8080""
    client := HttpClient()
    req, err := http.NewRequest(""GET"", rurl, nil)
    if err != nil {
       log.Println(""Unable to make GET request"", err)
       os.Exit(1)
    }
    req.Header.Add(""Accept"", ""*/*"")
    resp, err := client.Do(req)
    if err != nil {
        log.Println(err)
        os.Exit(1)
    }
    defer resp.Body.Close()
    data, err := ioutil.ReadAll(resp.Body)
    log.Println(string(data))
}


If I run both server and a client I see the following on a server side:

2017/02/08 15:46:49 HTTP request &{GET / HTTP/1.1 1 1 map[User-Agent:[Go-http-client/1.1] Accept:[*/*] Accept-Encoding:[gzip]] {} 0 [] false localhost:8080 map[] map[]  map[] 127.0.0.1:58941 / 0xc4204ef080   0xc420014d40} GET / HTTP/1.1
Host: localhost:8080
Accept: */*
Accept-Encoding: gzip
User-Agent: Go-http-client/1.1

 
2017/02/08 15:46:49 HTTP TLS &{771 true false 49195  true localhost [] [] []   [] [203 144 196 105 155 216 89 105 83 90 93 4]} ːiSZ]
2017/02/08 15:46:49 HTTP CERTS []


As you can see the client's certificates are empty.

While if I invoke curl call to a server providing my certificates, then I can see server certificates:

curl -L -k --key mykey.key --cert mycert.pem -vvv https://localhost:8080
*   Trying 127.0.0.1...
* TCP_NODELAY set
* Connected to localhost (127.0.0.1) port 8080 (#0)
* ALPN, offering http/1.1
* Cipher selection: ALL:!EXPORT:!EXPORT40:!EXPORT56:!aNULL:!LOW:!RC4:@STRENGTH
* successfully set certificate verify locations:
*   CAfile: /opt/local/share/curl/curl-ca-bundle.crt
    CApath: none
* TLSv1.2 (OUT), TLS header, Certificate Status (22):
* TLSv1.2 (OUT), TLS handshake, Client hello (1):
* TLSv1.2 (IN), TLS handshake, Server hello (2):
* TLSv1.2 (IN), TLS handshake, Certificate (11):
* TLSv1.2 (IN), TLS handshake, Server key exchange (12):
* TLSv1.2 (IN), TLS handshake, Server finished (14):
* TLSv1.2 (OUT), TLS handshake, Client key exchange (16):
* TLSv1.2 (OUT), TLS change cipher, Client hello (1):
* TLSv1.2 (OUT), TLS handshake, Finished (20):
* TLSv1.2 (IN), TLS change cipher, Client hello (1):
* TLSv1.2 (IN), TLS handshake, Finished (20):
* SSL connection using TLSv1.2 / ECDHE-ECDSA-AES128-GCM-SHA256
* ALPN, server accepted to use http/1.1
* Server certificate:
*  subject: C=US; ST=NY; L=Town; O=Bla-Bla
*  start date: Feb  8 14:12:06 2017 GMT
*  expire date: Feb  6 14:12:06 2027 GMT
*  issuer: C=US; ST=NY; L=Ithaca; O=Cornell
*  SSL certificate verify result: self signed certificate (18), continuing anyway.
> GET / HTTP/1.1
> Host: localhost:8080
> User-Agent: curl/7.52.1
> Accept: */*


As you can see SSL negotiation is in place and curl client successfully reports server certificate. What I need is to access client's certificate on a server side to do proper authentication. But so far I can't see any client's certificate.

Any help is really welcome.
Thanks,
Valentin.
"
33850935,"When I use RSA to encrypt/decrypt the data,they are working good in delphi.But when I use them with other program, they seems not work.

I use the golang 1.5 in server side,when I use EncryptOAEP/DecryptOAEP,EncryptPKCS1v15/DecryptPKCS1v15,these pair functions are all good.

When I try to put all of these together,they can't recognized each other,I tried lots of kind of combination,for their own,they work fine.

1.Delphi xe6
2.lockbox Release v3.6.3.0
3.some code

golang on serverside

import (
    ""errors""    
    ""strings""
    ""strconv""
    ""log""
    ""database/sql""
    _ ""github.com/go-sql-driver/mysql""
    //""strconv""
    ""encoding/base64""
    ""encoding/json""
    ""bytes""
    //""strings""
)

var privateKey = []byte(`
-----BEGIN RSA PRIVATE KEY-----
MIICXQIBAAKBgQDZsfv1qscqYdy4vY+P4e3cAtmvppXQcRvrF1cB4drkv0haU24Y
7m5qYtT52Kr539RdbKKdLAM6s20lWy7+5C0DgacdwYWd/7PeCELyEipZJL07Vro7
Ate8Bfjya+wltGK9+XNUIHiumUKULW4KDx21+1NLAUeJ6PeW+DAkmJWF6QIDAQAB
AoGBAJlNxenTQj6OfCl9FMR2jlMJjtMrtQT9InQEE7m3m7bLHeC+MCJOhmNVBjaM
ZpthDORdxIZ6oCuOf6Z2+Dl35lntGFh5J7S34UP2BWzF1IyyQfySCNexGNHKT1G1
XKQtHmtc2gWWthEg+S6ciIyw2IGrrP2Rke81vYHExPrexf0hAkEA9Izb0MiYsMCB
/jemLJB0Lb3Y/B8xjGjQFFBQT7bmwBVjvZWZVpnMnXi9sWGdgUpxsCuAIROXjZ40
IRZ2C9EouwJBAOPjPvV8Sgw4vaseOqlJvSq/C/pIFx6RVznDGlc8bRg7SgTPpjHG
4G+M3mVgpCX1a/EU1mB+fhiJ2LAZ/pTtY6sCQGaW9NwIWu3DRIVGCSMm0mYh/3X9
DAcwLSJoctiODQ1Fq9rreDE5QfpJnaJdJfsIJNtX1F+L3YceeBXtW0Ynz2MCQBI8
9KP274Is5FkWkUFNKnuKUK4WKOuEXEO+LpR+vIhs7k6WQ8nGDd4/mujoJBr5mkrw
DPwqA3N5TMNDQVGv8gMCQQCaKGJgWYgvo3/milFfImbp+m7/Y3vCptarldXrYQWO
AQjxwc71ZGBFDITYvdgJM1MTqc8xQek1FXn1vfpy2c6O
-----END RSA PRIVATE KEY-----
`)
var publicKey = []byte(`
-----BEGIN PUBLIC KEY-----
MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDZsfv1qscqYdy4vY+P4e3cAtmv
ppXQcRvrF1cB4drkv0haU24Y7m5qYtT52Kr539RdbKKdLAM6s20lWy7+5C0Dgacd
wYWd/7PeCELyEipZJL07Vro7Ate8Bfjya+wltGK9+XNUIHiumUKULW4KDx21+1NL
AUeJ6PeW+DAkmJWF6QIDAQAB
-----END PUBLIC KEY-----
`)
type DebugKeysRPC_Args struct {

}
type DebugKeysRPC_Reply struct {
    PubN        string
    PubE        uint64
    PrvN        string
    PrvD        string
    PrvP        string
    PrvQ        string
    Dp          string
    Dq          string
    Qinv        string
    CRTValues   string
    ID      uint64
    Key     string
    Dest    string  
}

func (t *AccessDB) DebugKeysRPC(args *DebugKeysRPC_Args, reply *DebugKeysRPC_Reply) error { 
    log.Println(""DebugKeysRPC"")

    if pubN,pubE,PrvN,PrvD,PrvP,PrvQ,Dp,Dq,Qinv,CRTValues,err:=ReadKeyFields(publicKey,privateKey);err==nil{
        log.Println(""ok read"")
        reply.PubN=base64.StdEncoding.EncodeToString(pubN)
        reply.PubE=uint64(pubE)
        reply.PrvN=base64.StdEncoding.EncodeToString(PrvN)
        reply.PrvD=base64.StdEncoding.EncodeToString(PrvD)
        reply.PrvP=base64.StdEncoding.EncodeToString(PrvP)
        reply.PrvQ=base64.StdEncoding.EncodeToString(PrvQ)
        reply.Dp=base64.StdEncoding.EncodeToString(Dp)
        reply.Dq=base64.StdEncoding.EncodeToString(Dq)
        reply.Qinv=base64.StdEncoding.EncodeToString(Qinv)
        reply.CRTValues=base64.StdEncoding.EncodeToString(CRTValues)
        reply.ID=1
        //origData:=[]byte(""abcdefghijklmnopqrstuvwxyz"")
        origData:=[]byte(""1234567890123456"")
        if resultRsa,err:=DbgRasEncryptOAEP(origData,publicKey);err==nil{
        //if resultRsa,err:=RsaEncrypt(origData,publicKey);err==nil{
            log.Printf(""resultRsa(%d): % x"", len(resultRsa),resultRsa)
            reply.Dest=base64.StdEncoding.EncodeToString(resultRsa)
            if resultRsaP,err:=DbgRsaDecryptOAEP(resultRsa,privateKey);err==nil{
                //log.Printf(""RsaDecrypt ok % x"", resultRsaP)   
                log.Println(""RsaDecrypt ok"")
                log.Printf(""resultRsaP(%d): %s"", len(string(resultRsaP)),string(resultRsaP))
            }else{
                log.Println(""RsaDecrypt"",err)
            }
        }else{
            log.Println(""RsaEncrypt"",err)
        }                   
    }else{
        WatchPublicKey(publicKey)
        WatchPrivateKey(privateKey)
        log.Println(err)
    }

    return nil
}


===============================================================================
some code in delphi side(I haven't install the lockbox,I insert all source into project).

===============================================================================

procedure RsaEncrypt( const PublicKey: TStream; const srcStream : TStream;tgtStream:TStream);
var
  Codec : TCodec;
  wasAborted: boolean;
  KeyPair: TAsymetricKeyPair;
  Key: TSymetricKey;
  lib : TCryptographicLibrary;
begin
  Codec := TCodec.Create(Nil);
  lib := TCryptographicLibrary.Create(Nil);
  try
    //0. Reset
    Codec.Reset;
    Codec.CryptoLibrary := lib;
    Codec.ChainModeId := ECB_ProgId;
    Codec.StreamCipherId := 'native.RSA';

    //1. Set the cipher to RSA encryption.
    Codec.StreamCipherId := RSA_ProgId;

    //2. Load our pre-fabricated public key.
    PublicKey.Position := 0;
    Codec.AsymetricKeySizeInBits := 1024;
    Key := Codec.Asymetric_Engine.CreateFromStream(PublicKey, [partPublic]);

    //3. Now set the key.
    Codec.InitFromKey(Key);
    Codec.EncryptStream(srcStream,tgtStream);
  finally
    lib.Free;
    Codec.Free;
  end;
end;

procedure RsaDecrypt( const PrivateKey: TStream; const srcStream : TStream;tgtStream:TStream);
var
  Codec : TCodec;
  wasAborted: boolean;
  KeyPair: TAsymetricKeyPair;
  //Key: TSymetricKey;
  lib : TCryptographicLibrary;
begin
  Codec := TCodec.Create(Nil);
  lib := TCryptographicLibrary.Create(Nil);
  try
   //0. Reset
   Codec.Reset;
   Codec.CryptoLibrary := lib;
   Codec.ChainModeId := ECB_ProgId;
   Codec.StreamCipherId := 'native.RSA';

    //1. Set the cipher to RSA encryption.
    Codec.StreamCipherId := RSA_ProgId;

    //2. Load our pre-fabricated private key.
    PrivateKey.Position := 0;
    Codec.AsymetricKeySizeInBits := 1024;
    KeyPair := Codec.Asymetric_Engine.CreateFromStream(PrivateKey, [partPrivate]);

    //3. Now set the key.
    Codec.InitFromKey(KeyPair);

    Codec.DecryptStream(tgtStream,srcStream);
  finally
    lib.Free;
    Codec.Free;
  end;
end;

procedure Sign(privateKey,srcStream,tgtStream:TMemoryStream);
var
  sign:TSignature;
begin
  try
    sign:=TSignature.Create;
    privateKey.Seek(0,soBeginning);
    sign.m_Signatory.LoadKeysFromStream(privateKey,[partPrivate]);

    sign.m_Signatory.Sign(srcStream,tgtStream);
  finally
    sign.Free;
  end;
end;

function Verify(publicKey,srcStream,tgtStream:TMemoryStream):Boolean;
var
  sign:TSignature;
  vResult:TVerifyResult;
  nDbg:Integer;
begin
  try
    result:=False;
    publicKey.Seek(0,soBeginning);
    srcStream.Seek(0,soBeginning);
    tgtStream.Seek(0,soBeginning);
    sign:=TSignature.Create;
    sign.m_Signatory.LoadKeysFromStream(publicKey,[partPublic]);

    vResult:=sign.m_Signatory.Verify(srcStream,tgtStream);
    if vResult=vPass then
    begin
      nDbg:=0;
      result:=True;
    end
    else if vResult=vFail then
    begin
      nDbg:=1;
    end
    else if vResult=vUserAbort then
      nDbg:=3
    else nDbg:=4;
  finally
    sign.Free;
  end;
end;

procedure readPubKey(pubN:TStream;pubE:TStream);
var
  publicKey:TMemoryStream;
  Codec : TCodec;
  Key: TAsymetricKeyPair;
  lib : TCryptographicLibrary;
begin
  try
    publicKey:=TMemoryStream.Create;

    publicKey.LoadFromFile('e:\public.key');

    Codec := TCodec.Create(Nil);
    lib := TCryptographicLibrary.Create(Nil);
    try
      //0. Reset
      Codec.Reset;
      Codec.CryptoLibrary := lib;
      Codec.ChainModeId := ECB_ProgId;

      //1. Set the cipher to RSA encryption.
      Codec.StreamCipherId := RSA_ProgId;

      //2. Load our pre-fabricated public key.
      PublicKey.Position := 0;
      Codec.AsymetricKeySizeInBits := 1024;
      Key := Codec.Asymetric_Engine.CreateFromStream(publicKey, [partPublic]);
      //pubN.Write(Key.F_RSA_n.Value,sizeof(Key.F_RSA_n.Value));
      //pubE.Write(Key.F_RSA_n.Value,sizeof(Key.F_RSA_e.Value));
      pubN.CopyFrom((TRSAKeyPair(Key)).F_RSA_n.Value.FValue,0);
      pubE.CopyFrom((TRSAKeyPair(Key)).F_RSA_e.Value.FValue,0);
    finally
      lib.Free;
      Codec.Free;
    end;

  finally
    publicKey.Free;
  end;
end;

procedure dbgRsaKeys();
var
  publicKey:TMemoryStream;
  privateKey:TMemoryStream;
  tgtStream:TMemoryStream;
  srcStream:TStringStream;
  src:string;
  rstStream:TStringStream;
  sResult:string;
begin
  publicKey:=TMemoryStream.Create;
  privateKey:=TMemoryStream.Create;
  rstStream:=TStringStream.Create;
  srcStream:=TStringStream.Create;
  tgtStream:=TMemoryStream.Create;
  try
    src:='tell me why,tell me how,tell me where';
    srcStream.WriteString(src);
    srcStream.Seek(0,soBeginning);
    publicKey.LoadFromFile('e:\public.key');
    privateKey.LoadFromFile('e:\private.key');

    RsaEncrypt( PublicKey,srcStream ,tgtStream);

    RsaDecrypt( PrivateKey,tgtStream,rstStream);
    sResult:=rstStream.DataString;
  finally
    publicKey.Free;
    privateKey.Free;
    srcStream.Free;
    tgtStream.Free;
    rstStream.Free;
  end;
end;
procedure TestEncrypt();
var
  publicKey:TMemoryStream;
  srcStream,tgtStream:TMemoryStream;
begin
  try
    publicKey:=TMemoryStream.Create;

    srcStream:=TMemoryStream.Create;
    srcStream.LoadFromFile('e:\scanconfig.txt');
    tgtStream:=TMemoryStream.Create;
    publicKey.LoadFromFile('e:\public.key');

    RsaEncrypt( PublicKey,srcStream ,tgtStream);

    tgtStream.SaveToFile('e:\scanconfig.enc');
  finally
    publicKey.Free;
    srcStream.Free;
    tgtStream.Free;
  end;
end;

procedure TestDecrypt(srcStream:TMemoryStream);
var
  privateKey:TMemoryStream;
  tgtStream:TStringStream;
  sResult:String;
begin
  //dbgRsaKeys();
  privateKey:=TMemoryStream.Create;
  tgtStream:=TStringStream.Create;
  try
    srcStream.Seek(0,soBeginning);
    privateKey.LoadFromFile('e:\private.key');
    RsaDecrypt( privateKey,srcStream,tgtStream);
    sResult:=tgtStream.DataString;
  finally
    privateKey.Free;
    tgtStream.Free;
  end;
end;


================================================================================
"
38129476,"This has really stumped me...I'm just trying to setup a basic server using Cobra and the standard http package. I've followed the golang example here for how to create a certificate and key, but no matter what I throw at it, I'm not getting it to go through and keep getting this error: 


  Cannot serve on http port: crypto/tls: failed to find certificate PEM data in certificate input, but did find a private key; PEM inputs may have been switched


so I am left with the belief that it must be something wrong with my program that won't let me process certificates.

This is what I use to parse my flags to start the server: 

var serverCmd = &cobra.Command{
    Use:   ""server"",
    Short: ""start a compiler server"",
    Run: func(cmd *cobra.Command, args []string) {
        addrUnsecure := """"
        addrSecure := """"

        addrUnsecure += "":"" + strconv.FormatUint(serverPort, 10)
        addrSecure += "":"" + strconv.FormatUint(securePort, 10)

        if noSSL {
            addrSecure = """"
        } else {
            if secureOnly {
                addrUnsecure = """"
            }
            if _, err := os.Stat(serverKey); os.IsNotExist(err) {
                log.Error(""Can't find ssl key %s. Use --no-ssl flag to disable"", serverKey)
                os.Exit(1)
            }
            if _, err := os.Stat(serverCert); os.IsNotExist(err) {
                log.Error(""Can't find ssl cert %s. Use --no-ssl flag to disable"", serverCert)
                os.Exit(1)
            }
        }

        server.StartServer(addrUnsecure, addrSecure, serverCert, serverKey)
    },
}

func addServerFlags() {
    serverCmd.Flags().Uint64VarP(&serverPort, ""port"", ""p"", setServerPort(), ""set the listening port for http"")
    serverCmd.Flags().Uint64VarP(&securePort, ""secure-port"", ""s"", setSecurePort(), ""set the listening port for https"")
    serverCmd.Flags().BoolVarP(&noSSL, ""no-ssl"", ""n"", setSSL(), ""use only http"")
    serverCmd.Flags().BoolVarP(&secureOnly, ""secure-only"", ""o"", setSecureOnly(), ""use only https"")
    serverCmd.Flags().StringVarP(&serverCert, ""cert"", ""c"", setDefaultServerCert(), ""set the https certificate"")
    serverCmd.Flags().StringVarP(&serverKey, ""key"", ""k"", setDefaultServerKey(), ""set the key to interact with the https certificate"")
}

func setServerPort() uint64 {
    return 9099
}

func setSecurePort() uint64 {
    return 9098
}

func setSSL() bool {
    return false
}

func setSecureOnly() bool {
    return false
}

func setDefaultServerCert() string {
    return """"
}

func setDefaultServerKey() string {
    return """"
}


and this is the function where the actual server is started:

func StartServer(addrUnsecure, addrSecure, key, cert string) {
    log.Warn(""Hello I'm the marmots' compilers server"")
    common.InitErisDir()
    // Routes

    http.HandleFunc(""/"", CompileHandler)
    // Use SSL ?
    log.Debug(cert)
    if addrSecure != """" {
        log.Debug(""Using HTTPS"")
        log.WithField(""=>"", addrSecure).Debug(""Listening on..."")
        if err := http.ListenAndServeTLS(addrUnsecure, cert, key, nil); err != nil {
            log.Error(""Cannot serve on http port: "", err)
            os.Exit(1)
        }
    }
    if addrUnsecure != """" {
        log.Debug(""Using HTTP"")
        log.WithField(""=>"", addrUnsecure).Debug(""Listening on..."")
        if err := http.ListenAndServe(addrUnsecure, nil); err != nil {
            log.Error(""Cannot serve on http port: "", err)
            os.Exit(1)
        }
    }
}


I've gotten this in both Docker running Ubuntu 14.04 and OS X locally on my machine. Thanks in advance to whoever can help me out. It's kind of embarassing because this seems like it should be a really simple thing to do and I'm willing to bet it's going to be something dumb that's got me here. 
"
44598106,"you can solve this with sync.WaitGroup


You can start listening your channels in separate goroutines.
WaitGroup will coordinate how many goroutines do you have.


wg.Add(1) says that we're going to start new goroutine.

wg.Done() says that goroutine is finished.

wg.Wait() blocks goroutine, until all started goroutines aren't finished yet.

This 3 methods allows you to coordinate goroutines.

Go playground link

PS. you might be interested in sync.RWMutex for your SafeCache
"
33339986,"Got stuck while passing multiple values in cookie. I'm not able to find a better way for managing session and cookies. Trying to use github.com/gorilla/securecookie this package. 

loginMain.go

package main

import (
    ""database/sql""
    ""log""
    ""net/http""
    ""shambhavi/packages/loginPkg""   
    _ ""github.com/go-sql-driver/mysql""
    ""github.com/gorilla/mux""
)

var router = mux.NewRouter()
var db *sql.DB

func connectDb() *sql.DB {
    db, dberr := sql.Open(""mysql"", ""root:root@tcp(127.0.0.1:8889)/shambhavi_db"")
    if dberr != nil {
        log.Println(dberr)
    }
    return db
}
func login(w http.ResponseWriter, r *http.Request) {
    var db *sql.DB = connectDb()
    loginPkg.LoginOperation(w, r, db)

}

func main() {
    http.HandleFunc(""/demo"", login)
    http.Handle(""/"", router)
    err := http.ListenAndServe(port, nil) // setting listening port
if err != nil {
    log.Fatal(""ListenAndServe: "", err)
}
}  


LoginPkg.go

package loginPkg

import (
    ""database/sql""
    ""encoding/json""
    ""fmt""
    ""net/http""
    ""shambhavi/packages/sessionPkg""

    _ ""github.com/go-sql-driver/mysql""
)

var retMap = make(map[string]string)

func ErrorHandler(err error) {
    if err != nil {
        panic(err)
    }
}

func LoginOperation(w http.ResponseWriter, r *http.Request, db *sql.DB) {
    fmt.Println(""In LoginOperation "")
    r.ParseForm()
    if len(r.Form[""username""][0]) == 0 && len(r.Form[""password""][0]) == 0 {
        fmt.Fprintf(w, ""Something is blank !!!"")
    } else {
        var lvl string
        var uFullName string
        err := db.QueryRow(""SELECT lvl_flag FROM admin_instance WHERE user_name = ? AND passwd = ?"", r.FormValue(""username""), r.FormValue(""password"")).Scan(&lvl)

        er := db.QueryRow(""SELECT emp_name FROM emp_detail WHERE emp_uname = ?"", r.FormValue(""username"")).Scan(&uFullName)
        ErrorHandler(er)
        retMap[""msg""] = ""Login successfully""
        retMap[""err""] = ""Not Login""
        retMap[""lvl""] = lvl
        retMap[""fullName""] = uFullName
        b, _ := json.Marshal(retMap)
        if err != nil {
            fmt.Println(err)
            fmt.Fprintf(w, ""%s"", b)

        } else {
            if lvl == ""1"" || lvl == ""2"" || lvl == ""3"" {
                sessionPkg.SetSession(w, r, r.FormValue(""username""), retMap) // Passing map to the fun, retMap
                fmt.Fprintf(w, ""%s"", b)
                usrnm := sessionPkg.GetUserName(r)
                fmt.Println(""From session variable"", usrnm)
            } else {
                fmt.Println(""Chukala ...."")
                fmt.Fprintf(w, ""%s"", b)
            }   
        }
    }
    defer db.Close()
}


The problem lies in following file....

sessionHandler.go

package sessionPkg

import (
    ""fmt""
    ""net/http""
    ""time""

    ""github.com/gorilla/securecookie""
)

var cookieHandler = securecookie.New(
    securecookie.GenerateRandomKey(64),
    securecookie.GenerateRandomKey(32))


func SetSession(w http.ResponseWriter, r *http.Request, username string, retMap map[string]string) {

    sessionData := map[string]string{
        ""userName"": username,
        ""lvl"":      retMap[""lvl""],
        ""fullName"": retMap[""fullName""],
    }

    expiration := time.Now().Add(365 * 24 * time.Hour)

    //if encoded, err := cookieHandler.Encode(""session"", sessionData); err == nil {
    cookie := http.Cookie{
        Name:    ""session"",
        Value:   sessionData[""userName""], //Here i want map or something else that can accept multiple values
        Expires: expiration,
        //MaxAge: 3600,
    }

    http.SetCookie(w, &cookie)
    //}
}

func GetUserName(request *http.Request) (userName string) {
    //fmt.Println(request.Cookie(""session""))
    cookieValue := make(map[string]string)
    if cookie, err := request.Cookie(""session""); err == nil {

        fmt.Println(""cookieValue = "", cookie.Value)
        //if err = cookieHandler.Decode(""session"", cookie.Value, &cookieValue); err == nil {
        //fmt.Println(cookie)
        cookieValue[""userName""] = cookie.Value
        //fmt.Println(cookieValue[""userName""])
        //}
        /*else {
            fmt.Println(""Error "", err)
        }*/
    }
    return cookieValue[""userName""]
}

/*func GetFullName(request *http.Request) (fullName string) {
    fmt.Println(""In GetFullName"")
    cookieValue := make(map[string]string)
    if cookie2, err := request.Cookie(""session""); err == nil {

        fmt.Println(""cookieValue = "", cookie2.Value)
        //if err = cookieHandler.Decode(""session"", cookie.Value, &cookieValue); err == nil {
        fmt.Println(cookie2)
        cookieValue[""fullName""] = cookie2.Value
        fmt.Println(cookieValue[""fullName""])
        //}
    }
    return cookieValue[""fullName""]
}*/

func ClearSession(response http.ResponseWriter) {
    cookie := &http.Cookie{
        Name:   ""session"",
        Value:  """",
        Path:   ""/"",
        MaxAge: -1,
    }
    http.SetCookie(response, cookie)
}


Problem indicated in code by comment. I want to use session like in PHP. Suggest the better way to secure the cookie and maintain the session. Give some explanation too.  

Edited: Explain cookieHandler.Encode() and cookieHandler.Decode(). It is not decoding the data which is passed to it.
"
29161705,"I am writing a function in golang to search for a string in elasticsearch documents which are indexed. I am using elasticsearch golang client elastic. For example consider the object is tweet,

type Tweet struct {
    User    string
    Message string
    Retweets int
}


And the search function is 

func SearchProject() error{
    // Search with a term query
    termQuery := elastic.NewTermQuery(""user"", ""olivere"")
    searchResult, err := client.Search().
        Index(""twitter"").   // search in index ""twitter""
        Query(&termQuery).  // specify the query
        Sort(""user"", true). // sort by ""user"" field, ascending
        From(0).Size(10).   // take documents 0-9
        Pretty(true).       // pretty print request and response JSON
        Do()                // execute
    if err != nil {
        // Handle error
        panic(err)
        return err
    }

    // searchResult is of type SearchResult and returns hits, suggestions,
    // and all kinds of other information from Elasticsearch.
    fmt.Printf(""Query took %d milliseconds\n"", searchResult.TookInMillis)

    // Each is a convenience function that iterates over hits in a search result.
    // It makes sure you don't need to check for nil values in the response.
    // However, it ignores errors in serialization. If you want full control
    // over iterating the hits, see below.
    var ttyp Tweet
    for _, item := range searchResult.Each(reflect.TypeOf(ttyp)) {
        t := item.(Tweet)
        fmt.Printf(""Tweet by %s: %s\n"", t.User, t.Message)
    }
    // TotalHits is another convenience function that works even when something goes wrong.
    fmt.Printf(""Found a total of %d tweets\n"", searchResult.TotalHits())

    // Here's how you iterate through results with full control over each step.
    if searchResult.Hits != nil {
        fmt.Printf(""Found a total of %d tweets\n"", searchResult.Hits.TotalHits)

        // Iterate through results
        for _, hit := range searchResult.Hits.Hits {
            // hit.Index contains the name of the index

            // Deserialize hit.Source into a Tweet (could also be just a map[string]interface{}).
            var t Tweet
            err := json.Unmarshal(*hit.Source, &t)
            if err != nil {
                // Deserialization failed
            }

            // Work with tweet
            fmt.Printf(""Tweet by %s: %s\n"", t.User, t.Message)
        }
    } else {
        // No hits
        fmt.Print(""Found no tweets\n"")
    }
    return nil
}


This search is printing tweets by the user 'olivere'.  But if I give 'olive' then search is not working. How do I search for a string which is part of User/Message/Retweets?

And the Indexing function looks like this,

func IndexProject(p *objects.ElasticProject) error {
// Index a tweet (using JSON serialization)
    tweet1 := `{""user"" : ""olivere"", ""message"" : ""It's a Raggy Waltz""}`
    put1, err := client.Index().
        Index(""twitter"").
        Type(""tweet"").
        Id(""1"").
        BodyJson(tweet1).
        Do()
    if err != nil {
        // Handle error
        panic(err)
        return err
    }
    fmt.Printf(""Indexed tweet %s to index %s, type %s\n"", put1.Id, put1.Index, put1.Type)

    return nil
}


Output:

Indexed tweet 1 to index twitter, type tweet
Got document 1 in version 1 from index twitter, type tweet
Query took 4 milliseconds
Tweet by olivere: It's a Raggy Waltz
Found a total of 1 tweets
Found a total of 1 tweets
Tweet by olivere: It's a Raggy Waltz


Version

Go 1.4.2
Elasticsearch-1.4.4


Elasticsearch Go Library

github.com/olivere/elastic


Could anyone help me on this.? Thank you
"
44863386,"I'm using two structs to hold user's info

// SecureDevice holds a user's device's infos
type SecureDevice struct {
    Name     string // Defined by the user
    DeviceIP string
    Token    struct {
        Token        string
        StartingDate time.Time // The token is supposed to last only a week before becoming invalid
    }
}

// GlobalUser is a struct defining all user's infos registered inside the server
type GlobalUser struct {
    Username          string
    Password          string
    Salt              string
    Mail              string
    ValidationToken   string // Used to validate the user's mail adress
    Lang              string
    ConversationsID   []int // The private messages the user has part in
    SecureDevicesList []SecureDevice
}


And I'm using a function to check if the user is logged in

// IsLoggedIn checks if client's token is valid
func IsLoggedIn(r *http.Request) string {
    ips := strings.Split(r.Header.Get(""X-Forwarded-For""), "", "")
    ip := ips[0]
    cookie, err := r.Cookie(""auth"")
    if err != nil {
        return ""ERR$"" + ""not_connected""
    }
    cookieValue := strings.Split(cookie.Value, ""$"")
    println(cookie.Value)
    user := GetUser(cookieValue[0])
    userToken := cookieValue[1]
    if user.Username == """" {
        return ""ERR$"" + ""error""
    }
    for _, SecureDevice := range user.SecureDevicesList {
        if SecureDevice.DeviceIP == ip && SecureDevice.Token.Token == userToken { // We make sure that the token provided is actually the user's token
            if time.Since(SecureDevice.Token.StartingDate)*time.Hour >= 168 { // If token is older than 1 week, we throw it away
                return ""ERR$"" + ""error_token_expired""
            } else if time.Since(SecureDevice.Token.StartingDate)*time.Second >= 30 { // If it's age is between 1 hour and one week, we renew it
                db, err := scribble.New(""./brony/db"", nil)
                if err != nil {
                    return ""ERR$"" + ""error_internal""
                }
                tokenBytes, err := GenerateRandomBytes(64) // Generates a salt
                if err != nil {
                    return ""ERR$"" + ""error_internal""
                }
                token := base64.URLEncoding.EncodeToString(tokenBytes)
                SecureDevice.Token.Token = token
                SecureDevice.Token.StartingDate = time.Now()
                errr := db.Write(""users"", user.Username, user)
                if errr != nil {
                    return ""ERR$"" + ""error_internal""
                }
                return ""TOK$"" + user.Username + ""$"" + SecureDevice.Token.Token
            } else if time.Since(SecureDevice.Token.StartingDate)*time.Hour <= 1 {
                return ""NIL$""
            }
        } else if SecureDevice.DeviceIP == ip {
            return ""ERR$"" + ""error_bad_token""
        }
    }
    return ""ERR$"" + ""error_device_not_registered""
}


But almost always when I load the page with

status := IsLoggedIn(r)
println(status)


It often gives me an error, since I'm printing ""IsLoggedIn"" to understand where the problem comes from

test$ppDXRggtztyA9OBbdZh1t1ESqRo2XvuOBt4xlDai9kVxwq-_3zlWyvgNgA7AZcSpasJ_YnXZvoG                                                                                                                                                             qlz1syF9X8g==
NIL$

test$ppDXRggtztyA9OBbdZh1t1ESqRo2XvuOBt4xlDai9kVxwq-_3zlWyvgNgA7AZcSpasJ_YnXZvoG                                                                                                                                                             qlz1syF9X8g==
ERR$error_token_expired

test$ppDXRggtztyA9OBbdZh1t1ESqRo2XvuOBt4xlDai9kVxwq-_3zlWyvgNgA7AZcSpasJ_YnXZvoG                                                                                                                                                             qlz1syF9X8g==
NIL$

test$ppDXRggtztyA9OBbdZh1t1ESqRo2XvuOBt4xlDai9kVxwq-_3zlWyvgNgA7AZcSpasJ_YnXZvoG                                                                                                                                                             qlz1syF9X8g==
ERR$error_token_expired
test$ppDXRggtztyA9OBbdZh1t1ESqRo2XvuOBt4xlDai9kVxwq-_3zlWyvgNgA7AZcSpasJ_YnXZvoG                                                                                                                                                             qlz1syF9X8g==
ERR$error_token_expired

test$ppDXRggtztyA9OBbdZh1t1ESqRo2XvuOBt4xlDai9kVxwq-_3zlWyvgNgA7AZcSpasJ_YnXZvoG                                                                                                                                                             qlz1syF9X8g==
ERR$error_token_expired

test$ppDXRggtztyA9OBbdZh1t1ESqRo2XvuOBt4xlDai9kVxwq-_3zlWyvgNgA7AZcSpasJ_YnXZvoG                                                                                                                                                             qlz1syF9X8g==
ERR$error_token_expired

test$ppDXRggtztyA9OBbdZh1t1ESqRo2XvuOBt4xlDai9kVxwq-_3zlWyvgNgA7AZcSpasJ_YnXZvoG                                                                                                                                                             qlz1syF9X8g==
ERR$error_token_expired

test$ppDXRggtztyA9OBbdZh1t1ESqRo2XvuOBt4xlDai9kVxwq-_3zlWyvgNgA7AZcSpasJ_YnXZvoG                                                                                                                                                             qlz1syF9X8g==
NIL$


At first I thought it was my token's renewal code which was faulty, but while beeing faulty and unfinished, it doesn't seem to be it's fault since after a few f5, it said that the cookie was ok. I really don't understand where the fault is, and it's starting to get really annoying, as I can't just let it be, it would be very annoying to say the least for a user to do f5 everytime and hope that when the page will refresh, it will miraculously work. The code runs on a debian server
"
37765837,"When I try to start the peer using 

peer node start


I get the following error

hyperledger@linux-box:/opt/gopath/src/github.com/hyperledger/fabric$ peer node start
20:42:02.999 [crypto] main -> INFO 001 Log level recognized 'info', set to INFO
20:42:03.017 [main] serve -> INFO 002 Security enabled status: true
20:42:03.017 [main] serve -> INFO 004 Privacy enabled status: true
20:42:03.017 [crypto] func1 -> INFO 005 Registering validator [vp] with name [vp]...
20:42:03.017 [eventhub_producer] start -> INFO 003 event processor started
panic: runtime error: invalid memory address or nil pointer dereference
[signal 0xb code=0x1 addr=0x10 pc=0x8ad221]

goroutine 1 [running]:
panic(0xd43fe0, 0xc82000e120)
    /opt/go/src/runtime/panic.go:481 +0x3e6
github.com/hyperledger/fabric/core/crypto/utils.PEMtoPrivateKey(0x15409e0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0)
    /opt/gopath/src/github.com/hyperledger/fabric/core/crypto/utils/keys.go:117 +0x91
github.com/hyperledger/fabric/core/crypto.(*nodeImpl).retrieveEnrollmentData(0xc820226630, 0xc8201c35c8, 0x2, 0xc8201c35f0, 0xc, 0x0, 0x0)
    /opt/gopath/src/github.com/hyperledger/fabric/core/crypto/node_eca.go:120 +0xe55
github.com/hyperledger/fabric/core/crypto.(*nodeImpl).registerCryptoEngine(0xc820226630, 0xc8201c35c8, 0x2, 0xc8201c35f0, 0xc, 0x0, 0x0)
    /opt/gopath/src/github.com/hyperledger/fabric/core/crypto/node_crypto.go:49 +0x5d6
github.com/hyperledger/fabric/core/crypto.(*nodeImpl).register(0xc820226630, 0x2, 0xc8201c35c8, 0x2, 0x0, 0x0, 0x0, 0xc8201c35c8, 0x2, 0xc8201c35f0, ...)
    /opt/gopath/src/github.com/hyperledger/fabric/core/crypto/node_impl.go:114 +0x5b8
github.com/hyperledger/fabric/core/crypto.(*peerImpl).register(0xc820242840, 0x2, 0xc8201c35c8, 0x2, 0x0, 0x0, 0x0, 0xc8201c35c8, 0x2, 0xc8201c35f0, ...)
    /opt/gopath/src/github.com/hyperledger/fabric/core/crypto/peer_impl.go:177 +0x20a
github.com/hyperledger/fabric/core/crypto.(*validatorImpl).register(0xc8201fd600, 0xc8201c35c8, 0x2, 0x0, 0x0, 0x0, 0xc8201c35c8, 0x2, 0xc8201c35f0, 0xc, ...)
    /opt/gopath/src/github.com/hyperledger/fabric/core/crypto/validator_impl.go:147 +0x20a
github.com/hyperledger/fabric/core/crypto.RegisterValidator(0xc8201c35c8, 0x2, 0x0, 0x0, 0x0, 0xc8201c35c8, 0x2, 0xc8201c35f0, 0xc, 0x0, ...)
    /opt/gopath/src/github.com/hyperledger/fabric/core/crypto/validator.go:55 +0x55d
main.getSecHelper.func1()
    /opt/gopath/src/github.com/hyperledger/fabric/peer/main.go:360 +0x200
sync.(*Once).Do(0x1540ad8, 0xc8201fd768)
    /opt/go/src/sync/once.go:44 +0xe4
main.getSecHelper(0x0, 0x0, 0x0, 0x0)
    /opt/gopath/src/github.com/hyperledger/fabric/peer/main.go:380 +0x7d
main.serve(0x15409e0, 0x0, 0x0, 0x0, 0x0)
    /opt/gopath/src/github.com/hyperledger/fabric/peer/main.go:446 +0xc23
main.glob.func3(0x1503160, 0x15409e0, 0x0, 0x0, 0x0, 0x0)
    /opt/gopath/src/github.com/hyperledger/fabric/peer/main.go:95 +0x41
github.com/hyperledger/fabric/vendor/github.com/spf13/cobra.(*Command).execute(0x1503160, 0x15409e0, 0x0, 0x0, 0x0, 0x0)
    /opt/gopath/src/github.com/hyperledger/fabric/vendor/github.com/spf13/cobra/command.go:497 +0x62c
github.com/hyperledger/fabric/vendor/github.com/spf13/cobra.(*Command).Execute(0x1502de0, 0x0, 0x0)
    /opt/gopath/src/github.com/hyperledger/fabric/vendor/github.com/spf13/cobra/command.go:584 +0x46a
main.main()
    /opt/gopath/src/github.com/hyperledger/fabric/peer/main.go:314 +0x18d9


My core.yaml contains the default contents , with security and privacy enabled.

Is this a bug ?
"
41748628,"I have a new TCP server written in Go that has 100+ clients attached to it.  Each client streams in data that needs to be looked at centrally as they are looking at radio packets over the air waves from various locations which then get analysed.  The code works but I am seeing a lot of contention and increased CPU around the locking and was after some thoughts on how to avoid the locking (if possible) or optimise around it.

As the TCP server spins up a GoRoutine for each packet received the addMessage function needs a level of synchronisation.  These packets also get analysed in another function later on that does a RLock() on the map.

It is the cullMessages() function that gets called once per second that really gets caught up in itself and can really slow down, sometimes taking 2-3 seconds to run which compounds the issue as the next 2-3 operations are queued waiting to unlock and run straight away!

Any ideas/thoughts would be appreciated!

var dataMessagesMutex sync.RWMutex
var dataMessages map[string][]*trackingPacket_v1

// Function is called from each TCP client who need to share this data
func addMessage(trackingPacket *trackingPacket_v1) {
    dataMessagesMutex.Lock()
    dataMessages[trackingPacket.packetID] = append(dataMessages[trackingPacket.packetID], trackingPacket)
    dataMessagesMutex.Unlock()
}

// Function called on a loop, need to delete based on age here
func cullMessages() {
    cullTS := time.Now().Add(-time.Second * MODES_MAX_MESSAGE_AGE)

    dataMessagesMutex.Lock()
    defer dataMessagesMutex.Unlock()

    for avr, data := range dataMessages {
        sort.Sort(PacketSorter(data))
        highestIndex := 0

        for i, messages := range data {
            if cullTS.Sub(messages.ProcessedTime) > 0 {
                // Need to delete the message here
                messages = nil
                highestIndex = i
            }
        }
        // Copy the new slice into the data variable
        data = data[highestIndex+1:]

        if len(data) == 0 {
            // Empty Messages, delete
            delete(dataMessages, avr)
        }
    }
}


UPDATE: 
Added analysis function 

func processCandidates() {
    mlatMessagesMutex.RLock()
    defer dataMessagesMutex.RUnlock()

    for _, data := range dataMessages {
        numberOfMessages := len(data)
        for a := 0; a < numberOfMessages; a++ {
            packetA := data[a]
            applicablePackets := []*trackingPacket_v1{packetA}
            for b := 0; b < numberOfMessages; b++ {
                // Don't compare identical packets
                if b == a {
                    continue
                }

                packetB := data[b]

                // Only consider this packet if it's within an acceptable
                // timestamp threshold
                tsDelta := math.Abs(packetA.NormalisedTS - packetB.NormalisedTS)

                if tsDelta < MAX_MESSAGE_TS_DIFF {
                    // Finally, we need to make sure that only one message per
                    // station is included in our batch
                    stationAlreadyRepresented := false
                    for i := 0; i < len(applicablePackets); i++ {
                        if applicablePackets[i].Sharecode == packetB.Sharecode {
                            stationAlreadyRepresented = true
                        }
                    }

                    if stationAlreadyRepresented == false {

                        applicablePackets = append(applicablePackets, packetB)
                    }
                }
            }

            // Remove any stations which are deemed too close to one another
            if len(applicablePackets) >= MIN_STATIONS_NEEDED {
                applicablePackets = cullPackets(applicablePackets)
            }

            // Provided we still have enough packets....
            if len(applicablePackets) >= MIN_STATIONS_NEEDED {
                // Generate a hash for this batch...
                hash := generateHashForPackets(applicablePackets)
                batchIsUnique := true

                for _, packet := range applicablePackets {
                    if packet.containsHash(hash) {
                        batchIsUnique = false
                        break
                    }
                }

                if batchIsUnique == true {
                    for _, packet := range applicablePackets {
                        packet.addHash(hash)
                    }

                    go sendOfDataForWork(applicablePackets)
                }
            }

        }
    }
}

"
44001684,"I try to embed a little c++ xerces program in my go application in order to validate xml against xsd.
The program compiles and runs fine when I use g++ with the following command:

g++ test-xerces.cpp -o xercesTest -v -lxerces-c
./xercesTest


However, when using go build, I get the following output:

go build validation-xerces.go 
    # command-line-arguments
    In file included from 
    /usr/local/include/xercesc/util/RefHashTableOf.hpp:252:0,
                 from 
    /usr/local/include/xercesc/internal/XSerializeEngine.hpp:25,
                 from 
    /usr/local/include/xercesc/internal/XSerializable.hpp:25,
                 from /usr/local/include/xercesc/util/QName.hpp:30,
                 from /usr/local/include/xercesc/framework/XMLAttr.hpp:26,
                 from 
    /usr/local/include/xercesc/framework/XMLDocumentHandler.hpp:27,
                 from 
    /usr/local/include/xercesc/parsers/AbstractDOMParser.hpp:26,
                 from 
    /usr/local/include/xercesc/parsers/XercesDOMParser.hpp:26,
                 from ./validation-xerces.go:10:
    /usr/local/include/xercesc/util/RefHashTableOf.c:33:15: fatal error: new: No such file or directory
    #include 
               ^
compilation terminated.


The program in question (I've stolen almost every part of it from people smarter than me):

package main
/*
#cgo LDFLAGS: lxerces-c

#include 

#include 
#include 
#include 
#include 
#include 
#include 

XERCES_CPP_NAMESPACE_USE

class ParserErrorHandler : public ErrorHandler
{
private:
    void reportParseException(const SAXParseException& ex)
    {
        char* msg = XMLString::transcode(ex.getMessage());
        fprintf(stderr, ""at line %llu column %llu, %s\n"",
                ex.getColumnNumber(), ex.getLineNumber(), msg);
        XMLString::release(&msg);
    }

public:
    void warning(const SAXParseException& ex)
    {
        reportParseException(ex);
    }

    void error(const SAXParseException& ex)
    {
        reportParseException(ex);
    }

    void fatalError(const SAXParseException& ex)
    {
        reportParseException(ex);
    }

    void resetErrors()
    {
    }
};

void ValidateSchema(const char* xmlFilePath)
{
    XercesDOMParser domParser;

    ParserErrorHandler parserErrorHandler;
    domParser.setErrorHandler(&parserErrorHandler);
    domParser.setValidationScheme(XercesDOMParser::Val_Auto);
    domParser.setDoNamespaces(true);
    domParser.setDoSchema(true);
    domParser.setValidationConstraintFatal(true);

    domParser.parse(xmlFilePath);
    if (domParser.getErrorCount() == 0)
        printf(""XML file validated against the schema successfully\n"");
    else
        printf(""XML file doesn't conform to the schema\n"");
}

int Cmain(int argc, const char *argv[])
{
    if (argc != 2)
    {
        printf(""SchemaValidator \n"");
        return 0;
    }

    XMLPlatformUtils::Initialize();

    ValidateSchema(argv[1]);

    XMLPlatformUtils::Terminate();

    return 0;
}
*/
import ""C""
import (
    ""unsafe""
)

func main() {
    argv := [][]byte{
        []byte(`/path/to/my/file.xml`),
    }
    c_argc := C.int(len(argv))

    var b *C.char
    ptrSize := unsafe.Sizeof(b)
    c_argv := C.malloc(C.size_t(len(argv)) * C.size_t(ptrSize))
    defer C.free(unsafe.Pointer(c_argv))

    // Assign each byte slice to its appropriate offset.
    for i := 0; i < len(argv); i++ {
        element := (**C.char)(unsafe.Pointer(uintptr(c_argv) + uintptr(i)*ptrSize))
        *element = (*C.char)(unsafe.Pointer(&argv[i][0]))
    }

    C.Cmain(c_argc, (**C.char)(c_argv))
}

"
25107817,"The function Scanner.Bytes may return the same slice used internally by the scanner.


func (s *Scanner) Bytes() []byte

  
  Bytes returns the most recent token generated by a call to Scan. The underlying array may point to data that will be overwritten by a subsequent call to Scan. It does no allocation.


As per documentation, this slice may be overwritten by subsequent calls to Scanner.Scan. Since your code does not ensure that this slice is not used after the next call to Scanner.Scan (and in fact your code produces lines and consumes them asynchonously), it may contain garbage at the point where you're trying to use it.

Explicitly copy the slice to make sure that the data is not being overwritten by subsequent calls to Scanner.Scan.

input <- append(nil, newestBytes...)

"
38572046,"I'm running my blockchain application on local network setup using Vagrant.
The network (ca and vp ) are running inside Vagrant VM while my application resides outside Vagrant. When I ran my application with security disabled, everything works fine. But now when I tried with security enabled, I'm getting the following error:  

himanshus-mbp:BCApplication himanshutyagi$ node app.js 
loading hardcoded peers
loading hardcoded users
[ibc-js] Peer:  vp0-dev_vp0...:5000
[ibc-js] No membership users found after filtering, assuming this is a network w/o membership
[ibc-js] Found chaincode in local file system
[ibc-js] Scanning files [ '.DS_Store', 'chaincode_finished.go', 'finished' ]
[ibc-js] Parsing file for shim version
[ibc-js] Found shim version: github.com/hyperledger/fabric/core/chaincode/shim
[ibc-js] Parsing file for invoke functions - chaincode_finished.go
[ibc-js] Found cc invoke function:  init
[ibc-js] Found cc invoke function:  delete_product
[ibc-js] Found cc invoke function:  delete_offering
[ibc-js] Found cc invoke function:  delete_contract
[ibc-js] Found cc invoke function:  delete_client
[ibc-js] Found cc invoke function:  write
[ibc-js] Found cc invoke function:  init_product
[ibc-js] Found cc invoke function:  init_offering
[ibc-js] Found cc invoke function:  init_contract
[ibc-js] Found cc invoke function:  init_client
[ibc-js] Found cc invoke function:  set_user_type
[ibc-js] Parsing file for query functions - chaincode_finished.go
[ibc-js] Found cc query function:  read
[ibc-js] Found cc query function:  read_product_index
[ibc-js] Found cc query function:  read_offering_index
[ibc-js] Found cc query function:  read_contract_index
[ibc-js] Found cc query function:  read_client_index
[ibc-js] load_chaincode() finished
chaincode summary file indicates chaincode has been previously deployed
------------------------------------------ Chain is up and running ------------------------------------------
Getting Offering List: 
[ibc-js] read  - success: { jsonrpc: '2.0',
  error: 
   { code: -32602,
     message: 'Invalid params',
     data: 'Must supply username for chaincode when security is enabled.' },
  id: 1469460324754 }
read _offeringindex: null { name: 'query() resp error',
  code: 400,
  details: 
   { code: -32602,
     message: 'Invalid params',
     data: 'Must supply username for chaincode when security is enabled.' } }
/Users/himanshutyagi/Desktop/workspace/node_modules/async/lib/async.js:106
        if (!arr.length) {
                ^

TypeError: Cannot read property 'length' of null
    at Object.async.each (/Users/himanshutyagi/Desktop/workspace/node_modules/async/lib/async.js:106:17)
    at /Users/himanshutyagi/Desktop/workspace/BCApplication/BCApplication/app.js:379:10
    at Object.options.success (/Users/himanshutyagi/Desktop/workspace/BCApplication/BCApplication/node_modules/ibm-blockchain-js/index.js:1020:22)
    at success (/Users/himanshutyagi/Desktop/workspace/BCApplication/BCApplication/node_modules/ibm-blockchain-js/lib/rest.js:109:30)
    at IncomingMessage. (/Users/himanshutyagi/Desktop/workspace/BCApplication/BCApplication/node_modules/ibm-blockchain-js/lib/rest.js:192:7)
    at emitNone (events.js:72:20)
    at IncomingMessage.emit (events.js:166:7)
    at endReadableNT (_stream_readable.js:921:12)
    at nextTickCallbackWith2Args (node.js:442:9)
    at process._tickCallback (node.js:356:17)


What also is weird is that in the logs, it says No membership users found after filtering I also re deployed the chaincode with the same enrollID and enrollPW as I've mentioned in my app.js blockchain js configuration. Following are the details:

var options =   {
                    network:{
                        /*
                        peers: peers,
                        users: users,
                        options: {quiet: true, tls:false, maxRetry: 1}*/
                        'peers': [
                            {
                                        'discovery_host': 'localhost',
                                        'discovery_port': 30303,
                                        'api_host': 'localhost',
                                        'api_port_tls': 443,
                                        'api_port': 5000,
                                        'type': 'peer',
                                        'network_id': 'dev',
                                        'id': 'dev_vp0',
                                        'api_url': 'http://localhost:5000'
                                    }
                            ],
                            ""users"": [
                          {
                            ""username"": ""tyagi_user_type1"",
                            ""secret"": ""1ccf8703ac"",
                            ""enrollId"": ""tyagi_type1"",
                            ""enrollSecret"": ""1ccf8703ac""
                          }
                        ],
                    options: {quiet: true, tls:false, maxRetry: 1}
                    },
                    ...
};


What does ""Must supply username for chaincode"" mean. Has anyone faced a similar issue while running with security enabled on a local network ?

UPDATE:
So, I changed the enrillId to user_type1_xxx , now ""No Membership users found.."" message doesn't come anymore. But I'm getting a connection refused error when the user is trying to register. 

himanshus-mbp:BCApplication himanshutyagi$ node app.js
loading hardcoded peers
loading hardcoded users
[ibc-js] Peer:  vp0-dev_vp0...:443
[ibc-js] Registering  vp0-dev_vp0...:443  w/enrollID - user_type1_tyagi
[ibc-js] Register - failure x1 : user_type1_tyagi 500
[ibc-js]    going to try to register again in 30 secs
Query for the product table executed
Query for the offering table executed
Query for the contract table executed
Query for the product table executed
[ibc-js] Registering  vp0-dev_vp0...:443  w/enrollID - user_type1_tyagi
[ibc-js] Register - failure x2 : user_type1_tyagi 500
[ibc-js]    going to try to register again in 30 secs
Query for the product table executed
Query for the offering table executed
Query for the contract table executed
Query for the product table executed
[ibc-js] Registering  vp0-dev_vp0...:443  w/enrollID - user_type1_tyagi
[ibc-js] Register - failure x3 : user_type1_tyagi 500
[ibc-js]    going to try to register again in 30 secs
Query for the product table executed
Query for the offering table executed
Query for the contract table executed
Query for the product table executed
Query for the product table executed
Query for the offering table executed
Query for the contract table executed
Query for the product table executed
[ibc-js] Registering  vp0-dev_vp0...:443  w/enrollID - user_type1_tyagi
[ibc-js] Register - failure x4 : user_type1_tyagi 500
! looks like an error loading the chaincode or network, app will fail
 { name: 'register() error',
  code: 500,
  details: 
   { [Error: connect ECONNREFUSED 127.0.0.1:443]
     code: 'ECONNREFUSED',
     errno: 'ECONNREFUSED',
     syscall: 'connect',
     address: '127.0.0.1',
     port: 443 } }

"
44517997,"The package github.com/kylelemons/gousb has been deprecated in favor of github.com/google/gousb. Please note that the new package has a slightly different API - we think it should be less confusing.

That being said, your call with OpenEndpoint(1,0,0,1) looks correct - it should set configuration #1 on the device, claim interface #0 with alt setting #0 and then return a representation of an endpoint with address 0x01, which is an OUT endpoint. Looking at the gousb code, I can't find any obvious issues. You can try again with the current head of the package from github, and if it still returns EP address 130 (0x82) after OpenEndpoint(1,0,0,1), please file an issue on github, this definitely should not be happening.
"
35203131,"You missed one point only: you need to export the fields of your struct:

type PublicKey struct {
    Name  string
    Price string
}


And it will work (try it on the Go Playground):

[{Name:Galaxy Nexus Price:3460.00} {Name:Galaxy Nexus Price:3460.00}]


Note that the JSON text contains the field names with lowercased text, but the json package is ""clever"" enough to match them. If they would be completely different, you could use struct tags to tell the json package how they are found (or how they should be marshaled) in the JSON text, e.g.:

type PublicKey struct {
    Name  string `json:""some_name""`
    Price string `json:""JsonPrice""`
}


To parse your other JSON text, create a Go struct that models the JSON data. I suggest to format the JSON to see the real structure, e.g. you can use this online JSON formatter/validator. Then you can unmarshal into a slice of this struct.

Or simply unmarshal into a slice of maps, e.g. []map[string]interface{}, but then you need to index the map to get the different values, and you also need to use type assertion to get ""typed"" values.
"
39425289,"There are two problems I can see there.  


Although you think you're sending a valid Json, you aren't.
NewBuffer should receive []byte, not string


Try it like this:

s := `[{""i sware to ritchie"":""this json is 100 percent valid""},{""i can even"":""copy and paste it into a curl POST request and receive it flawless on the remote side""}]`

req, err := http.NewRequest(""POST"", url, bytes.NewBuffer([]byte(fmt.Sprintf(`{""data"":%s}`, s))))

"
36383824,"I'm currently attempting to debug an issue with issuing a HTTP POST via GoLang 1.6.

The connection is failing with an 'EOF' error. 

The test client code: https://gist.github.com/fatmcgav/35d1a4fbd74c7208f445c487f756a5e1

package main

import (
    ""bytes""
    ""crypto/tls""
    ""encoding/json""
    ""fmt""
    ""net/http""
    ""net/http/httputil""
    ""os""
)

func main() {

    const body = ""{\""auth\"":"" +
        ""{\""identity\"":"" +
        ""{\""methods\"":[\""password\""],"" +
        ""\""password\"":"" +
        ""{\""user\"":{\""name\"":\""xxx\"","" +
        ""\""password\"":\""xxx\"","" +
        ""\""domain\"":{\""name\"":\""xxx_domain\""}"" +
        ""}"" +
        ""}"" +
        ""},\""scope\"":{\""project\"":"" +
        ""{\""domain\"": "" +
        ""{\""name\"":\""xxx_domain\""},\""name\"":\""xxx\""}}}}""

    // Unmarshall JSON
    var m map[string]interface{}
    json.Unmarshal([]byte(body), &m)
    // fmt.Println(""%v"", m)

    var req *http.Request
    var resp *http.Response
    var dump []byte
    var err error
    client := &http.Client{}

    url := ""https://identity.xxx/v3/auth/tokens""

    fmt.Println(""Requesting auth token against URL: %s"", url)

    rendered, err := json.Marshal(m)
    if err != nil {
        fmt.Println(""Error marshalling body: %q"", err)
        os.Exit(2)
    }

    req, err = http.NewRequest(""POST"", url, bytes.NewReader(rendered))
    if err != nil {
        fmt.Println(""Got an error: %q"", err)
        os.Exit(2)
    }

    // Need to Close connection
    req.Close = true

    fmt.Println(""Setting Insecure TLS mode"")
    // Configure custom TLS settings.
    config := &tls.Config{InsecureSkipVerify: true}
    transport := &http.Transport{TLSClientConfig: config,
        DisableKeepAlives:  true,
        DisableCompression: true,
    }
    client.Transport = transport

    req.Header.Set(""Content-Type"", ""application/json"")
    req.Header.Set(""Accept"", ""application/json"")

    dump, err = httputil.DumpRequestOut(req, true)
    fmt.Printf(""Outgoing requst = \n%q\n"", dump)

    resp, err = client.Do(req)
    if err != nil {
        fmt.Println(""Error encountered: %q"", err)
    }
    dump, err = httputil.DumpResponse(resp, true)
    fmt.Printf(""Response = \n%q\n"", dump)
}


and resultant output is here:

 ~/golang/scripts  go build req-test.go && ./req-test
Requesting auth token against URL: %s https://identity.xxx/v3/auth/tokens
Setting Insecure TLS mode
Outgoing requst =
""POST /v3/auth/tokens HTTP/1.1\r\nHost: identity.xxx\r\nUser-Agent: Go-http-client/1.1\r\nConnection: close\r\nContent-Length: 262\r\nAccept: application/json\r\nContent-Type: application/json\r\nAccept-Encoding: gzip\r\n\r\n{\""auth\"":{\""identity\"":{\""methods\"":[\""password\""],\""password\"":{\""user\"":{\""domain\"":{\""name\"":\""BusinessSupport_domain\""},\""name\"":\""xxx\"",\""password\"":\""xxx\""}}},\""scope\"":{\""project\"":{\""domain\"":{\""name\"":\""xxx_domain\""},\""name\"":\""xxx\""}}}}""
Error encountered: %q Post https://identity.xxx/v3/auth/tokens: EOF
panic: runtime error: invalid memory address or nil pointer dereference
[signal 0xb code=0x1 addr=0x0 pc=0x13659e]

goroutine 1 [running]:
panic(0x338980, 0xc82000a170)
        /usr/local/opt/go/libexec/src/runtime/panic.go:464 +0x3e6
net/http/httputil.DumpResponse(0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0)
        /usr/local/opt/go/libexec/src/net/http/httputil/dump.go:285 +0x42e
main.main()
        /Users/gavinw/golang/scripts/req-test.go:77 +0xdc


For obvious reasons, I've anonymised some of the details.. 

Any pointers on what I'm doing wrong.. 

Cheers
Gavin
"
37425805,"No issues building at commandline:


  Darians-MacBook-Pro:gdriveweb darianhickman$ go build helloworld/hello.go
  
  Darians-MacBook-Pro:gdriveweb darianhickman$ 


Error at locahost:8080/


  The Go application could not be built.
  
  (Executed command: /Users/darianhickman/go_appengine/goroot/bin/go-app-builder -app_base /Users/darianhickman/gowork/src/bitbucket.org/darian_hickman/gdriveweb/helloworld -arch 6 -dynamic -goroot /Users/darianhickman/go_appengine/goroot -nobuild_files ^^$ -unsafe -gopath /Users/darianhickman/gowork -binary_name _go_app -extra_imports appengine_internal/init -work_dir /var/folders/fk/wknp5jzn53gbgbml0yn695_m0000gn/T/tmpsHFP6tappengine-go-bin -gcflags -I,/Users/darianhickman/go_appengine/goroot/pkg/darwin_amd64_appengine -ldflags -L,/Users/darianhickman/go_appengine/goroot/pkg/darwin_amd64_appengine hello.go)
  /Users/darianhickman/gowork/src/golang.org/x/net/context/ctxhttp/ctxhttp.go:35: req.Cancel undefined (type *http.Request has no field or method Cancel)
  
  2016/05/24 19:39:17 go-app-builder: build timing: 6×6g (469ms total), 0×6l (0 total)
  2016/05/24 19:39:17 go-app-builder: failed running 6g: exit status 1


When I research the error


  *http.Request has no field or method Cancel


it leads to a bunch of nonapplicable posts about updating to >Go1.5. 

Source:

 package hello

import (
    ""encoding/json""
    ""fmt""
    ""golang.org/x/net/context""
    ""golang.org/x/oauth2""
    ""golang.org/x/oauth2/google""
    ""google.golang.org/api/drive/v3""
    _ ""google.golang.org/appengine/urlfetch""
    ""io/ioutil""
    ""log""
    ""net/http""
    ""net/url""
    ""os""
    ""os/user""
    ""path/filepath""
)

const (
    assetfolder = ""0B-zdryEj60U_MXVkajFweXBQWHM""
)

var (
    dir *drive.FileList
)

func init() {
    http.HandleFunc(""/"", handler)

    ctx := context.Background()

    b, err := ioutil.ReadFile(""client_secret.json"")
    if err != nil {
        log.Fatalf(""Unable to read client secret file: %v"", err)
    }

    // If modifying these scopes, delete your previously saved credentials
    // at ~/.credentials/drive-go-quickstart.json
    config, err := google.ConfigFromJSON(b, drive.DriveMetadataReadonlyScope)
    if err != nil {
        log.Fatalf(""Unable to parse client secret file to config: %v"", err)
    }
    client := getClient(ctx, config)

    srv, err := drive.New(client)
    if err != nil {
        log.Fatalf(""Unable to retrieve drive Client %v"", err)
    }

    dir, err = srv.Files.List().PageSize(10).
        Fields(""nextPageToken, files(id, name)"").Do()
    if err != nil {
        log.Fatalf(""Unable to retrieve files."", err)
    }

}

func handler(w http.ResponseWriter, r *http.Request) {

    //fmt.Fprint(w, r.RequestURI)

    fmt.Fprint(w, ""Files:"")
    if len(dir.Files) > 0 {
        for _, i := range dir.Files {
            fmt.Fprint(w, ""%s (%s)\n"", i.Name, i.Id)
        }
    } else {
        fmt.Fprint(w, ""No files found."")
    }
}

// getClient uses a Context and Config to retrieve a Token
// then generate a Client. It returns the generated Client.
func getClient(ctx context.Context, config *oauth2.Config) *http.Client {
    cacheFile, err := tokenCacheFile()
    if err != nil {
        log.Fatalf(""Unable to get path to cached credential file. %v"", err)
    }
    tok, err := tokenFromFile(cacheFile)
    if err != nil {
        tok = getTokenFromWeb(config)
        saveToken(cacheFile, tok)
    }
    return config.Client(ctx, tok)
}

// getTokenFromWeb uses Config to request a Token.
// It returns the retrieved Token.
func getTokenFromWeb(config *oauth2.Config) *oauth2.Token {
    authURL := config.AuthCodeURL(""state-token"", oauth2.AccessTypeOffline)
    fmt.Printf(""Go to the following link in your browser then type the ""+
        ""authorization code: \n%v\n"", authURL)

    var code string
    if _, err := fmt.Scan(&code); err != nil {
        log.Fatalf(""Unable to read authorization code %v"", err)
    }

    tok, err := config.Exchange(oauth2.NoContext, code)
    if err != nil {
        log.Fatalf(""Unable to retrieve token from web %v"", err)
    }
    return tok
}

// tokenCacheFile generates credential file path/filename.
// It returns the generated credential path/filename.
func tokenCacheFile() (string, error) {
    usr, err := user.Current()
    if err != nil {
        return """", err
    }
    tokenCacheDir := filepath.Join(usr.HomeDir, "".credentials"")
    os.MkdirAll(tokenCacheDir, 0700)
    return filepath.Join(tokenCacheDir,
        url.QueryEscape(""drive-go-quickstart.json"")), err
}

// tokenFromFile retrieves a Token from a given file path.
// It returns the retrieved Token and any read error encountered.
func tokenFromFile(file string) (*oauth2.Token, error) {
    f, err := os.Open(file)
    if err != nil {
        return nil, err
    }
    t := &oauth2.Token{}
    err = json.NewDecoder(f).Decode(t)
    defer f.Close()
    return t, err
}

// saveToken uses a file path to create a file and store the
// token in it.
func saveToken(file string, token *oauth2.Token) {
    fmt.Printf(""Saving credential file to: %s\n"", file)
    f, err := os.Create(file)
    if err != nil {
        log.Fatalf(""Unable to cache oauth token: %v"", err)
    }
    defer f.Close()
    json.NewEncoder(f).Encode(token)
}

func main() {
    ctx := context.Background()

    b, err := ioutil.ReadFile(""client_secret.json"")
    if err != nil {
        log.Fatalf(""Unable to read client secret file: %v"", err)
    }

    // If modifying these scopes, delete your previously saved credentials
    // at ~/.credentials/drive-go-quickstart.json
    config, err := google.ConfigFromJSON(b, drive.DriveMetadataReadonlyScope)
    if err != nil {
        log.Fatalf(""Unable to parse client secret file to config: %v"", err)
    }
    client := getClient(ctx, config)

    srv, err := drive.New(client)
    if err != nil {
        log.Fatalf(""Unable to retrieve drive Client %v"", err)
    }

    r, err := srv.Files.List().PageSize(10).
        Fields(""nextPageToken, files(id, name)"").Do()
    if err != nil {
        log.Fatalf(""Unable to retrieve files."", err)
    }

    fmt.Println(""Files:"")
    if len(r.Files) > 0 {
        for _, i := range r.Files {
            fmt.Printf(""%s (%s)\n"", i.Name, i.Id)
        }
    } else {
        fmt.Print(""No files found."")
    }

}

"
38010631,"The second solution handles the leak by using the quit channel. When the quit channel is closed (in Same() function), the case 2 of select statement succeeds(case 
"
25370701,"It might be related to Thread Switching: 

The solution could be to use LockOSThread 

http://golang.org/pkg/runtime/#LockOSThread

You can read more about it here: 
https://code.google.com/p/go-wiki/wiki/LockOSThread

Also your Init function has capital I if you are trying to initialize the library it has to be lower case.
"
27842294,"Checking the len of a channel is always a race, you can't use that for any sort of synchronization.

The producer is always the side that closes a channel, because it's a fatal error to try and send on a closed channel. Don't use a defer here, just close the channel when you're done sending.
"
40680642,"I'm working with Go in an API for the bus frequency of my city, but i'm a little bit stuck on the threads when i try to make HTTP Get to many urls.
Without concurrency, the programs takes over 16 minutes to complete the 1500 url calls to take the HTTP status code, and i was trying to use the concurrency, but after reading many posts i don't understand how goroutines work... 

The idea is to make ONE function and change the number of requests, like here:

 go getBusPostStatus(600, 800)


But i'm completely stucked on that...

Here is the code:

package main

import (
""fmt""
""net/http""
""strconv""
""time""
)
var i int = 0
var convStr string
var message = make(chan string)

/*func main(){
    for i = 0; i < 1500; i++ {
        z = strconv.Itoa(i)
        url := ""http://www.urbanosdezaragoza.es/frm_esquemaparadatime.php?poste="" + z
        resp, err := http.Get(url)
        if err != nil {
            fmt.Println(""Houston, we've got problems"")
        }else{
            if resp.StatusCode == 200{
                fmt.Println(""OK: El poste ""+z+"" existe"")
            }else{
                fmt.Println(""WARN: El poste ""+z+"" NO existe"")
            }
        }
    }
}*/

//Return 2 houndred posts
func returnTH(c chan string){
 for i = 0; i < 200; i++ {  
    convStr = strconv.Itoa(i)
    url := ""http://www.urbanosdezaragoza.es/frm_esquemaparadatime.php?poste="" + convStr
    resp, err := http.Get(url)
    if err != nil {
        fmt.Println(""Houston, we've got problems"")
    }else{
        if resp.StatusCode == 200{
            //fmt.Println(""OK: El poste ""+z+"" existe"")
            c <- ""OK: The bus post ""+convStr+"" exists""
        }else{
            //fmt.Println(""WARN: El poste ""+z+"" NO existe"")
            c <- ""WARN: The bus post ""+convStr+"" does not exist""
        }   
    }
  }
}
func returnFH(z chan string){
  for i = 201; i < 400; i++ {   
   convStr = strconv.Itoa(i)
   url := ""http://www.urbanosdezaragoza.es/frm_esquemaparadatime.php?poste="" + convStr
    resp, err := http.Get(url)
    if err != nil {
        fmt.Println(""Houston, we've got problems"")
    }else{
        if resp.StatusCode == 200{
            //fmt.Println(""OK: El poste ""+z+"" existe"")
            z <- ""OK: The bus post ""+convStr+"" exists""
        }else{
            //fmt.Println(""WARN: El poste ""+z+"" NO existe"")
            z <- ""WARN: The bus post ""+convStr+"" does not exist""
        }   
    } 
  }
}

func threadPrint(c, z chan string){
   for {
       threadOne := <- c
       threadTwo := <- z
       fmt.Println(threadOne)
       fmt.Println(threadTwo)
   }
}
func main(){
    start := time.Now()
    var c chan string = make(chan string)
    var z chan string = make(chan string)
    //for i = 0; i < 1500; i++{
    go returnTH(c)
    go returnFH(z)
    go threadPrint(c,z)
    /*go getBusPostStatus(400, 600)
    go getBusPostStatus(600, 800)
    go getBusPostStatus(800, 1000)
    go getBusPostStatus(1000, 1200)
    go getBusPostStatus(1200, 1400)
    go getBusPostStatus(1400, 1500)*/
    //}
    timeExec:= time.Since(start)
    fmt.Println(""Time to exec code = "", timeExec)

    /*var input string
    fmt.Scanln(&input)
    fmt.Println(""done"")*/
}


Many thanks in advance!! 
"
42684321,"Your main problem is you're not checking errors, at least in the example you're not. If you check the error returned from reader.Read() you would know that it is ErrBareQuote, to avoid that error you have to set the csv.Reader's LazyQuotes field to true. Here's a working version of your code https://play.golang.org/p/3y-T1DCsp6
"
36676691,"I'm porting an app from Play (Scala) to Go and wondering how to implement dependency injection. In Scala I used the cake pattern, while in Go I implemented a DAO interface along with an implementation for Mongo.

Here below is how I tried to implement a pattern that let me change the DAO implementation as needed (e.g. test, different DB, etc.):

1. entity.go

package models

import (
    ""time""
    ""gopkg.in/mgo.v2/bson""
)

type (
    Entity struct {
        Id        bson.ObjectId `json:""id,omitempty"" bson:""_id,omitempty""`
        CreatedAt time.Time     `json:""createdAt,omitempty"" bson:""createdAt,omitempty""`
        LastUpdate time.Time    `json:""lastUpdate,omitempty"" bson:""lastUpdate,omitempty""`
    }
)


2. user.go

package models

import (
    ""time""
)

type (
    User struct {
        Entity                  `bson:"",inline""`
        Name      string        `json:""name,omitempty"" bson:""name,omitempty""`
        BirthDate time.Time     `json:""birthDate,omitempty"" bson:""birthDate,omitempty""`
    }
)


3. dao.go

package persistence

type (
    DAO interface {
        Insert(entity interface{}) error
        List(result interface{}, sort string) error
        Find(id string, result interface{}) error
        Update(id string, update interface{}) error
        Remove(id string) error
        Close()
    }

    daoFactory func() DAO
)

var (
    New daoFactory
)


4. mongoDao.go (DB info and collection name are hard-coded since it's just an example)

package persistence

import (
    ""fmt""
    ""time""
    ""errors""
    ""gopkg.in/mgo.v2""
    ""gopkg.in/mgo.v2/bson""
    ""github.com/fatih/structs""

    ""cmd/server/models""
)

type (
    mongoDAO struct{
        session *mgo.Session
    }
)

func NewMongoDAO() DAO {
    dialInfo := &mgo.DialInfo{
        Addrs:      []string{""localhost:27017""},
        Timeout:    60 * time.Second,
        Database:   ""test"",
    }

    session, err := mgo.DialWithInfo(dialInfo)

    if err != nil {
        panic(err)
    }

    session.SetMode(mgo.Monotonic, true)

    return &mongoDAO{session}
}

func (dao *mongoDAO) Insert(entity interface{}) error {

    doc := entity.(*models.User)
    doc.Id = bson.NewObjectId()
    doc.CreatedAt = time.Now().UTC()
    doc.LastUpdate = time.Now().UTC()

    return dao.session.DB(""test"").C(""users"").Insert(doc)
}

func (dao *mongoDAO) List(result interface{}, sort string) error {
    return dao.session.DB(""test"").C(""users"").Find(nil).Sort(sort).All(result)
}

func (dao *mongoDAO) Find(id string, result interface{}) error {
    if !bson.IsObjectIdHex(id) {
        return errors.New(fmt.Sprintf(""%s is not a valid hex id"", id))
    }

    oid := bson.ObjectIdHex(id)

    return dao.session.DB(""test"").C(""users"").FindId(oid).One(result)
}

func (dao *mongoDAO) Update(id string, update interface{}) error {
    if !bson.IsObjectIdHex(id) {
        return errors.New(fmt.Sprintf(""%s is not a valid hex id"", id))
    }

    oid := bson.ObjectIdHex(id)

    doc := update.(*models.User)
    doc.LastUpdate = time.Now().UTC()

    return dao.session.DB(""test"").C(""users"").Update(oid, bson.M{""$set"": structs.Map(update)})
}

func (dao *mongoDAO) Remove(id string) error {
    if !bson.IsObjectIdHex(id) {
        return errors.New(fmt.Sprintf(""%s is not a valid hex id"", id))
    }

    oid := bson.ObjectIdHex(id)

    return dao.session.DB(""test"").C(""users"").RemoveId(oid)
}

func (dao *mongoDAO) Close() {
    dao.session.Close()
}

func init() {
    New = NewMongoDAO
}


Finally, here is how I use the types above:

5. userController.go

package controllers

import (
    ""net/http""
    ""github.com/labstack/echo""

    ""cmd/server/models""
    ""cmd/server/persistence""
)

type (
    UserController struct {
        dao persistence.DAO
    }
)

func NewUserController(dao persistence.DAO) *UserController {
    return &UserController{dao}
}

func (userController *UserController) CreateUser() echo.HandlerFunc {
    return func(context echo.Context) error {
        user := &models.User{}

        if err := context.Bind(user); err != nil {
            return err
        }

        if err := userController.dao.Insert(user); err != nil {
            return err
        }

        return context.JSON(http.StatusCreated, user)
    }
}

func (userController *UserController) UpdateUser() echo.HandlerFunc {
    return func(context echo.Context) error {
        user := &models.User{}

        if err := context.Bind(user); err != nil {
            return err
        }

        id := context.Param(""id"")
        if err := userController.dao.Update(id, user); err != nil {
            return err
        }

        return context.JSON(http.StatusOK, user)
    }
}

....


The code above is 90% fine... I've just a problem in mongoDao.go with methods Insert and Update where the compiler forces me to cast input entity to a specific type (*models.User), but this prevents me from having a generic DAO component that works for all types. How do I fix this issue?
"
44690546,"What you're trying to do is use communication as an execution rendezvous. The sender wants to know something about when the receiver gets messages.

ZMQ implements the Actor model. What you need is a modification of the Communicating Sequential Processes model (one where sends timeout). Basically you need to add control message flows to/from the workers, the idea being that the server asks the worker to receive a message and the server waits for the reply. The reply means that the worker is ready to receive a message right now, and that the server and worker have both rendezvoused at a send/receive in their program flows. If that reply fails to arrive within timeout seconds, then the server doesn't send the actual message. 

Or you could cheat by having everything going to the workers regardless, wrapped in a message that carries a ""sent at time X"" field, and have the worker decide to discard old messages.
"
37320179,"oracle is a source analysis command line tool, you can't import it. Use the following command to get it:

go get golang.org/x/tools/cmd/oracle


This will create an executable named oracle in your $GOPATH/bin directory.

Visit http://golang.org/s/oracle-user-manual for the complete oracle documentation.
"
44017582,"Your current code is not concurrent at all. All the alphanumeric codes are generated sequentially in a single for loop running in the sole goroutine you are creating besides main.

You are adding len(alphabets) == 26 to wg.Wait. That means you need to call 26 wg.Done for the call to wg.Wait to complete. Each wg.Done call reduces the waitgroup counter by one.

In your code, you are calling wg.Done only once. That means waitgroup counter stays at 25 once your goroutine returns and the call to wg.Wait would never return since no other goroutine is running that may reduce the waitgroup counter by making further calls to wg.Done.

To (vaguely) get what you want, you can try something like this:

// ...

n := 10 // number of codes you want to print

wg.Add(n)

for i := 0; i < n; i++ {
  go func(numbers []string, alphabets []string) {
    defer wg.Done()
    makeAleph(numbers, alphabets)
  }(numbers, alphabets)

wg.Wait()

// ...


Now, n goroutines will be spawned, each responsible for printing one code by calling makeAleph. As soon as a goroutine returns, wg.Done is called. A total n wg.Dones are called allowing call to wg.Wait in main to complete.
"
32370700,"I'm trying to write a simple client-server application. It works fine with both sides on the same computer, but it blocks when run on two different computers. The computers are a RaspBerry Pi 2 and a MacBook Pro.

The problem is that the client blocks in binary.Write after a few good runs. Typically, the server that receives the data prints that it has received 63 and the client that sends the data prints that it will be sending 64.

If I ad the deadline to the server, it quits with a time-out. The client also has a deadline but doesn't time out.

I tried replacing the data by a simple byte array or just a single int. It still blocks. But the smaller the data is, the more times it goes right.

If I remove the Printf functions in the client, it also goes well for a longer time.

I also tried replacing the functionality of the server by a simple copy from the socket to STDIO (a tip I found here somewhere) but it still fails to come out of binary.Write.

Any idea?

Here is the complete source. There's some bogus stuff in there (the count loop, for example), but it's all really quite simple. Or am I mistaken?

package main

import (
    //  ""bytes""
    ""encoding/binary""
    ""fmt""
    ""io""
    ""net""
    ""os""
    ""os/exec""
    ""runtime/trace""
    ""time""
    ""unsafe""
)

type TheMessageType struct {
    X             int32
    RestOfMessage [1000]byte
}

func listener(theCounter int, active bool, f *os.File) {
    var message TheMessageType
    var err error
    var conn net.Conn

    count := theCounter

    for {
        // Dial the server
        fmt.Printf(""LISTENER %d: connecting to socket\n"", count)
        conn, err = net.Dial(""tcp"", ""192.168.1.113:49152"")
        if err != nil {
            fmt.Printf(""LISTENER %d: not connected, retrying in 3 seconds\n"", count)
            time.Sleep(3 * time.Second)
        } else {
            fmt.Printf(""LISTENER %d: connected\n"", count)
            break
        }
    }
    defer conn.Close()

    // Loop writing to socket
    for {
        // Set deadline
        // conn.SetDeadline(time.Now().Add(2 * time.Second))

        // Print some info
        fmt.Printf(""LISTENER %d: writing from %v to %v\n"", count, conn.LocalAddr(), conn.RemoteAddr())

        // Prepare message to write to socket
        message.X = int32(count)
        theString := fmt.Sprintf(""%d"", count)
        copy(message.RestOfMessage[:], theString)

        // binary write directly to socket
        fmt.Printf(""LISTENER %d: binary.Write this: %d, %s\n"", count, message.X, message.RestOfMessage)

        f.Sync()
        err = binary.Write(conn, binary.LittleEndian, message)

        f.Sync()
        fmt.Printf(""LISTENER %d: written\n"", count)
        // time.Sleep(50 * time.Millisecond)
        checkError(err, ""LISTENER"")

        count = count + 1
    }
}

func main() {
    var myMessage TheMessageType
    var ln net.Listener
    var conn net.Conn
    var err error
    var theCount int
    var avgspeed, speed float64
    var speedlist [10]float64

    curspeed := 0

    const listenerActive = true
    const mainActive = false

    f, err := os.Create(""theFile.out"")
    trace.Start(f)

    t0 := time.Now()
    t1 := time.Now()

    transferSize := unsafe.Sizeof(myMessage)

    fmt.Printf(""MAIN: timestamp %s ; size of transfers is %d\n"", t0.String(), transferSize)

    if mainActive {
        fmt.Println(""MAIN: listen"")
        ln, err = net.Listen(""tcp"", "":49152"")
        fmt.Println(""MAIN: defer"")
        defer ln.Close()
        fmt.Println(""MAIN: checkError"")
        checkError(err, ""MAIN"")
    }

    // launch listener
    if listenerActive {
        go listener(theCount, listenerActive, f)
    }

    for theCount = 1; ; theCount++ {

        if mainActive {
            fmt.Println(""MAIN: accept"")
            conn, err = ln.Accept()
            checkError(err, ""MAIN"")

            exit := false

            for !exit {
                // Set deadline
                // conn.SetDeadline(time.Now().Add(2 * time.Second))

                // Print some info
                fmt.Printf(""MAIN: reading on %v from %v\n"", conn.LocalAddr(), conn.RemoteAddr())

                // move time
                t0 = t1

                // read from socket
                fmt.Println(""MAIN: reader"")

                f.Sync()
                err = binary.Read(conn, binary.LittleEndian, &myMessage)

                f.Sync()
                if err == io.EOF {
                    fmt.Println(""EOF!"")
                    exit = true
                    conn.Close()
                } else {
                    checkError(err, ""MAIN"")
                }

                // clear screen
                c := exec.Command(""clear"")
                c.Stdout = os.Stdout
                c.Run()

                // print received data
                fmt.Printf(""MAIN: socket message received: %d, %s\n"", myMessage.X, myMessage.RestOfMessage)

                // calculate speed & average
                t1 = time.Now()
                tdif := t1.Sub(t0)
                speed = float64(transferSize) / tdif.Seconds() / 1000000.0 * 8.0
                speedlist[curspeed] = speed
                curspeed = curspeed + 1
                if curspeed == 10 {
                    curspeed = 0
                }
                totalspeed := 0.0
                for i := 0; i < 10; i++ {
                    totalspeed += speedlist[i]
                }
                avgspeed = totalspeed / 10

                // print speed
                fmt.Printf(""MAIN: avg mbit/s %9.2f ; actual mbit/s: %9.2f\n"", avgspeed, speed)
                // time.Sleep(1 * time.Second)
            }
        }
    }
}

func checkError(err error, name string) {
    if err != nil {
        fmt.Fprintf(os.Stderr, ""%s: Fatal error: %s\n"", name, err.Error())
        //      panic(fmt.Sprintf(""%v"", err.Error()))
        os.Exit(1)
    }
}


Here's the stacktrace of the client when it's blocked writing:

goroutine 1 [running]:
runtime.throw(0x1927b8, 0x5)
    /usr/local/go/src/runtime/panic.go:527 +0x90 fp=0xc82004bd78 sp=0xc82004bd60
runtime.sigpanic()
    /usr/local/go/src/runtime/sigpanic_unix.go:27 +0x2ba fp=0xc82004bdc8 sp=0xc82004bd78
main.main()
    /Users/ple/dev/go/src/Peter-test/main.go:108 +0x33c fp=0xc82004bf50 sp=0xc82004bdc8
runtime.main()
    /usr/local/go/src/runtime/proc.go:111 +0x2b0 fp=0xc82004bfa0 sp=0xc82004bf50
runtime.goexit()
    /usr/local/go/src/runtime/asm_amd64.s:1696 +0x1 fp=0xc82004bfa8 sp=0xc82004bfa0

goroutine 17 [syscall, locked to thread]:
runtime.goexit()
    /usr/local/go/src/runtime/asm_amd64.s:1696 +0x1

goroutine 5 [trace reader (blocked)]:
runtime.ReadTrace(0x0, 0x0, 0x0)
    /usr/local/go/src/runtime/trace.go:339 +0x207
runtime/trace.Start.func1(0x5a42e0, 0xc82002a020)
    /usr/local/go/src/runtime/trace/trace.go:28 +0x18
created by runtime/trace.Start
    /usr/local/go/src/runtime/trace/trace.go:34 +0x78

goroutine 6 [runnable]:
reflect.Value.Index(0x1234c0, 0xc8204ac004, 0x51, 0x75, 0x12ac00, 0xc8204ac078, 0x48)
    /usr/local/go/src/reflect/value.go:823
encoding/binary.(*encoder).value(0xc8200475a0, 0x1234c0, 0xc8204ac004, 0x51)
    /usr/local/go/src/encoding/binary/binary.go:509 +0x808
encoding/binary.(*encoder).value(0xc8200475a0, 0x162ba0, 0xc8204ac000, 0x59)
    /usr/local/go/src/encoding/binary/binary.go:518 +0xb4f
encoding/binary.Write(0x621138, 0xc8200a2000, 0x621160, 0x289ef0, 0x162ba0, 0xc8204ac000, 0x0, 0x0)
    /usr/local/go/src/encoding/binary/binary.go:316 +0x1792
main.listener(0x0, 0x1, 0xc82002a020)
    /Users/ple/dev/go/src/Peter-test/main.go:59 +0xac8
created by main.main
    /Users/ple/dev/go/src/Peter-test/main.go:105 +0x332

"
29630598,"I am trying to search youtube video by key like in the golang example. I modified that code a little to let it search by different keys several times. 
When I search once it is ok. 

func main() {
    result1, err1 := SearchYoutubeByKey(""hello"")

    if err1 != nil {
        panic(err1)
    }
    fmt.Println(result1)

    // result2, err2 := SearchYoutubeByKey(""world"")
    // if err2 != nil {
    //  panic(err2)
    // }
    // fmt.Println(result2)
}


But if I search twice ...

func main() {
    result1, err1 := SearchYoutubeByKey(""hello"")

    if err1 != nil {
        panic(err1)
    }
    fmt.Println(result1)

    result2, err2 := SearchYoutubeByKey(""world"")
    if err2 != nil {
        panic(err2)
    }
    fmt.Println(result2)
}


... then it panics with error message ...

flag redefined: query


... on line ...

query := flag.String(""query"", str, ""Search term"")


Full code:

package main

import (
    ""code.google.com/p/google-api-go-client/googleapi/transport""
    ""code.google.com/p/google-api-go-client/youtube/v3""
    ""flag""
    ""fmt""
    ""net/http""
)

var (
    maxResults = flag.Int64(""max-results"", 25, ""Max YouTube results"")
    service    *youtube.Service
    response   *youtube.SearchListResponse
)

const developerKey = ""youtube developer key""

type YoutubeSearchResult struct {
    Title, YoutubeId string
}

func SearchYoutubeByKey(str string) (result []*YoutubeSearchResult, err error) {
    query := flag.String(""query"", str, ""Search term"")
    flag.Parse()

    client := &http.Client{
        Transport: &transport.APIKey{Key: developerKey},
    }

    service, err = youtube.New(client)
    if err != nil {
        return
    }

    // Make the API call to YouTube.
    call := service.Search.List(""id,snippet"").
        Q(*query).
        MaxResults(*maxResults)
    response, err = call.Do()
    if err != nil {
        return
    }

    // Iterate through each item and add it to the correct list.
    for _, item := range response.Items {
        switch item.Id.Kind {
        case ""youtube#video"":
            result = append(result, &YoutubeSearchResult{Title: item.Snippet.Title, YoutubeId: item.Id.VideoId})
        }
    }
    return
}

func main() {


    result1, err1 := SearchYoutubeByKey(""hello"")

    if err1 != nil {
        panic(err1)
    }
    fmt.Println(result1)

    result2, err2 := SearchYoutubeByKey(""world"")
    if err2 != nil {
        panic(err2)
    }
    fmt.Println(result2)
}


So it is impossible to use this code on a website. Only the first user will be able to search first time, the others will fail.

I cannot change flag during runtime but how to search by 2 different keys in one program? 

Update

working solution:

package main

import (
    ""code.google.com/p/google-api-go-client/googleapi/transport""
    ""code.google.com/p/google-api-go-client/youtube/v3""
    ""flag""
    ""fmt""
    ""net/http""
)

var (
    maxResults = flag.Int64(""max-results"", 25, ""Max YouTube results"")
    service    *youtube.Service
    response   *youtube.SearchListResponse
    query      = flag.String(""query"", ""str"", ""Search term"")
)

const developerKey = ""youtube api key""

type YoutubeSearchResult struct {
    Title, YoutubeId string
}

func SearchYoutubeByKey(str string) (result []*YoutubeSearchResult, err error) {
    flag.Parse()

    client := &http.Client{
        Transport: &transport.APIKey{Key: developerKey},
    }

    service, err = youtube.New(client)
    if err != nil {
        return
    }

    // Make the API call to YouTube.
    call := service.Search.List(""id,snippet"").
        Q(str).
        MaxResults(*maxResults)
    response, err = call.Do()
    if err != nil {
        return
    }

    // Iterate through each item and add it to the correct list.
    for _, item := range response.Items {
        switch item.Id.Kind {
        case ""youtube#video"":
            result = append(result, &YoutubeSearchResult{Title: item.Snippet.Title, YoutubeId: item.Id.VideoId})
        }
    }
    return
}

func main() {
    result1, err1 := SearchYoutubeByKey(""hello"")

    if err1 != nil {
        panic(err1)
    }
    fmt.Println(result1)

    result2, err2 := SearchYoutubeByKey(""world"")
    if err2 != nil {
        panic(err2)
    }
    fmt.Println(result2)
}

"
41025575,"although this is a dead post, I cannot help but note since no one else has (explicitly), and it's kinda' important to know why:


nested for loops exhibit quadratic running time complexity,
and as you stated, searching an array takes linear time,


so simply put:


the computation time will increase by the square of the total number of elements.


now to answer why this isn't the case in php -- well cause you were using a hash map which:


can be said, exhibits a constant time complexity


again, simply put this means that:


look up time is not related to the number of elements (aka the size of the collection).


see: big-o

with all that being said, please note: 


i don't know php,


thus do not the know details regarding how the language implements arrays, and

im not an algorithm expert,


so please treat my post as a statement for the general case.

pce
"
43293493,"Currently trying out Google Cloud with Go, and I'm having the most bizarre issue I have ever seen.

I have made an ultra simple ""hello world"" app that just prints out some text to the browser. It compiles perfectly with ""go build"", and even deploys to Google Cloud and runs there just fine, but when I use ""goapp serve"" to run it locally it randomly crashes when I start it, with a huge stack trace and the message:

fatal error: unexpected signal during runtime execution
[signal 0xb code=0x1 addr=0xb01dfacedebac1e pc=0xf47b]


When I get the error, I simply run ""goapp serve"" again, and after a few tries it somehow magically decides to work. Other times, if I can't get it to run after 10-20 tries, I simply make a micro change in the code somewhere, like editing a string, changing a single character, and then it runs just fine locally. Whaaaaat!?!?!?

I'm so baffled how this is even possible. I seems that ""goapp serve"" is extremely fragile. It's Google official local development server, so I would expect it to be a little more stable, or at least give some more human readable clues.

I have searched all over and can't find anything related to this.

Any ideas how or what is causing this?

Here is the stack trace:

ERROR   go_runtime.py:181] Failed to build Go application: (Executed command: /usr/local/go_appengine/goroot/bin/go-app-builder -app_base /Users/kieran/Go/src/hello/main -arch 6 -dynamic -goroot /usr/local/go_appengine/goroot -nobuild_files ^^$ -unsafe -gopath /Users/kieran/Go -binary_name _go_app -extra_imports appengine_internal/init -work_dir /var/folders/w3/wrcy8wfn3gzbnphs0cq6yw9r0000gn/T/tmpf_Nrsvappengine-go-bin -gcflags -I,/usr/local/go_appengine/goroot/pkg/darwin_amd64_appengine -ldflags -L,/usr/local/go_appengine/goroot/pkg/darwin_amd64_appengine main.go)

fatal error: unexpected signal during runtime execution
[signal 0xb code=0x1 addr=0xb01dfacedebac1e pc=0xf47b]

runtime stack:
runtime.throw(0x2c4ac0, 0x2a)
    /private/var/folders/9y/ppk2fnqj5lscwqw_l6lhdrx8005bt1/T/appengine/go_appengine/goroot/src/runtime/panic.go:547 +0x90
runtime.sigpanic()
    /private/var/folders/9y/ppk2fnqj5lscwqw_l6lhdrx8005bt1/T/appengine/go_appengine/goroot/src/runtime/sigpanic_unix.go:12 +0x5a
runtime.unlock(0x3aa0c0)
    /private/var/folders/9y/ppk2fnqj5lscwqw_l6lhdrx8005bt1/T/appengine/go_appengine/goroot/src/runtime/lock_sema.go:107 +0x14b
runtime.(*mheap).alloc_m(0x3aa0c0, 0x1, 0x20000000020, 0x8a5178)
    /private/var/folders/9y/ppk2fnqj5lscwqw_l6lhdrx8005bt1/T/appengine/go_appengine/goroot/src/runtime/mheap.go:492 +0x314
runtime.(*mheap).alloc.func1()
    /private/var/folders/9y/ppk2fnqj5lscwqw_l6lhdrx8005bt1/T/appengine/go_appengine/goroot/src/runtime/mheap.go:502 +0x41
runtime.systemstack(0xc820039e58)
    /private/var/folders/9y/ppk2fnqj5lscwqw_l6lhdrx8005bt1/T/appengine/go_appengine/goroot/src/runtime/asm_amd64.s:307 +0xab
runtime.(*mheap).alloc(0x3aa0c0, 0x1, 0x10000000020, 0xf11f)
    /private/var/folders/9y/ppk2fnqj5lscwqw_l6lhdrx8005bt1/T/appengine/go_appengine/goroot/src/runtime/mheap.go:503 +0x63
runtime.(*mcentral).grow(0x3ac190, 0x0)
    /private/var/folders/9y/ppk2fnqj5lscwqw_l6lhdrx8005bt1/T/appengine/go_appengine/goroot/src/runtime/mcentral.go:209 +0x93
runtime.(*mcentral).cacheSpan(0x3ac190, 0x8a5178)
    /private/var/folders/9y/ppk2fnqj5lscwqw_l6lhdrx8005bt1/T/appengine/go_appengine/goroot/src/runtime/mcentral.go:89 +0x47d
runtime.(*mcache).refill(0x406c20, 0x20, 0x8a5178)
    /private/var/folders/9y/ppk2fnqj5lscwqw_l6lhdrx8005bt1/T/appengine/go_appengine/goroot/src/runtime/mcache.go:119 +0xcc
runtime.mallocgc.func2()
    /private/var/folders/9y/ppk2fnqj5lscwqw_l6lhdrx8005bt1/T/appengine/go_appengine/goroot/src/runtime/malloc.go:642 +0x2b
runtime.systemstack(0xc820012000)
    /private/var/folders/9y/ppk2fnqj5lscwqw_l6lhdrx8005bt1/T/appengine/go_appengine/goroot/src/runtime/asm_amd64.s:291 +0x79
runtime.mstart()
    /private/var/folders/9y/ppk2fnqj5lscwqw_l6lhdrx8005bt1/T/appengine/go_appengine/goroot/src/runtime/proc.go:1051

goroutine 1 [running]:
runtime.systemstack_switch()
    /private/var/folders/9y/ppk2fnqj5lscwqw_l6lhdrx8005bt1/T/appengine/go_appengine/goroot/src/runtime/asm_amd64.s:245 fp=0xc8200329d0 sp=0xc8200329c8
runtime.mallocgc(0x480, 0x25c640, 0xc800000000, 0xc820074240)
    /private/var/folders/9y/ppk2fnqj5lscwqw_l6lhdrx8005bt1/T/appengine/go_appengine/goroot/src/runtime/malloc.go:643 +0x869 fp=0xc820032aa8 sp=0xc8200329d0
runtime.newarray(0x25c640, 0x18, 0x152be8)
    /private/var/folders/9y/ppk2fnqj5lscwqw_l6lhdrx8005bt1/T/appengine/go_appengine/goroot/src/runtime/malloc.go:798 +0xc9 fp=0xc820032ae8 sp=0xc820032aa8
runtime.makeslice(0x1e6920, 0x18, 0x18, 0x0, 0x0, 0x0)
    /private/var/folders/9y/ppk2fnqj5lscwqw_l6lhdrx8005bt1/T/appengine/go_appengine/goroot/src/runtime/slice.go:32 +0x165 fp=0xc820032b38 sp=0xc820032ae8
cmd/link/internal/ld.readsym(0xc820074240, 0xc825a9e1a0, 0xc821107850, 0x8, 0xc821ecb360, 0x4c)
    /private/var/folders/9y/ppk2fnqj5lscwqw_l6lhdrx8005bt1/T/appengine/go_appengine/goroot/src/cmd/link/internal/ld/objfile.go:239 +0xba6 fp=0xc820032f80 sp=0xc820032b38
cmd/link/internal/ld.ldobjfile(0xc820074240, 0xc825a9e1a0, 0xc821107850, 0x8, 0xbf902, 0xc821ecb360, 0x4c)
    /private/var/folders/9y/ppk2fnqj5lscwqw_l6lhdrx8005bt1/T/appengine/go_appengine/goroot/src/cmd/link/internal/ld/objfile.go:147 +0xa62 fp=0xc820033190 sp=0xc820032f80
cmd/link/internal/ld.ldobj(0xc825a9e1a0, 0xc821107850, 0x8, 0xbf93e, 0xc821ecb360, 0x4c, 0xc82326a050, 0x44, 0x1, 0x0)
    /private/var/folders/9y/ppk2fnqj5lscwqw_l6lhdrx8005bt1/T/appengine/go_appengine/goroot/src/cmd/link/internal/ld/lib.go:1351 +0x1569 fp=0xc820033400 sp=0xc820033190
cmd/link/internal/ld.objfile(0xc82409ce70)
    /private/var/folders/9y/ppk2fnqj5lscwqw_l6lhdrx8005bt1/T/appengine/go_appengine/goroot/src/cmd/link/internal/ld/lib.go:847 +0x10d9 fp=0xc820033710 sp=0xc820033400
cmd/link/internal/ld.loadlib()
    /private/var/folders/9y/ppk2fnqj5lscwqw_l6lhdrx8005bt1/T/appengine/go_appengine/goroot/src/cmd/link/internal/ld/lib.go:513 +0x5ce fp=0xc8200339f0 sp=0xc820033710
cmd/link/internal/ld.Ldmain()
    /private/var/folders/9y/ppk2fnqj5lscwqw_l6lhdrx8005bt1/T/appengine/go_appengine/goroot/src/cmd/link/internal/ld/pobj.go:214 +0x1cd3 fp=0xc820033e70 sp=0xc8200339f0
cmd/link/internal/amd64.Main()
    /private/var/folders/9y/ppk2fnqj5lscwqw_l6lhdrx8005bt1/T/appengine/go_appengine/goroot/src/cmd/link/internal/amd64/obj.go:44 +0x19 fp=0xc820033e78 sp=0xc820033e70
main.main()
    /private/var/folders/9y/ppk2fnqj5lscwqw_l6lhdrx8005bt1/T/appengine/go_appengine/goroot/src/cmd/link/main.go:27 +0x36f fp=0xc820033f50 sp=0xc820033e78
runtime.main()
    /private/var/folders/9y/ppk2fnqj5lscwqw_l6lhdrx8005bt1/T/appengine/go_appengine/goroot/src/runtime/proc.go:188 +0x2b0 fp=0xc820033fa0 sp=0xc820033f50
runtime.goexit()
    /private/var/folders/9y/ppk2fnqj5lscwqw_l6lhdrx8005bt1/T/appengine/go_appengine/goroot/src/runtime/asm_amd64.s:1998 +0x1 fp=0xc820033fa8 sp=0xc820033fa0

"
36993047,"The problem isn't in your Python, because the Go program gets the same error without being called from Python. In your main func, you are creating a slice called v, starting from argument position 1, so excluding the name of the program:

for i := 1; i < len(args); i++ {
    f,_ := strconv.Atoi(os.Args[i])
    v = append(v, f)
}


But then you're giving mergesort the length of args, not the length of v, so it's an off-by-one error as it's been told v has 1 more element than it actually does. Down the line the program tries to access an element of v that's beyond the end of the slice:

mergesort(v, 0, len(args) - 1)


Try mergesort(v, 0, len(v) - 1) in your main function, instead.
"
7314110,"The Moustachio example application for GAE by Andrew Gerrand contains a resize.go file with a native Go implementation. There was also a similar question on the go-nuts mailing list some days ago and Nigel has posted an updated version of this file there. You might want to try it :)
"
29190369,"The program stops receiving on the channels when a difference is detected. 

The walk goroutines run until they block sending to the channels. They never exit. This is the leak.
"
21217369,"The problem was dundundun I had old cookies stored from before the change that had the Path ""/api/1.0/user"" and apparently this caused a problem since, I imagine, the longer or deeper path has priority over the shorter, root path, which makes perfect sense in retrospect.
"
21726804,"Ok, the problem was not with the code, but has something to do with http://golang.org/ and they way they execute web code. Locally it did seem to be faster to use the string constants:

> go run bench_string_constant_golang.go

My StringMy StringMy StringMy StringMy StringMy StringMy StringMy StringMy Strin
gMy StringMy StringMy StringMy StringMy StringMy StringMy StringMy StringMy Stri
ngMy StringMy StringMy StringMy StringMy StringMy StringMy StringMy StringMy Str
ingMy StringMy StringMy StringMy StringMy StringMy StringMy StringMy StringMy St
ringMy StringMy StringMy StringMy StringMy StringMy StringMy StringMy StringMy S
tringMy StringMy StringMy StringMy StringMy StringMy StringMy StringMy StringMy
StringMy StringMy StringMy StringMy StringMy StringMy StringMy StringMy StringMy
 StringMy StringMy StringMy StringMy StringMy StringMy StringMy StringMy StringM
y StringMy StringMy StringMy StringMy StringMy StringMy StringMy StringMy String
My StringMy StringMy StringMy StringMy StringMy StringMy StringMy StringMy Strin
gMy StringMy StringMy StringMy StringMy StringMy StringMy StringMy StringMy Stri
ngMy StringMy String2014/02/12 12:07:21
Took 1.6400938s

My String 2My String 2My String 2My String 2My String 2My String 2My String 2My
String 2My String 2My String 2My String 2My String 2My String 2My String 2My Str
ing 2My String 2My String 2My String 2My String 2My String 2My String 2My String
 2My String 2My String 2My String 2My String 2My String 2My String 2My String 2M
y String 2My String 2My String 2My String 2My String 2My String 2My String 2My S
tring 2My String 2My String 2My String 2My String 2My String 2My String 2My Stri
ng 2My String 2My String 2My String 2My String 2My String 2My String 2My String
2My String 2My String 2My String 2My String 2My String 2My String 2My String 2My
 String 2My String 2My String 2My String 2My String 2My String 2My String 2My St
ring 2My String 2My String 2My String 2My String 2My String 2My String 2My Strin
g 2My String 2My String 2My String 2My String 2My String 2My String 2My String 2
My String 2My String 2My String 2My String 2My String 2My String 2My String 2My
String 2My String 2My String 2My String 2My String 2My String 2My String 2My Str
ing 2My String 2My String 2My String 2My String 2My String 22014/02/12 12:07:23
Took 1.6220928s

2014/02/12 12:07:23
Took 100.0057ms

"
26030710,"You need to account for the number of bytes returned from ReadAt, otherwise the last fileBuffer you send will have extra garbage bytes.

Example:

n, err := file.ReadAt(fileBuffer, currentByte)
connection.Write(fileBuffer[:n])


Also bytes.Trim(fileBuffer, ""\x00"") will destroy almost any binary file since usually they use null bytes to fill space.

Also the proper way of doing this is just using io.Copy:

file, err := os.Open(strings.TrimSpace(fileName)) // For read access.
if err != nil {
    log.Fatal(err)
}
defer file.Close() // make sure to close the file even if we panic.
n, err = io.Copy(connection, file)
if err != nil {
    log.Fatal(err)
}
fmt.Println(n, ""bytes sent"")

"
44687426,"I have an application running on a server which takes requests from a phone app and then load balances the request across worker servers. I'm trying to add a timeout in the case that messages on the main server that have been in the outbound queue for the length of the timeout are removed from the queue. More specifically, the application on the main server is written in golang and implements the Paranoid Pirate Pattern of load balancing. The code I currently have is:

import (
    ""fmt""
    zmq ""github.com/pebbe/zmq4""
    ""time""
)

const (
    HEARTBEAT_LIVENESS = 3
    HEARTBEAT_INTERVAL = 1500 * time.Millisecond

    MESSAGE_READY     = ""\001""
    MESSAGE_HEARTBEAT = ""\002""
)

var (
    client *zmq.Socket
    backend *zmq.Socket
    frontend *zmq.Socket
    workerPoller *zmq.Poller
    brokerPoller *zmq.Poller
    workerQueue []Worker
)

type Worker struct {
    Id string
    Expire time.Time
}

type RequestWrapper {
    RequestToSend Request

}

func NewWorker(id string) Worker {
    return Worker{
        Id: id,
        Expire: time.Now().Add(HEARTBEAT_INTERVAL * HEARTBEAT_LIVENESS),
    }
}

func AddReadyWorker(workers []Worker, worker Worker) []Worker {
    fmt.Println(worker.Id, "" joined"")
    for i, w := range workers {
        if worker.Id == w.Id {
            if i == 0 {
                workers = workers[1:]
            } else if i == len(workers)-1 {
                workers = workers[:i]
            } else {
                workers = append(workers[:i], workers[i+1:]...)
            }
            break
        }
    }
    return append(workers, worker)
}

func PurgeInactiveWorkers() {
    now := time.Now()
    for i, worker := range workerQueue {
        if now.Before(worker.Expire) {
            workerQueue = workerQueue[i:]
            return
        }
    }

    workerQueue = workerQueue[0:0]
}

func LoadBalance() {
// Loop:
    heartbeat := time.Tick(HEARTBEAT_INTERVAL)
    for {
        var sockets []zmq.Polled

        // If you have available workers, poll on the both front and backend
        // If not poll on backend with infinite timeout
        if len(workerQueue) > 0 {
            sockets, _ = brokerPoller.Poll(HEARTBEAT_INTERVAL)
        } else {
            sockets, _ = workerPoller.Poll(HEARTBEAT_INTERVAL)
        }

        for _, socket := range sockets {
            switch socket.Socket {
                // backend is a router
                case backend:
                    workerId, _ := backend.Recv(0)
                    workerQueue = AddReadyWorker(workerQueue, NewWorker(workerId))
                    clientId, _ := backend.Recv(0)
                    if clientId != MESSAGE_READY && clientId != MESSAGE_HEARTBEAT {
                        route, _ := backend.Recv(0)
                        message, _ := backend.RecvBytes(0)

                        fmt.Println(""Received response"")
                        RouteResponse(route, message)

                        // frontend.Send(clientId, zmq.SNDMORE)
                        // frontend.Send("""", zmq.SNDMORE)
                        // frontend.SendBytes(message, 0)
                    }
                // frontend is a dealer
                case frontend:
                    clientId, _ := frontend.Recv(0)
                    route, _ := frontend.Recv(0)
                    message, _ := frontend.RecvBytes(0)

                    backend.Send(workerQueue[0].Id, zmq.SNDMORE)
                    backend.Send(clientId, zmq.SNDMORE)
                    backend.Send(route, zmq.SNDMORE)
                    backend.SendBytes(message, 0)

                    workerQueue = workerQueue[1:]
            }
        }

        select {
            case <-heartbeat:
                for _, worker := range workerQueue {
                    backend.Send(worker.Id, zmq.SNDMORE)
                    backend.Send(MESSAGE_HEARTBEAT, 0)
                }
                break
            default:
        }

        PurgeInactiveWorkers()
    }
}


If the backend sends a message, but it is not actually sent to a worker in some period of time, I want it to expire and not ever be sent. Is there a socket option that can accomplish this? If not, what would I have to do to accomplish this?

Two ways I think I can do this without socket options are:

1) Have the backend wrap the message in a wrapper and send to a golang queue and not through zeromq. The wrapper contains the time that the message was ""sent"". The backend concurrently pulls from the front of the golang queue one at a time and checks if the message is expired. If so, don't send, if not, send the message. I could have the backend add the message to the golang queue first and then truly send it out after in the same block of code. That way, I don't need a lock.

2) Send the wrapper message through zeromq to a retriever and the retriever checks if its expired and returns early. I don't like this because it seems like its bad for performance.
"
40386521,"From Bulk imports part in https://godoc.org/github.com/lib/pq, it should be

stmt.Exec(contact.First_name, contact.Last_name, contact.Email)

"
36992800,"Just overingeneering in loop condition. Try

for lineNumber := 0; lineNumber <= LongestSlice(stuff)-1; lineNumber++ {


in outer loop in func joinStrings. See it works https://play.golang.org/p/eR4JJtY4T1
"
43670872,"I'm using the Gin Gonic framework to create a reverse proxy endpoint, with the target endpoint being served using grpc Gateway using the code given below. This is similar to the reverse proxy methodology suggested for gin here and here

ep1 := v1.Group(""/ep1"")
{
    ep1.GET(""/ep2"", reverseProxy(""http://localhost:50000""))
}

func reverseProxy(target string) gin.HandlerFunc {
    url, err := url.Parse(target)
    if err != nil {
        log.Println(""Reverse Proxy target url could not be parsed:"", err)
        return nil
    }
    proxy := httputil.NewSingleHostReverseProxy(url)
    return func(c *gin.Context) {
        proxy.ServeHTTP(c.Writer, c.Request)
    }
}


However, when on actually sending a request to this gin endpoint (/ep1/ep2) a go panic is seen:

interface conversion: *http.timeoutWriter is not http.CloseNotifier: missing method CloseNotify
/usr/local/Cellar/go/1.8/libexec/src/runtime/panic.go:489 (0x10288df)
    gopanic: reflectcall(nil, unsafe.Pointer(d.fn), deferArgs(d), uint32(d.siz), uint32(d.siz))
/usr/local/Cellar/go/1.8/libexec/src/runtime/iface.go:131 (0x100c3af)
    additab: panic(&TypeAssertionError{"""", typ.string(), inter.typ.string(), iname})
/usr/local/Cellar/go/1.8/libexec/src/runtime/iface.go:79 (0x100bc34)
    getitab: additab(m, true, canfail)
/usr/local/Cellar/go/1.8/libexec/src/runtime/iface.go:256 (0x100cbb8)
    assertI2I: r.tab = getitab(inter, tab._type, false)
/path/to/vendor/github.com/gin-gonic/gin/response_writer.go:110 (0x14de6f3)
    (*responseWriter).CloseNotify: return w.ResponseWriter.(http.CloseNotifier).CloseNotify()
/usr/local/Cellar/go/1.8/libexec/src/net/http/httputil/reverseproxy.go:142 (0x14d4d12)
    (*ReverseProxy).ServeHTTP: notifyChan := cn.CloseNotify()
/path/to/main.go:379 (0x16d2ead)
    reverseProxy.func1: proxy.ServeHTTP(c.Writer, c.Request)
/path/to/vendor/github.com/gin-gonic/gin/context.go:97 (0x14d657a)
    (*Context).Next: c.handlers[c.index](c)
/path/to/middlewares/locale.go:12 (0x15737d9)
    getLocaleMiddleware.func1: c.Next()
/path/to/vendor/github.com/gin-gonic/gin/context.go:97 (0x14d657a)
    (*Context).Next: c.handlers[c.index](c)
/path/to/middlewares/session_cookie.go:27 (0x1574e7c)
    getSessionCookieMiddleware.func1: c.Next()
/path/to/vendor/github.com/gin-gonic/gin/context.go:97 (0x14d657a)
    (*Context).Next: c.handlers[c.index](c)
/path/to/middlewares/affiliate_api.go:27 (0x15729a1)
    getAffiliateAPIMiddleware.func1: c.Next()
/path/to/vendor/github.com/gin-gonic/gin/context.go:97 (0x14d657a)
    (*Context).Next: c.handlers[c.index](c)
/path/to/middlewares/metrics.go:17 (0x157465b)
    getMetricsMiddleware.func1: c.Next()
/path/to/vendor/github.com/gin-gonic/gin/context.go:97 (0x14d657a)
    (*Context).Next: c.handlers[c.index](c)
/path/to/middlewares/input_validations.go:75 (0x1572dcb)
    getInputValidationMiddleware.func1: c.Next()
/path/to/vendor/github.com/gin-gonic/gin/context.go:97 (0x14d657a)
    (*Context).Next: c.handlers[c.index](c)
/path/to/middlewares/logger.go:68 (0x1573aea)
    LoggerWithWriter.func1: c.Next()
/path/to/vendor/github.com/gin-gonic/gin/context.go:97 (0x14d657a)
    (*Context).Next: c.handlers[c.index](c)
/path/to/middlewares/request_tracer.go:13 (0x1574d6c)
    getTracerContext.func1: c.Next()
/path/to/vendor/github.com/gin-gonic/gin/context.go:97 (0x14d657a)
    (*Context).Next: c.handlers[c.index](c)
/path/to/vendor/github.com/gin-gonic/gin/recovery.go:45 (0x14e4b6a)
    RecoveryWithWriter.func1: c.Next()
/path/to/vendor/github.com/gin-gonic/gin/context.go:97 (0x14d657a)
    (*Context).Next: c.handlers[c.index](c)
/path/to/vendor/github.com/gin-gonic/gin/gin.go:284 (0x14dc710)
    (*Engine).handleHTTPRequest: context.Next()
/path/to/vendor/github.com/gin-gonic/gin/gin.go:265 (0x14dc02b)
    (*Engine).ServeHTTP: engine.handleHTTPRequest(c)
/usr/local/Cellar/go/1.8/libexec/src/net/http/server.go:2967 (0x140fa53)
    (*timeoutHandler).ServeHTTP.func1: h.handler.ServeHTTP(tw, r)
/usr/local/Cellar/go/1.8/libexec/src/runtime/asm_amd64.s:2197 (0x1054851)


Any ideas on why this might be happening or what's wrong in the code?
"
8272760,"I want to write three concurrent go routines that sends integers to each other. Now, my code is compiled properly, however after first execution it gives error ""throw: all goroutines are asleep - deadlock!"". I tried to find the error but I could not able to find any error in code logic.Can anybody help me to find the mistake with my code. My code is given below. 

package main

import ""rand""

func Routine1(command12 chan int, response12 chan int, command13 chan int, response13 chan int) {

    // z12 is a variable which stores the value comming from channel 2 and z13 is a variable which stores the value comming from channel 3.

    z12 := 200
    z13 := 200
    m12 := false
    m13 := false
    y := 0

    for i := 0; i < 20; i++ {
        y = rand.Intn(100)

        // If y's value is not 0 then the value will be sent to routine 2 or 3 according to   prime or not.
        // If y's value is 0 then process state (the varibles used by it means z12, z13) and channel state will be saved.[routine 1 is initiator]

        if y == 0 {
            print(z12, ""    z12 STATE SAVED\n"")
            print(z13, ""    z13 STATE SAVED\n"")

            // Routine 1 is initiator,  it sends 0 to make other process to save the state.

            y = 0
            command12 <- y
            command13 <- y

            // Untill routine 2 and 3 does not send 0, process 1 is on channel saving state (it's process state is already saved).
            // When routine 1 recives 0 from both other processes, channel is saved and routine 1 retuns to it's common routine procedure.
            // When routine 1 recives 0 from any other processes, saving channel bettwen them is stopped.
            // m12, m13 is used to mark whether 0 recived or not.

            for m12 != true || m13 != true {
                select {
                case cmd1 := <-response12:
                    {
                        z12 = cmd1
                        if z12 != 0 {
                            print(z12, ""    z12  Channel Saving.... \n"")
                            y = rand.Intn(100)
                            command12 <- y
                        }
                        if z12 == 0 {
                            m12 = true
                            print("" z12  Channel Saving Stopped \n"")
                        }
                    }

                case cmd2 := <-response13:
                    {
                        z13 = cmd2
                        if z13 != 0 {
                            print(z13, ""    z13  Channel Saving.... \n"")
                            y = rand.Intn(100)
                            command13 <- y
                        }
                        if z13 == 0 {
                            m13 = true
                            print(""    z13  Channel Saving Stopped \n"")
                        }
                    }
                }

            }

            // After saving process state it retuns to it's normal behaviour.

            m12 = false
            m13 = false
        }

        if y != 0 {

            // If y value is not 0, routine 1 just sends int to other process according to prime or not and recives int accordingly.

            if y%2 == 0 {
                command12 <- y
            }

            if y%2 != 0 {
                command13 <- y
            }
            select {
            case cmd1 := <-response12:
                {
                    z12 = cmd1
                    print(z12, ""    z12\n"")
                }
            case cmd2 := <-response13:
                {
                    z13 = cmd2
                    print(z13, ""   z13\n"")
                }
            }
        }
    }
    close(command12)
    close(command13)
}


//Routine 2 (or 3) is not an initiator (means it can't send 0). When it recives 0 (from routine 1 or 3) it save the state of process and the state of the channel from which it recived).
// When it recives 0 from both other two routine, it saves all channel state and returns to it's common behaviour. [same in routine 3]

func Routine2(command12 chan int, response12 chan int, command23 chan int, response23 chan int) {
    z21 := 200
    z23 := 200
    m21 := false
    m23 := false

    for i := 0; i < 20; i++ {
        select {
        case x, open := <-command12:
            {
                if !open {
                    return
                }
                if x != 0 && m23 != true {
                    z21 = x
                    print(z21, ""   z21\n"")
                }
                if x != 0 && m23 == true {
                    z21 = x
                    print(z21, ""   z21 Channel Saving \n"")
                }
                if x == 0 {
                    m21 = true
                    if m21 == true && m23 == true {
                        print("" z21 and z23 Channel Saving Stopped \n"")
                        m23 = false
                        m21 = false
                    }
                    if m21 == true && m23 != true {
                        z21 = x
                        print(z21, ""   z21  Channel Saved \n"")

                    }

                }
            }

        case x, open := <-response23:
            {
                if !open {
                    return
                }
                if x != 0 && m21 != true {
                    z23 = x
                    print(z23, ""   z21\n"")
                }
                if x != 0 && m21 == true {
                    z23 = x
                    print(z23, ""   z23 Channel Saving \n"")
                }
                if x == 0 {
                    m23 = true
                    if m21 == true && m23 == true {
                        print("" z23 Channel Saving Stopped \n"")
                        m23 = false
                        m21 = false
                    }
                    if m23 == true && m21 != true {
                        z23 = x
                        print(z23, ""   z23  Channel Saved \n"")
                    }

                }
            }
        }

        if m23 == false && m21 == false {
            y := rand.Intn(100)
            if y%2 == 0 {
                if y == 0 {
                    y = 10
                    response12 <- y
                }
            }

            if y%2 != 0 {
                if y == 0 {
                    y = 10
                    response23 <- y
                }
            }
        }

        if m23 == true && m21 != true {
            y := rand.Intn(100)
            response12 <- y
        }

        if m23 != true && m21 == true {
            y := rand.Intn(100)
            command23 <- y
        }

    }
    close(response12)
    close(command23)
}

func Routine3(command13 chan int, response13 chan int, command23 chan int, response23 chan int) {
    z31 := 200
    z32 := 200
    m31 := false
    m32 := false

    for i := 0; i < 20; i++ {
        select {
        case x, open := <-command13:
            {
                if !open {
                    return
                }
                if x != 0 && m32 != true {
                    z31 = x
                    print(z31, ""   z21\n"")
                }
                if x != 0 && m32 == true {
                    z31 = x
                    print(z31, ""   z31 Channel Saving \n"")
                }
                if x == 0 {
                    m31 = true
                    if m31 == true && m32 == true {
                        print("" z21 Channel Saving Stopped \n"")
                        m31 = false
                        m32 = false
                    }
                    if m31 == true && m32 != true {
                        z31 = x
                        print(z31, ""   z31  Channel Saved \n"")

                    }

                }
            }

        case x, open := <-command23:
            {
                if !open {
                    return
                }
                if x != 0 && m31 != true {
                    z32 = x
                    print(z32, ""   z32\n"")
                }
                if x != 0 && m31 == true {
                    z32 = x
                    print(z32, ""   z32 Channel Saving \n"")
                }
                if x == 0 {
                    m32 = true
                    if m31 == true && m32 == true {
                        print("" z32 Channel Saving Stopped \n"")
                        m31 = false
                        m32 = false
                    }
                    if m32 == true && m31 != true {
                        z32 = x
                        print(z32, ""   z32  Channel Saved \n"")

                    }

                }
            }
        }
        if m31 == false && m32 == false {
            y := rand.Intn(100)
            if y%2 == 0 {
                response13 <- y
            }

            if y%2 != 0 {
                response23 <- y
            }
        }

        if m31 == true && m32 != true {
            y := rand.Intn(100)
            response13 <- y
        }

        if m31 != true && m32 == true {
            y := rand.Intn(100)
            response23 <- y
        }

    }
    close(response13)
    close(response23)
}


func main() {

    // Three concurrent channels are created to pass integers to each other.
    // command 12 used to send int and response12 is used to receive int from routine 1 to routine 2.
    // response 12 used to send int and command 12 is used to receive int from routine 2 to routine 1. {so as for others}

    command12 := make(chan int)
    response12 := make(chan int)
    command13 := make(chan int)
    response13 := make(chan int)
    command23 := make(chan int)
    response23 := make(chan int)

    go Routine1(command12, response12, command13, response13)
    go Routine2(command12, response12, command23, response23)
    Routine3(command13, response13, command23, response23)
}

"
39059763,"From Go net/http documentation:


  For control over proxies, TLS configuration, keep-alives, compression, and other settings, create a Transport:


tr := &http.Transport{
    TLSClientConfig:    &tls.Config{...},
    DisableCompression: true,
}
client := &http.Client{Transport: tr}


From the appengine documentation it appears you can use the net/http package as usual with a few tweaks.
"
40395692,"io.Copy(&buf, nc) on Go side will continue to read from the connection's input stream until it's closed. On Java side, you try to read from the connection's input stream, but Go side is still waiting for further input, since Java is still keeping its output steam (Go's input stream) open.

Solution: on Java side, close the output stream using the socket's shutdownOutput() method after you are done writing to it.
"
37478116,"Benchmarks are hard to get right, and it's easy to think you're measuring one thing (cost of goroutines/threads) when you're measuring something else. I think that's what's happening here.

For example, the inner loop in the threads/goroutines aren't the same in the two programs. Rewriting the goroutine to be more like the java code:

for j := 0; j != 10*1000*1000; j++ {}
chanSignal <- true


results in a 2x speedup for the go.

That still leaves a significant performance gap when I run it on my machine -- the go code takes 663ms with 1000 goroutines, and the java code 55ms with 1000 threads. Perhaps what's happening is that the JVM is JITting away the useless loop in the run method of the thread after it's been executed a few times.

Here's some evidence that the cost of goroutines aren't relevant. Just executing the code serially gives a runtime of 2.55 seconds on my machine:

package main

import (
    ""fmt""
    ""time""
)

func main() {
    goroutineNum := 1000
    startTime := time.Now()
    for i := 0; i < goroutineNum; i++ {
        for j := 0; j < 1000*1000*10; j++ {
        }
    }
    fmt.Println(time.Since(startTime))
}


The goroutine-based version of this code, on 4 processors, runs in 663ms, which is only slightly more than one quarter of the 2.55 seconds the serial code takes (on my machine). So this is really quite efficient parallelism, and the cost of the goroutines is negligible.

So mostly I think you're benchmarking how efficiently java and go execute empty loops. It looks like this is a perfect use-case for JIT, and you're seeing that in the excellent run-time performance of the Java code.
"
37502451,"The problem is that Go interprets your literal value as an int. But, it does not really fit into 32 bits, so it fails. However, you can set the value of a big.Int after its creation:

PublicKey.N = big.NewInt(0)
PublicKey.N.SetBytes([]byte(""8162962977631249175163884403387595004235353952981629629776312491751638844033875950042353539529""))
fmt.Println(N)
// 8162962977631249175163884403387595004235353952981629629776312491751638844033875950042353539529

"
41956295,"The net/http occurs when there is a large amount of http.Get() requests from client side. To avoid the TLS handshake timeout error, 

t := &http.Transport{
            Dial: (&net.Dialer{
                    Timeout: 60 * time.Second,
                    KeepAlive: 30 * time.Second,
            }).Dial,
            // We use ABSURDLY large keys, and should probably not.
            TLSHandshakeTimeout: 60 * time.Second,
    }
    c := &http.Client{
            Transport: t,
    }
    resp, err := c.Get(""https://internal.lan/"")


Found it here
"
30485586,"Thanks for answer,
I added example @qwertmax and fixed bug for parse fragment of url. Please update package and see example.

package main
// Thanks @qwertmax for this example
// (http://stackoverflow.com/questions/29359907/social-network-vk-auth-with-martini)


import (
    ""log""
    ""github.com/go-martini/martini""
    ""github.com/yanple/vk_api""
    ""net/http""
)

var api vk_api.Api

func prepareMartini() *martini.ClassicMartini {
    m := martini.Classic()

    m.Get(""/vk/auth"", func(w http.ResponseWriter, r *http.Request) {
        authUrl, err := api.GetAuthUrl(
        ""http://localhost:3000/vk/token"",
        ""app client id"",
        ""wall,offline"")

        if err != nil {
            panic(err)
        }

        http.Redirect(w, r, authUrl, http.StatusFound)
    })

    m.Get(""/vk/token"", func(w http.ResponseWriter, r *http.Request) {
        code := r.URL.Query().Get(""code"")

        err := api.OAuth(
        ""http://localhost:3000/vk/token"", // redirect uri
        ""app secret key"",
        ""app client id"",
        code)
        if err != nil {
            panic(err)
        }
        http.Redirect(w, r, ""/"", http.StatusFound)
    })

    m.Get(""/"", func(w http.ResponseWriter, r *http.Request) string {
        if api.AccessToken == """" {
            return ""Авторизоваться""
        }

        // Api have: AccessToken, UserId, ExpiresIn
        log.Println(""[LOG] martini.go:48 ->"", api.AccessToken)

        // Make query
        params := make(map[string]string)
        params[""domain""] = ""yanple""
        params[""count""] = ""1""

        strResp, err := api.Request(""wall.get"", params)
        if err != nil {
            panic(err)
        }
        return strResp
    })
    return m
}

func main() {
    prepareMartini().Run()
}


Update 1:
  Update your package with command: go get -u github.com/yanple/vk_api
  Thanks for the comment.
"
25756628,"A reminder that security is unusually treacherous territory, and if there's a way to call on other well-tested code even more of your toplevel task than just what Go's OpenPGP package is handling for you, consider it. It's good that at least low-level details are outsourced to openpgp because they're nasty and so so easy to get wrong. But tiny mistakes at any level can make crypto features worse than useless; if there's a way to write less security-critical code, that's one of the best things anyone can do for security.

On the specific question: you have to Close() the writer to get everything flushed out (a trait OpenPGP's writer shares with, say, compress/gzip's). 

Unrelated changes: the way you're printing things is a better fit log.Println, which just lets you pass a bunch of values you want printed with spaces in between (like, say, Python print), rather than needing format specifiers like ""%s"" or ""%d"". (The ""EXTRA"" in your initial output is what Go's Printf emits when you pass more things than you had format specifiers for.) It's also best practice to check errors (I dropped if err != nils where I saw a need, but inelegantly and without much thought, and I may not have gotten all the calls) and to run go fmt on your code. 

Again, I can't testify to the seaworthiness of this code or anything like that. But now it round-trips all the text. I wound up with:

package main

import (
    ""bytes""
    ""code.google.com/p/go.crypto/openpgp""
    ""encoding/base64""
    ""io/ioutil""
    ""log""
    ""os""
)

// create gpg keys with
// $ gpg --gen-key
// ensure you correct paths and passphrase

const mysecretstring = ""this is so very secret!""
const prefix, passphrase = ""/Users/stuart-warren/"", ""1234""
const secretKeyring = prefix + "".gnupg/secring.gpg""
const publicKeyring = prefix + "".gnupg/pubring.gpg""

func encTest() error {
    log.Println(""Secret:"", mysecretstring)
    log.Println(""Secret Keyring:"", secretKeyring)
    log.Println(""Public Keyring:"", publicKeyring)
    log.Println(""Passphrase:"", passphrase)

    // Read in public key
    keyringFileBuffer, _ := os.Open(publicKeyring)
    defer keyringFileBuffer.Close()
    entitylist, err := openpgp.ReadKeyRing(keyringFileBuffer)
    if err != nil {
        return err
    }

    // encrypt string
    buf := new(bytes.Buffer)
    w, err := openpgp.Encrypt(buf, entitylist, nil, nil, nil)
    if err != nil {
        return err
    }
    _, err = w.Write([]byte(mysecretstring))
    if err != nil {
        return err
    }
    err = w.Close()
    if err != nil {
        return err
    }

    // Encode to base64
    bytesp, err := ioutil.ReadAll(buf)
    if err != nil {
        return err
    }
    encstr := base64.StdEncoding.EncodeToString(bytesp)

    // Output encrypted/encoded string
    log.Println(""Encrypted Secret:"", encstr)

    // Here is where I would transfer the encrypted string to someone else
    // but we'll just decrypt it in the same code

    // init some vars
    var entity2 *openpgp.Entity
    var entitylist2 openpgp.EntityList

    // Open the private key file
    keyringFileBuffer2, err := os.Open(secretKeyring)
    if err != nil {
        return err
    }
    defer keyringFileBuffer2.Close()
    entitylist2, err = openpgp.ReadKeyRing(keyringFileBuffer2)
    if err != nil {
        return err
    }
    entity2 = entitylist2[0]

    // Get the passphrase and read the private key.
    // Have not touched the encrypted string yet
    passphrasebyte := []byte(passphrase)
    log.Println(""Decrypting private key using passphrase"")
    entity2.PrivateKey.Decrypt(passphrasebyte)
    for _, subkey := range entity2.Subkeys {
        subkey.PrivateKey.Decrypt(passphrasebyte)
    }
    log.Println(""Finished decrypting private key using passphrase"")

    // Decode the base64 string
    dec, err := base64.StdEncoding.DecodeString(encstr)
    if err != nil {
        return err
    }

    // Decrypt it with the contents of the private key
    md, err := openpgp.ReadMessage(bytes.NewBuffer(dec), entitylist2, nil, nil)
    if err != nil {
        return err
    }
    bytess, err := ioutil.ReadAll(md.UnverifiedBody)
    if err != nil {
        return err
    }
    decstr := string(bytess)

    // should be done
    log.Println(""Decrypted Secret:"", decstr)

    return nil
}

func main() {
    err := encTest()
    if err != nil {
        log.Fatal(err)
    }
}

"
27691957,"I am new to Go and I am trying to setup a simple graph database using Cayley with BoltDB as the backend datastore. Right now I am trying to run cayley from the command line. Running this command:

cayley http --db=""bolt""


Generates this error:

panic: runtime error: invalid memory address or nil pointer dereference
[signal 0xb code=0x1 addr=0x8 pc=0x2517e7]

goroutine 16 [running]:
runtime.panic(0x6ae9e0, 0xbc1f44)
    /usr/local/go/src/pkg/runtime/panic.c:279 +0xf5
github.com/boltdb/bolt.(*Bucket).Get(0x0, 0xc208000b68, 0x4, 0x8, 0x0, 0x0, 0x0)
    /Users/tbrown/Development/src/github.com/boltdb/bolt/bucket.go:256 +0x57
github.com/google/cayley/graph/bolt.(*QuadStore).getInt64ForKey(0xc20800eff0, 0xc208028270,     0x750ac0, 0x4, 0x0, 0xc20800e0b8, 0x0, 0x0)
    /Users/tbrown/Development/src/github.com/google/cayley/graph/bolt/quadstore.go:437 +0xd9
github.com/google/cayley/graph/bolt.func·009(0xc208028270, 0x0, 0x0)
    /Users/tbrown/Development/src/github.com/google/cayley/graph/bolt/quadstore.go:452 +0x76
github.com/boltdb/bolt.(*DB).View(0xc20807e180, 0xc2080a9a90, 0x0, 0x0)
    /Users/tbrown/Development/src/github.com/boltdb/bolt/db.go:490 +0xe4
github.com/google/cayley/graph/bolt.(*QuadStore).getMetadata(0xc20800eff0, 0x0, 0x0)
    /Users/tbrown/Development/src/github.com/google/cayley/graph/bolt/quadstore.go:458 +0x5a
github.com/google/cayley/graph/bolt.newQuadStore(0x75be50, 0xb, 0x0, 0x0, 0x0, 0x0, 0x0)
    /Users/tbrown/Development/src/github.com/google/cayley/graph/bolt/quadstore.go:91 +0x226
github.com/google/cayley/graph.NewQuadStore(0x7fff5fbff2b1, 0x4, 0x75be50, 0xb, 0x0, 0x0, 0x0, 0x0, 0x0)
    /Users/tbrown/Development/src/github.com/google/cayley/graph/quadstore.go:174 +0x21b
github.com/google/cayley/db.OpenQuadStore(0xc208048180, 0x0, 0x0, 0x0, 0x0)
    /Users/tbrown/Development/src/github.com/google/cayley/db/db.go:53 +0x176
github.com/google/cayley/db.Open(0xc208048180, 0x4, 0x0, 0x0)
    /Users/tbrown/Development/src/github.com/google/cayley/db/db.go:40 +0x3f
main.main()
    /Users/tbrown/Development/src/database_comparison/cayley/src/cayley/cayley.go:234 +0x77e

goroutine 19 [finalizer wait]:
runtime.park(0x17a40, 0xbc8118, 0xbc63a9)
    /usr/local/go/src/pkg/runtime/proc.c:1369 +0x89
runtime.parkunlock(0xbc8118, 0xbc63a9)
    /usr/local/go/src/pkg/runtime/proc.c:1385 +0x3b
runfinq()
    /usr/local/go/src/pkg/runtime/mgc0.c:2644 +0xcf
runtime.goexit()
    /usr/local/go/src/pkg/runtime/proc.c:1445

goroutine 20 [chan receive]:
github.com/barakmich/glog.(*loggingT).flushDaemon(0xbcb000)
    /Users/tbrown/Development/src/github.com/barakmich/glog/glog.go:923 +0x75
created by github.com/barakmich/glog.init·1
    /Users/tbrown/Development/src/github.com/barakmich/glog/glog.go:408 +0x37a

goroutine 17 [syscall]:
runtime.goexit()
    /usr/local/go/src/pkg/runtime/proc.c:1445

goroutine 22 [syscall]:
os/signal.loop()
    /usr/local/go/src/pkg/os/signal/signal_unix.go:21 +0x1e
created by os/signal.init·1
    /usr/local/go/src/pkg/os/signal/signal_unix.go:27 +0x32


I feel like I am missing a step somewhere but I can't find any good documentation on using Cayley with Bolt. Any suggestions?
"
37573985,"I have a go program which connects to a tcp server and publishes that message to web service. the application works fine in the first go and it panics after a week or so. I am not sure why. the stack trace isn't helpful either.
(I cross compile from mac os to linux; env GOOS=linux GOARCH=386  go build)
could some one give pointers on what might be the issue?

the tcp server connection might go off once in a while; I have build the reconnection logic by hand. 
the error condition would be applicable to posting as well. the internet connection might break at any time; so ""dns"" resolver which go uses by default ""cgo"" was panicking. I had recompile with the ""netgo"" to use pure go network implementation.

Stack trace

net.runtime_pollWait(0xf75c12d8, 0x72, 0x18690000)
    /usr/local/go/src/runtime/netpoll.go:157 +0x55 net.(*pollDesc).Wait(0x18a6bb38, 0x72, 0x0, 0x0)/usr/local/go/src/net/fd_poll_runtime.go:73 +0x35
    net.(*pollDesc).WaitRead(0x18a6bb38, 0x0, 0x0) _poll_runtime.go:78 +0x33
    net.(*netFD).Read(0x18a6bb00, 0x18cd6000, 0x1000, 0x1000, 0x0, 0xf75bc018, 0x18690000)/usr/local/go/src/net/fd_unix.go:232 +0x19anet.(*conn).Read(0x18cd4d78, 0x18cd6000, 0x1000, 0x1000, 0x0, 0x0, 0x0)
    /usr/local/go/src/net/net.go:172 +0xb9
    net/http.noteEOFReader.Read(0xf75fc018, 0x18cd4d78, 0x1889770c, 0x18cd6000, 0x1000, 0x1000, 0x2c3620, 0x0, 0x0)
    /usr/local/go/src/net/http/transport.go:1370 +0x55
    net/http.(*noteEOFReader).Read(0x18cd29e0, 0x18cd6000, 0x1000, 0x1000, 0x8056f0c, 0x0, 0x0)
    :126 +0xae
    bufio.(*Reader).fill(0x1881b7d0)
    /usr/local/go/src/bufio/bufio.go:97 +0x172
    bufio.(*Reader).Peek(0x1881b7d0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0)
    /usr/local/go/src/bufio/bufio.go:132 +0xad
    net/http.(*persistConn).readLoop(0x188976e0)
    /usr/local/go/src/net/http/transport.go:876 +0xe3
    created by net/http.(*Transport).dialConn
    /usr/local/go/src/net/http/transport.go:685 +0xabc


GO program go program

  package main

 import (
  ""bufio""
  ""bytes""
  ""encoding/json""
  ""flag""
  ""fmt""
  ""net""
  ""net/http""
  ""time""
  )

  var (
    server             = flag.String(""deamon"", ""127.0.0.1:7070"", ""AMQP URI"")
    msgRoutingKey      = flag.String(""routingKey"", ""routingKey"", "" routing key"")
    msgexchange        = flag.String(""exchange"", ""exchange"", "" excahnge "")
    mywebserviceServer = flag.String(""mywebservice-server"", ""127.0.0.1:8080"",      ""mywebserviceServer:port "")
  )

   func init() {

     flag.Parse()
   }

   type TcpConnector struct {
    Outbound      chan string
    Inbound       chan string
    Addr          string
    ReconnectTime time.Duration
   }

type Message struct {
  RoutingKey string `json:""routingKey""`
  Exchange   string `json:""exchange""`
  Data       string `json:""data""`
}

func main() {
  start := time.Now()
  tcpClient := NewTcpConnector(*server)
  elapsed := time.Since(start)
  fmt.Println(""the connecting params are  %s"", *server, *msgexchange, *msgRoutingKey, *mywebserviceServer)
  fmt.Println(""connecting to daemon took %s"", elapsed)
   go func() {
    for msg := range tcpClient.Inbound {
        fmt.Println(msg)
        rabbitMessage := Message{
            RoutingKey: *msgRoutingKey,
            Exchange:   *msgexchange,
            Data:       msg,
        }
        mywebserviceMessageEndpoint :=    fmt.Sprintf(""http://%s/v1/messages/publish"", *mywebserviceServer)
        doPut(mywebserviceMessageEndpoint, &rabbitMessage)

      }
    }()

   select {}
 }

func doPut(url string, rabbitMessage *Message) {
 start := time.Now()
 b, err := json.Marshal(rabbitMessage)
 client := &http.Client{}
 request, err := http.NewRequest(""PUT"", url, bytes.NewBuffer(b))
 request.Header.Add(""Content-Type"", ""application/json"")
 request.Header.Add(""accept"", ""application/json"")
 response, err := client.Do(request)
 if err != nil {
    fmt.Println(err)
 } else {
    defer response.Body.Close()
    fmt.Println(""   "", response.StatusCode)
    hdr := response.Header
    for key, value := range hdr {
        fmt.Println(""   "", key, "":"", value)
    }

 }

 elapsed := time.Since(start)
 fmt.Println(""posting to mywebservice took %s"", elapsed)

}

func NewTcpConnector(addr string) *TcpConnector {
 tcpConnector := &TcpConnector{
    Addr:          addr,
    Outbound:      make(chan string, 100),
    Inbound:       make(chan string, 100),
    ReconnectTime: 30 * time.Second,
 }
 tcpConnector.connect()
 return tcpConnector
}

//keep connect private, will be in trouble if got called twice
func (tcpConnector *TcpConnector) connect() {
 conn, err := net.Dial(""tcp"", tcpConnector.Addr)
 if err != nil {
    fmt.Println(""Failed to make a connection"", err)
    time.Sleep(tcpConnector.ReconnectTime)
    tcpConnector.connect()
    return
 }

go func() {
    for msg := range tcpConnector.Outbound {

        _, err = fmt.Fprintf(conn, msg+""\n"")
        if err != nil {
            fmt.Println(""Failed sending event"", err)
            time.Sleep(tcpConnector.ReconnectTime)
            tcpConnector.connect()
            break
        }

    }
}()
go func() {
    reader := bufio.NewReaderSize(conn, 1024*1024)
    for {
        message, err := reader.ReadBytes('\n')
        if err != nil {
            break
        }
        fmt.Println(""Message Received: %s"", message)
        tcpConnector.Inbound <- string(message)
        fmt.Println(""Message sent to chan"")
    }

    fmt.Println(""reconnecting..."")
    tcpConnector.connect()
}()
fmt.Println(""Connected tcp"")
}

"
32005076,"Ok. First off, I don't believe you that the code compiles.

Let's look at some mistakes, shall we?

db, err := sql.Open(""mysql"", ""dbconnectinfo"")


This line opens a database connection. It should only be used once, preferably inside an init() function. For example,

var db *sql.DB

func init() {
    var err error

    // Now the db variable above is automagically set to the left value (db)
    // of sql.Open and the ""var err error"" above is the right value (err)
    db, err = sql.Open(""mysql"", ""root@tcp(127.0.0.1:3306)"")
    if err != nil {
        panic(err)
    }
}


Bang. Now you're connected to your MySQL database.

Now what?

Well this (from Get) is gross:

db, err := sql.Query(""mysql"", ""db:connectinfo"")
    errCheck(err)

    var sdi = new(SimpleDiscoveredInfo)
    err = db.QueryRow(""SELECT opendpoint, oplocalid, claimedid FROM discovery_cache WHERE id=?"", id).Scan(&sdi)
    errCheck(err)


Instead, it should be this:

// No need for a pointer...
var sdi SimpleDiscoveredInfo

// Because we take the address of 'sdi' right here (inside Scan)
// And that's a useless (and potentially problematic) layer of indirection.
// Notice how I dropped the other ""db, err := sql.Query"" part? We don't
// need it because we've already declared ""db"" as you saw in the first
// part of my answer.
err := db.QueryRow(""SELECT ..."").Scan(&sdi)
if err != nil {
    panic(err)
}

// Return the address of sdi, which means we're returning a pointer
// do wherever sdi is inside the heap.
return &sdi


Up next is this:

  /*
       db, err := sql.Query(""mysql"", ""db:connectinfo"")
         errCheck(err)
         rows, err := db.Query(""SELECT opendpoint, oplocalid, claimedid FROM discovery_cache"")
         errCheck(err)

       was unsure what to do here because I'm not sure how to 
       return the info properly 
    */


If you've been paying attention, we can drop the first sql.Query line.

Great, now we just have:

rows, err := db.Query(""SELECT ..."")

So, why don't you do what you did inside the Accept method and parse the rows using for rows.Next()... ?
"
29245641,"First, as has been commented, are you sure you can't use
the go/build package directly rather than running go list?

I Wouldn't use println (or fmt.Println) inside HTTP handlers. It's much better to use log.Println and/or get the error into the ResponseWriter. Also, it's a good idea to wrap your ListenAndServe call with log.Fatal.

When printing/logging error values you can just use err, no need to have err.Error().

Further, when you actually want to do something more detailed than just reporting/logging the error message you can look at it's type and other info. For example, log.Printf(""verbose error info: %#v"", err) gives:

&json.SyntaxError{msg:""invalid character ',' looking for beginning of value"", Offset:0}


I tried this because I know the json package returns various error types with additional info and I was hoping the offset value would be of help. If it had been then something like this might have been helpful:

if err := json.Compact(…) {
    if err != nil {
        log.Println(""json.Compact:"", err)
        if serr, ok := err.(*json.SyntaxError); ok {
            log.Println(""Occurred at offset:"", serr.Offset)
            // … something to show the data in buff around that offset …
        }
    }
}


But offset zero isn't helpful :(

So although this doesn't identify you problem hopefully
it can be of some help to your further investigation.

Edit:

So after adding:

log.Println(""Write file:"", ioutil.WriteFile(""data.json"", buff.Bytes(), 0600))


to the above error handling block I then ran a JSON validator on the resultant file and it identified this piece:

        ""XTestImports"": [
                ""io"",
                ""log"",
                ""net""
        ]
},,{
        ""Dir"": ""/usr/local/go/src/mime"",
        ""ImportPath"": ""mime"",
        ""Name"": ""mime"",


Note the double ,,.

That should tell you whete the error in your code is.
But if not, you need to skip empty entries, either when processing t.J or when you build it. The later is better and just involves:

    if len(newj) > 0 {
        myObj.J = append(myObj.J, newj)
    }


(where btw you don't check for errors from json.Unmarshal so it's not clear if that is supposed to ever be empty or if it's empty due to a preceeding error. Never ignore error returns!)
"
15693797,"Call Elem() on your reflect.Value object.

Quoting from The Laws of Reflection article:


  To get to what p points to, we call the Elem method of Value, which indirects through the pointer

"
29831469,"I have just recently started faffing with golang.
I taught myself php & jquery pretty easily & by creating a project to do so.

I am trying the same atm to teach myself golang, but I have gotten to a point
now which either im missing the point or just searching incorrectly.

....

Ok so what I am trying to do is make a IRC bot.
The one function listens to channel chatter & if certain commands are picked up
it then will add relevant information to a sqlite3 database.

The problem is that one of the commands queries the database & will return multiple rows, which then need to be passed back to the original function & outputted into the IRC channel.

Where I am getting stuck is returning the queries output to the original function since it is multiple rows of data

Im importing the below libraries
fmt
net/textproto
regexp
strings
os
database/sql
_ github.com/mattn/go-sqlite3

func getLineup() {
    // Open Database
    db, err := sql.Open(""sqlite3"", ""./database.db"")
    if err != nil {
            fmt.Println(err)
            os.Exit(1)
    }
    defer db.Close()

    // Prepare Query
    statement, err := db.Prepare(""SELECT team, player FROM lineup ORDER BY team DESC;"")
    if err != nil {
            fmt.Println(err)
            os.Exit(1)
    }

    // Execute Statement
    rows, err := statement.Query()
    defer rows.Close()


    fmt.Println(""Lineup:"")

    for rows.Next() {
            var team string
            var player string
            rows.Scan(&team, &player)
            fmt.Printf(""%v %v\n"", team, player)
    }

}


So I can print it, but I need to pass it to another function which is where im lost

================================UPDATE====================================

Ok so here is my full code...
@evanmcdonnal With the updated code you gave above I now get the error

bot.go:70: cannot use p (type Player) as type *Player in append


package main

import (
    ""fmt""
    ""net/textproto""
    ""regexp""
    ""log""
    ""strings""
    ""database/sql""
    // SQLite3
    _ ""github.com/mattn/go-sqlite3""
)


type PrivMsg struct {
    nick, channel, text string
}

var (
    conn *textproto.Conn
    err  error

    ping    = regexp.MustCompile(""^PING :([a-zA-Z0-9\\.]+)$"")
    motd    = regexp.MustCompile("":End of /MOTD command\\.$"")
    privmsg = regexp.MustCompile(""^:([a-zA-Z0-9`_\\-]+)![a-zA-Z0-9/\\\\\\.\\-]+@[a-zA-Z0-9/\\\\\\.\\-]+ PRIVMSG (#[a-zA-Z0-9]+) :(.*)$"")
)


func talk(channel, msg string) {
    conn.Cmd(""PRIVMSG "" + channel + "" :"" + msg)
}


func handlePing(auth string) {
    conn.Cmd(""PONG :"" + auth)
    fmt.Printf(""PONG :%s\n"", auth)
}

type Player struct {
    TeamName string
    PlayerName string
}

func getLineup() {
    // Open Database
    db, err := sql.Open(""sqlite3"", ""./database.db"")
    if err != nil {
        log.Fatal(err)
    }

    // Prepare Query
    statement, err := db.Prepare(""SELECT team, player FROM lineup ORDER BY team DESC;"")
    if err != nil {
        log.Fatal(err)
    }

    // Execute Statement
    rows, err := statement.Query()
    defer rows.Close()


// Output Code
    var Players []*Player
    for rows.Next() {
        p := &Player{}
        if err := rows.Scan(p.TeamName, p.PlayerName); err != nil{
            log.Fatal(err)
        }
        //Players = append(Players, p)
        return p.TeamName, p.PlayerName
    }
    // pass Players to next function/return it whatever

    fmt.Println(Players)
}




func handlePrivmsg(pm *PrivMsg) {
    if strings.Contains(pm.text, ""!add t"") {
        talk(pm.channel, pm.nick + "" added to Terrorists"")
        saveLineup(""T"", pm.nick)
    }
    if strings.Contains(pm.text, ""!add ct"") {
        talk(pm.channel, pm.nick + "" added to Counter-Terrorists"")
        saveLineup(""CT"", pm.nick)
    }
    if strings.Contains(pm.text, ""!rem"") {
        talk(pm.channel, pm.nick + "" has been removed from the current lineup"")
    }
    if strings.Contains(pm.text, ""!votemap"") {
        talk(pm.channel, pm.nick + "" map vote code"")
    }
    if strings.Contains(pm.text, ""!moveme"") {
        talk(pm.channel, pm.nick + "" has been moved to Counter-Terrorists"")
    }
    if strings.Contains(pm.text, ""!teams"") {
        getLineup()
        //fmt.Println(*tpList)
        talk(pm.channel, pm.nick + "" will show the current teams"")
    }
    if strings.Contains(pm.text, ""!add ct"") {
        talk(pm.channel, pm.nick + "" added to Counter-Terrorists"")
    }
    if strings.Contains(pm.text, ""pug-bot"") {
        talk(pm.channel, ""Hello, "" + pm.nick + ""!"")
    }
}


func saveLineup(Team, Player string) {

    // Open Database
    db, err := sql.Open(""sqlite3"", ""./database.db"")
    if err != nil {
        //log.Fatal(err)
        fmt.Printf(""%s"", err)
    }

    // Get Current Lineup
    rows, err := db.Query(""SELECT team, player FROM lineup WHERE player = ?;"", Player)
    if err != nil {
        log.Fatal(err)
    }
    defer rows.Close()

    if Player == Player {
        fmt.Println(""You have already added yourself"")
    } else {
        // Insert new Player
        db.Exec(
            ""INSERT INTO lineup (team, player) VALUES (?, ?);"",
            Team,
            Player,
        )
    }

}


func handleMotd() {
    conn.Cmd(""JOIN #ircchannel"")
    fmt.Println(""JOIN #ircchannel"")
}


func parseLine(line string) {
    // Channel activity
    if match := privmsg.FindStringSubmatch(line); match != nil {
        pm := new(PrivMsg)
        pm.nick, pm.channel, pm.text = match[1], match[2], match[3]
        handlePrivmsg(pm)
        return
    }

    // Server PING
    if match := ping.FindStringSubmatch(line); match != nil {
        handlePing(match[1])
        return
    }

    // End of MOTD (successful login to IRC server)
    if match := motd.FindString(line); match != """" {
        handleMotd()
        return
    }
}

func main() {
    conn, err = textproto.Dial(""tcp"", ""irc.server.org:6667"")
    if err != nil {
        fmt.Printf(""%s"", err)
        return
    }

    conn.Cmd(""NICK pug-bot\n\rUSER pug-bot 8 * :pAsSwOrD"")

    for {
        text, err := conn.ReadLine()
        if err != nil {
            fmt.Printf(""%s"", err)
            return
        }

        go parseLine(text)

        fmt.Println(text)
    }


}


Essentially I would like to pass the result of the sql query back into the talk(pm.channel, pm.nick + "" SQL QUERY RESULT"") irc talk section
"
40195990,"First of all I would like to discuss the ""impossible"" part.

import ""fmt""

type Animal interface {
    Say() string
}

type Cat struct {}

func (cat Cat) Say() string {
    return ""miao""
}

type Sheep struct {}

func (sheep Sheep) Say() string {
    return ""bahh""
}

type Cow struct {}

func (cow Cow) Say() string {
    return ""moo""
}

func main() {

    cat := Cat{}
    sheep := Sheep{}
    cow := Cow{}

    fmt.Println(cat.Say())
    fmt.Println(sheep.Say())
    fmt.Println(cow.Say())
}


This will work exactly as you would expect. So there is a polymorphism in terms of ""different structs responding differently to same method"".

The intention of Exhibit#1 demonstrates that what Go does is actually similar to Java castings before @Overrides.

Just add the following method to the first example and see how that will work:

func (this B) strange() {
    fmt.Printf(""my string is %q\n"", this.str())
}

"
42786222,"Crypto is hard and the go libraries are perhaps not high level enough so it's easy to make mistakes. 

For anyone looking for an example of doing it right by an expert in the field (a security developer at CoreOS), this gives a good example of AES encryption (along with other common uses of crypto). 

https://github.com/gtank/cryptopasta
"
37386558,"you missed the declaration of  c_ccB in your c code. add extern char* c_ccB(char*); to you p.c please.

And, you forget to free the memory allocated for CString in c_ccB.
"
26267135,"I fixed it.  The issue was a lack of knowledge of bash config files.  I found the details on the SublimeLinter page for troubleshooting custom linters.

http://www.sublimelinter.com/en/latest/troubleshooting.html#special-considerations-for-bash

Turning on Debug, I saw that the expanded PATH that the SublimeLinter was using did not include any of my custom PATH settings.

Short answer:


move all of your GO variables to a .bash_profile file
move all of your PATH variables to that same .bash_profile file
add a line to your .bashrc file to execute the .bash_profile file for interactive terminals


(Longer answer below, for Linux users)

When starting a terminal, this is an ""interactive"" bash shell.  bash reads the .bashrc file only, which I had setup correctly.  I did not have a .bash_profile as my .bashrc worked fine for interactive shells with all of my settings.

But from within SublimeLinter, this loads a ""login"" bash shell - that is not interactive.  On Linux, this only loads the .bash_profile file - not the .bashrc file.

The fix:


Add this to the top of your .bashrc file: 

source ~/.bash_profile
Move your GO variables and PATH changes (and FYI, ALL OTHER path entries you've modified in this .bashrc file) to a new .bash_profile file.  Make sure to remove them from .bashrc.


Done.  Close Sublime and reopen.  The path is now picked up properly.

This works because the source ~/.bash_profile file is read on every interactive terminal you open, cause the .bashrc file is used there.  But for login only sessions, such as the one from SublimeLinter, only the .bash_profile is used - your .bashrc is not executed.

So, you want to specify your custom GO variables (GOROOT, GOPATH, etc) in your .bash_profile only, not in the .bashrc.  But, in order to read this .bash_profile file from interactive shells (e.g. terminals), you have to execute that .bash_profile.  We do this with the first line to add at the top of your .bashrc file: source ~/.bash_profile.  This runs the profile script that sucks in your custom GO variables, as well as all of your custom PATH variables.

(for OSX) See the first link above in this comment.

You can read more about bash files here: http://www.joshstaiger.org/archives/2005/07/bash_profile_vs.html
"
20888190,"Here is the working demo i just finished writing, it mostly uses code samples from the go document but it is tailored to do what most apps including my use case expects out of encryption methods.

It use AES encryption.
encrypt from string to base64 string. Easy to use on URL and dbs.
decrypt from base64 string created above to original text.

Simple text conversions everywhere.

GIST: Here is the gist, please let me know if there are any need for the improvements.

It's a simple go file, ready to be run.
"
41113388,"I am trying to communicate with a USB device (cottonwood RFID reader) with golang under Linux.

Here is where I am so far:


My computer sees the hardware: I see the device in my /dev/bus/usb
The hardware works fine: the demo software they provide works seemlessly (under windows, they don't have a Linux version)
It seems I can open the endpoints
It seems I can write to the device


Now, when I try to read from thehardware, I always get a timeout. I'm a total beginner on hardware, any help would be greatly appreciated, maybe the issue is actually very basic.

My very simple codebase is here: 

package main

import (
    ""fmt""
    ""log""
    ""strconv""

    ""github.com/jpoirier/gousb/usb""
)

func main() {
    // Only one context should be needed for an application.  It should always be closed.
    ctx := usb.NewContext()
    defer func() {
        errCl := ctx.Close()
        if errCl != nil {
            log.Fatal(errCl)
        }
    }()

    ctx.Debug(1)

    // ListDevices is used to find the devices to open.
    devs, err := ctx.ListDevices(
        func(desc *usb.Descriptor) bool {
            if desc.Vendor == GetCottonwoodVendor() && desc.Product == GetCottonwoodProduct() {
                return true
            }
            return false
        })

    // All Devices returned from ListDevices must be closed.
    defer func() {
        for _, dev := range devs {
            errCl := dev.Close()
            if errCl != nil {
                log.Fatal(errCl)
            }
        }
    }()

    // ListDevices can occasionally  fail, so be sure to check its return value.
    if err != nil {
        log.Fatalf(""list: %s"", err)
    }

for _, dev := range devs {
    // Once the device has been selected from ListDevices, it is opened
    // and can be interacted with.
    // Open up two ep for read and write

    epBulkWrite, err := dev.OpenEndpoint(1, 0, 0, 2|uint8(usb.ENDPOINT_DIR_OUT))
    if err != nil {
        log.Fatalf(""OpenEndpoint Write error for %v: %v"", dev.Address, err)
    }

    // Poll Firmware/Hardware Version ID

    // AntennaOn
    // outAntennaPowerOnCmd := []byte{0x18, 0x03, 0xFF}
    outFirmIdCmd := []byte{0x10, 0x03, 0x00}
    // outHardIdCmd := []byte{0x10, 0x03, 0x01}

    i, err := epBulkWrite.Write(outFirmIdCmd)
    if err != nil {
        log.Fatalf(""Cannot write command: %v\n"", err)
    }
    log.Printf(""%v bytes sent"", i)

    time.Sleep(1 * time.Second)

    epBulkRead, err := dev.OpenEndpoint(1, 0, 0, 1|uint8(usb.ENDPOINT_DIR_IN))
    if err != nil {
        log.Fatalf(""OpenEndpoint Read error for %v: %v"", dev.Address, err)
    }

    readBuffer := make([]byte, 64)
    n, errRead := epBulkRead.Read(readBuffer)
    log.Printf(""read %d bytes: %v"", n, readBuffer)
    if errRead != nil {
        log.Printf(""error reading: %v"", errRead)
        break
    }
}

// GetCottonwoodVendor returns the vendor ID of cottonwood UHF reader
func GetCottonwoodVendor() usb.ID {
    value, err := strconv.ParseUint(""1325"", 16, 16)
    if err != nil {
        log.Fatal(err)
    }
    return usb.ID(value)
}

// GetCottonwoodProduct returns the product ID of cottonwood UHF reader
func GetCottonwoodProduct() usb.ID {
    value, err := strconv.ParseUint(""c029"", 16, 16)
    if err != nil {
        log.Fatal(err)
    }
    return usb.ID(value)
}


First time I launch it, I get:

2016/12/14 19:19:18 3 bytes sent
2016/12/14 19:19:20 read 0 bytes: [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]
2016/12/14 19:19:20 error reading: libusb: timeout [code -7]


Second time and all after:

2016/12/14 19:21:21 Cannot write command: libusb: timeout [code -7]


I tried with another library using hidraw, but it seems not to work either (probably detach usb device issue).
"
41186742,"According to the error message, the error is on this line:

local res = redis.call(""HMSET"", KEYS[1], unpack(a))


The issue is that the application is passing two arguments to the script, the key and argv converted to a string. The call unpack(a) yields a single value.

The fix is to pass each argument separately to the script:

reply, errS := rScript.Do(retryConn,
   ""JJNb324a680c35d11e6a1123c15c2d271f21481871788G"",
   ""30000"",
   ""SSF_lastAccessedDate"", ""1481627386"",
   ""SSF_expiryDate"", ""2481657386"")


I recommend initializing a package level variable with the script so the hash of the script text is computed once instead of on every use of the script:

var rScript = redis.NewScript(1, `if redis.call(""EXISTS"", KEYS[1]) == 1 then
    local keyvalues = redis.call(""HGETALL"", KEYS[1])
    local a = {}
    for i=2, table.getn(ARGV) do
      a[i-1] = ARGV[i]
    end
    local res = redis.call(""HMSET"", KEYS[1], unpack(a))
    redis.call(""EXPIRE"", KEYS[1], ARGV[1])  
    return keyvalues
else
    return 2 -- ""Key doesn't exists""
end`)


and use this script in main():

func main() {
  ...
  reply, errS := rScript.Do(retryConn,
   ""JJNb324a680c35d11e6a1123c15c2d271f21481871788G"",
   ""30000"",
   ""SSF_lastAccessedDate"", ""1481627386"",
   ""SSF_expiryDate"", ""2481657386"")

  ...
}


Also, use table.remove to simplify the script:

var rScript = redis.NewScript(1, `if redis.call(""EXISTS"", KEYS[1]) == 1 then
    local keyvalues = redis.call(""HGETALL"", KEYS[1])
    local expires = table.remove(ARGV, 1)
    local res = redis.call(""HMSET"", KEYS[1], unpack(ARGV))
    redis.call(""EXPIRE"", KEYS[1], expires)  
    return keyvalues
else
    return 2 -- ""Key doesn't exists""
end`)


Use redis.Strings to convert the slice of []byte returned from the server to a slice of strings:

  reply, errS := redis.Strings(rScript.Do(retryConn,
   ""JJNb324a680c35d11e6a1123c15c2d271f21481871788G"",
   ""30000"",
   ""SSF_lastAccessedDate"", ""1481627386"",
   ""SSF_expiryDate"", ""2481657386""))


Printing this reply will give the result you are expecting.
"
25687264,"The problem is that you're ignoring the err object. resp is probably nil because of this error, which causes a panic when you try to access resp.StatusCode. I'm not sure what's the point with doesFileExist, but try this : 

func httpGET(url string) {
    log.Println(""httpGet is runnning"")

    resp, err := httpClient.Get(url)

    if err != nil || resp.StatusCode != 200 && !doesFileExist(""down"") {
        isDown()
    } else if resp.StatusCode == 200 && doesFileExist(""down"") {
        log.Println(""200 response"")
        sendmail(""up"")
        removeDownFile()
    }
}

"
39396083,"According to current database/sql docs, the sql has four builtin functions that returns driver.Value, and the underlying types are int64, float64, string and bool. So I guess that's the only four types supported.

I just changed the underlying type of my enum from int to int64 and things are working.

The problematic section is updated to the following snippet:

// Platform Type enumeration
type PlatformType int64
const (
    PLATFORM_TYPE_NOT_A_VALUE PlatformType = iota
    PLATFORM_TYPE_TYPE1
    PLATFORM_TYPE_TYPE2 
)

var types = [...]string {
    ""Not a type"",
    ""Type1"",
    ""Type2"",
}

func (platform_type PlatformType) String() string {
    return types[platform_type]
}

func (u *PlatformType) Scan(value interface{}) error { *u = PlatformType(value.(int64)); return nil }
func (u PlatformType) Value() (driver.Value, error)  { return int64(u), nil }

"
35443781,"I am trying to implement a multithreaded crawler using a go lang as a sample task to learn the language.

It supposed to scan pages, follow links and save them do DB.

To avoid duplicates I'm trying to use map where I save all the URLs I've already saved.

The synchronous version works fine, but I have troubles when I'm trying to use goroutines.

I'm trying to use mutex as a sync object for map, and channel as a way to coordinate goroutines. But obviously I don't have clear understanding of them. 

The problem is that I have many duplicate entries, so my map store/check does not work properly.

Here is my code:

package main

import (
    ""fmt""
    ""net/http""
    ""golang.org/x/net/html""
    ""strings""
    ""database/sql""
    _ ""github.com/ziutek/mymysql/godrv""
    ""io/ioutil""
    ""runtime/debug""
    ""sync""
)

const maxDepth = 2;

var workers = make(chan bool)

type Pages struct {
    mu sync.Mutex
    pagesMap map[string]bool
}

func main() {
    var pagesMutex Pages
    fmt.Println(""Start"")
    const database = ""gotest""
    const user = ""root""
    const password = ""123""

    //open connection to DB
    con, err := sql.Open(""mymysql"", database + ""/"" + user + ""/"" + password)
    if err != nil { /* error handling */
        fmt.Printf(""%s"", err)
        debug.PrintStack()
    }

    fmt.Println(""call 1st save site"")
    pagesMutex.pagesMap = make(map[string]bool)
    go pagesMutex.saveSite(con, ""http://golang.org/"", 0)

    fmt.Println(""saving true to channel"")
    workers <- true

    fmt.Println(""finishing in main"")
    defer con.Close()
}


func (p *Pages) saveSite(con *sql.DB, url string, depth int) {
    fmt.Println(""Save "", url, depth)
    fmt.Println(""trying to lock"")
    p.mu.Lock()
    fmt.Println(""locked on mutex"")
    pageDownloaded := p.pagesMap[url] == true
    if pageDownloaded {
        p.mu.Unlock()
        return
    } else {
        p.pagesMap[url] = true
    }
    p.mu.Unlock()

    response, err := http.Get(url)
    if err != nil {
        fmt.Printf(""%s"", err)
        debug.PrintStack()
    } else {
        defer response.Body.Close()

        contents, err := ioutil.ReadAll(response.Body)
        if err != nil {
            if err != nil {
                fmt.Printf(""%s"", err)
                debug.PrintStack()
            }
        }

        _, err = con.Exec(""insert into pages (url) values (?)"", string(url))
        if err != nil {
            fmt.Printf(""%s"", err)
            debug.PrintStack()
        }
        z := html.NewTokenizer(strings.NewReader((string(contents))))

        for {
            tokenType := z.Next()
            if tokenType == html.ErrorToken {
                return
            }

            token := z.Token()
            switch tokenType {
            case html.StartTagToken: // 

                tagName := token.Data
                if strings.Compare(string(tagName), ""a"") == 0 {
                    for _, attr := range token.Attr {
                        if strings.Compare(attr.Key, ""href"") == 0 {
                            if depth < maxDepth  {
                                urlNew := attr.Val
                                if !strings.HasPrefix(urlNew, ""http"")  {
                                    if strings.HasPrefix(urlNew, ""/"")  {
                                        urlNew = urlNew[1:]
                                    }
                                    urlNew = url + urlNew
                                }
                                //urlNew = path.Clean(urlNew)
                                go  p.saveSite(con, urlNew, depth + 1)

                            }
                        }
                    }

                }
            case html.TextToken: // text between start and end tag
            case html.EndTagToken: // 
            case html.SelfClosingTagToken: // 

            }

        }

    }
    val := <-workers
    fmt.Println(""finished Save Site"", val)
}


Could someone explain to me how to do this properly, please?
"
44496638,"As AniSkywalker and putu have mentioned in the comments, you could impliment encoding.TextUnmarshaler.

However I think in your case since you need to use Priority as a json map key, it's much easier to just use Priority as a type string.

type Priority string

const (
    VERYLOW = ""verylow""
    LOW = ""low""
    MEDIUM = ""medium""
    HIGH = ""high""
    VERYHIGH = ""veryhigh"" )


This way you can discard the use of the following as well.

const (
    verylow  = ""verylow""
    low      = ""low""
    medium   = ""medium""
    high     = ""high""
    veryhigh = ""veryhigh""
)

"
40413641,"If you look at the heroku buildpack for Go (https://github.com/heroku/heroku-buildpack-go/blob/master/bin/compile), it does not currently support GoDeps, as traditional GoDeps style dependency management has been deprecated as Go v1.6.  You can convert your GoDeps dependencies to a vendored dependency and that should fix that.

I personally recommend using glide: https://github.com/Masterminds/glide

But you can also use:

https://github.com/kardianos/govendor

or

https://github.com/constabulary/gb

As those are supported in the compile script for the buildpack.

Each of those support an automated conversion of GoDeps to their formats.

If you have ./vendor/vendor.json Heroku will automatically use govendor, unless you configure Heroku to use something otherwise.

This page may help as well https://elements.heroku.com/buildpacks/heroku/heroku-buildpack-go

It does support Godep, technically, but it would seem you have to either use an older version of Go or move GoDeps to vendor.
"
28767991,"EDIT:

You mentioned in the comment that you use MariaDB (not MySQL).

See MariaDB Tutorial: DATA TYPES:


  VARBINARY(size) - Maximum size of 255 characters. - Where size is the number of characters to store. Variable-length string.


varbinary length is limited to 255 characters... Also it is in section STRING DATATYPES. This means MariaDB handles varbinary as a string...

This may very well explain the value you see: after about 255 bytes it contains just 0 values and nothing else, most likely because only 255 bytes come from the database and the rest is just filled with the zero-value of byte (which is 0).



A string in Go is stored as a byte array and interpreted using UTF-8 encoding.

A string may contain any byte sequence, but not all byte sequences represent valid UTF-8 encoded text.

So if you use Data to store arbitrary seuqence of bytes, you can't always display or treat it as a text. Just because printing the result of string(Data) conversion displays only 16 characters it doesn't mean Data contains only 16 bytes (or the bytes of 16 characters).

You can check it by printing its length:

fmt.Println(len(charData.Data))


Read this blog post to learn more about the topic:

Strings, bytes, runes and characters in Go

Edit:

You mentioned you use MySQL. What version?

MySQL version 5.0.2 and below only allows 255 bytes in varbinary, version 5.0.3 and above allows 64 KB. If the data inserted does not fit into the max (or defined) length, it is truncated.

Also please see MySQL 5.6 Reference Manual :: Section 11 Data Types :: 11.7 Data Type Storage Requirements:


  The internal representation of a table has a maximum row size of 65,535 bytes, even if the storage engine is capable of supporting larger rows.


So if you (obviously) have other values in the row, they also have to fit into the row limit (which is 64 KB). Note that this is MySQL 5.6.
"
16797428,"Don't use sync/atomic - from the linked page


  Package atomic provides low-level atomic memory primitives useful for
  implementing synchronization algorithms.
  These functions require great care to be used correctly. Except for
  special, low-level applications, synchronization is better done with
  channels or the facilities of the sync package


Last time I had to do this I benchmarked something which looked like your second example with a mutex and something which looked like your third example with a channel.  The channels code won when things got really busy, but make sure you make the channel buffer big.
"
11363216,"I've had the exact same problem for a while now and I've been looking into it every time I worked off the frustration of the last attempt. Compiling 32-bit glfw for go was no problem but the 64 bit version eluded me. 

Today, after reading kneo's comment I tried his solution but couldn't get it to work. But it lead me to looking at libglfwdll.a which had the @nn stdcall suffixes while libglfw.a didn't have them. Trying various LDFLAGS (-Wl,--kill-at, -Wl,--enable-stdcall-fixup) didn't yield successful results, I studied http://www.willus.com/mingw/yongweiwu_stdcall.html but couldn't get it to work. 

I was about to give up when I when I decided to see if there was a new version of glfw (2.7.6) with the following bugfix:

[Win32] Bugfix: A .def file using __stdcall naming conventions was used for the 64-bit DLL on MinGW-w64


so long story short, compiling the new glfw version and installing it fixed the issue and go get github.com/jteeuwen/glfw now works without any problem.
"
16280362,"According to the docs for func (*Client) Do:


  ""An error is returned if caused by client policy (such as CheckRedirect), or if there was an HTTP protocol error. A non-2xx response doesn't cause an error.
  
  When err is nil, resp always contains a non-nil resp.Body.""


Then looking at this code:

res, err := client.Do(req)
defer res.Body.Close()

if err != nil {
    return nil, err
}


I'm guessing that err is not nil. You're accessing the .Close() method on res.Body before you check for the err.

The defer only defers the function call. The field and method are accessed immediately.



So instead, try checking the error immediately.

res, err := client.Do(req)

if err != nil {
    return nil, err
}
defer res.Body.Close()

"
44000340,"Execute insert, update, query and delete sequentially in for loop for 500,000 times, ""too many connections"" occurs after running for ten seconds even I set max connection of MySQL to 10,000. When running 'show processlist', the number of sleep status connections quickly raise up to around 10,000. (but it's fine when executing CURD separately, very quick to finish 1000,000 times of loop).

Only execute for loop for one time works fine: 2017-05-16 17:10:26  total cost time5.241008ms.

below is the code:

func insertUnis(db *sql.DB, name string){
    stmt_insert, err := db.Prepare(""insert into memDB1 values(?,?,'world.cnworld.cnworld.cnworld.cn',?,'ee02:123::af01:9231:df18:8998:ee02:123::af01:9231:df18:8998:abcd','2017070035|2703258|1943|0|0|10.121.205.248|088:abcd:e02:123::/64','Framed-Interface-Id`varchar(64)COLLATEutf8_binNOTNULLdefaultthah','varchar(64)COLLATEutf8_binNOTNULLdefault0xBF019231DF18899934hdas','Call-From-Id`varchar(32)COLLATEd',?,'Current-Bandwidt','NAS-Port-Idvarchar(256)COLLATEutf8_binNOTNULLdefaultsrunk 6/0/36:33.351 0/0/0/0/0/0NAS-Port-Idvarchar(256)COLLATEutf8_binNOTNULLdefaultsrunk 6/0/36:33.351 0/0/0/0/0/0NAS-Port-Idvarchar(256)COLLATEutf8_binNOTNULLdefaultsrunk 6/0/36:33.351 0/0/0/0/0/0sefiuhu',48204,57239,2458787490,2458787490,2458787490,'Static-Bandwidthvhar(24)','Bas-Bandwidth` varchar(64) COLLATE utf8_bin NOT NULL defaultegse','Session-Id varchar(64) COLLATE utf8_bin NOT NULL defaultlasefjie','Coa-Session-Id` varchar(64) COLLATE utf8_bin NOT NULL defaultsdf','macaddr`varchar(32) COLLATE utf8',?,65535,45656,'Reseverd1` varchar(32) COLLATE u',4294967292)"")
    if err != nil {
        Log(LL_ERROR, ""stmt_insert Prepare err:"", err.Error(), ""."")
    }
    defer stmt_insert.Close()
    stmt_update, err := db.Prepare(""update memDB1 set user_name=? where session_key=?"")
    if err != nil {
        Log(LL_ERROR, ""stmt_update Prepare err:"", err.Error(), ""."")
    }   
    defer stmt_update.Close()
    stmt_del, err := db.Prepare(""delete from memDB1 where session_key=?"")
        if err != nil {
            Log(LL_ERROR, ""stmt_del Prepare err:"", err.Error(), ""."")
    }
    defer stmt_del.Close() 
    for i:=0;i<500000;i++{
        session_key:=string(Krand(64,3))
        user_name := string(Krand(64,3))
        frame_ip := string(Krand(32,3))     
        Nas_IP := string(Krand(32,3))   
        nat_ip := string(Krand(32,3))   

        _, err = stmt_insert.Exec(session_key,user_name,frame_ip,Nas_IP,nat_ip)
        if err != nil {
            Log(LL_ERROR, ""stmt_insert Exec err:"", err.Error(), ""."")
        }

        _, err = stmt_update.Exec(string(Krand(64,3)), session_key)
        if err != nil {
            Log(LL_ERROR, ""stmt_update Exec err:"", err.Error(), ""."")
        }
        sql := ""SELECT * FROM memDB1 where session_key='"" + session_key+""'""
        row, err := db.Query(sql)
        defer row.Close()
        if err != nil {
            Log(LL_ERROR, ""Query err:"", err.Error(), ""."")
        }
        _, err = stmt_del.Exec(session_key)
         if err != nil {
            Log(LL_ERROR, ""stmt_del Exec err:"", err.Error(), ""."")
        }
    }
    common_package.WgDay.Done()
    return
}


The MySQL process list:

mysql> show full processlist;
...............
| 1292138 | cid  | localhost:46799 | ciddb | Sleep   |    0 |          | NULL                  |
| 1292139 | cid  | localhost:46800 | ciddb | Sleep   |    0 |          | NULL                  |
| 1292140 | cid  | localhost:46801 | ciddb | Sleep   |    0 |          | NULL                  |
| 1292141 | cid  | localhost:46802 | ciddb | Sleep   |    0 |          | NULL                  |
+---------+------+-----------------+-------+---------+------+----------+-----------------------+
8719 rows in set (0.04 sec)


MySQL error messages:

2017-05-16 16:37:56  stmt_insert Exec err:Error 1040: Too many connections. 
2017-05-16 16:37:56  stmt_update Exec err:Error 1040: Too many connections. 
2017-05-16 16:37:56  Query err:Error 1040: Too many connections. 2017-05-16 16:37:56  stmt_del Exec err:Error 1040: Too many connections. 
2017-05-16 16:37:56  stmt_insert Exec err:Error 1040: Too many connections. 
2017-05-16 16:37:56  stmt_update Exec err:Error 1040: Too many connections 


MySQL setting: max_connections 10050 set global wait_timeout = 30; set global interactive_timeout = 30; 

it's a memory table and had 5 indexes: KEY index1 (session_key), KEY index2 (Nas-IP), KEY index3 (user_name), KEY index4 (nat_ip), KEY index5 (frame_ip)
"
17326373,"You should check out this resize library: github.com/nfnt/resize. It has 6 good interpolation functions to choose from.
"
43018667,"I try to start using Go in VSCode. I've installed Go as well as Git and created a project in Code, containing a single .go file.

When I type something, VSCode warns me that tools like golint are missing and prompts me to install them. I click on ""Install all"".

Then the console shows this :

Installing 10 tools
  gocode
  gopkgs
  go-outline
  go-symbols
  guru
  gorename
  godef
  goreturns
  golint
  gotests

Installing gocode SUCCEEDED
Installing gopkgs SUCCEEDED
Installing go-outline SUCCEEDED
Installing go-symbols FAILED
Installing guru FAILED
Installing gorename FAILED
Installing godef SUCCEEDED
Installing goreturns FAILED
Installing golint FAILED
Installing gotests FAILED

6 tools failed to install.

go-symbols:
Error: Command failed: C:\Go\bin\go.exe get -u -v github.com/newhook/go-symbols
github.com/newhook/go-symbols (download)
Fetching https://golang.org/x/tools/go/buildutil?go-get=1
Parsing meta tags from https://golang.org/x/tools/go/buildutil?go-get=1 (status code 200)
get ""golang.org/x/tools/go/buildutil"": found meta tag main.metaImport{Prefix:""golang.org/x/tools"", VCS:""git"", RepoRoot:""https://go.googlesource.com/tools""} at https://golang.org/x/tools/go/buildutil?go-get=1
get ""golang.org/x/tools/go/buildutil"": verifying non-authoritative meta tag
Fetching https://golang.org/x/tools?go-get=1
Parsing meta tags from https://golang.org/x/tools?go-get=1 (status code 200)
golang.org/x/tools (download)
# cd C:\Users\user\go\src\golang.org\x\tools; git pull --ff-only
fatal: Not a git repository (or any of the parent directories): .git
package golang.org/x/tools/go/buildutil: exit status 128
github.com/newhook/go-symbols (download)
Fetching https://golang.org/x/tools/go/buildutil?go-get=1
Parsing meta tags from https://golang.org/x/tools/go/buildutil?go-get=1 (status code 200)
get ""golang.org/x/tools/go/buildutil"": found meta tag main.metaImport{Prefix:""golang.org/x/tools"", VCS:""git"", RepoRoot:""https://go.googlesource.com/tools""} at https://golang.org/x/tools/go/buildutil?go-get=1
get ""golang.org/x/tools/go/buildutil"": verifying non-authoritative meta tag
Fetching https://golang.org/x/tools?go-get=1
Parsing meta tags from https://golang.org/x/tools?go-get=1 (status code 200)
golang.org/x/tools (download)
# cd C:\Users\user\go\src\golang.org\x\tools; git pull --ff-only
fatal: Not a git repository (or any of the parent directories): .git
package golang.org/x/tools/go/buildutil: exit status 128

guru:
Error: Command failed: C:\Go\bin\go.exe get -u -v golang.org/x/tools/cmd/guru
Fetching https://golang.org/x/tools/cmd/guru?go-get=1
Parsing meta tags from https://golang.org/x/tools/cmd/guru?go-get=1 (status code 200)
get ""golang.org/x/tools/cmd/guru"": found meta tag main.metaImport{Prefix:""golang.org/x/tools"", VCS:""git"", RepoRoot:""https://go.googlesource.com/tools""} at https://golang.org/x/tools/cmd/guru?go-get=1
get ""golang.org/x/tools/cmd/guru"": verifying non-authoritative meta tag
Fetching https://golang.org/x/tools?go-get=1
Parsing meta tags from https://golang.org/x/tools?go-get=1 (status code 200)
golang.org/x/tools (download)
# cd C:\Users\user\go\src\golang.org\x\tools; git pull --ff-only
fatal: Not a git repository (or any of the parent directories): .git
package golang.org/x/tools/cmd/guru: exit status 128
Fetching https://golang.org/x/tools/cmd/guru?go-get=1
Parsing meta tags from https://golang.org/x/tools/cmd/guru?go-get=1 (status code 200)
get ""golang.org/x/tools/cmd/guru"": found meta tag main.metaImport{Prefix:""golang.org/x/tools"", VCS:""git"", RepoRoot:""https://go.googlesource.com/tools""} at https://golang.org/x/tools/cmd/guru?go-get=1
get ""golang.org/x/tools/cmd/guru"": verifying non-authoritative meta tag
Fetching https://golang.org/x/tools?go-get=1
Parsing meta tags from https://golang.org/x/tools?go-get=1 (status code 200)
golang.org/x/tools (download)
# cd C:\Users\user\go\src\golang.org\x\tools; git pull --ff-only
fatal: Not a git repository (or any of the parent directories): .git
package golang.org/x/tools/cmd/guru: exit status 128

gorename:
Error: Command failed: C:\Go\bin\go.exe get -u -v golang.org/x/tools/cmd/gorename
Fetching https://golang.org/x/tools/cmd/gorename?go-get=1
Parsing meta tags from https://golang.org/x/tools/cmd/gorename?go-get=1 (status code 200)
get ""golang.org/x/tools/cmd/gorename"": found meta tag main.metaImport{Prefix:""golang.org/x/tools"", VCS:""git"", RepoRoot:""https://go.googlesource.com/tools""} at https://golang.org/x/tools/cmd/gorename?go-get=1
get ""golang.org/x/tools/cmd/gorename"": verifying non-authoritative meta tag
Fetching https://golang.org/x/tools?go-get=1
Parsing meta tags from https://golang.org/x/tools?go-get=1 (status code 200)
golang.org/x/tools (download)
# cd C:\Users\user\go\src\golang.org\x\tools; git pull --ff-only
fatal: Not a git repository (or any of the parent directories): .git
package golang.org/x/tools/cmd/gorename: exit status 128
Fetching https://golang.org/x/tools/cmd/gorename?go-get=1
Parsing meta tags from https://golang.org/x/tools/cmd/gorename?go-get=1 (status code 200)
get ""golang.org/x/tools/cmd/gorename"": found meta tag main.metaImport{Prefix:""golang.org/x/tools"", VCS:""git"", RepoRoot:""https://go.googlesource.com/tools""} at https://golang.org/x/tools/cmd/gorename?go-get=1
get ""golang.org/x/tools/cmd/gorename"": verifying non-authoritative meta tag
Fetching https://golang.org/x/tools?go-get=1
Parsing meta tags from https://golang.org/x/tools?go-get=1 (status code 200)
golang.org/x/tools (download)
# cd C:\Users\user\go\src\golang.org\x\tools; git pull --ff-only
fatal: Not a git repository (or any of the parent directories): .git
package golang.org/x/tools/cmd/gorename: exit status 128

goreturns:
Error: Command failed: C:\Go\bin\go.exe get -u -v sourcegraph.com/sqs/goreturns
Fetching https://sourcegraph.com/sqs/goreturns?go-get=1
Parsing meta tags from https://sourcegraph.com/sqs/goreturns?go-get=1 (status code 200)
get ""sourcegraph.com/sqs/goreturns"": found meta tag main.metaImport{Prefix:""sourcegraph.com/sqs/goreturns"", VCS:""git"", RepoRoot:""https://github.com/sqs/goreturns""} at https://sourcegraph.com/sqs/goreturns?go-get=1
sourcegraph.com/sqs/goreturns (download)
github.com/sqs/goreturns (download)
Fetching https://golang.org/x/tools/imports?go-get=1
Parsing meta tags from https://golang.org/x/tools/imports?go-get=1 (status code 200)
get ""golang.org/x/tools/imports"": found meta tag main.metaImport{Prefix:""golang.org/x/tools"", VCS:""git"", RepoRoot:""https://go.googlesource.com/tools""} at https://golang.org/x/tools/imports?go-get=1
get ""golang.org/x/tools/imports"": verifying non-authoritative meta tag
Fetching https://golang.org/x/tools?go-get=1
Parsing meta tags from https://golang.org/x/tools?go-get=1 (status code 200)
golang.org/x/tools (download)
# cd C:\Users\user\go\src\golang.org\x\tools; git pull --ff-only
fatal: Not a git repository (or any of the parent directories): .git
package golang.org/x/tools/imports: exit status 128
Fetching https://sourcegraph.com/sqs/goreturns?go-get=1
Parsing meta tags from https://sourcegraph.com/sqs/goreturns?go-get=1 (status code 200)
get ""sourcegraph.com/sqs/goreturns"": found meta tag main.metaImport{Prefix:""sourcegraph.com/sqs/goreturns"", VCS:""git"", RepoRoot:""https://github.com/sqs/goreturns""} at https://sourcegraph.com/sqs/goreturns?go-get=1
sourcegraph.com/sqs/goreturns (download)
github.com/sqs/goreturns (download)
Fetching https://golang.org/x/tools/imports?go-get=1
Parsing meta tags from https://golang.org/x/tools/imports?go-get=1 (status code 200)
get ""golang.org/x/tools/imports"": found meta tag main.metaImport{Prefix:""golang.org/x/tools"", VCS:""git"", RepoRoot:""https://go.googlesource.com/tools""} at https://golang.org/x/tools/imports?go-get=1
get ""golang.org/x/tools/imports"": verifying non-authoritative meta tag
Fetching https://golang.org/x/tools?go-get=1
Parsing meta tags from https://golang.org/x/tools?go-get=1 (status code 200)
golang.org/x/tools (download)
# cd C:\Users\user\go\src\golang.org\x\tools; git pull --ff-only
fatal: Not a git repository (or any of the parent directories): .git
package golang.org/x/tools/imports: exit status 128

golint:
Error: Command failed: C:\Go\bin\go.exe get -u -v github.com/golang/lint/golint
github.com/golang/lint (download)
Fetching https://golang.org/x/tools/go/gcexportdata?go-get=1
Parsing meta tags from https://golang.org/x/tools/go/gcexportdata?go-get=1 (status code 200)
get ""golang.org/x/tools/go/gcexportdata"": found meta tag main.metaImport{Prefix:""golang.org/x/tools"", VCS:""git"", RepoRoot:""https://go.googlesource.com/tools""} at https://golang.org/x/tools/go/gcexportdata?go-get=1
get ""golang.org/x/tools/go/gcexportdata"": verifying non-authoritative meta tag
Fetching https://golang.org/x/tools?go-get=1
Parsing meta tags from https://golang.org/x/tools?go-get=1 (status code 200)
golang.org/x/tools (download)
# cd C:\Users\user\go\src\golang.org\x\tools; git pull --ff-only
fatal: Not a git repository (or any of the parent directories): .git
package golang.org/x/tools/go/gcexportdata: exit status 128
github.com/golang/lint (download)
Fetching https://golang.org/x/tools/go/gcexportdata?go-get=1
Parsing meta tags from https://golang.org/x/tools/go/gcexportdata?go-get=1 (status code 200)
get ""golang.org/x/tools/go/gcexportdata"": found meta tag main.metaImport{Prefix:""golang.org/x/tools"", VCS:""git"", RepoRoot:""https://go.googlesource.com/tools""} at https://golang.org/x/tools/go/gcexportdata?go-get=1
get ""golang.org/x/tools/go/gcexportdata"": verifying non-authoritative meta tag
Fetching https://golang.org/x/tools?go-get=1
Parsing meta tags from https://golang.org/x/tools?go-get=1 (status code 200)
golang.org/x/tools (download)
# cd C:\Users\user\go\src\golang.org\x\tools; git pull --ff-only
fatal: Not a git repository (or any of the parent directories): .git
package golang.org/x/tools/go/gcexportdata: exit status 128

gotests:
Error: Command failed: C:\Go\bin\go.exe get -u -v github.com/cweill/gotests/...
github.com/cweill/gotests (download)
Fetching https://golang.org/x/tools/imports?go-get=1
Parsing meta tags from https://golang.org/x/tools/imports?go-get=1 (status code 200)
get ""golang.org/x/tools/imports"": found meta tag main.metaImport{Prefix:""golang.org/x/tools"", VCS:""git"", RepoRoot:""https://go.googlesource.com/tools""} at https://golang.org/x/tools/imports?go-get=1
get ""golang.org/x/tools/imports"": verifying non-authoritative meta tag
Fetching https://golang.org/x/tools?go-get=1
Parsing meta tags from https://golang.org/x/tools?go-get=1 (status code 200)
golang.org/x/tools (download)
# cd C:\Users\user\go\src\golang.org\x\tools; git pull --ff-only
fatal: Not a git repository (or any of the parent directories): .git
package golang.org/x/tools/imports: exit status 128
github.com/cweill/gotests (download)
Fetching https://golang.org/x/tools/imports?go-get=1
Parsing meta tags from https://golang.org/x/tools/imports?go-get=1 (status code 200)
get ""golang.org/x/tools/imports"": found meta tag main.metaImport{Prefix:""golang.org/x/tools"", VCS:""git"", RepoRoot:""https://go.googlesource.com/tools""} at https://golang.org/x/tools/imports?go-get=1
get ""golang.org/x/tools/imports"": verifying non-authoritative meta tag
Fetching https://golang.org/x/tools?go-get=1
Parsing meta tags from https://golang.org/x/tools?go-get=1 (status code 200)
golang.org/x/tools (download)
# cd C:\Users\user\go\src\golang.org\x\tools; git pull --ff-only
fatal: Not a git repository (or any of the parent directories): .git
package golang.org/x/tools/imports: exit status 128


Some tools are able to install, others are not. I can't do anything about the Not a git repository error because it's an automated process and I'm not the one typing the git commands.

I tried installing the tools separately in PowerShell and I get the same errors. My go directory is created (in %USERPROFILE%\go) and the GOPATH is set correctly.

Any ideas ?
"
22035083,"If you're trying to synchronize a pool of workers (e.g. allow n goroutines to crunch away at some amount of work) then channels are a very good way to go about it, but if all you actually need is a counter (e.g page views) then they are overkill. The sync and sync/atomic packages are there to help.

import ""sync/atomic""

type count32 int32

func (c *count32) increment() int32 {
    return atomic.AddInt32((*int32)(c), 1)
}

func (c *count32) get() int32 {
    return atomic.LoadInt32((*int32)(c))
}


Go Playground Example
"
28460249,"It is indeed possible, all you need to do is goapp serve --port=3000 (or whatever port you'd like).

If you're trying to access your goapp on a VM (parallels), like I was, you can do goapp serve --host=0.0.0.0

Documentation: https://cloud.google.com/appengine/docs/go/tools/devserver#Go_Command-line_arguments
"
33750000,"The problem is likely

gl.ReadPixels(int32(rx), int32(ry), 1, 1, gl.RGB, gl.UNSIGNED_BYTE, gl.Ptr(&data))


Specifically

gl.Ptr(&data)


The documentation for that function is:

// Ptr takes a slice or pointer (to a singular scalar value or the first
// element of an array or slice) and returns its GL-compatible address.


You're passing a POINTER to a slice. This is... problematic if you look at the implementation.

func Ptr(data interface{}) unsafe.Pointer {
    if data == nil {
        return unsafe.Pointer(nil)
    }
    var addr unsafe.Pointer
    v := reflect.ValueOf(data)
    switch v.Type().Kind() {
    case reflect.Ptr:
        e := v.Elem()
        switch e.Kind() {
        case
            reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64,
            reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64,
            reflect.Float32, reflect.Float64:
            addr = unsafe.Pointer(e.UnsafeAddr())
        }
    case reflect.Uintptr:
        addr = unsafe.Pointer(v.Pointer())
    case reflect.Slice:


addr = unsafe.Pointer(v.Index(0).UnsafeAddr())
    default:
        panic(fmt.Sprintf(""Unsupported type %s; must be a pointer, slice, or array"", v.Type()))
    }
    return addr
}


As you can see, if you pass in a pointer to anything other than a basic uint/float/int, it will fail silently and return a null unsafe.Pointer if it's not of the correct type. So you either want to pass in gl.Ptr(&data[0]) or gl.Ptr(data). It's honestly kind of surprising this wasn't segfaulting.
"
38729871,"Go build and go test are still working.

Before updating to macOS beta I had no problems using the test coverage tools.

""go test"" is working fine; however, all of the coverage test commands are throwing this error (go test -coverprofile=coverage.out throws the same issue). 

If anyone has any idea how to fix this, I would really appreciate it!

$ go test -cover
go build github.com/hunteramericano/ErrorQuiver: /usr/local/Cellar/go/1.6.3/libexec/pkg/tool/darwin_amd64/cover: signal:
fatal error: unexpected signal during runtime execution
[signal 0xb code=0x1 addr=0x57060029ec pc=0x17cc70]

goroutine 9 [running]:
runtime.throw(0x689a00, 0x2a)
/usr/local/Cellar/go/1.6.3/libexec/src/runtime/panic.go:547 +0x90 fp=0xc820037870 sp=0xc820037858
runtime.sigpanic()
/usr/local/Cellar/go/1.6.3/libexec/src/runtime/sigpanic_unix.go:12 +0x5a fp=0xc8200378c0 sp=0xc820037870
sync.(*Pool).Get(0x882700, 0x0, 0x0)
/usr/local/Cellar/go/1.6.3/libexec/src/sync/pool.go:102 +0x40 fp=0xc820037910 sp=0xc8200378c0
fmt.newPrinter(0x10)
/usr/local/Cellar/go/1.6.3/libexec/src/fmt/print.go:133 +0x27 fp=0xc820037950 sp=0xc820037910
fmt.Fprintf(0xde5230, 0xc82017a150, 0x638380, 0x17, 0xc820037af0, 0x1, 0x1, 0x0, 0x0, 0x0)
/usr/local/Cellar/go/1.6.3/libexec/src/fmt/print.go:187 +0x30 fp=0xc820037998 sp=0xc820037950
main.(*builder).runTest(0xc82017aaf0, 0xc82005e410, 0x0, 0x0)
/usr/local/Cellar/go/1.6.3/libexec/src/cmd/go/test.go:1070 +0x463 fp=0xc820037e00 sp=0xc820037998
main.(*builder).do.func1(0xc82005e410)
/usr/local/Cellar/go/1.6.3/libexec/src/cmd/go/build.go:1257 +0x3b2 fp=0xc820037ec0 sp=0xc820037e00
main.(*builder).do.func2(0xc82038ae20, 0xc82017aaf0, 0xc820428400)
/usr/local/Cellar/go/1.6.3/libexec/src/cmd/go/build.go:1314 +0x156 fp=0xc820037f98 sp=0xc820037ec0
runtime.goexit()
/usr/local/Cellar/go/1.6.3/libexec/src/runtime/asm_amd64.s:1998 +0x1 fp=0xc820037fa0 sp=0xc820037f98
created by main.(*builder).do
/usr/local/Cellar/go/1.6.3/libexec/src/cmd/go/build.go:1320 +0x39e

goroutine 1 [semacquire]:
sync.runtime_Semacquire(0xc82038ae2c)
/usr/local/Cellar/go/1.6.3/libexec/src/runtime/sema.go:47 +0x26
sync.(*WaitGroup).Wait(0xc82038ae20)
/usr/local/Cellar/go/1.6.3/libexec/src/sync/waitgroup.go:127 +0xb4
main.(*builder).do(0xc82017aaf0, 0xc82005e680)
/usr/local/Cellar/go/1.6.3/libexec/src/cmd/go/build.go:1323 +0x3c6
main.runTest(0x889620, 0xc82000a230, 0x1, 0x1)
/usr/local/Cellar/go/1.6.3/libexec/src/cmd/go/test.go:595 +0x2836
main.main()
/usr/local/Cellar/go/1.6.3/libexec/src/cmd/go/main.go:181 +0x783

goroutine 17 [syscall, locked to thread]:
runtime.goexit()
/usr/local/Cellar/go/1.6.3/libexec/src/runtime/asm_amd64.s:1998 +0x1

goroutine 5 [syscall]:
os/signal.signal_recv(0x0)
/usr/local/Cellar/go/1.6.3/libexec/src/runtime/sigqueue.go:116 +0x132
os/signal.loop()
/usr/local/Cellar/go/1.6.3/libexec/src/os/signal/signal_unix.go:22 +0x18
created by os/signal.init.1
/usr/local/Cellar/go/1.6.3/libexec/src/os/signal/signal_unix.go:28 +0x37

goroutine 7 [select]:
main.(*builder).do.func2(0xc82038ae20, 0xc82017aaf0, 0xc820428400)
/usr/local/Cellar/go/1.6.3/libexec/src/cmd/go/build.go:1304 +0x1cf
created by main.(*builder).do
/usr/local/Cellar/go/1.6.3/libexec/src/cmd/go/build.go:1320 +0x39e

goroutine 8 [select]:
main.(*builder).do.func2(0xc82038ae20, 0xc82017aaf0, 0xc820428400)
/usr/local/Cellar/go/1.6.3/libexec/src/cmd/go/build.go:1304 +0x1cf
created by main.(*builder).do
/usr/local/Cellar/go/1.6.3/libexec/src/cmd/go/build.go:1320 +0x39e

goroutine 10 [select]:
main.(*builder).do.func2(0xc82038ae20, 0xc82017aaf0, 0xc820428400)
/usr/local/Cellar/go/1.6.3/libexec/src/cmd/go/build.go:1304 +0x1cf
created by main.(*builder).do
/usr/local/Cellar/go/1.6.3/libexec/src/cmd/go/build.go:1320 +0x39e
$

"
37904662,"The error message is telling exactly what is the issue:


  panic: runtime error: slice bounds out of range


Since you are calling the same function iteratively and re-slicing the slice you need to check each time if you reached the slice capacity range, in other terms if the slice pointer is pointing to a valid address (index), otherwise you get the out of range error message. 

And since you are making a recursive iteration, by decreasing the path length each time, you have to check if the slice index is within a valid range.

//re-slice the slice - get rid of the current node
if len(path) > 0 {
       path = path[:len(path)-1]
}


https://play.golang.org/p/pX2TlAP-bp
"
30124515,"I trying to upload to google cloud storage a json array which is posted by an app engine application using the following code: 

saveData : function saveData() {
  var _this = this,
      save = this.shadowRoot.querySelector('#save-data'),
      subData = JSON.stringify(_this.app.userSession);

  save.url=""url"";
  save.body = subData;
  save.go();
}


The posted message is handled in go with the code posted below. With this code I'm able to create a folder on the cloud storage bucket which is named with the user ID. What I would love to do is to copy into the folder the entire json array -i.e. the variable f in the code below. I tried with io.Copy(wc, f) but it gives me the following error: 


  cannot use content (type userData) as type io.Reader in argument to
  io.Copy:
          userData does not implement io.Reader (missing Read method)


Obviously I'm doing something wrong, but I'm quite new to go and I'm totally stuck. Can someone help me?

package expt

import (
    ""bytes""
    ""encoding/json""
    ""io/ioutil""
    ""log""
    ""net/http""
    ""golang.org/x/net/context""
    ""golang.org/x/oauth2""
    ""golang.org/x/oauth2/google""
    ""google.golang.org/appengine""
    ""google.golang.org/appengine/file""
    ""google.golang.org/appengine/urlfetch""
    ""google.golang.org/cloud""
    ""google.golang.org/cloud/storage""
)

var bucket = ""expt""

func init() {
    http.HandleFunc(""/"", handleStatic)
    http.HandleFunc(""/save"", saveJson)
}

func handleStatic(w http.ResponseWriter, r *http.Request) {
    w.Header().Set(""Cache-Control"", ""no-cache"")
    http.ServeFile(w, r, ""static/""+r.URL.Path)
}

type Result map[string]interface {
}

type userData struct {
    id     string
    age    string
    gender string
}

func testA(r *http.Request) userData {
    defer r.Body.Close()
    body, err := ioutil.ReadAll(r.Body)
    var userDataCurr userData
    if err != nil {
        log.Printf(""Couldn't read request body: %s"", err)
    } else {
        var f Result
        err := json.Unmarshal(body, &f)
        if err != nil {
            log.Println(""Error: %s"", err)
        } else {
            user := f[""user""].(map[string]interface{})
            userDataCurr.id = user[""id""].(string)
        }
    }
    return userDataCurr
}

// saveData struct holds information needed to run the various saving functions.
type saveData struct {
    c   context.Context
    r   *http.Request
    w   http.ResponseWriter
    ctx context.Context
    // cleanUp is a list of filenames that need cleaning up at the end of the saving.
    cleanUp []string
    // failed indicates that one or more of the saving steps failed.
    failed bool
}

func (d *saveData) errorf(format string, args ...interface{}) {
    d.failed = true
    // log.Errorf(d.c, format, args...)
}

// testSave is the main saving entry point that calls the GCS operations.
func saveJson(w http.ResponseWriter, r *http.Request) {

    c := appengine.NewContext(r)
    if bucket == """" {
        var err error
        if bucket, err = file.DefaultBucketName(c); err != nil {
            // log.Errorf(c, ""failed to get default GCS bucket name: %v"", err)
            return
        }
    }
    hc := &http.Client{
        Transport: &oauth2.Transport{
            Source: google.AppEngineTokenSource(c, storage.ScopeFullControl),
            Base:   &urlfetch.Transport{Context: c},
        },
    }
    ctx := cloud.NewContext(appengine.AppID(c), hc)

    d := &saveData{
        c:   c,
        r:   r,
        w:   w,
        ctx: ctx,
    }

    d.createUserFolder()

}

// createFile creates a file in Google Cloud Storage.
func (d *saveData) createFile(fileName string) {

    wc := storage.NewWriter(d.ctx, bucket, fileName)
    wc.ContentType = ""text/plain""
    d.cleanUp = append(d.cleanUp, fileName)

    if err := wc.Close(); err != nil {
        d.errorf(""createFile: unable to close bucket %q, file %q: %v"", bucket, fileName, err)
        return
    }
}

//create files that will be used by listBucket.
func (d *saveData) createUserFolder() {
    var (
        content = testA(d.r)
        buffer  bytes.Buffer
    )

    buffer.WriteString(content.id)
    buffer.WriteString(""/"")
    d.createFile(buffer.String())
}

"
41959727,"Try returnBeaconData = append(returnBeaconData, *beacondataXY)

new() built-in function returns a pointer, you can alternatively write:

var beacondataXY = types.BeaconDataXY{}
"
17329295,"On Windows:

>go version
go version devel +edd229b63fa4 Wed Jun 26 11:36:18 2013 -0700 windows/amd64
>go get -v code.google.com/p/odbc
code.google.com/p/odbc (download)
code.google.com/p/odbc/api
code.google.com/p/odbc
>go get -v bitbucket.org/miquella/mgodbc
bitbucket.org/miquella/mgodbc (download)
bitbucket.org/miquella/mgodbc
>


On Linux:

$ go version
go version devel +65e2aba21abe Wed Jun 26 13:14:11 2013 -0700 linux/amd64
$ sudo apt-get install unixodbc unixodbc-dev
Reading package lists... Done
Building dependency tree       
Reading state information... Done
unixodbc is already the newest version.
unixodbc-dev is already the newest version.
0 upgraded, 0 newly installed, 0 to remove and 10 not upgraded.
$ go get -v code.google.com/p/odbc
code.google.com/p/odbc (download)
code.google.com/p/odbc/api
code.google.com/p/odbc
$ go get -v bitbucket.org/miquella/mgodbc
bitbucket.org/miquella/mgodbc (download)
bitbucket.org/miquella/mgodbc
$ 


On Darwin, you seem to have issues with SQL header files.

/usr/include/sql.h
/usr/include/sqlext.h
/usr/include/sqltypes.h
/usr/include/sqlucode.h


Contact the odbc package authors to report these problems.

UPDATE:

When you tell us about the error

mgodbc.go:180: cannot convert &state[0] (type *uint16) to type *_Ctype_SQLWCHAR  


you don't tell us what the type of _Ctype_SQLWCHAR is. We can only guess! My guess would be that it should look like this

package main

func main() {
    type _Ctype_ushort uint16
    type _Ctype_WCHAR _Ctype_ushort
    type _Ctype_SQLWCHAR _Ctype_WCHAR
    var state [6]uint16
    // (*C.SQLWCHAR)(&state[0])
    _ = (*_Ctype_SQLWCHAR)(&state[0])
}


which compiles with no errors.

UPDATE:

Use a systematic approach to problem solving.

Read about Go build contraints: Build Constraints, Package build.

Read the files in code.google.com/p/odbc/api.

Grep the files in code.google.com/p/odbc/api.

$ grep -r 'linux' *
api_unix.go:// +build linux
api_unix.go:// #cgo linux LDFLAGS: -lodbc
Makefile:   GOOS=linux ./mksyscall_unix.pl $^ \
mksyscall_unix.pl:// +build linux
mksyscall_unix.pl:// #cgo linux LDFLAGS: -lodbc
zapi_unix.go:// +build linux
zapi_unix.go:// #cgo linux LDFLAGS: -lodbc
$ 


Clearly, after reading the api_unix.go, zapi_unix.go, mksyscall_unix.pl, and Makefile files, when the api_unix.go file is modified, the zapi_unix.go file should be modified too.

You probably didn't do that. Therefore, darwin is not included in the zapi_unix.go build constraints. The package api names that you show as undefined are defined in zapi_unix.go.

api.SQLGetData
api.SQLBindCol  
api.SQLDescribeCol  
api.SQLAllocHandle  
api.SQLDriverConnect  
api.SQLDisconnect  
api.SQLAllocHandle  
api.SQLSetEnvAttr   

"
36379116,"Note that curl is sending a ""Content-Type"" header of multipart/form-data. Your Go program is sending a ""Content-Disposition"" header with just form-data (note the difference, it lacking the leading multipart composite top-level media type), but it doesn't take care of sending the correct ""Content-Type"" header for the containing HTTP request.

Go's multipart.Writer type's CreateFormFile method does the same, but again, that's only part of the job:

h.Set(""Content-Disposition"",
        fmt.Sprintf(`form-data; name=""%s""; filename=""%s""`,
                escapeQuotes(fieldname), escapeQuotes(filename)))


To get the proper ""Content-Type"" header value, you need to use multipart.Writer.FormDataContentType. To put that value to use, you'll need to get your multipart.Writer into your WatsonClassifier.request method, so that you can set the content type on your http.Request instance:

req.Header.Set(""Content-Type"", writer.FormDataContentType())


Alternately, add another parameter to WatsonClassifier.request for the content type, and pass the result of FormDataContentType as the argument from the call site in WatsonClassifier.Train.

Let us know if that does the trick.
"
18839429,"I'm trying to have Go submit a form on a webpage for me to simulate a login. From there I'm trying to use the cookies to keep a persistent session for one more call to a sub-page.

I'm able to successfully do the log in with no issues, I'm just having issues catching the cookies being set by the returning server. I'm wondering if it's because their login script does several redirects? (I am getting an output).

Any ideas why I'm not catching the cookies being returned?

Here is the code I'm using:

 import (
    ""crypto/tls""
    ""fmt""
    ""io/ioutil""
    ""net/http""
    ""net/url""
    ""strings""
    ""sync""
)

type Jar struct {
    lk      sync.Mutex
    cookies map[string][]*http.Cookie
}

var CookieJar *Jar

func NewJar() *Jar {
    jar := new(Jar)
    jar.cookies = make(map[string][]*http.Cookie)
    return jar
}

// SetCookies handles the receipt of the cookies in a reply for the
// given URL.  It may or may not choose to save the cookies, depending
// on the jar's policy and implementation.
func (jar *Jar) SetCookies(u *url.URL, cookies []*http.Cookie) {
    jar.lk.Lock()
    jar.cookies[u.Host] = cookies
    jar.lk.Unlock()
}

// Cookies returns the cookies to send in a request for the given URL.
// It is up to the implementation to honor the standard cookie use
// restrictions such as in RFC 6265.
func (jar *Jar) Cookies(u *url.URL) []*http.Cookie {
    return jar.cookies[u.Host]
}

func NewClient() *http.Client {
    tr := &http.Transport{
    TLSClientConfig: &tls.Config{InsecureSkipVerify: false},
}

    CookieJar = NewJar()
    client := &http.Client{
        Transport:     tr,
        CheckRedirect: nil,
        Jar:           CookieJar,
    }

    return client
 }

 func Login() {
    client := NewClient()

    api := ""https://www.statuscake.com/App/""
    uri, _ := url.Parse(""https://www.statuscake.com"")

    fmt.Printf(""uri: %s\n"", uri)

    values := url.Values{}
    values.Add(""username"", username)
    values.Add(""password"", password)
    values.Add(""Login"", ""yes"")
    values.Add(""redirect"", """")
    str := values.Encode()
    req, err := http.NewRequest(""POST"", api, strings.NewReader(str))

    req.Header.Set(""Content-Type"", ""application/x-www-form-urlencoded"")
    req.Header.Set(""Accept"", ""text/html"")
    req.Header.Set(""User-Agent"", ""Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/29.0.1547.65 Safari/537.36"")
    cookies := CookieJar.Cookies(uri)
    for i := 0; i < len(cookies); i++ {
        fmt.Printf(""Cookie[%d]: %s"", i, cookies[i])
        req.AddCookie(cookies[i])
    }

    resp, err := client.Do(req)
    if err != nil {
        panic(err)
    }
    fmt.Printf(""Response: %v\n"", resp)

    fmt.Printf(""Response.Cookies: %v\n"", resp.Cookies())

    cookies = resp.Cookies()
    CookieJar.SetCookies(uri, cookies)

    defer resp.Body.Close()

    if resp.StatusCode == 200 {
        fmt.Printf(""\n\n-----\n"")
        fmt.Println(""HTTP Code: "", resp.StatusCode)
        fmt.Println(""Response Cookies: "", resp.Cookies())
        fmt.Println(""Request Headers: "", req.Header)
        fmt.Println(""Request Cookies: "", req.Cookies())
        fmt.Println(""Response Headers: "", resp.Header)
        fmt.Printf(""-----\n\n"")
    }
 }

"
30478485,"I have latest tools installed, in the app.go I have following imports

""github.com/go-martini/martini""
""github.com/martini-contrib/binding""
""github.com/martini-contrib/render""
""github.com/moovweb/gokogiri""
""github.com/moovweb/gokogiri/xml""


And in app.yaml

application: app
version: 1
runtime: go
api_version: go1

handlers:
- url: /.*
  script: _go_app


I saved external dependencies using godep save tool. But while trying to execute goapp serve command following error occured

SRSLY-2:app bezigon$ goapp serve
INFO     2015-05-27 09:11:22,645 devappserver2.py:745] Skipping SDK update check.
INFO     2015-05-27 09:11:23,048 api_server.py:190] Starting API server at: http://localhost:57449
INFO     2015-05-27 09:11:23,071 dispatcher.py:192] Starting module ""default"" running at: http://localhost:8080
INFO     2015-05-27 09:11:23,073 admin_server.py:118] Starting admin server at: http://localhost:8000
ERROR    2015-05-27 09:11:24,772 go_runtime.py:180] Failed to build Go application: (Executed command: /Users/bezigon/google-cloud-sdk/platform/google_appengine/goroot/bin/go-app-builder -app_base /Users/bezigon/go/src/github.com/bezigon/app -arch 6 -dynamic -goroot /Users/bezigon/google-cloud-sdk/platform/google_appengine/goroot -nobuild_files ^^$ -unsafe -gopath /Users/bezigon/go -print_extras_hash Godeps/_workspace/src/github.com/moovweb/gokogiri/html/xpath_test.go Godeps/_workspace/src/github.com/martini-contrib/binding/validate_test.go Godeps/_workspace/src/github.com/moovweb/gokogiri/xml/attribute.go Godeps/_workspace/src/github.com/martini-contrib/binding/file_test.go Godeps/_workspace/src/github.com/moovweb/gokogiri/xml/document_test.go Godeps/_workspace/src/github.com/moovweb/gokogiri/xpath/util.go Godeps/_workspace/src/github.com/go-martini/martini/logger.go Godeps/_workspace/src/github.com/martini-contrib/binding/misc_test.go Godeps/_workspace/src/github.com/go-martini/martini/response_writer_test.go Godeps/_workspace/src/github.com/codegangsta/inject/inject_test.go Godeps/_workspace/src/github.com/moovweb/gokogiri/xml/text.go Godeps/_workspace/src/github.com/go-martini/martini/go_version.go Godeps/_workspace/src/github.com/go-martini/martini/router_test.go Godeps/_workspace/src/github.com/moovweb/gokogiri/xml/nodeset.go Godeps/_workspace/src/github.com/moovweb/gokogiri/xpath/xpath_test.go Godeps/_workspace/src/github.com/moovweb/gokogiri/xpath/xpath.go Godeps/_workspace/src/github.com/martini-contrib/binding/errors.go Godeps/_workspace/src/github.com/moovweb/gokogiri/mem/mem_test.go Godeps/_workspace/src/github.com/moovweb/gokogiri/help/help_test.go Godeps/_workspace/src/github.com/moovweb/gokogiri/html/fragment_test.go Godeps/_workspace/src/github.com/moovweb/gokogiri/html/node_test.go Godeps/_workspace/src/github.com/martini-contrib/render/render.go Godeps/_workspace/src/github.com/moovweb/gokogiri/help/help.go Godeps/_workspace/src/github.com/moovweb/gokogiri/mem/mem.go Godeps/_workspace/src/github.com/go-martini/martini/recovery.go Godeps/_workspace/src/github.com/moovweb/gokogiri/xml/document.go Godeps/_workspace/src/github.com/moovweb/gokogiri/html/document.go Godeps/_workspace/src/github.com/moovweb/gokogiri/gokogiri.go Godeps/_workspace/src/github.com/moovweb/gokogiri/xml/element.go Godeps/_workspace/src/github.com/martini-contrib/binding/errors_test.go Godeps/_workspace/src/github.com/moovweb/gokogiri/util/util_test.go Godeps/_workspace/src/github.com/moovweb/gokogiri/xml/fragment.go Godeps/_workspace/src/github.com/moovweb/gokogiri/xml/attribute_test.go Godeps/_workspace/src/github.com/moovweb/gokogiri/css/css_test.go Godeps/_workspace/src/github.com/oxtoacart/bpool/bytepool.go Godeps/_workspace/src/github.com/moovweb/gokogiri/xml/fragment_test.go Godeps/_workspace/src/github.com/martini-contrib/binding/errorhandler_test.go Godeps/_workspace/src/github.com/moovweb/gokogiri/xml/utils_test.go Godeps/_workspace/src/github.com/oxtoacart/bpool/bpool.go Godeps/_workspace/src/github.com/moovweb/gokogiri/util/util.go Godeps/_workspace/src/github.com/moovweb/gokogiri/html/utils_test.go Godeps/_workspace/src/github.com/go-martini/martini/response_writer.go Godeps/_workspace/src/github.com/moovweb/gokogiri/css/css.go Godeps/_workspace/src/github.com/go-martini/martini/env.go Godeps/_workspace/src/github.com/moovweb/gokogiri/xml/search_test.go Godeps/_workspace/src/github.com/moovweb/gokogiri/gokogiri_test.go Godeps/_workspace/src/github.com/go-martini/martini/static_test.go Godeps/_workspace/src/github.com/codegangsta/inject/inject.go Godeps/_workspace/src/github.com/moovweb/gokogiri/xpath/expression.go Godeps/_workspace/src/github.com/martini-contrib/binding/form_test.go Godeps/_workspace/src/github.com/go-martini/martini/static.go Godeps/_workspace/src/github.com/go-martini/martini/martini.go Godeps/_workspace/src/github.com/moovweb/gokogiri/html/fragment.go Godeps/_workspace/src/github.com/martini-contrib/binding/bind_test.go app.go Godeps/_workspace/src/github.com/martini-contrib/render/render_test.go Godeps/_workspace/src/github.com/martini-contrib/binding/binding.go Godeps/_workspace/src/github.com/moovweb/gokogiri/xml/cdata.go Godeps/_workspace/src/github.com/go-martini/martini/martini_test.go Godeps/_workspace/src/github.com/moovweb/gokogiri/xml/node_test.go Godeps/_workspace/src/github.com/oxtoacart/bpool/bufferpool.go Godeps/_workspace/src/github.com/martini-contrib/binding/json_test.go Godeps/_workspace/src/github.com/moovweb/gokogiri/xpath/util_test.go Godeps/_workspace/src/github.com/go-martini/martini/router.go Godeps/_workspace/src/github.com/martini-contrib/binding/common_test.go Godeps/_workspace/src/github.com/moovweb/gokogiri/xml/pi.go Godeps/_workspace/src/github.com/go-martini/martini/logger_test.go Godeps/_workspace/src/github.com/go-martini/martini/recovery_test.go Godeps/_workspace/src/github.com/go-martini/martini/return_handler.go Godeps/_workspace/src/github.com/moovweb/gokogiri/help/util_test.go Godeps/_workspace/src/github.com/moovweb/gokogiri/html/document_test.go Godeps/_workspace/src/github.com/moovweb/gokogiri/html/crash_test.go Godeps/_workspace/src/github.com/moovweb/gokogiri/xml/comment.go Godeps/_workspace/src/github.com/martini-contrib/binding/multipart_test.go Godeps/_workspace/src/github.com/moovweb/gokogiri/xml/node.go Godeps/_workspace/src/github.com/go-martini/martini/env_test.go Godeps/_workspace/src/github.com/moovweb/gokogiri/html/encoding_test.go)

2015/05/27 12:11:24 go-app-builder: Failed parsing input: package github.com/moovweb/gokogiri/html required, but all its files were excluded by nobuild_files


What should I do?

By the way it looks to https://blog.golang.org/the-app-engine-sdk-and-workspaces-gopath, but I have not found the answer.

UPD: I have added a testcase, check it out https://github.com/bezigon/testcase
"
29879036,"I'm working on a websocket server and for some reason it outputs: 


  ""WSARecv tcp 127.0.0.1:8080: Use of closed network connection.""


I don't know why it says that because i haven't closed the connection any time...

Here are some files of the server (if need the full source code: github)

connection.go

package net

import (
  ""log""

  ""golang.org/x/net/websocket""

  pnet ""kekocity/misc/packet""
  ""kekocity/interfaces""
)

type Connection struct {
  socket *websocket.Conn

  txChan chan pnet.INetMessageWriter
    rxChan chan pnet.INetMessageReader

  user interfaces.IUser
}

func NewConnection(_socket *websocket.Conn) *Connection {
  // The pointer allow us to modify connection struct from outside
  connection := &Connection{
    socket: _socket,
    txChan: make(chan pnet.INetMessageWriter),
    rxChan: make(chan pnet.INetMessageReader),
  }

  go connection.ReceivePoller()
  go connection.SendPoller()

  return connection
}

func (c *Connection) AssignToUser(_user interfaces.IUser) {
  if _user == nil {
    panic(""net.connection: the user interface can not be nil!"")
    return
  }

  c.user = _user
  _user.SetNetworkChans(c.rxChan, c.txChan)
}

/*
 * ReceivePoller and SendPoller starts listening when the first packet is verified and the new connection is started
 */
func (c *Connection) ReceivePoller() {
  for {
    packet := pnet.NewPacket()

    var buffer []uint8
        err := websocket.Message.Receive(c.socket, &buffer)

        if err == nil {
            copy(packet.Buffer[0:len(buffer)], buffer[0:len(buffer)])

            c.parsePacket(packet)
        } else {
            println(err.Error())
            break
        }
  }
}

func (c *Connection) SendPoller() {
  for {
    // Read messages from transmit channel
    message := <-c.txChan

    if message == nil {
      log.Println(""SenPoller"", ""The message is nil, break the loop"")
      break
    }

    // Convert netmessage to packet
    packet := message.WritePacket()
    packet.SetHeader()

    // Create byte buffer
    buffer := packet.GetBuffer()
    data := buffer[0:packet.GetMsgSize()]

    // Send bytes off to the internetz
    websocket.Message.Send(c.socket, data)
  }
}

func (c *Connection) parsePacket(_packet pnet.IPacket) {
  log.Println(""net.connection:"", ""Received new packet!"")
}

func (c *Connection) Close() {
  // Close channels
  close(c.txChan)
  close(c.rxChan)

  // Close the socket
  c.socket.Close()

  c.user = nil
}


server.go

package net

// 
import (
  ""log""
  ""fmt""
  ""net/http""

  ""golang.org/x/net/websocket""

  pnet ""kekocity/misc/packet""
  cmap ""kekocity/misc/concurrentmap""
  ""kekocity/data/helpers""
  ""kekocity/net/message""
)

var server *Server

type Server struct {
  port int

  connectedUsers *cmap.ConcurrentMap
}

func init() {
    server = newServer()
}

func newServer() *Server {
    return &Server{
    port: 8080,
    connectedUsers: cmap.New(),
  }
}

func Listen(_port int) {
  server.port = _port

  log.Printf(""Listening for connections on port %d!"", _port)

  http.Handle(""/ws"", websocket.Handler(clientConnection))

    err := http.ListenAndServe(fmt.Sprintf("":%d"", _port), nil)
    if err != nil {
        panic(""ListenAndServe: "" + err.Error())
    }
}

func clientConnection(clientsock *websocket.Conn) {
  packet := pnet.NewPacket()
  buffer := make([]uint8, pnet.PACKET_MAXSIZE)

  recv, err := clientsock.Read(buffer)

  if err == nil {
    copy(packet.Buffer[0:recv], buffer[0:recv])

    parseFirstMessage(clientsock, packet)
  } else {
    if err.Error() != ""EOF"" {
      log.Println(""net.server"", ""Client connection error:"", err.Error())
    }
  }
}

func parseFirstMessage(_conn *websocket.Conn, _packet *pnet.Packet) {
  _message := _packet.ToString()

  // If the first packet length is < 1 close the socket
  if len(_message) < 1 {
    _conn.Close()
    return
  }

  // Create the connection
  connection := NewConnection(_conn)

  // Authentication wrapper
  authPacket := &message.AuthMessage{}
  user, err := helpers.AuthHelper.AuthenticateUsingCredentials(_message)

  if err != nil {
    log.Fatal(""Invalid credentials!"")
    authPacket.Status = ""error""
  } else {
    // Need to check if its already logged

    authPacket.Status = ""success""

    connection.AssignToUser(user)
      connection.txChan <- authPacket

    return
  }

  // Send bad auth message and close
  connection.txChan <- authPacket
  connection.Close()
}


Full source code: github
"
41238407,"I have created pdf in serverside(golang) then I want to download that pdf thorugh the api call.I have used ajax post request. that request direct into following ExportReport handlder. but my downloaded pdf document is blank page.
There is error happen because of the Content-Length setting on request header
Error is :

 http: wrote more than the declared Content-Length
2016/12/20 14:37:39 http: multiple response.WriteHeader calls


This error broken down pdf download.please go though my code snippets.

func ExportReport(w http.ResponseWriter, r *http.Request) *core_commons.AppError {

    url := ""https://mydomainname/reporting/repository/dashboard.pdf""

    timeout := time.Duration(5) * time.Second
    cfg := &tls.Config{
        InsecureSkipVerify: true,
    }
    transport := &http.Transport{
        TLSClientConfig:       cfg,
        ResponseHeaderTimeout: timeout,
        Dial: func(network, addr string) (net.Conn, error) {
            return net.DialTimeout(network, addr, timeout)
        },
        DisableKeepAlives: true,
    }

    client := &http.Client{
        Transport: transport,
    }
    resp, err := client.Get(url)
    if err != nil {
        fmt.Println(err)
    }
    defer resp.Body.Close()

    w.Header().Set(""Content-Disposition"", ""attachment; filename=dashboard.pdf"")
    w.Header().Set(""Content-Type"", r.Header.Get(""Content-Type""))
    w.Header().Set(""Content-Length"", r.Header.Get(""Content-Length""))

    _, err = io.Copy(w, resp.Body)
    if err != nil {
        fmt.Println(err)
    }
    return nil
}


Following are the how to invoke ajax request.

$.ajax({
    type: ""POST"",
    url: '/reporting/api/report/export',
    data: JSON.stringify(payload),
    contentType: 'application/pdf',
    success: function(response, status, xhr) {
        // check for a filename
        var filename = """";
        var disposition = xhr.getResponseHeader('Content-Disposition');
        if (disposition && disposition.indexOf('attachment') !== -1) {
            var filenameRegex = /filename[^;=\n]*=((['""]).*?\2|[^;\n]*)/;
            var matches = filenameRegex.exec(disposition);
            if (matches != null && matches[1]) filename = matches[1].replace(/['""]/g, '');
        }

        var type = xhr.getResponseHeader('Content-Type');
        var blob = new Blob([response], { type: type });

        if (typeof window.navigator.msSaveBlob !== 'undefined') {
            // IE workaround for ""HTML7007: One or more blob URLs were revoked by closing the blob for which they were created. These URLs will no longer resolve as the data backing the URL has been freed.""
            window.navigator.msSaveBlob(blob, filename);
        } else {
            var URL = window.URL || window.webkitURL;
            var downloadUrl = URL.createObjectURL(blob);

            if (filename) {
                // use HTML5 a[download] attribute to specify filename
                var a = document.createElement(""a"");
                // safari doesn't support this yet
                if (typeof a.download === 'undefined') {
                    window.location = downloadUrl;
                } else {
                    a.href = downloadUrl;
                    a.download = filename;
                    document.body.appendChild(a);
                    a.click();
                }
            } else {
                window.location = downloadUrl;
            }

            setTimeout(function () { URL.revokeObjectURL(downloadUrl); }, 100); // cleanup
        }
    }
});

"
33300868,"I got this panic: 

C:\Users\loow\Desktop\USBWebserver v8.5\duplicate_submissions>go run server.go
2015/10/23 13:00:39 http: panic serving [::1]:63867: runtime error: invalid memo
ry address or nil pointer dereference
goroutine 5 [running]:
net/http.(*conn).serve.func1(0xc0820a1810, 0x3b55b8, 0xc082024040)
        c:/go/src/net/http/server.go:1287 +0xbc
main.login(0x2990058, 0xc0820d4000, 0xc0820be1c0)
        C:/Users/loow/Desktop/USBWebserver v8.5/duplicate_submissions/server.go:
27 +0x5a5
net/http.HandlerFunc.ServeHTTP(0x8326a8, 0x2990058, 0xc0820d4000, 0xc0820be1c0)
        c:/go/src/net/http/server.go:1422 +0x41
net/http.(*ServeMux).ServeHTTP(0xc082062360, 0x2990058, 0xc0820d4000, 0xc0820be1
c0)
        c:/go/src/net/http/server.go:1699 +0x184
net/http.serverHandler.ServeHTTP(0xc08200c360, 0x2990058, 0xc0820d4000, 0xc0820b
e1c0)
        c:/go/src/net/http/server.go:1862 +0x1a5
net/http.(*conn).serve(0xc0820a1810)
        c:/go/src/net/http/server.go:1361 +0xbf5
created by net/http.(*Server).Serve
        c:/go/src/net/http/server.go:1910 +0x3fd
2015/10/23 13:00:39 http: panic serving [::1]:63868: runtime error: invalid memo
ry address or nil pointer dereference
goroutine 33 [running]:
net/http.(*conn).serve.func1(0xc082114000, 0x3b55b8, 0xc082112000)
        c:/go/src/net/http/server.go:1287 +0xbc
main.login(0x2990058, 0xc0821140b0, 0xc0821200e0)
        C:/Users/loow/Desktop/USBWebserver v8.5/duplicate_submissions/server.go:
27 +0x5a5
net/http.HandlerFunc.ServeHTTP(0x8326a8, 0x2990058, 0xc0821140b0, 0xc0821200e0)
        c:/go/src/net/http/server.go:1422 +0x41
net/http.(*ServeMux).ServeHTTP(0xc082062360, 0x2990058, 0xc0821140b0, 0xc0821200
e0)
        c:/go/src/net/http/server.go:1699 +0x184
net/http.serverHandler.ServeHTTP(0xc08200c360, 0x2990058, 0xc0821140b0, 0xc08212
00e0)
        c:/go/src/net/http/server.go:1862 +0x1a5
net/http.(*conn).serve(0xc082114000)
        c:/go/src/net/http/server.go:1361 +0xbf5
created by net/http.(*Server).Serve
        c:/go/src/net/http/server.go:1910 +0x3fd
exit status 2


Whit this code: 

package main

import(
    ""fmt""
    ""net/http""
    ""html/template""
    ""log""
    ""time""
    ""crypto/md5""
    ""io""
    ""strconv""
)

func loginForm(w http.ResponseWriter, r *http.Request){

}

func login(w http.ResponseWriter, r *http.Request){
    fmt.Println(r.Method)
    if r.Method == ""GET""{
        cruTime := time.Now().Unix()
        h := md5.New()
        io.WriteString(h,strconv.FormatInt(cruTime,10))
        token := fmt.Sprintf(""%x"", h.Sum(nil))
        fmt.Println(token)
        t, err := template.ParseFiles(""templates/index.gtpl"")
        fmt.Println(err.Error())
        err = t.Execute(w, token)
        fmt.Println(err.Error())
    } else{
        r.ParseForm()
        token := r.Form.Get(""token"")
        if token != """"{
            fmt.Println(token)
        } else{
            fmt.Println(""There is no token"")
        }
        fmt.Println(""username length: "", len(r.Form[""username""][0]))
        fmt.Println(""username: "", template.HTMLEscapeString(r.Form.Get(""username"")))
        fmt.Println(""password: "", template.HTMLEscapeString(r.Form.Get(""password"")))
        template.HTMLEscape(w, []byte(r.Form.Get(""username"")))

    }
}

func main(){
    http.HandleFunc(""/"", loginForm)
    http.HandleFunc(""/login"", login)
    err := http.ListenAndServe("":9090"", nil)
    if err != nil {
        log.Fatal(""ListenAndServe: "", err)
    }
}


I cant fix it, I tried everything what I found in the stackoverflow. What is the problem? There is no error, and the panic said that the problem in t, err := template.ParseFiles(""templates/index.gtpl"")..

There is the template file:

Football
Basketball
Tennis
Username: 
Password: 



"
23897327,"Turning my comment into an answer:

For some reason OpenGL often requires everything run in the same OS thread. time.Tick and time.After call different runtime functions and one may be causing different opengl calls to run in separate threads. By default, Go makes does not guarantee a goroutine runs on a specific thread.

To fix this, you need to use runtime.LockOSThread. This will ensure that goroutine and only that goroutine ever run on the current thread.

You can read more on the topic here: https://groups.google.com/forum/#!topic/golang-nuts/5Pvv1Gr1eoo
"
43829022,"I've already changed many times the port number on the server and client, but the server always get the incorrect port number.

when I execute the client the server will log this:
2017/05/07 15:06:07 grpc: Server.Serve failed to complete security handshake from ""127.0.0.1:32763"": remote error: tls: bad certificate
and on the client side, i got this:
2017/05/07 15:06:07 Failed to dial localhost:8070: connection error: desc = ""transport: x509: certificate is not valid for any names, but wanted to match localhost:8070""; please retry.
rpc error: code = Internal desc = connection error: desc = ""transport: x509: certificate is not valid for any names, but wanted to match localhost:8070""

I have this code for the server.go

func serve() {
    addr := ""localhost:8070""
    crt, key := certificate.CreatePemKey()
    certificate, err := tls.X509KeyPair(crt, key)
    if err != nil {
        fmt.Println(err)
    }

    certPool := x509.NewCertPool()
    ca, err := ioutil.ReadFile(""F:/GIAG3.crt"")
    if err != nil {
        fmt.Println(err)
    }

    if ok := certPool.AppendCertsFromPEM(ca); !ok {
        fmt.Println(""unable to append certificate"")
    }

    lis, err := net.Listen(""tcp"", addr)
    if err != nil {
        fmt.Println(""could not list on %s: %s"", addr, err)
    }

    // Create the TLS credentials
    creds := credentials.NewTLS(&tls.Config{
        ClientAuth:   tls.RequireAndVerifyClientCert,
        Certificates: []tls.Certificate{certificate},
        ClientCAs:    certPool,
    })

    srv := grpc.NewServer(grpc.Creds(creds))
    pb.RegisterPingerServer(srv, &server{})

    if err := srv.Serve(lis); err != nil {
        fmt.Println(""grpc serve error: %s"", err)
    }
}


and this is for the client.go

func testDial2() {
    addr := ""localhost:8070""
    crt, key := certificate.CreatePemKey()
    certificate, err := tls.X509KeyPair(crt, key)
    if err != nil {
        fmt.Println(err)
    }

    certPool := x509.NewCertPool()
    ca, err := ioutil.ReadFile(""F:/GIAG3.crt"")
    if err != nil {
        fmt.Println(err)
    }

    if ok := certPool.AppendCertsFromPEM(ca); !ok {
        fmt.Println(""unable to append certificate"")
    }

    creds := credentials.NewTLS(&tls.Config{
        ServerName:   addr,
        Certificates: []tls.Certificate{certificate},
        RootCAs:      certPool,
    })

    conn, err := grpc.Dial(addr, grpc.WithTransportCredentials(creds))
    if err != nil {
        fmt.Println(err)
    }

    defer conn.Close()
    c := pb.NewPingerClient(conn)
    r, err := c.Ping(context.Background(), &pb.Payload{Message: ""Ping""})
    if err != nil {
        fmt.Println(err)
    }
    log.Printf(""%s"", r.Message)
}


this is for the CreatePemKey, it is based on this example https://golang.org/src/crypto/tls/generate_cert.go

func publicKey(priv interface{}) interface{} {
    switch k := priv.(type) {
    case *rsa.PrivateKey:
        return &k.PublicKey
    case *ecdsa.PrivateKey:
        return &k.PublicKey
    default:
        return nil
    }
}

func pemBlockForKey(priv interface{}) *pem.Block {
    switch k := priv.(type) {
    case *rsa.PrivateKey:
        return &pem.Block{Type: ""RSA PRIVATE KEY"", Bytes: x509.MarshalPKCS1PrivateKey(k)}
    case *ecdsa.PrivateKey:
        b, err := x509.MarshalECPrivateKey(k)
        if err != nil {
            fmt.Fprintf(os.Stderr, ""Unable to marshal ECDSA private key: %v"", err)
            os.Exit(2)
        }
        return &pem.Block{Type: ""EC PRIVATE KEY"", Bytes: b}
    default:
        return nil
    }
}

func CreatePemKey() (certpem, keypem []byte) {
    priv, _ := rsa.GenerateKey(rand.Reader, 2048)
    notBefore := time.Now()
    notAfter := notBefore.AddDate(1, 0, 0)
    serialNumberLimit := new(big.Int).Lsh(big.NewInt(1), 128)
    serialNumber, _ := rand.Int(rand.Reader, serialNumberLimit)

    template := x509.Certificate{
        SerialNumber: serialNumber,
        Subject: pkix.Name{
            Organization: []string{""Acme Co""},
        },
        NotBefore:             notBefore,
        NotAfter:              notAfter,
        KeyUsage:              x509.KeyUsageKeyEncipherment | x509.KeyUsageDigitalSignature,
        ExtKeyUsage:           []x509.ExtKeyUsage{x509.ExtKeyUsageServerAuth},
        BasicConstraintsValid: true,
    }
    // template.IPAddresses = append(template.IPAddresses, net.ParseIP(""localhost""))
    template.IsCA = true
    derbytes, _ := x509.CreateCertificate(rand.Reader, &template, &template, publicKey(priv), priv)
    certpem = pem.EncodeToMemory(&pem.Block{Type: ""CERTIFICATE"", Bytes: derbytes})
    keypem = pem.EncodeToMemory(pemBlockForKey(priv))
    return certpem, keypem
}


BTW the GIAG3.crt is came from here https://pki.goog/

Please help me, thanks
"
30983231,"I have built an API with Golang and MongoDB, but the complete code is just in one file. I want to split the code according to the MVC pattern, where directories are controllers, models and views. Can anyone help me?

My code is here:

package main

import (
    ""encoding/json""
    ""log""
    ""net/http""

    ""time""

    ""github.com/gorilla/mux""
    ""gopkg.in/mgo.v2""
    ""gopkg.in/mgo.v2/bson""
)

var (
    session    *mgo.Session
    collection *mgo.Collection
    err        error
)

type Note struct {
    Id          bson.ObjectId `bson:""_id"" json:""id""`
    Title       string        `json:""title""`
    Description string        `json:""description""`
    CreatedOn   time.Time     `json:""craetedOn""`
}
type NoteResource struct {
    Note Note `json:""note""`
}
type NotesResource struct {
    Notes []Note `json:""notes""`
}

func CreateNoteHandler(w http.ResponseWriter, r *http.Request) {
    var noteResource NoteResource

    err := json.NewDecoder(r.Body).Decode(&noteResource)
    if err != nil {
        panic(err)
    }
    note := noteResource.Note
    //get a new Id
    obj_id := bson.NewObjectId()
    note.Id = obj_id
    note.CreatedOn = time.Now()

    //Insert into document collection
    err = collection.Insert(&note)
    if err != nil {
        panic(err)
    } else {
        log.Printf(""Inserted New Record with Title :%s"", note.Title)
    }
    j, err := json.Marshal(NoteResource{Note: note})
    if err != nil {
        panic(err)
    }
    w.Header().Set(""Content-Type"", ""application/json"")
    w.Write(j)
}
func NotesHandler(w http.ResponseWriter, r *http.Request) {
    var notes []Note
    iter := collection.Find(nil).Iter()
    result := Note{}
    for iter.Next(&result) {
        notes = append(notes, result)
    }
    w.Header().Set(""Content-Type"", ""application/json"")
    j, err := json.Marshal(NotesResource{Notes: notes})
    if err != nil {
        panic(err)
    }
    w.Write(j)
}
func UpdateNoteHanlder(w http.ResponseWriter, r *http.Request) {
    var err error
    //get id from incoming url
    vars := mux.Vars(r)
    id := bson.ObjectIdHex(vars[""id""])
    //decode the incoming Note into json
    var noteResource NoteResource
    err = json.NewDecoder(r.Body).Decode(&noteResource)
    if err != nil {
        panic(err)
    }
    //partial update on mongodb
    err = collection.Update(bson.M{""_id"": id},
        bson.M{""$set"": bson.M{
            ""title"":      noteResource.Note.Title,
            ""decription"": noteResource.Note.Description,
        }})
    if err == nil {
        log.Printf(""Updated Note : %s"", id, noteResource.Note.Title)
    } else {
        panic(err)
    }
    w.WriteHeader(http.StatusNoContent)
}
func DeleteNoteHandler(w http.ResponseWriter, r *http.Request) {
    var err error
    vars := mux.Vars(r)
    id := vars[""id""]
    //Remove from database
    err = collection.Remove(bson.M{""_id"": bson.ObjectIdHex(id)})
    if err != nil {
        log.Printf(""Could not find the Note %s to delete"", id)
    }
    w.WriteHeader(http.StatusNoContent)
}
func main() {
    var err error
    r := mux.NewRouter()
    r.HandleFunc(""/api/notes"", NotesHandler).Methods(""GET"")
    r.HandleFunc(""/api/notes"", CreateNoteHandler).Methods(""POST"")
    r.HandleFunc(""/api/notes/{id}"", UpdateNoteHanlder).Methods(""PUT"")
    r.HandleFunc(""/api/notes/{id}"", DeleteNoteHandler).Methods(""DELETE"")
    http.Handle(""/api/"", r)
    http.Handle(""/"", http.FileServer(http.Dir(""."")))
    log.Println(""Starting Mongodb Session"")
    session, err = mgo.Dial(""localhost"")
    if err != nil {
        panic(err)
    }
    defer session.Close()
    session.SetMode(mgo.Monotonic, true)
    collection = session.DB(""notesdb"").C(""notes"")
    log.Println(""Listening on 8080"")
    http.ListenAndServe("":8080"", nil)
}

"
36358573,"First, it is not idomatic to export a global var like that. Complex types should be  initialized by the runtime (which you are doing with main()), but retained globally from the runtime to control the disposal.  

You are also missing a db.Close().

I believe I ran I to the same issue with your pattern a few years ago when first using MySQL.  There is an oddness with the way one creates a local scoped pointer, and then assign it to a global var.  It is usually better to assign it directly to global var.  But I think the core issue is you need to assign the pointer to the pointer.

The pattern I use is to keep the testable database/sql *DB in the global state where I initialize it.  Why reinvent the wheel when the wheel works:

package main

import ( 
  ...
  ""database/sql""

  ""mypackage-that-inits-db/database""
)

var db *sql.DB

find main() {

  var err error
  db, err = database.Init_SQL(...params)
  if err != nil {
    ...
  }
  defer db.Close()

  InitUsers(db)
  InitStats(db)
  ...

  http.ListenAndServe(...)

  // now inject db global dependency in other code
  //

  globalStats := NewStatsEngine(db)
  globalStats.RecordUpdateToSomething(...)

  users := getUsers(db)

   ... etc

}


That's typically the pattern you see in other code.

Note the control over defer and Close, where it belongs here in caller.

Can't Test that easily

Also note that your code in other packages now becomes easily testable by creating a mock sql.DB object and injecting it into NewStatsEngine, getUsers, etc instead of having to mock a global var, test, tear down and setup again for test test, test, teardown, etc.  Also since Go 1.5, tests could be run concurrently so you'll even need to put a mutex.Lock around your global DB var if you leave your package like that.  Switching to a IoC pattern, like Dependency Injection which I demo'd in the code above, makes so much easier to test (and debug) your code.
"
33768554,"I am a bit new to Go and especially new to pointers (coming from python) so bare with me a bit here. I am trying to build a Query struct that will represent data to and from our Cassandra database.

The issue is, I am trying to take a Type as one of my fields in the struct so I can reconstruct it later. I feel like I am really close, but it is giving me some issues. I get a really nasty looking error trying to do this:

2015/11/17 15:42:22 http: panic serving 127.0.0.1:57962: reflect: NumField of non-struct type
goroutine 34 [running]:
net/http.(*conn).serve.func1(0xc820184000, 0x7f36d7459b00, 0xc820180008)
    /usr/lib/go/src/net/http/server.go:1287 +0xb5
reflect.(*rtype).NumField(0x790820, 0xc8200b9a60)
    /usr/lib/go/src/reflect/type.go:660 +0x7b
github.com/relops/cqlr.(*Binding).compile(0xc82004f6f0, 0x77ab60, 0xc8200b9a60, 0x16, 0xc820194140, 0x5, 0x5, 0x0, 0x0)
    /home/jared/dev/go-pp/src/github.com/relops/cqlr/cqlr.go:160 +0xf8
github.com/relops/cqlr.(*Binding).Scan(0xc82004f6f0, 0x77ab60, 0xc8200b9a60, 0x825280)
    /home/jared/dev/go-pp/src/github.com/relops/cqlr/cqlr.go:99 +0x199
main/cassandra/query.Query.RetryingQuery(0x9325e0, 0x19, 0x0, 0x0, 0x0, 0x0, 0x7f36d74580a8, 0x87b120, 0x0, 0x0, ...)
    /home/jared/dev/go-pp/src/main/cassandra/query/query.go:39 +0x39e
main.ViewHosts(0x7f36d7459f88, 0xc8200e73f0, 0xc82018e000)
    /home/jared/dev/go-pp/src/main/handlers.go:86 +0x1f3
net/http.HandlerFunc.ServeHTTP(0x9a03b0, 0x7f36d7459f88, 0xc8200e73f0, 0xc82018e000)
    /usr/lib/go/src/net/http/server.go:1422 +0x3a
main/utils.Logger.func1(0x7f36d7459f88, 0xc8200e73f0, 0xc82018e000)
    /home/jared/dev/go-pp/src/main/utils/logger.go:32 +0x9c
net/http.HandlerFunc.ServeHTTP(0xc820109200, 0x7f36d7459f88, 0xc8200e73f0, 0xc82018e000)
    /usr/lib/go/src/net/http/server.go:1422 +0x3a
github.com/gorilla/mux.(*Router).ServeHTTP(0xc82001aa00, 0x7f36d7459f88, 0xc8200e73f0, 0xc82018e000)
    /home/jared/dev/go-pp/src/github.com/gorilla/mux/mux.go:100 +0x29e
net/http.serverHandler.ServeHTTP(0xc82016b1a0, 0x7f36d7459f88, 0xc8200e73f0, 0xc82018e000)
    /usr/lib/go/src/net/http/server.go:1862 +0x19e
net/http.(*conn).serve(0xc820184000)
    /usr/lib/go/src/net/http/server.go:1361 +0xbee
created by net/http.(*Server).Serve
    /usr/lib/go/src/net/http/server.go:1910 +0x3f6


Here is the code

type Query struct {
    query       string
    values      interface{}
    attempts    int
    maxAttempts int
    structType  reflect.Type
}

func NewQuery(query string, t reflect.Type) (q Query) {
    q.query = query
    q.structType = t
    return
}

func (query Query) RetryingQuery() (results []interface{}) {
    var q *gocql.Query
    if query.values != nil {
        q = c.Session.Query(query.query, query.values)
    } else {
        q = c.Session.Query(query.query)
    }

    bindQuery := cqlr.BindQuery(q)

    value := reflect.New(query.structType).Pointer()
    for bindQuery.Scan(&value) {
        results = append(results, value)
    }
    return
}


// setting up and calling the query here (in another file)
var host cmodels.Host
query := query.NewQuery(""SELECT * FROM server.host"", reflect.TypeOf(host))
queryResults := query.RetryingQuery()


However, with slight modification of the code I get past the error but I am getting a weird result.

func (query Query) RetryingQuery() (results []interface{}) {
    var q *gocql.Query
    if query.values != nil {
        q = c.Session.Query(query.query, query.values)
    } else {
        q = c.Session.Query(query.query)
    }

    bindQuery := cqlr.BindQuery(q)
    value := reflect.New(query.structType)
    for bindQuery.Scan(&value) {
        results = append(results, value)
    }
    return
}


That code above gives me:

[{""flag"":22},{""flag"":22},{""flag"":22},{""flag"":22},{""flag"":22},...]

"
43015259,"For university, I had to implement a bank transfer simulation in Java. Having done that, I wanted to implement it in Go, because I heard a lot about Go's concurrency capabilities and wanted to try them out.

I have two parties, foo and bar. Each party has a list of bank accounts with a balance and a number for identification. Every of foo's accounts should transfer a certain amount to one of bar's accounts. Those transfers should be split up in smaller and less suspicious transfers, transferring one unit repeatedly  until the whole amount was transferred. At the same time, bar is  transferring the same amount back to foo, so that the sum of foo's and bar's accounts, respectively, should be the same at the beginning and at the end.

Here's my Account struct:

type Account struct {
    Owner string
    Number int
    Balance int
}

func NewAccount(owner string, number int, balance int) *Account {
    account := &Account{Owner: owner, Number: number, Balance: balance}
    return account
}

func (account Account) String() string {
    return fmt.Sprintf(""%s-%04d"", account.Owner, account.Number)
}


This is the function/method the account has to run in order to receive payments (I implemented outgoing payments as payments of negative amounts):

func (account *Account) Listen(channel <-chan int) {
    for amount := range channel {
        account.Balance += amount
    }
}


And here's my Transfer struct:

type Transfer struct {
    Source *Account
    Target *Account
    Amount int
}

func NewTransfer(source *Account, target *Account, amount int) *Transfer {
    transfer := Transfer{Source: source, Target: target, Amount: amount}
    return &transfer
}

func (transfer Transfer) String() string {
    return fmt.Sprintf(""Transfer from [%s] to [%s] with amount CHF %4d.-"",
        transfer.Source, transfer.Target, transfer.Amount)
}


Here's the function/method that performs the payment in a bunch of micro payments over a channel to each account:

func (transfer Transfer) Execute(status chan<- string) {
    const PAYMENT = 1
    sourceChannel := make(chan int)
    targetChannel := make(chan int)
    go transfer.Source.Listen(sourceChannel)
    go transfer.Target.Listen(targetChannel)
    for paid := 0; paid < transfer.Amount; paid += PAYMENT {
        sourceChannel <- -PAYMENT
        targetChannel <- +PAYMENT
    }
    close(sourceChannel)
    close(targetChannel)
    status <- fmt.Sprintf(""transfer done: %s"", transfer)
}


And, finally, here's the actual program:

func main() {
    const ACCOUNTS = 25
    const TRANSFERS = ACCOUNTS * 2
    const AMOUNT = 5000
    const BALANCE = 9000

    fooStartBalance := 0
    barStartBalance := 0
    fooAccounts := [ACCOUNTS]*Account{}
    barAccounts := [ACCOUNTS]*Account{}
    for i := 0; i < ACCOUNTS; i++ {
        fooAccounts[i] = NewAccount(""foo"", i + 1, BALANCE)
        fooStartBalance += fooAccounts[i].Balance
        barAccounts[i] = NewAccount(""bar"", i + 1, BALANCE)
        barStartBalance += barAccounts[i].Balance
    }

    fooToBarTransfers := [ACCOUNTS]*Transfer{}
    barToFooTransfers := [ACCOUNTS]*Transfer{}
    for i := 0; i < ACCOUNTS; i++ {
        fooToBarTransfers[i] = NewTransfer(fooAccounts[i], barAccounts[i], AMOUNT)
        barToFooTransfers[i] = NewTransfer(barAccounts[i], fooAccounts[i], AMOUNT)
    }

    status := make(chan string)
    for i := 0; i < ACCOUNTS; i++ {
        go fooToBarTransfers[i].Execute(status)
        go barToFooTransfers[i].Execute(status)
    }

    for i := 0; i < TRANSFERS; i++ {
        fmt.Printf(""%2d. %s\n"", i + 1, <-status)
    }
    close(status)
    fooEndBalance := 0
    barEndBalance := 0
    for i := 0; i < ACCOUNTS; i++ {
        fooEndBalance += fooAccounts[i].Balance
        barEndBalance += barAccounts[i].Balance
    }

    fmt.Printf(""Start: foo: %4d, bar: %4d\n"", fooStartBalance, fooStartBalance)
    fmt.Printf(""  End: foo: %4d, bar: %4d\n"", fooEndBalance, fooEndBalance)
}


As the stdout shows, all the transfers have been done at the end:

 1. transfer done: Transfer from [bar-0011] to [foo-0011] with amount CHF 5000.-
[other 48 transfers omitted]
50. transfer done: Transfer from [bar-0013] to [foo-0013] with amount CHF 5000.-


But money is either created:

Start: foo: 225000, bar: 225000
  End: foo: 225053, bar: 225053


Or lost:

Start: foo: 225000, bar: 225000
  End: foo: 225053, bar: 225053


So I thought (with my Java mindset) that the problem might be Account.Listen(): maybe Balance is read by Goroutine A, then comes Goroutine B, executing Account.Listen() completely, then Goroutine A goes ahead doing the calculation with the old value. A mutex might fix it:

type Account struct {
    Owner string
    Number int
    Balance int
    Mutex sync.Mutex
}

func (account *Account) Listen(channel <-chan int) {
    for amount := range channel {
        account.Mutex.Lock()
        account.Balance += amount
        account.Mutex.Unlock()
    }
}


Which works great... nine ouf of ten times. But then:

Start: foo: 225000, bar: 225000
  End: foo: 225001, bar: 225001


This is very strange. The mutex seems to help, because it works most of the time, and when it doesn't work, it's only off by one. I really don't get at what other place synchronization might be an issue. 

Update: I am no able to prevent data race warnings when I implement Account as follows:

type Account struct {
    sync.Mutex
    Owner string
    Number int
    Balance int
}

func NewAccount(owner string, number int, balance int) *Account {
    account := &Account{Owner: owner, Number: number, Balance: balance}
    return account
}

func (account *Account) String() string {
    return fmt.Sprintf(""%s-%04d"", account.Owner, account.Number)
}

func (account *Account) Listen(channel <-chan int) {
    for amount := range channel {
        account.Lock()
        account.Balance += amount
        account.Unlock()
    }
}

func (account *Account) GetBalance() int {
    account.Lock()
    newBalance := account.Balance
    defer account.Unlock()
    return newBalance
}


And I also access the Balance at the end like this:

fooEndBalance += fooAccounts[i].GetBalance()
barEndBalance += barAccounts[i].GetBalance()


As I said, the data race detecter now stays silent, but I still got some errors in roughly every 10th run:

Start: foo: 100000, bar: 100000
  End: foo: 99999, bar: 99999


I really don't get what I'm doing wrong.
"
33446194,"The request is getting an error which you're just ignoring and then you get a nil pointer dereference when you attempt to access the response status in the Printf on the next line.

Here is your example printing the error; http://play.golang.org/p/V8BCrM_Ag7

Every request gets this; Get http://mickle.com.au/wp-content/uploads/2015/03/11222.jpg: dial tcp: Protocol not available

Basically, you need to assign the error to something and check it before you allow execution to continue. The common syntax would look like this;

if response, err := client.Do(req); err != nil {
   // handles error and return
}

"
30499024,"Following link has the answer

https://groups.google.com/d/msg/google-appengine-go/mGuMV4tVR0U/A3qaCau7zY4J

Briefly, the reason is


  ""cgo"" is not supported on classic App Engine.  If you want to build your app, you will need to use Go on Managed VMs (""vm: true"" in your app.yaml).
  Please see https://cloud.google.com/appengine/docs/go/managed-vms/ for more information.

"
37205971,"The code below reads its values from this file:

2 3\n
1.0 2.0 3.0\n
-1.0 -2.0 -3.0\n


And should print:
[ {1 2 3}, {-1 -2 -3} ]

But instead I get this:

[{2 [31 2 3]} {0 []}] strconv.ParseFloat: parsing ""3.0-1.0"": invalid syntax

It seems that the reader.ReadLine() stays at the same location. Is there a simpler way to scan lines, then values inside each line?

package main

import (
    ""bufio""
    ""bytes""
    ""fmt""
    ""os""
    ""strconv""
    ""strings""
)

type Example struct {
    classLabel int
    attributes []float64
}

func NewExample(classLabel int, attributes []float64) *Example {
    return &Example{classLabel, attributes}
}

func readFile(path string) ([]Example, error) {

    var (
        result       []Example
        err          error
        file         *os.File
        part         []byte
        size         int
        attributeNum int
    )

    if file, err = os.Open(path); err != nil {
        return result, err
    }
    defer file.Close()

    reader := bufio.NewReader(file)
    buffer := bytes.NewBuffer(make([]byte, 0))

    if part, _, err = reader.ReadLine(); err != nil {
        return result, err
    }
    buffer.Write(part)
    newLine := buffer.String()
    fmt.Println(""newLine="" + newLine)

    r := strings.NewReader(newLine)
    scanner := bufio.NewScanner(r)
    scanner.Split(bufio.ScanWords)

    if scanner.Scan() {
        size, err = strconv.Atoi(scanner.Text())
        if err != nil {
            return result, err
        }
    }
    fmt.Println(""size="" + strconv.Itoa(size))

    if scanner.Scan() {
        attributeNum, err = strconv.Atoi(scanner.Text())
        if err != nil {
            return result, err
        }
    }
    fmt.Println(""attributeNum="" + strconv.Itoa(attributeNum))

    result = make([]Example, size)

    var classLabel int
    var attributes []float64

    for k := 0; k < size; k++ {
        if part, _, err = reader.ReadLine(); err != nil {
            return result, err
        }
        buffer.Write(part)
        newLine := buffer.String()
        fmt.Println(""newLine="" + newLine)

        r := strings.NewReader(newLine)
        scanner := bufio.NewScanner(r)
        scanner.Split(bufio.ScanWords)

        if scanner.Scan() {
            classLabel, err = strconv.Atoi(scanner.Text())
            if err != nil {
                return result, err
            }
        }
        fmt.Println(""classLabel="" + strconv.Itoa(classLabel))

        for i := 0; i < attributeNum; i++ {
            var attribute float64
            if scanner.Scan() {
                attribute, err = strconv.ParseFloat(scanner.Text(), 64)
                if err != nil {
                    return result, err
                }
                attributes = append(attributes, attribute)
                fmt.Println(""attribute="" + strconv.FormatFloat(attribute, 'f', -1, 64))
            }
        }
        result[k] = *NewExample(classLabel, attributes)
    }

    return result, scanner.Err()
}

func main() {
    example, err := readFile(""test.txt"")
    fmt.Println(example, err)
}

"
41559026,"Hi am trying to set a global event hook in go but i dont get the event handle or any error message , kindly help , below is code , from my code below i expected to get error message from SetWinEventHook if any but it just blocks at Logger.Println(""procSetWinEventHook S"") please not that i have not included my custo Logger but thats not a blocker.

  package main

import(
    ""fmt""
    ""syscall""
    ""unsafe""
    ""log""
    ""golang.org/x/sys/windows""
)

var(
    user32 = windows.NewLazyDLL(""user32.dll"")
    modkernel32 = windows.NewLazyDLL(""kernel32.dll"")

    procSetWinEventHook     = user32.NewProc(""SetWinEventHook"")
    procUnhookWinEvent      = user32.NewProc(""UnhookWinEvent"")
    procGetMessage = user32.NewProc(""GetMessageW"")
    procTranslateMessage = user32.NewProc(""TranslateMessage"")
    procDispatchMessage = user32.NewProc(""DispatchMessageW"")

    procGetModuleHandle            = modkernel32.NewProc(""GetModuleHandleW"")

    ActiveWinEventHook WINEVENTPROC = func (hWinEventHook HWINEVENTHOOK, event uint32, hwnd HWND, idObject int32, idChild int32, idEventThread uint32, dwmsEventTime uint32)  {
        log.Println(""fond"")

    }

)

type WINEVENTPROC func(hWinEventHook HWINEVENTHOOK, event uint32, hwnd HWND, idObject int32, idChild int32, idEventThread uint32, dwmsEventTime uint32) uintptr

type (
    HANDLE          uintptr
    HINSTANCE       HANDLE
    HHOOK       HANDLE
    HMODULE     HANDLE
    HWINEVENTHOOK HANDLE
    DWORD           uint32
    INT           int
    WPARAM           uintptr
    LPARAM uintptr
    LRESULT uintptr
    HWND HANDLE
    UINT uint32
    BOOL int32
    ULONG_PTR uintptr
    LONG                  int32
    LPWSTR                *WCHAR
    WCHAR                 uint16
)

type POINT struct {
    X, Y int32
}

type MSG struct {
    Hwnd    HWND
    Message uint32
    WParam  uintptr
    LParam  uintptr
    Time    uint32
    Pt      POINT
}


const (
    //~ EVENT_SYSTEM_FOREGROUND DWORD = 0x0003
    //~ WINEVENT_OUTOFCONTEXT  DWORD = 0x0000
    //~ WINEVENT_INCONTEXT   = 0x0004
    EVENT_SYSTEM_FOREGROUND  = 3
    WINEVENT_OUTOFCONTEXT   = 0
    WINEVENT_INCONTEXT   = 4
    WINEVENT_SKIPOWNPROCESS   = 2
    WINEVENT_SKIPOWNTHREAD   = 1
)

func main() {

    log.Println(""starting"")
    hinst := GetModuleHandle("""")
    fmt.Println(hinst)

    winEvHook := SetWinEventHook(EVENT_SYSTEM_FOREGROUND, EVENT_SYSTEM_FOREGROUND, 0 , ActiveWinEventHook, 0, 0, WINEVENT_OUTOFCONTEXT|WINEVENT_SKIPOWNPROCESS )
    log.Println(""Windows Event Hook: "")
    log.Println(""Windows Event Hook: "", winEvHook)

    for {

        var msg MSG
        if m := GetMessage(&msg, 0, 0, 0); m != 0 {
            TranslateMessage(&msg)
            DispatchMessage(&msg)
       }
    }
    UnhookWinEvent(winEvHook)
    return

}


func SetWinEventHook(eventMin DWORD, eventMax DWORD, hmodWinEventProc HMODULE, pfnWinEventProc WINEVENTPROC, idProcess DWORD, idThread DWORD, dwFlags DWORD) HWINEVENTHOOK {
    log.Println(""procSetWinEventHook S"")
    ret, ret2 , err := procSetWinEventHook.Call(
        uintptr(eventMin),
        uintptr(eventMax),
        uintptr(hmodWinEventProc),
        pfnWinEventProcCallback,
        uintptr(idProcess),
        uintptr(idThread),
        uintptr(dwFlags),
    )

    log.Printf(""%#v"", err)
    log.Printf(""%#v"", ret)
    log.Printf(""%#v"", ret2)
    log.Println(""procSetWinEventHook E"")
    return HWINEVENTHOOK(ret)
}

func UnhookWinEvent(hWinEventHook HWINEVENTHOOK) bool {
    ret, _, _ := procUnhookWinEvent.Call(
        uintptr(hWinEventHook),
    )
    return ret != 0
}

func GetModuleHandle(modulename string) HINSTANCE {
    var mn uintptr
    if modulename == """" {
        mn = 0
    } else {
        mn = uintptr(unsafe.Pointer(syscall.StringToUTF16Ptr(modulename)))
    }
    ret, _, _ := procGetModuleHandle.Call(mn)
    return HINSTANCE(ret)
}

func GetMessage(msg *MSG, hwnd HWND, msgFilterMin UINT, msgFilterMax UINT) int {
    ret, _, _ := procGetMessage.Call(
        uintptr(unsafe.Pointer(msg)),
        uintptr(hwnd),
        uintptr(msgFilterMin),
        uintptr(msgFilterMax))

    return int(ret)
}

func TranslateMessage(msg *MSG) bool {
    ret, _, _ := procTranslateMessage.Call(
        uintptr(unsafe.Pointer(msg)))
    return ret != 0
}

func DispatchMessage(msg *MSG) uintptr {
    ret, _, _ := procDispatchMessage.Call(
        uintptr(unsafe.Pointer(msg)))
    return ret
}

"
39334209,"I figured it out. The issue was I saved a file in my project in an intermediate state.

package whatever

import (
    """"
)


govendor was complaining the import statement was empty. 
"
20655702,"I'm trying to sign a string and later on verifying it with the public key. My verified result is empty. What am I doing wrong?

    package main

import (
    ""crypto""
    ""crypto/rand""
    ""crypto/rsa""
    ""crypto/sha256""
    ""crypto/x509""
    ""encoding/base64""
    ""encoding/pem""
    ""errors""
    ""fmt""
    ""io/ioutil""
)

func main() {
    signer, err := loadPrivateKey(""private.pem"");
    if err != nil {
        fmt.Errorf(""signer is damaged: %v"", err)
    }

    toSign := ""date: Thu, 05 Jan 2012 21:31:40 GMT"";

    signed, err := signer.Sign([]byte(toSign))
    if err != nil {
        fmt.Errorf(""could not sign request: %v"", err)
    }
    sig := base64.StdEncoding.EncodeToString(signed)
    fmt.Printf(""Encoded: %v\n"", sig)


    parser, perr := loadPublicKey(""public.pem"");
    if perr != nil {
        fmt.Errorf(""could not sign request: %v"", err)
    }
    unsigned, err := parser.Unsign(signed);
     if err != nil {
        fmt.Errorf(""could not sign request: %v"", err)
    }

    fmt.Printf(""Decrypted: %v\n"", base64.StdEncoding.EncodeToString(unsigned))    
}


// loadPrivateKey loads an parses a PEM encoded private key file.
func loadPublicKey(path string) (Unsigner, error) {
        data, err := ioutil.ReadFile(path)

        if err != nil {
                return nil, err
        }
        return parsePublicKey(data)
}

// parsePublicKey parses a PEM encoded private key.
func parsePublicKey(pemBytes []byte) (Unsigner, error) {
        block, _ := pem.Decode(pemBytes)
        if block == nil {
                return nil, errors.New(""ssh: no key found"")
        }

        var rawkey interface{}
        switch block.Type {
        case ""PUBLIC KEY"":
                rsa, err := x509.ParsePKIXPublicKey(block.Bytes)
                if err != nil {
                        return nil, err
                }
                rawkey = rsa
        default:
                return nil, fmt.Errorf(""ssh: unsupported key type %q"", block.Type)
        }

        return newUnsignerFromKey(rawkey)
}


// loadPrivateKey loads an parses a PEM encoded private key file.
func loadPrivateKey(path string) (Signer, error) {
        data, err := ioutil.ReadFile(path)
        if err != nil {
                return nil, err
        }
        return parsePrivateKey(data)
}

// parsePublicKey parses a PEM encoded private key.
func parsePrivateKey(pemBytes []byte) (Signer, error) {
        block, _ := pem.Decode(pemBytes)
        if block == nil {
                return nil, errors.New(""ssh: no key found"")
        }

        var rawkey interface{}
        switch block.Type {
        case ""RSA PRIVATE KEY"":
                rsa, err := x509.ParsePKCS1PrivateKey(block.Bytes)
                if err != nil {
                        return nil, err
                }
                rawkey = rsa
        default:
                return nil, fmt.Errorf(""ssh: unsupported key type %q"", block.Type)
        }
        return newSignerFromKey(rawkey)
}

// A Signer is can create signatures that verify against a public key.
type Signer interface {
        // Sign returns raw signature for the given data. This method
        // will apply the hash specified for the keytype to the data.
        Sign(data []byte) ([]byte, error)
}

// A Signer is can create signatures that verify against a public key.
type Unsigner interface {
        // Sign returns raw signature for the given data. This method
        // will apply the hash specified for the keytype to the data.
        Unsign(data []byte) ([]byte, error)
}

func newSignerFromKey(k interface{}) (Signer, error) {
        var sshKey Signer
        switch t := k.(type) {
        case *rsa.PrivateKey:
                sshKey = &rsaPrivateKey{t}
        default: 
                return nil, fmt.Errorf(""ssh: unsupported key type %T"", k)
        }
        return sshKey, nil
}

func newUnsignerFromKey(k interface{}) (Unsigner, error) {
        var sshKey Unsigner
        switch t := k.(type) {
        case *rsa.PublicKey:
                sshKey = &rsaPublicKey{t}
        default:
                return nil, fmt.Errorf(""ssh: unsupported key type %T"", k)
        }
        return sshKey, nil
}

type rsaPublicKey struct {
    *rsa.PublicKey
}

type rsaPrivateKey struct {
        *rsa.PrivateKey
}

// Sign signs data with rsa-sha256
func (r *rsaPrivateKey) Sign(data []byte) ([]byte, error) {
        h := sha256.New()
        h.Write(data)
        d := h.Sum(nil)
        return rsa.SignPKCS1v15(rand.Reader, r.PrivateKey, crypto.SHA256, d)
}

// Unsign encrypts data with rsa-sha256
func (r *rsaPublicKey) Unsign(message []byte) ([]byte, error) {  
        return rsa.EncryptPKCS1v15(rand.Reader, r.PublicKey, message)        
}


private.pem looks like this:

-----BEGIN RSA PRIVATE KEY-----
MIICXgIBAAKBgQDCFENGw33yGihy92pDjZQhl0C36rPJj+CvfSC8+q28hxA161QF
NUd13wuCTUcq0Qd2qsBe/2hFyc2DCJJg0h1L78+6Z4UMR7EOcpfdUE9Hf3m/hs+F
UR45uBJeDK1HSFHD8bHKD6kv8FPGfJTotc+2xjJwoYi+1hqp1fIekaxsyQIDAQAB
AoGBAJR8ZkCUvx5kzv+utdl7T5MnordT1TvoXXJGXK7ZZ+UuvMNUCdN2QPc4sBiA
QWvLw1cSKt5DsKZ8UETpYPy8pPYnnDEz2dDYiaew9+xEpubyeW2oH4Zx71wqBtOK
kqwrXa/pzdpiucRRjk6vE6YY7EBBs/g7uanVpGibOVAEsqH1AkEA7DkjVH28WDUg
f1nqvfn2Kj6CT7nIcE3jGJsZZ7zlZmBmHFDONMLUrXR/Zm3pR5m0tCmBqa5RK95u
412jt1dPIwJBANJT3v8pnkth48bQo/fKel6uEYyboRtA5/uHuHkZ6FQF7OUkGogc
mSJluOdc5t6hI1VsLn0QZEjQZMEOWr+wKSMCQQCC4kXJEsHAve77oP6HtG/IiEn7
kpyUXRNvFsDE0czpJJBvL/aRFUJxuRK91jhjC68sA7NsKMGg5OXb5I5Jj36xAkEA
gIT7aFOYBFwGgQAQkWNKLvySgKbAZRTeLBacpHMuQdl1DfdntvAyqpAZ0lY0RKmW
G6aFKaqQfOXKCyWoUiVknQJAXrlgySFci/2ueKlIE1QqIiLSZ8V8OlpFLRnb1pzI
7U1yQXnTAEFYM560yJlzUpOb1V4cScGd365tiSMvxLOvTA==
-----END RSA PRIVATE KEY-----


And public.pem:

-----BEGIN PUBLIC KEY-----
MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDCFENGw33yGihy92pDjZQhl0C3
6rPJj+CvfSC8+q28hxA161QFNUd13wuCTUcq0Qd2qsBe/2hFyc2DCJJg0h1L78+6
Z4UMR7EOcpfdUE9Hf3m/hs+FUR45uBJeDK1HSFHD8bHKD6kv8FPGfJTotc+2xjJw
oYi+1hqp1fIekaxsyQIDAQAB
-----END PUBLIC KEY-----


Thanks. 
"
29271263,"tl;dr: A loop that does nothing but repeat a non-blocking check until it succeeds can cause hard-to-diagnose trouble (at a minimum, it can overuse CPU); using a blocking check can fix it. 

I'm not all that sure about the details of your case; I wrote a loop like yours that consistently hangs with ""process took too long"" on the Playground, but when I run it locally it does complete.

As I commented, I'd aim for a simpler design, too.



Go only has limited pre-emption of running goroutines: the running thread only yields control to the goroutine scheduler when a blocking operation (an like I/O or channel op or waiting to take a lock) happens.

So with GOMAXPROCS=1, if the (one) running thread starts looping, nothing else will necessarily get a chance to run. 

A for { select { ...default: } } can therefore start a loop checking for items in a channel but never give up control of the main thread so that another goroutine can write an item. Other code gets to run anyway when when GOMAXPROCS is over 1, but not when it's 1 as it is on App Engine (or the Playground). The behavior depends not only on GOMAXPROCS, but on which goroutine happens to run first, which isn't necessarily defined.

To avoid that situation, remove the default: so the select is a blocking operation that yields to the scheduler when it can't receive an item, allowing other code to run. You can generalize this to other cases where you might loop doing a nonblocking check; any of them could keep resources busy constantly rechecking when a blocking call would not. When GOMAXPROCS>1 or the runtime's limited preemption saves you, polling (as repeated checking is called) can still consume more CPU than blocking.

For example, this fails with ""process took too long"" on the Playground, though annoyingly it completes reliably on my machine:

package main

import ""fmt""

func main() {
    c := make(chan struct{})
    go func() { c <- struct{}{} }()
    for {
        select {
        case <-c:
            fmt.Println(""success"")
            return
        default:
        }
    }
} 


I can't tell if there are other problems, but the hang for a pattern similar to the sample is noteworthy.
"
31107386,"The library you are using doesn't support concurrency as per https://code.google.com/p/go-sqlite/source/browse/go1/sqlite3/doc.go#29 - 


  Concurrency
  
  A single connection instance and all of its derived objects (prepared
  statements, backup operations, etc.) may NOT be used concurrently from multiple
  goroutines without external synchronization. The only exception is
  Conn.Interrupt(), which may be called from another goroutine to abort a
  long-running operation. It is safe to use separate connection instances
  concurrently, even if they are accessing the same database file.


As sqlite3 is a file-based database, the driver needs to manage concurrent access from multiple threads.

The https://github.com/mattn/go-sqlite3 library should support thread-safe operation provided your sqlite3 was compiled to do so.
"
37082839,"The Start() method should give you what you're looking for. My script to append a simple text file after my sample Go program terminated continued to run:

package main

import (
    ""os/exec""
)

func main() {
    cmd := exec.Command(""./appender.sh"")
    cmd.Start()
}

"
43725478,"I'm new to the go programming language. Trying to use gousb to access an epson receipt printer. 

So I took some example code from the repo and repurposed it a bit just to validate that I could access the printer. 

I can see the printer and enumerate the endpoints. I receive this output:

Printer found: 020.005 Receipt Printer M129C/TM-T70 (Seiko Epson Corp.)
Length of device array: 1
[0] 020.005 04b8 - 0202
  [0] Config 01 [1]
    [0]--------------[0]
    [0] Interface 00 Setup 00 [0]
      Vendor Specific Class (Vendor Specific Subclass)
      [0] [1] Endpoint #1 OUT bulk - unsynchronized data [64 0] [OUT]
      [1] [130] Endpoint #2 IN  bulk - unsynchronized data [64 0] [IN]


My understanding is that if I want to write something to the printer, I would open the endpoint that corresponds to [OUT]. Aand this is where my trouble begins.

If I use outEP, err := thePrinter.OpenEndpoint(1,0,0,0), I receive a seg fault. If I pass a 1, gousb assumes I'm trying to access endpoint 130 [IN].

So.. What do I pass as the endpoint ID to access the OUT endpoint?

Code:

package main

import (
        ""fmt""
        ""strings""

        ""github.com/kylelemons/gousb/usb""
        ""github.com/kylelemons/gousb/usbid""

        ""C""
)

func main() {
  ctx := usb.NewContext()
  defer ctx.Close()


  ctx.Debug(3)

  var thePrinter *usb.Device

  devs, _ := ctx.ListDevices(func(desc *usb.Descriptor) bool {
    if strings.Contains(usbid.Describe(desc), ""Seiko Epson Corp"") {
      fmt.Printf(""Printer found: %03d.%03d %s\n"", desc.Bus, desc.Address, usbid.Describe(desc))
      return true
    } else {
      return false
    }

  })

  fmt.Printf(""Length of device array: %d\n"", len(devs))

  for x, dev := range devs {
    fmt.Printf(""[%d] %03d.%03d %s - %s\n"", x, dev.Bus, dev.Address, dev.Vendor, dev.Product)

    for i, cfg := range dev.Configs {
      // This loop just uses more of the built-in and usbid pretty printing to list
      // the USB devices.
      fmt.Printf(""  [%d] %s [%d]\n"", i, cfg, cfg.Config)
      for j, alt := range cfg.Interfaces {
        fmt.Printf(""    [%d]--------------[%d]\n"", j, alt.Number)
        for k, iface := range alt.Setups {
          fmt.Printf(""    [%d] %s [%d]\n"", k, iface, iface.Number)
          fmt.Printf(""      %s\n"", usbid.Classify(iface))
          for l, end := range iface.Endpoints {
            fmt.Printf(""      [%d] [%d] %s [%s]\n"", l, end.Address, end, end.Direction() )
          }
        }
      }
      fmt.Printf(""    --------------\n"")
    }



    thePrinter=dev
  }

  outEP, err := thePrinter.OpenEndpoint(1,0,0,1)

  fmt.Printf(""OpenEndpoint Err: [%s]\n"", err)

  fmt.Printf(""direction: [%s] %d\n"", outEP.Info().Direction(), outEP.Info().Address)

  message := []byte(""hi there!\n"")

  _, outerr := outEP.Write(message)

  fmt.Printf(""write Err: [%s]"", outerr)

}


EDIT: I was asked to examine the error returned by OpenEndpoint prior to looking at the value of the endpoint. Here is what was returned (it was nil)

OpenEndpoint Err: [%!s()]
direction: [IN] 130
OpenEndpoint Err: [%!s()]
libusb: warning [libusb_exit] application left some devices open
write Err: [usb: write: not an OUT endpoint]
[Finished in 1.512s]


This is what I receive when I send an endpoint number of zero:

OpenEndpoint Err: [usb: unknown endpoint 00]
libusb: warning [libusb_exit] application left some devices open
panic: runtime error: invalid memory address or nil pointer dereference
[signal SIGSEGV: segmentation violation code=0x1 addr=0x20 pc=0x41e94c4]

goroutine 1 [running]:
main.main()
    /Users/.../go/src/github.com/deltasonic/epson/main.go:63 +0xcb4
exit status 2
[Finished in 0.817s]


EDIT:

I'm attempting this on a mac, Mac OS 10.12.
"
37415066,"addsales:= []Sales{Sales{
            FIRSTNAME : ""chetan"",
         LASTNAME : ""kumar"",
         AGE : 24,
          },
        }

    match := bson.M{""user.firstName"" : ""nepolean""}
    change := bson.M{""$push"":bson.M{""user.$.sales"":bson.M{""$each"":addsales}}}


    err = c.Update(match,change)
    if err !=nil{
        panic(err)      
    }else{
    fmt.Println(""success"")
    }

"
42209040,"I am quite new to go and try to learn, I am setting up an application with a gin-gonic server.
I managed to have it to work with everything in on main package, I would like to organize it better with all the apirest related in a package (which I manage) AND to split each group CRUD by file.

so in the ""main"" file of the package within the init function, I defined : 

Router := gin.New()
Router.Use(gin.Logger())
Router.Use(gin.Recovery())


and I though that I would be able in each other files of the package to use it like that : 

v1 := Router.Group(""/api/v1/todos"")
v1.Use(AuthRequired())
{
    v1.POST(""/"", CreateTodo)
    v1.GET(""/"", FetchAllTodo)
    v1.GET(""/:id"", FetchSingleTodo)
    v1.PUT(""/:id"", UpdateTodo)
    v1.DELETE(""/:id"", DeleteTodo)
}


or 

packagename.Router.Group


but none are working and I get : 


  undefined: Router in Router.Group


Stéphane
PS : I did setup a sub folder for the package and I am able to go build it if it's in one file.



I though that the solution was to declare the Router variable as *gin.Engine but while it's compiling fine, I get a panic error on the Router.Group call 

let me post some more part of code : 

maincode.go : 

package main

import (
    ""fmt""
    ""./apirest""
    ""github.com/braintree/manners""
)

func main(){
    fmt.Printf(""hello world.\n"")
    //router.Run()
    manners.ListenAndServe("":8080"", apirest.Router)
}


Then I split the apirest package in 2 files : 

apirest.go (I did manually cleanup, maybee I missed an import) : 

package apirest

import (
    ""fmt""
    ""github.com/gin-gonic/gin""
    ""github.com/braintree/manners""
    ""os""
    ""os/signal""
)

//Router pour gérer l'api
var Router *gin.Engine

/*
    MAIN FUNCTION
*/
func init() {

    Router := gin.New()
    Router.Use(gin.Logger())
    Router.Use(gin.Recovery())

    c := make(chan os.Signal, 1)
    signal.Notify(c, os.Interrupt)
    go func(){
        for sig := range c {
            // sig is a ^C, handle it
            fmt.Printf(""ctl+c catched ""+sig.String())
            manners.Close()
        }
    }()

    LoadMonitor()

}


and then the todoCRUD.go file that handle all the declaration, the todoCRUD.go and apirest.go are in the same subfolder apirest (and compile ok) : 

package apirest

import (
    ""fmt""
    ""github.com/gin-gonic/gin""
    ""gopkg.in/validator.v2""
    ""github.com/jinzhu/gorm""
    ""strconv""
    ""net/http""
    ""time""
)

//Todo definition d'un element todo
type Todo struct {
    gorm.Model
    CreatedAt   time.Time
    UpdatedAt   time.Time
    OwnerID     int    `json:""ownerid""  validate:""nonzero""`
    URL         string `json:""url""`
}

//TransformedTodo version pour le retour d'api sans certaines infos
type TransformedTodo struct {
    ID          uint   `json:""id""`
    CreatedAt   time.Time
    UpdatedAt   time.Time
    OwnerID     uint   `json:""ownerid""`
    URL         string `json:""url""`   
}

//LoadTodo permet de lancer le mappage todos
func LoadTodo(){
    v1 := Router.Group(""/api/v1/todos"")
    {
        v1.POST(""/"", CreateTodo)
        v1.GET(""/"", FetchAllTodo)
        v1.GET(""/:id"", FetchSingleTodo)
        v1.PUT(""/:id"", UpdateTodo)
        v1.DELETE(""/:id"", DeleteTodo)
    }
}

//CreateTodo génération d'un todo
func CreateTodo(c *gin.Context) {

    owner, _ := strconv.Atoi(c.PostForm(""ownerid""))
    todo := Todo{
        OwnerID: owner,
        URL: c.PostForm(""url""),
    };
    v := validator.NewValidator()
    if errs := v.Validate(todo); errs!=nil {
        errors := errs.(validator.ErrorMap)
        var errOuts []string
        for f, e := range errors {
            errOuts = append(errOuts, fmt.Sprintf(""\t - %s (%v)\n"", f, e))
        }
        //c.JSON(500, gin.H{""Error"": errs.Error()})
        c.JSON(500, gin.H{""Erreur sur le(s) champ(s) : "": errOuts})
    } else {

        db, _ := Database()
        defer db.Close()
        db.Save(&todo)

        c.JSON(http.StatusCreated, gin.H{""status"" : http.StatusCreated, ""message"" : ""Todo item created successfully!"", ""resourceId"": todo.ID})
    }
}

//FetchAllTodo récupération de tous les todos
func FetchAllTodo(c *gin.Context) {
    var todos []Todo
    var _todos []TransformedTodo

    db, _ := Database()
    defer db.Close()
    db.Find(&todos)

    if (len(todos) <= 0) {
        c.JSON(http.StatusNotFound, gin.H{""status"" : http.StatusNotFound, ""message"" : ""No todo found!""})
        return
    }

    //transforms the todos for building a good response,
    //je peux choisir des champs a ne pas display
    for _, item := range todos {
        status := false
        if (item.Status == 1) {
            status = true
        } else {
            status = false
        }
        _todos = append(_todos, TransformedTodo{ID: item.ID, URL:item.URL})
    }
    c.JSON(http.StatusOK, gin.H{""status"" : http.StatusOK, ""data"" : _todos})
}

//FetchSingleTodo Récupération d'un seul todo en fonction de son id
func FetchSingleTodo(c *gin.Context) {
    var todo Todo
    todoID := c.Param(""id"")

    db, _ := Database()
    defer db.Close()
    db.First(&todo, todoID)

    if (todo.ID == 0) {
        c.JSON(http.StatusNotFound, gin.H{""status"" : http.StatusNotFound, ""message"" : ""No todo found!""})
        return
    }

    _todo := TransformedTodo{ID: todo.ID, URL:todo.URL}
    c.JSON(http.StatusOK, gin.H{""status"" : http.StatusOK, ""data"" : _todo})
}

//UpdateTodo Mise à jour d'un todo
func UpdateTodo(c *gin.Context) {
    var todo Todo
    todoID := c.Param(""id"")
    db, _ := Database()
    defer db.Close()
    db.First(&todo, todoID)

    if (todo.ID == 0) {
        c.JSON(http.StatusNotFound, gin.H{""status"" : http.StatusNotFound, ""message"" : ""No todo found!""})
        return
    }

    db.Model(&todo).Update(""title"", c.PostForm(""title""))
    db.Model(&todo).Update(""completed"", c.PostForm(""completed""))
    c.JSON(http.StatusOK, gin.H{""status"" : http.StatusOK, ""message"" : ""Todo updated successfully!""})
}


//DeleteTodo Suppression d'un todo
func DeleteTodo(c *gin.Context) {
    var todo Todo
    todoID := c.Param(""id"")
    db, _ := Database()
    defer db.Close()
    db.First(&todo, todoID)

    if (todo.ID == 0) {
        c.JSON(http.StatusNotFound, gin.H{""status"" : http.StatusNotFound, ""message"" : ""No todo found!""})
        return
    }

    db.Delete(&todo)
    c.JSON(http.StatusOK, gin.H{""status"" : http.StatusOK, ""message"" : ""Todo deleted successfully!""})
}


The Idea is to have a xxxxCRUD.go file for each entity to handle but the whole folder in the same package.

the exact errror is : 


  PS D:\www\developpement> go run .\maincode.go [GIN-debug] [WARNING]
  Running in ""debug"" mode. Switch to ""release"" mode in production.
   - using env:   export GIN_MODE=release
   - using code:  gin.SetMode(gin.ReleaseMode)
  
  panic: runtime error: invalid memory address or nil pointer
  dereference [signal 0xc0000005 code=0x0 addr=0x0 pc=0x46cc0f]
  
  goroutine 1 [running]: panic(0x831880, 0xc04200a080)
          C:/Go/src/runtime/panic.go:500 +0x1af
  /D/www/developpement/apirest.LoadTodo()
          D:/www/developpement/apirest/todoCRUD.go:33 +0x2f   [Router.Group]
  /D/www/developpement/apirest.init.1()
          D:/www/developpement/apirest/apirest.go:73 +0x220     [LoadTodo()]
  /D/www/developpement/apirest.init()
          D:/www/developpement/apirest/todoCRUD.go:190 +0x80  [last line] main.init()
          D:/www/developpement/maincode.go:13 +0x3a         [manners.ListenAndServe("":8080"", apirest.Router)] exit status 2


I hope that this will help to understand !

Thanks for your time and help !

Stéphane
"
37222753,"You never put anything into the fromPipeline.

If I add the line fromPipeline[1]  anywhere, I'll see Complete : 2  By Pipeline : 1 printed out as retiredOpCode does its work.
"
29630761,"The panic message tells you exactly what's wrong. Your command line flags should be defined only once. If you try to redefine them during runtime, it panics.
"
37917249,"The problem is the global db variable you declare by var db *sql.DB is never assigned a value. So it keeps its default value which is nil. And trying to dereference a nil pointer gives you the error.

You probably think that in the init function you are assigning this variable the newly created DB instance. But := creates a new local variable to hold the new DB instance. The global db variable is left untouched. See example.

So instead do,

var err error
db, err = sql.Open(""mysql"", ""root:abc@/abc"")


Also from my experience using a global variable when you can avoid it leads to errors hard to debug. (like this one.) I think you can avoid it by making connectDb return a DB instance.
"
35005872,"Recursion is not a language specific concept. If you know what is recursion and if you know how to write a function in Go, then you can write a recursive function in Go.

This is a dummy recursive function in Go.

func f(n int) int {
    if n < 0 {
        return 0 // or something else
    }
    if n == 0 {
        return 1
    }
    return n * f(n - 1)
}


This is a recursive function in Go, because,


It has a termination (base) condition(n 
f(n) depends on f(x) for all x 
It's written in Go.

"
29833021,"I think what you're failing to understand is how to model the data in your Go app (after it's returned from the db). The variables you're using to store the values you read are only scoped for the loop and are singletons, how would you return a collection? Well by using a collection of course!

So here are the two options I would consider; 

1) just concat everything into one big string. If you're going to dump the output to the console soon after his and you don't have any real processing to do, it's probably simplest to just declare a string before the loop, keep your scan as it is, append the results into the string in some common format like comma delimited then pass that to the function/write it to IRC or whatever.

2) use an actual collection. In any serious program you're probably going to do more with data coming from a db than print just print it. A more realistic implementation would be to create Player struct which has teamName and playerName fields. Before the loop you'd initialize a slice of Players or an array if you know how many results will be coming back. In the loop you would create a new instance and add it to the slice with the append function. After the loop you pass the slice/array to whatever needs to use the data next.

Here are couple samples. Note that these are both untested and I am not considering performance. For example if performance were a concern you should probably be using something like this for string concatenation How to efficiently concatenate strings in Go?

type Player struct {
    TeamName string
    PlayerName string
}

var Players []*Player
for rows.Next() {
        p := &Player{}
        if err := rows.Scan(p.TeamName, p.PlayerName); err != nil{
             // handle error
        }
        Players = append(Players, p)
}
// pass Players to next function/return it whatever


// simpler less robust option 1

lineUp := """"
for rows.Next() {
            var team string
            var player string
            rows.Scan(&team, &player)
            lineUp += team + "":"" + player ""\n""
    }
return lineUp

"
