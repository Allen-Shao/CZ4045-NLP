PostId,Body
39527767,"With slice value type

map is a good choice if you need fast lookup, but since you want to store multiple values for the same key, that warrants for a slice as the value type:

m := map[int][]interface{}{}
m[1] = append(m[1], ""one"")
m[2] = append(m[2], ""two"")
m[1] = append(m[1], ""three"")
fmt.Println(m[1])


Output (try it on the Go Playground):

[one three]


Note that using this map is a little less convenient, as when you want to add a new value you don't (can't) just assign it but you have to append to the existing slice associated with the key, and you have to assign back the (potentially) new slice.

To ease this ""pain"", you may create your own type and provide helper methods to support different operations on the map. This is also true for the subsequent alternatives, so being a little more verbose does not necessarily mean you have to struggle with it.

With pointer to slice value type

Note that you could avoid having to reassign the new slice if you would store pointers in the map, for example:

m := map[int]*[]interface{}{}
m[1] = &[]interface{}{}
m[2] = &[]interface{}{}

s := m[1]
*s = append(*s, ""one"")
s = m[2]
*s = append(*s, ""two"")
s = m[1]
*s = append(*s, ""three"")
fmt.Println(m[1])


Output (try it on the Go Playground):

&[one three]


You still have to assign back the slice returned by append(), but not to a map key but to the pointed value (acquired from / stored in the map).

But as you can see, handling it is more hassle, but may be more efficient if you add new elements frequently. Also note that since zero value for any pointer type is nil, before you could add an element for a key, you first have to initialize it with a pointer to an existing, non-nil slice (but if you create your own type, you can hide this check and initialization).

With map as value type

Previous solutions (with slices in keys) are good, but if you also have to support frequent removal operation, they lag behind, as whenever you have to remove an element, you index the map to get the slice, and you have to search this slice and remove the element from it (and removing from a slice includes slice header update and copying subsequent elements to 1-less indices). If this slice is not sorted, this is a linear search and so it has O(n) complexity (where n is the number of elements associated with the same key, not the number of keys in the map). May not be acceptable depending on your case.

To support fast element removal, you may keep the value slices sorted, and so finding the removable element in them is O(log(n)) complexity – acceptable in most cases.

An even faster solution may use another map (as a set, see example #1 and example #2) as the value type, which will be O(1) complexity for removals too. Cool. It could look like this:

m := map[int]map[interface{}]bool{}
m[1] = map[interface{}]bool{}
m[2] = map[interface{}]bool{}

m[1][""one""] = true
m[2][""two""] = true
m[1][""three""] = true
fmt.Println(m[1])


Output (try it on the Go Playground):

map[one:true three:true]


Just as with the pointer-to-slice value type, you first have to initialize a value for a key with a non-nil map before you can actually ""add"" values to it. Hide this by creating your own type and adding methods.
"
26146146,"lines = append(lines[:i], 
           append([]string{""MY INSERTED TEXT HERE""}, lines[i:]...)...)


or

lines = append(lines, """")
copy(lines[i+1:], lines[i:])
lines[i] = ""MY INSERTED TEXT HERE""


The second approach is more efficient. The two approaches are listed on the useful SliceTricks page.
"
42377447,"You just have defined a recursive data type. You can render it by defining a recursive template:

{{define ""replies""}}
  
    {{ range $key, $value := . }}
      
        
          {{ $value.ID }}
        
        {{ $value.PostNum }}
      

      {{template ""replies"" .Replies}}
    {{end}}
  
{{end}}


  {{ .Title  }}
  {{ .Body  }}

  {{ template ""replies"" .Replies }}


"
38079036,"Problem: There is a list of tables associated keys. It is necessary to implement CRUD for each table + some functional on the specifics of the table (pagination, etc.).
Troubles: duplicated in each of the functional implementation for each table About 50% of the code.
Question: What are the ways on the specifics of the language, of the optimization / refactoring / use similar code patterns?

Example code part


//------------------------------------------------------------------
//  user
//----------------------------------------------------------------------
func (d *Database) UserCreate(email, password, username string, role int) *Answer {
    //variables
    answer := d.initCall(""UserCreate"")
    user := new(User)
    //check exist user
    if userExist := d.DB.Find(&User{}, &User{Email:email}).Error; userExist == nil {
        answer.AnswerJSON.ErrorAnswer.Message = ""[usercreate] user already exist""
        answer.AnswerJSON.Result = nil
        answer.AnswerJSON.Status = false
    } else {

        userinfo := UserInfo{Data:time.Now()}
        session := Session{Data:time.Now()}
        cook := Cook{}

        //make support  tables object
        //userinfo object
        userinfo.Password = password
        userinfo.Username = username
        //cook object
        cook.SessionID = session.ID
        cook.Cookie = d.cookgeneratenew(""somesaltforcooksgenerate"")
        cook.Status = true
        cook.Lastconnect = time.Now()
        cook.CountConnect += 1

        //user object
        user.Email = email
        user.Session = session
        user.UserInfo = userinfo
        user.Cook = cook
        user.Role = int64(role)

        //make request + //serizlizations to json answer
        if err := d.DB.Create(user).Error; err != nil {
            answer.AnswerJSON.ErrorAnswer.Message = err.Error()
            answer.AnswerJSON.Status = false
        } else {
            answer.AnswerJSON.Result = user
            answer.AnswerJSON.Status = true
        }
    }
    d.serilize(answer)
    return answer
}
func (d *Database) UserDelete(userid int64) *Answer {
    answer := d.initCall(""UserDelete"")
    user := new(User)
    //check exists
    if userExists := d.DB.Find(user, ""ID = ?"", userid).Error; userExists == nil {
        if userDelete := d.DB.Delete(user).Error; userDelete != nil {
            answer.AnswerJSON.ErrorAnswer.Message = userExists.Error()
            answer.AnswerJSON.Status = false
        } else {
            answer.AnswerJSON.Status = true
            answer.AnswerJSON.ErrorAnswer = nil
        }
    } else {
        answer.AnswerJSON.ErrorAnswer.Message = userExists.Error()
        answer.AnswerJSON.Status = false
    }
    d.serilize(answer)
    return answer
}
func (d *Database) UserRead(userid int64) *Answer {
    answer := d.initCall(""UserRead"")
    user := new(User)
    if userExists := d.DB.Find(user, ""ID = ?"", userid).Error; userExists != nil {
        answer.AnswerJSON.ErrorAnswer.Message = userExists.Error()
        answer.AnswerJSON.Status = false
    } else {
        if rel := d.DB.Model(user).Related(&user.Session).Error; rel != nil {
            answer.AnswerJSON.Result = nil
            answer.AnswerJSON.ErrorAnswer.Message = rel.Error()
            answer.AnswerJSON.Status = false
        } else if rel = d.DB.Model(user).Related(&user.UserInfo).Error; rel != nil {
            answer.AnswerJSON.Result = nil
            answer.AnswerJSON.ErrorAnswer.Message = rel.Error()
            answer.AnswerJSON.Status = false
        } else if rel = d.DB.Model(user).Related(&user.Cook).Error; rel != nil {
            answer.AnswerJSON.Result = nil
            answer.AnswerJSON.ErrorAnswer.Message = rel.Error()
            answer.AnswerJSON.Status = false
        } else {
            answer.AnswerJSON.Result = user
            answer.AnswerJSON.ErrorAnswer = nil
            answer.AnswerJSON.Status = true
        }
    }
    d.serilize(answer)
    return answer
}
func (d *Database) UserReadAll() *Answer {
    answer := d.initCall(""UserReadAll"")
    users := []User{}

    if usersGet := d.DB.Find(&users).Error; usersGet != nil {
        answer.AnswerJSON.ErrorAnswer.Message = usersGet.Error()
        answer.AnswerJSON.Status = false
    } else {
        for _, user := range users {
            d.DB.Model(user).Related(&user.Session)
            d.DB.Model(user).Related(&user.UserInfo)
            d.DB.Model(user).Related(&user.Cook)
        }
        answer.AnswerJSON.Result = users
        answer.AnswerJSON.ErrorAnswer = nil
        answer.AnswerJSON.Status = true
    }
    d.serilize(answer)
    return answer
}
func (d *Database) UserUpdate(userid int64, uu *UserUpdateStruct) *Answer {
    answer := d.initCall(""UserUpdate"")
    user := new(User)

    if userExists := d.DB.Find(user, ""ID = ?"", userid).Error; userExists != nil {
        answer.AnswerJSON.ErrorAnswer.Message = userExists.Error()
        answer.AnswerJSON.Status = false
    } else {
        //get relevating struct info
        d.DB.Model(user).Related(&user.Session)
        d.DB.Model(user).Related(&user.UserInfo)
        d.DB.Model(user).Related(&user.Cook)

        //update columns
        if uu.Email != """" {
            user.Email = uu.Email
        }
        if uu.Avatar > 0 {
            user.UserInfo.Avatar = uu.Avatar
        }
        if uu.Birthday != """" {
            user.UserInfo.Birthday = uu.Birthday
        }
        if uu.Location != """" {
            user.UserInfo.Location = uu.Location
        }
        if uu.Male != """" {
            user.UserInfo.Male = uu.Male
        }
        if uu.Password != """" {
            user.UserInfo.Password = uu.Password
        }
        if uu.Role > 0 {
            if roleErr := d.DB.Find(&Role{}).Error; roleErr != nil {
                //role not found
                fmt.Printf(""[userupdate] role not found `%d`\n"", uu.Role)
            } else {
                user.Role = uu.Role
            }
        }

        //update
        if errUpdate := d.DB.Save(user).Error; errUpdate != nil {
            answer.AnswerJSON.ErrorAnswer.Message = errUpdate.Error()
            answer.AnswerJSON.Status = false
        } else {
            answer.AnswerJSON.Result = user
            answer.AnswerJSON.ErrorAnswer = nil
            answer.AnswerJSON.Status = true
        }
    }
    d.serilize(answer)
    return answer
}
func (d *Database) UserPaginate(page, countPage int) *Answer {
    answer := d.initCall(""UserPaginate"")
    result := []*User{}
    if errPag := d.DB.Limit(countPage).Offset((page * countPage) - countPage).Find(&result).Error; errPag != nil {
        answer.AnswerJSON.ErrorAnswer.Message = errPag.Error()
        answer.AnswerJSON.Status = false
    } else {
        for _, user := range result {
            d.DB.Model(&user).Related(&user.Session)
            d.DB.Model(&user).Related(&user.UserInfo)
            d.DB.Model(&user).Related(&user.Cook)
        }
        answer.AnswerJSON.Result = result
        answer.AnswerJSON.ErrorAnswer = nil
        answer.AnswerJSON.Status = true
    }
    d.serilize(answer)
    return answer
}
//-------------------------------------------------------------------
//  category
//--------------------------------------------------------------------
func (d *Database) CategoryCreate(name string) *Answer {
    //variables
    answer := d.initCall(""CategoryCreate"")
    cat := new(Category)
    //check exist user
    if catExist := d.DB.Find(&Category{}, &Category{Name:name}).Error; catExist == nil {
        answer.AnswerJSON.ErrorAnswer.Message = ""[categorycreate] category already exist""
        answer.AnswerJSON.Result = nil
        answer.AnswerJSON.Status = false
    } else {
        cat.Name = name
        //make request + //serizlizations to json answer
        if err := d.DB.Create(cat).Error; err != nil {
            answer.AnswerJSON.ErrorAnswer.Message = err.Error()
            answer.AnswerJSON.Status = false
        } else {
            answer.AnswerJSON.Result = cat
            answer.AnswerJSON.Status = true
        }
    }
    d.serilize(answer)
    return answer
}
func (d *Database) CategoryDelete(catid int64) *Answer {
    answer := d.initCall(""CategoryDelete"")
    cat := new(Category)
    //check exists
    if catExists := d.DB.Find(cat, ""ID = ?"", catid).Error; catExists == nil {
        if catDelete := d.DB.Delete(cat).Error; catDelete != nil {
            answer.AnswerJSON.ErrorAnswer.Message = catExists.Error()
            answer.AnswerJSON.Status = false
        } else {
            answer.AnswerJSON.Status = true
            answer.AnswerJSON.ErrorAnswer = nil
        }
    } else {
        answer.AnswerJSON.ErrorAnswer.Message = catExists.Error()
        answer.AnswerJSON.Status = false
    }
    d.serilize(answer)
    return answer
}
func (d *Database) CategoryRead(catid int64) *Answer {
    answer := d.initCall(""CategoryRead"")
    cat := new(Category)
    if catExists := d.DB.Find(cat, ""ID = ?"", catid).Error; catExists != nil {
        answer.AnswerJSON.ErrorAnswer.Message = catExists.Error()
        answer.AnswerJSON.Status = false
    } else {
        if rel := d.DB.Model(cat).Related(&cat.Post).Error; rel != nil {
            answer.AnswerJSON.Result = nil
            answer.AnswerJSON.ErrorAnswer.Message = rel.Error()
            answer.AnswerJSON.Status = false
        } else {
            for x, p := range cat.Post {
                d.DB.Model(&p).Related(&p.Comment)
                d.DB.Model(&p).Related(&p.PostSeo)
                cat.Post[x] = p
            }
            answer.AnswerJSON.Result = cat
            answer.AnswerJSON.ErrorAnswer = nil
            answer.AnswerJSON.Status = true
        }
    }
    d.serilize(answer)
    return answer
}
func (d *Database) CategoryReadAll() *Answer {
    answer := d.initCall(""CategoryReadAll"")
    cats := []Category{}

    if catsGet := d.DB.Find(&cats).Error; catsGet != nil {
        answer.AnswerJSON.ErrorAnswer.Message = catsGet.Error()
        answer.AnswerJSON.Status = false
    } else {
        //categorys
        for _, cat := range cats {
            d.DB.Model(cat).Related(&cat.Post)
            //get relete POST
            for x, p := range cat.Post {
                d.DB.Model(&p).Related(&p.Comment)
                d.DB.Model(&p).Related(&p.PostSeo)
                cat.Post[x] = p
            }
        }
        answer.AnswerJSON.Result = cats
        answer.AnswerJSON.ErrorAnswer = nil
        answer.AnswerJSON.Status = true
    }
    d.serilize(answer)
    return answer
}
func (d *Database) CategoryUpdate(catid int64, name string) *Answer {
    answer := d.initCall(""CategoryUpdate"")
    cat := new(Category)

    if catExists := d.DB.Find(cat, ""ID = ?"", catid).Error; catExists != nil {
        answer.AnswerJSON.ErrorAnswer.Message = catExists.Error()
        answer.AnswerJSON.Status = false
    } else {
        //get relevating struct info
        d.DB.Model(cat).Related(&cat.Post)

        //update columns
        if name != """" {
            cat.Name = name
        }
        //update
        if errUpdate := d.DB.Save(cat).Error; errUpdate != nil {
            answer.AnswerJSON.ErrorAnswer.Message = errUpdate.Error()
            answer.AnswerJSON.Status = false
        } else {
            answer.AnswerJSON.Result = cat
            answer.AnswerJSON.ErrorAnswer = nil
            answer.AnswerJSON.Status = true
        }
    }
    d.serilize(answer)
    return answer
}
func (d *Database) CategoryPaginate(page, countPage int) *Answer {
    answer := d.initCall(""CategoryPaginate"")
    result := []*Category{}
    if errPag := d.DB.Limit(countPage).Offset((page * countPage) - countPage).Find(&result).Error; errPag != nil {
        answer.AnswerJSON.ErrorAnswer.Message = errPag.Error()
        answer.AnswerJSON.Status = false
    } else {
        for _, cat := range result {
            d.DB.Model(&cat).Related(&cat.Post)
            //get relete POST
            for x, p := range cat.Post {
                d.DB.Model(&p).Related(&p.Comment)
                d.DB.Model(&p).Related(&p.PostSeo)
                cat.Post[x] = p
            }
        }
        answer.AnswerJSON.Result = result
        answer.AnswerJSON.ErrorAnswer = nil
        answer.AnswerJSON.Status = true
    }
    d.serilize(answer)
    return answer
}

"
44895648,"You have to define slice of Weather struct in WeatherData. 

Uncomment Weather struct and update WeatherData struct to following.

// WeatherData struct to collect data from the API call
type WeatherData struct {
    Wind    Wind      `json:""wind""`
    Sys     Sys       `json:""sys""`
    Weather []Weather `json:""weather""`
    Name    string    `json:""name""`
}


Please have a look on example code: https://play.golang.org/p/4KFqRuxcx2
"
38923623,"The goroutines are only working on copies of the slice headers, the underlying arrays are the same. To make a copy of a slice, you need to use copy (or append to a different slice).

buf_Seq = append(buf_Seq, line)
bufCopy := make([]string, len(buf_Seq))
copy(bufCopy, buf_Seq)


You can then safely pass bufCopy to the goroutines, or simply use it directly in the closure.
"
25745374,"I try to write a function that validate data. Look at the following code:

func Create(name, email, password, local string, termOf bool) map[string]string {

    wait := new(sync.WaitGroup)
    mutex := new(sync.Mutex)
    errMsg := make(map[string]string)

    if !termOf {
        mutex.Lock()
        errMsg[""termOf""] = translate(local, ""text06"")
        mutex.Unlock()
    }

    wait.Add(1)
    go func() {
        err := ValidateName(name, local)
        mutex.Lock()
        errMsg[""name""] = err.Error()
        mutex.Unlock()
        wait.Done()
    }()

    wait.Add(1)
    go func() {
        err := ValidateEmail(email, local)
        mutex.Lock()
        errMsg[""email""] = err.Error()
        mutex.Unlock()
        wait.Done()
    }()

    wait.Add(1)
    go func() {
        err := ValidatePassword(password, local)
        mutex.Lock()
        errMsg[""password""] = err.Error()
        mutex.Unlock()
        wait.Done()
    }()

    wait.Wait()

    // If errors appear
    if len(errMsg) > 0 {
        return errMsg
    }

    return nil
}


As you can see here, I use three goroutines and in the goroutine I lock it to change errMsg variable map type. When I run the function, I've got compiler error

runtime error: invalid memory address or nil pointer dereference
[signal 0xc0000005 code=0x0 addr=0x14 pc=0x44206a]


But when I remove in the goroutine all errMsg inserts, then the function works. I do not know the reason what I do wrong.
"
39948383,"Given this Go text/template code:

Let's say:
{{ if eq .Foo ""foo"" }}
Hello, StackOverflow!
{{ else if eq .Foo ""bar"" }}
Hello, World!
{{ end }}


We get the following output in case Foo equals ""foo"":

Let's say:

Hello, StackOverflow!


(followed by a newline)

Is there a way to get rid of the extra newlines?

I would expect that this can be accomplished using the {{- and -}} syntax:

Let's say:
{{- if eq .Foo ""foo"" }}
Hello, StackOverflow!
{{- else if eq .Foo ""bar"" }}
Hello, World!
{{- end }}


However, that yields an illegal number syntax: ""-"" error.
"
42377057,"I want to deploy Prometheus to Cloud Foundry without using Docker container. When I try to deploy it with the standard Cloud Foundry Go Buildpack I get the following error:

can't load package: package prometheus: no buildable Go source files in /tmp/tmp.vv4iyDzMvE/.go/src/prometheus


Which somehow makes sense, because there are actually no sources in the  root directory and the project is compiled with the Prometheus utility tool.

Is there any way to deploy Prometheus to Cloud Foundry, like using another Buildpack or something?
"
19906544,"Numpy's arange function returns a list of evenly spaced values within a given interval with float steps. Is there a short and simple way to create a slice like that in Go?
"
32217055,"It turns out the method I needed was img.At(x, y).RGBA(), this returns those values respectively.
"
34879997,"You could dial to the socket before using it:

_, err = net.Dial(""tcp"", ""127.0.0.1:8021"")    //8021 is a closed socket
if err != nil {
    panic(""Error, socket not opened"")
}


EDIT:
Maybe this way is more clear:

isOpen := true
_, err = net.Dial(""tcp"", ""127.0.0.1:8021"")    //8021 is a closed socket
if err != nil {
    isOpen = false
}

if isOpen {
    //Your logic here
}

"
24519448,"godoc is very picky regarding the names, your Example function name needs to correlate with an actual function name, type name or other. See http://golang.org/pkg/testing/#hdr-Examples for reference.

Example of godoc exmaple: https://godoc.org/github.com/creack/multio#example-Multiplexer--ReadWriter, code: https://github.com/creack/multio/blob/master/example_test.go

You will notice, that the Example are called ExampleMultiplexer_simple  ExampleMultiplexer_readWriter. This is because I wanted two example, I could have simply use ExampleMultiplexer. This works because I have a type called (exactly) Multiplexer. If you have a function, you can do the same, but the name needs to match.

When using a suffixe, it is very important that the suffix begins with a lowercase, otherwise godoc will discard it.

So to answer your question: yes you can use arbitrary name, but you still need to follow the godoc style of ExampleTypeName_suffix (lower case suffix first letter)
"
33180089,"For a function like json.Unamrshal, you don't need the map, you only need the correct type pointer, which you can make with reflect.New. The json package will allocate the map as needed.

m := reflect.New(reflect.MapOf(reflect.TypeOf(""""), reflect.TypeOf(typ)))


If you need to allocate the map, use the Set method to assign it to the pointer.

http://play.golang.org/p/hnOhh8242i

mapType := reflect.MapOf(reflect.TypeOf(""""), reflect.TypeOf(typ))

ptr := reflect.New(mapType)
ptr.Elem().Set(reflect.MakeMap(mapType))

"
18923123,"I have a http server. It is written with Go.
I have this code:

package main
import (
    ""net/http""
    ""runtime""
)
var cur = 0
func handler(w http.ResponseWriter, r *http.Request) {
    cur = cur + 1;
}
func main() {
    runtime.GOMAXPROCS(runtime.NumCPU())
    http.HandleFunc(""/"", handler)
    http.ListenAndServe("":9010"", nil)
}


Is it safe?
May be I need to use a mutex?
"
36152294,"see test code:

package main

import ""fmt""

func main() {
    i := 10

    closure1 := func() {
        fmt.Printf(""closure, i: %d\n"", i)
        i = 15
    }

    closure1()

    fmt.Printf(""in main, i: %d\n"", i)

    closure2 := func(x int) {
        fmt.Printf(""function call, pass parameter, i: %d\n"", x)
    }

    i = 20

    closure1()
    closure2(i)
}


I think the output of the closure2 should be 20, but the real result is 15, i do not know why????
anybody can help me , please see my comment in my code, thanks in advance.
"
21551995,"I like the answers here so far and I want to add one that allows you to do static type checking on the interface you pass in using an interface:

package main

import (
    ""fmt""
)

type Animalizer interface {
    GetColour() string
}

type Animal struct {
    Colour string
    Name   string
}

type Dog struct {
    Animal
}

func (a *Animal) GetColour() string {
    return a.Colour
}

func PrintColour(a Animalizer) {
    fmt.Print(a.GetColour())
}

func main() {
    a := new(Animal)
    a.Colour = ""Void""
    d := new(Dog)
    d.Colour = ""Black""

    PrintColour(a)
    PrintColour(d)
}


On the playground

It will be possible to add further fields to Dog. The difference to Uriel's Answer is that calls to PrintColour will fail at compile time if something else than a struct implementing Animalizer is passed in. 

Also you won't have to use a typeswitch since the compiler knows an Animalizer is implementing GetColour.

And, finally, the behaviour (printing) is separated from the struct, GetColour just returns the colour.
"
27187685,"You could check out the implementation of PuerkitoBio/throttled, presented in this article:


  throttled, a Go package that implements various strategies to control access to HTTP handlers.
  Out-of-the-box, it supports rate-limiting of requests, constant interval flow of requests and memory usage thresholds to grant or deny access, but it also provides mechanisms to extend its functionality.


The rate limit isn't exactly what you need, but can give a good idea for implementing a similar feature. 
"
39132056,"You may use one func Save(d interface{}) like this:

package main

import (
    ""encoding/json""
    ""fmt""
)

type User struct {
    ID   int
    Name string
}

type Admin struct {
    User
    Level int
}

func main() {
    Save(User{})
    Save(Admin{})
}

func Save(d interface{}) {
    body, err := json.Marshal(d)
    if err != nil {
        panic(err)
    }
    st := string(body)
    fmt.Println(st)
}


output:

{""ID"":0,""Name"":""""}
{""ID"":0,""Name"":"""",""Level"":0}




for your case, use this one function for all types:

func Save(i interface{}, id int) {
    data, err := json.Marshal(i)
    check(err)
    if id == 0 {
        _, err = app.DB.Exec(`INSERT INTO users(data) VALUES ($1) `, string(data))
    } else {
        _, err = app.DB.Exec(`UPDATE users SET data = $1 WHERE id=$2`, string(data), id)
    }
    check(err)
}


And call it like this:

u := User{}
a := Admin{}

Save(u, u.ID)
Save(a, a.ID)




And Yes, this is even simplifies call to Save to one parameter:

package main

import (
    ""encoding/json""
    ""fmt""
)

type Model interface {
    ID() int
    setID(int)
}

type User struct {
    Id   int
    Name string
}

func (t User) ID() int      { return t.Id }
func (t User) setID(id int) { t.Id = id }

type Admin struct {
    User
    Level int
}

func main() {
    Save(User{})
    Save(Admin{})
}

func Save(d Model) {
    body, err := json.Marshal(d)
    if err != nil {
        panic(err)
    }
    st := string(body)
    fmt.Println(st)

    fmt.Println(""ID is "", d.ID())
}


output:

{""Id"":0,""Name"":""""}
ID is  0
{""Id"":0,""Name"":"""",""Level"":0}
ID is  0




Now You may use this one function for all types:

func Save(i Model) {
    data, err := json.Marshal(i)
    check(err)
    id := i.ID()
    if id == 0 {
        _, err = app.DB.Exec(`INSERT INTO users(data) VALUES ($1) `, string(data))
    } else {
        _, err = app.DB.Exec(`UPDATE users SET data = $1 WHERE id=$2`, string(data), id)
    }
    check(err)
}


And call it like this:

u := User{}
a := Admin{}

Save(u)
Save(a)




Effective Go:


  Getters
  
  Go doesn't provide automatic support for getters and setters. There's
  nothing wrong with providing getters and setters yourself, and it's
  often appropriate to do so, but it's neither idiomatic nor necessary
  to put Get into the getter's name. If you have a field called owner
  (lower case, unexported), the getter method should be called Owner
  (upper case, exported), not GetOwner. The use of upper-case names for
  export provides the hook to discriminate the field from the method. A
  setter function, if needed, will likely be called SetOwner. Both names
  read well in practice:

owner := obj.Owner()
if owner != user {
    obj.SetOwner(user)
}


"
21494035,"I want to sign a public key from ascii armor with a private key in go language.For that I developed following code but the problem is when I check the signature in gpg --check-sigs the signature created by code is shown as ""bad Signature"".Please Help as I cant figure out any way of solving it.I have already postd on golang-nuts.I am just learning golang for my college project and I am stuck here,Please help.

    // signer
package main

import (
    ""bytes""
    ""code.google.com/p/go.crypto/openpgp""
    ""code.google.com/p/go.crypto/openpgp/armor""
    ""code.google.com/p/go.crypto/openpgp/packet""
    ""fmt""
)

// This function takes asciiarmored private key which will sign the public key
//Public key is also ascii armored,pripwd is password of private key in string
//This function will return ascii armored signed public key i.e. (pubkey+sign by prikey)
func SignPubKeyPKS(asciiPub string, asciiPri string, pripwd string) (asciiSignedKey string) {
    //get Private key from armor
    _, priEnt := getPri(asciiPri, pripwd) //pripwd is the password todecrypt the private key
    _, pubEnt := getPub(asciiPub)         //This will generate signature and add it to pubEnt
    usrIdstring := """"
    for _, uIds := range pubEnt.Identities {
        usrIdstring = uIds.Name

    }
    fmt.Println(usrIdstring)
    errSign := pubEnt.SignIdentity(usrIdstring, &priEnt, nil)
    if errSign != nil {
        fmt.Println(""Signing Key "", errSign.Error())
        return
    }
    asciiSignedKey = PubEntToAsciiArmor(pubEnt)
    return
}

//get packet.PublicKey and openpgp.Entity of Public Key from ascii armor
func getPub(asciiPub string) (pubKey packet.PublicKey, retEntity openpgp.Entity) {
    read1 := bytes.NewReader([]byte(asciiPub))
    entityList, errReadArm := openpgp.ReadArmoredKeyRing(read1)
    if errReadArm != nil {
        fmt.Println(""Reading Pubkey "", errReadArm.Error())
        return
    }
    for _, pubKeyEntity := range entityList {
        if pubKeyEntity.PrimaryKey != nil {
            pubKey = *pubKeyEntity.PrimaryKey
            retEntity = *pubKeyEntity
        }
    }
    return
}

//get packet.PrivateKEy and openpgp.Entity of Private Key from ascii armor
func getPri(asciiPri string, pripwd string) (priKey packet.PrivateKey, priEnt openpgp.Entity) {
    read1 := bytes.NewReader([]byte(asciiPri))
    entityList, errReadArm := openpgp.ReadArmoredKeyRing(read1)
    if errReadArm != nil {
        fmt.Println(""Reading PriKey "", errReadArm.Error())
        return
    }
    for _, can_pri := range entityList {
        smPr := can_pri.PrivateKey
        retEntity := can_pri
        if smPr == nil {
            fmt.Println(""No Private Key"")
            return
        }

        priKey = *smPr

        errDecr := priKey.Decrypt([]byte(pripwd))
        if errDecr != nil {
            fmt.Println(""Decrypting "", errDecr.Error())
            return
        }
        retEntity.PrivateKey = &priKey
        priEnt = *retEntity
    }
    return
}

//Create ASscii Armor from openpgp.Entity
func PubEntToAsciiArmor(pubEnt openpgp.Entity) (asciiEntity string) {
    gotWriter := bytes.NewBuffer(nil)
    wr, errEncode := armor.Encode(gotWriter, openpgp.PublicKeyType, nil)
    if errEncode != nil {
        fmt.Println(""Encoding Armor "", errEncode.Error())
        return
    }
    errSerial := pubEnt.Serialize(wr)
    if errSerial != nil {
        fmt.Println(""Serializing PubKey "", errSerial.Error())
    }
    errClosing := wr.Close()
    if errClosing != nil {
        fmt.Println(""Closing writer "", errClosing.Error())
    }
    asciiEntity = gotWriter.String()
    return
}

"
37557763,"Create a struct that implements an interface.
Encapsulate it into another struct.
Fetch the struct / dereference it.


Fetching gets pointer to the implementation of the interface.
Dereferencing the pointer results in another point to the interface.


Why wouldn't dereferencing the pointer to the implementation gives the implementation instance?

package main

import (
    ""fmt""
    ""net/http""

    ""golang.org/x/net/http2""
)

func main() {
    transport := &http2.Transport{}
    client := &http.Client{Transport: transport}

    tmp1 := client.Transport
    tmp2 := &client.Transport
    tmp3 := &tmp1

    fmt.Printf(""%T\n%T\n%T\n"", tmp1, tmp2, tmp3)

    //dialTLS := tmp1.DialTLS
}


This code outputs...

*http2.Transport
*http.RoundTripper
*http.RoundTripper


As well, trying to access a property of the tmp1 (uncommenting dialTLS := tmp1.DialTLS) results in compile error...

tmp1.DialTLS undefined (type http.RoundTripper has no field or method DialTLS)


...even though fmt.Printf(""%+v"", tmp1) outputs...

&{DialTLS: TLSClientConfig:0xc8203ec8c0 ConnPool: DisableCompression:false MaxHeaderListSize:0 t1: connPoolOnce:{m:{state:0 sema:0} done:0} connPoolOrDef:}


What I am attempting to do is access DialTLS in the Transport instance.
"
41104049,"I have to deserialize some binary messages coming from another application. I would love to use restruct.io but some fields in the message structure use a ""non-standard"" number of bits ( 5 bits, 3 bits, ... 10 bits ... ).

Is there any way to handle this type of structs? I have been searching for some time without any success so any help will be very welcomed. 

thanks in advance

I wil try to give an example to clarify my question. Given the code: 

package main

import (
    ""encoding/binary""
    ""fmt""

    restruct ""gopkg.in/restruct.v1""
)

type MessageType uint8

const (
    MessageTypeOne MessageType = iota + 1
    MessageTypeTwo
    MessageTypeThree
)

// Message is the data to deserialize from the binary stream
type Message struct {
    Length     uint32      `struct:""uint32""` // message size in bytes (including length)
    Type       MessageType `struct:""uint8""`
    Version    uint8       `struct:""uint8:4""` // Just need 4 bits
    Subversion uint8       `struct:""uint8:2""` // just need 2 bits
    Optional   uint8       `struct:""uint8:1""` // just one bit --> '1' means next field is NOT present
    NodeName   string      ``
    ANumber    uint16      `struct:""uint16:10""` // just need 10 bits
}

// (length(4)+type(1)+(version(4bits)+Subversion(2bits)+Optional(1bit))) = 6 bytes
// need 32bit alignment
func main() {
    var inStream = []byte{0x08, // just 8 bytes needed
        0x01,       // messge type = MessageTypeOne
        0x4a,       // Version=0100 Subversion=10 Optional=1 ANumber = 0 (MSB bit)
        0x00, 0x60, // ANumber(000 0000 011) Padding = 0 0000 for 32 bits alignment
    }
    var msg Message

    err := restruct.Unpack(inStream, binary.BigEndian, &msg)
    if err != nil {
        panic(err)
    }
    fmt.Println(msg)
    // Expected:
    // msg.Length = 8
    // msg.Type = 1
    // msg.Version = 4
    // msg.Subversion = 2
    // msg.Optional = 1
    // msg.NodeName = """"
    // msg.ANumber = 3
}


I will receive inStream from a TCP connection and will want to deserialize the binary data and get a Message struct with the expected values ... 

Hope this will clarify my question.

Thanks again ;)
"
44201166,"The following code prettily statisfies your requirement, you can get this code at https://gist.github.com/hygull/645c3dc39c69b6b69c06f5ea9deee41f. The table data has been also provided.

/**
    {
        ""created_on"": ""26 may 2017"",
        ""todos"": [
            ""go get github.com/go-sql-driver/mysql""     
        ],
        ""aim"": ""Reading fname column into []string(slice of strings)""
    }
*/


/* 
mysql> select * from users;
+----+-----------+----------+----------+-------------------------------+--------------+
| id | fname     | lname    | uname    | email                         | contact      |
+----+-----------+----------+----------+-------------------------------+--------------+
|  1 | Rishikesh | Agrawani | hygull   | rishikesh0014051992@gmail.com | 917353787704 |
|  2 | Sandeep   | E        | sandeep  | sandeepeswar8@gmail.com       | 919739040038 |
|  3 | Darshan   | Sidar    | darshan  | sidardarshan@gmail.com        | 917996917565 |
|  4 | Surendra  | Prajapat | surendra | surendrakgadwal@gmail.com     | 918385894407 |
|  5 | Mukesh    | Jakhar   | mukesh   | mjakhar.kjahhar@gmail.com     | 919772254140 |
+----+-----------+----------+----------+-------------------------------+--------------+
5 rows in set (0.00 sec)

mysql> 
*/

package main
import ""fmt""
import ""log""
import (
    _""github.com/go-sql-driver/mysql""   
    ""database/sql""
)

func main() {
    // db, err := sql.Open(""mysql"", "":@tcp(127.0.0.1:)/?charset=utf8"" )
    db, err := sql.Open(""mysql"", ""hygull:admin@67@tcp(127.0.0.1:3306)/practice_db?charset=utf8"")

    if err != nil {
        log.Fatal(err)
    }

    rows, err := db.Query(""select fname from users"")

    if err != nil {
        log.Fatal(err)
    }

    firstnames:=[]string{}
    for rows.Next() {
        var fname string
        rows.Scan(&fname)
        firstnames = append(firstnames, fname)
    }

    fmt.Println(firstnames)
    db.Close()
}

/* 
[Rishikesh Sandeep Darshan Surendra Mukesh]
*/

"
17383554,"I want to be able to Marshal/Unmarshall a struct

type MyType struct {
    Items       `json:""item""`
}


Where an example JSON document it must be able to handle is

{""items"":[""value1"", {""x"":""y""}, ""value3""]}


I am only starting to learn Go.  I am starting to think I might need to impose some restrictions on the structure of the array.  Using the above example, my idea would be

{""items"":[
    {""type"":null, ""value"":""value1""}
    {""type:""x"", ""value"":""y""},
    {""type"": ""value3"", ""value"":""value3""}
]}


Then modelling the objects inside with their own struct.  I'd rather do it the first way, is it possible?
"
22883255,"You should not try to get value from sC channel in main function because the only value you send to it is  consumed by getC function in seperate go routine. While trying to read sC channel main function blocks waiting for something and it never ends. Go routine getS is finished, go routine getC has consumed value from channel sC and has also finished. There is nothing in channel sC anymore.

The possible solution is to create another channel s2C and send to it value received from sC channel. 

The complete correct code would look like this:

package main

func main() {
    sC := make(chan string)
    go getS(sC)

    s2C := make(chan string)
    cC := make(chan string)
    go getC(s2C, cC)

    s := <-sC
    println(s)
    s2C <- s

    c := <-cC
    println(c)
}

func getS(sC chan string) {
    s :=  "" simple completed ""
    sC <- s
}

func getC(sC chan string, cC chan string) {
    s := <-sC
    c := s + "" more ""
    cC <- c
}

"
40502637,"Time zone setting is not supported directly, but you may use a custom log.Formatter in which you may ""switch"" to the time zone of your choice, UTC included.

A simple usage that uses the local time zone (not UTC) may look like this:

import (
    log ""github.com/Sirupsen/logrus""
)

func main() {
    log.SetFormatter(&log.JSONFormatter{})
    log.Info(""Testing"")
}


Output (time is formatted using my +01 local timezone):

{""level"":""info"",""msg"":""Testing"",""time"":""2016-11-09T09:28:02+01:00""}


Now let's create a custom log.Formatter which switches to UTC:

type UTCFormatter struct {
    log.Formatter
}

func (u UTCFormatter) Format(e *log.Entry) ([]byte, error) {
    e.Time = e.Time.UTC()
    return u.Formatter.Format(e)
}

func main() {
    log.SetFormatter(UTCFormatter{&log.JSONFormatter{}})
    log.Info(""Testing"")
}


Output (time is formatted in UTC timezone):

{""level"":""info"",""msg"":""Testing"",""time"":""2016-11-09T08:28:09Z""}

"
29948833,"Maybe this will do what you want. Disclaimer: I am not an expert in openpgp; I don't know whether this is correct or not. But it does work with gpg --import.

package main

import (
        ""fmt""
        ""os""

        ""golang.org/x/crypto/openpgp""
        ""golang.org/x/crypto/openpgp/armor""
)

func main() {
        var e *openpgp.Entity
        e, err := openpgp.NewEntity(""itis"", ""test"", ""itis@itis3.com"", nil)
        if err != nil {
                fmt.Println(err)
                return
        }

        // Add more identities here if you wish

        // Sign all the identities
        for _, id := range e.Identities {
                err := id.SelfSignature.SignUserId(id.UserId.Id, e.PrimaryKey, e.PrivateKey, nil)
                if err != nil {
                        fmt.Println(err)
                        return
                }
        }

        w, err := armor.Encode(os.Stdout, openpgp.PublicKeyType, nil)
        if err != nil {
                fmt.Println(err)
                return
        }
        defer w.Close()

        e.Serialize(w)
}

"
41239174,"Know that Reader.ReadString() returns you a string value with the delimieter. So r.ReadString('\n') will return you a string with the trailing newline character.

And when you split the string at the commas, the last part will contain the newline character, and attempting to parse the number from it will fail, as shown in this example:

line := ""0,1,2\n""
for _, ele := range strings.Split(line, "","") {
    fmt.Println(strconv.ParseInt(ele, 10, 64))
}


Output (try it on the Go Playground):

0 
1 
0 strconv.ParseInt: parsing ""2\n"": invalid syntax


You religiously omit error checks, don't do that! As you can see in the above example, checking and printing the error returned by strconv.ParseInt() immediately revealed the error and what's going wrong.

What you may do is cut the trailing newline character before attempting to parse any number from it, e.g.:

strconv.ParseInt(strings.TrimSpace(ele), 10, 64)


Or use the bufio.Scanner which can scan lines and it cuts trailing newlines automatically.
"
33632365,"I'm learning Go programming and try to test the following average function:

func average(xs []float64) float64 {
    total := 0.0
    for _, v := range xs {
        total += v
    }
    return total / float64(len(xs))
}


I tried to generate a slice of random float numbers by:

var xs []float64
for n := 0; n < 10; n++ {
    xs[n] = rand.Float64()
}


however, I got 

panic: runtime error: index out of range


Question:


How to generate a slice of random number in Golang?
Is expression or function call, like xs := []float64 { for ... } allowed in slice literals?

"
14152326,"I don't see you populate the ID field anywhere so of course it's going to be 0 since that's the zero value for that field. AppEngine won't modify your struct when it stores it. The newly created key you get back when you Put the struct contains the generated IntId() when an incomplete key is used. I think your confusion was caused by assuming something the docs never said. Namely that AppEngine would auto-populate ID fields in your stored data for you.

Since in your case you want the ID field of the struct to store the id used in the key you probably want to generate you're own unique ids for when you create a Key instead of using incomplete keys.

When the doc says a string can be zero it's referring to the zero value of a string type which would the empty string """". You can read more about zero values here: http://golang.org/ref/spec#The_zero_value
"
16931561,"The fmt package has a Scan function that reads stdin, and writes consecutive space separated values to the variables you provide. Is there a way to use this with Slices, so that I could create a slice of sice n, and have scan read n values and put them into the slice?
"
32215509,"Ever since Go 1.5 came out, I started taking another look at how I could integrate it into an existing project of mine.

The project's codebase is written entirely in C for low level access to to hardware and other fun stuff. However, some of the higher level things are tedious, and I would like to start writing them in a higher level language (Go)

Is there any way I can call Go code from a C program? I installed Go 1.5, which added -buildmode=c-archive (https://golang.org/s/execmodes) which I am trying to get working.

However, I can't seem to get Go to generate the appropriate header files to allow my project to actually compile. When I generate the archive, I see the function in the exported symbols (using objdump), but without the header files to include gcc complains about the function not existing (as expected)

I'm quite new to Go - however, I love the language and would like to make use of it. Is there any idiomatic way (""idiomatic"" gets used a lot in the world of Go I see...) to get this to play nicely with each other?

The reason I asked this question and specifically mentioned Go 1.5 is that according to this document, https://docs.google.com/document/d/1nr-TQHw_er6GOQRsF6T43GGhFDelrAP0NqSS_00RgZQ/edit?pli=1#heading=h.1gw5ytjfcoke
Go 1.5 added support for non-Go programs to call Go code. Specifically, mentioned under the section ""Go code linked into, and called from, a non-Go program""
"
29377477,"Suppose I have an array of items that implement an interface Reader:

var items []Foo


How would I pass these items into a function that takes readers?

func (items []Reader) { ... }


I can't use the type []Reader because I get an error like:

Cannot use type `[]Foo` as type `[]Reader`...

"
36204611,"So far, I use different workspaces either when I want to use a different version of Go or I want to separate my private work from the code the kids and I have fun with.  Also if I want to play with some open source code but want a simple way of cleaning it all up later.

Something like 

mk /tmp/tmpgo
cd /tmp/tmpgo
# Copy or edit a setenv file
. setenv  # I use bash


The setenv file looks something like this.

export GOROOT=$HOME/go16
export GOPATH=$PWD
export GOBIN=$GOPATH/bin
export PATH=$GOROOT/bin:$GOPATH/bin:$PATH
export PS1='\[\033[01;32m\]workspacenamehere\[\033[01;33m\] \W\[\033[00m\] '


This gives me a go workspace with its own bin, src, pkg subdirectories.  I can go get anything I want.  Later I can delete the whole temporary directory if I like.  Getting things from repositories like github.com has a tendency to get many packages from other contributors, but because it puts them all into a clean src subdirectory, it's easy to use find and see what has been pulled down.  And later it is even easier to remove everything from the hd again.
"
10138446,"There are no stability problem.

I have a few webservers 100% in go that run for months, serving about a million queries per month without any problem (mostly json, through GET, POST, and websockets).

They're on 64 bits ubuntu servers but I guess you would have difficulties producing the so much gossiped about 32 bits bug, especially with a web server.

Don't use a front-end if you have no specific reason : It's easy to make a complete web application just using Go. 

You will be far from alone. In my opinion Go is especially well suited to build long running servers. Goroutines and channels makes it really easy to handle both user requests and long term tasks (or, for example, do the postreatment of user queries after you answered the http query, which isn't so easy in php and is too many LOC in java if you want to do it properly).
"
26565794,"I am developing a server with the latest Go GAE SDK. I am running tests after every change:

goapp test -test.v=true


I am using -cover to record coverage as described by goapp help testflag:

goapp test -cover -test.v=true -test.coverprofile=c.out
[..]
coverage: 53.8% of statements
ok      _/var/lib/jenkins/jobs/loyalty/workspace    30.464s


This completes successfully and prints the percentage of lines covered by tests. However, attempting to visualize the results fails:

goapp tool cover -html=c.out
cover: can't find ""app.go"": cannot find package ""_/home/ingo/git/loyalty/"" in any of:
/home/ingo/Downloads/go_appengine_sdk_linux_amd64-1.9.10/go_appengine/goroot/src/pkg/_/home/ingo/git/loyalty (from $GOROOT)
/home/ingo/git/loyalty/src/_/home/ingo/git/loyalty (from $GOPATH)


Does Go's cover tool only work on non-GAE apps? Do I have to package my app differently in order to visualize the coverage results?

I unsuccessfully asked this on golang-nuts before.
"
29620344,"I've already tried to authenticate using OAuth sucessfully with golang.com/x/oauth2 library.

// provider variable is oauth2.Config
// scope is: https://www.googleapis.com/auth/userinfo.email
url := provider.AuthCodeURL(``) // redirect URL


after getting redirected back from the client, I send the auth_code successfully

auth_code := ctx.Request.URL.RawQuery // code=XXXX
if len(auth_code) > 5 {
    auth_code = auth_code[5:] // XXXX
}
tok, err := provider.Exchange(oauth2.NoContext, auth_code)
if err == nil {
    client := provider.Client(oauth2.NoContext, tok)
    email_url := `https://www.googleapis.com/auth/userinfo.email`
    //Log.Describe(client)
    response, err := client.Get(email_url) 
    if err == nil {
        ctx.Render(`login_oauth`, response)
        //handled = true
    }
}
//Log.Describe(err)


I found nothing that tells the e-mail part on the response (the Body is empty):

{
    ""Status"": ""200 OK"",
    ""StatusCode"": 200,
    ""Proto"": ""HTTP/1.1"",
    ""ProtoMajor"": 1,
    ""ProtoMinor"": 1,
    ""Header"": {
        ""Alternate-Protocol"": [
            ""443:quic,p=0.5""
        ],
        ""Cache-Control"": [
            ""private, max-age=0""
        ],
        ""Content-Type"": [
            ""text/plain""
        ],
        ""Date"": [
            ""Tue, 14 Apr 2015 05:52:17 GMT""
        ],
        ""Expires"": [
            ""Tue, 14 Apr 2015 05:52:17 GMT""
        ],
        ""Server"": [
            ""GSE""
        ],
        ""X-Content-Type-Options"": [
            ""nosniff""
        ],
        ""X-Frame-Options"": [
            ""SAMEORIGIN""
        ],
        ""X-Xss-Protection"": [
            ""1; mode=block""
        ]
    },
    ""Body"": {}, // empty!!!
    ""ContentLength"": -1,
    ""TransferEncoding"": [
        ""chunked""
    ],
    ""Close"": false,
    ""Trailer"": null,
    ""Request"": {
        ""Method"": ""GET"",
        ""URL"": {
            ""Scheme"": ""https"",
            ""Opaque"": """",
            ""User"": null,
            ""Host"": ""www.googleapis.com"",
            ""Path"": ""/auth/userinfo.email"",
            ""RawQuery"": """",
            ""Fragment"": """"
        },
        ""Proto"": ""HTTP/1.1"",
        ""ProtoMajor"": 1,
        ""ProtoMinor"": 1,
        ""Header"": {
            ""Authorization"": [
                ""Bearer ya29.VQFRHDe21t7g2cUhN8sUwjpRRi10XldgLe0RFhMe2ZxgyRo7q90HoKES5WmcucwKqtjZdq_KvYjKiQ""
            ]
        },
        ""Body"": null,
        ""ContentLength"": 0,
        ""TransferEncoding"": null,
        ""Close"": false,
        ""Host"": ""www.googleapis.com"",
        ""Form"": null,
        ""PostForm"": null,
        ""MultipartForm"": null,
        ""Trailer"": null,
        ""RemoteAddr"": """",
        ""RequestURI"": """",
        ""TLS"": null
    },
    ""TLS"": {
         // really long output
    }
}


First question, how to get the e-mail correctly? without using Google+ API.

edit #2 I've tried using another scope for oauth2.Config:

https://www.googleapis.com/auth/plus.profile.emails.read
https://www.googleapis.com/auth/plus.login
https://www.googleapis.com/auth/plus.me


and try to retrieve the e-mail using newer API:

https://www.googleapis.com/plus/v1/people/me


but it gives 403 Forbidden

edit #3 I've tried using another scope:

openid
profile
email


and try to retrieve the e-mail using this URL:

https://www.googleapis.com/oauth2/v3/userinfo


but it still give empty Body as before.

Second question, can I reuse the oauth2.Config (provider) variable for another user? or should I create a copies for each user?
"
38829469,"If I don't use a filter, I get results. If I use a filter (this record definitely exists), I don't get any results. It might be the lack of an index defined for that property, but, as I understand it, simple indices should automatically be created in the development server (and an index.yaml file created and populated with it). This is not happening.

query = datastore.NewQuery(""UserAccount"").Filter(""email ="", ""test@example.com"")

ua := UserAccount{}
t := query.Run(ctx)
for ; ; {
    if _, err = t.Next(&ua); err == nil {
        log.Debugf(ctx, ""Current: %s"", ua)
    } else if err == datastore.Done {
        break
    } else {
        panic(err)
    }
}


When the development server terminates, it states that it's ""saving search indexes"":

INFO     2016-08-08 05:09:52,894 api_server.py:651] Saving search indexes


However, since an ""index.yaml"" file doesn't appear, I'm assuming that no indices needed to be created, which means that my query must not've had the desired effect?

What am I missing?

Edit:

Note that the record was previously created and the application stopped and started many times since. I sincerely doubt this is a eventual-consistency thing.

Edit 2:

For the purpose of testing, I've created the following model with the following code. They both exhibit the same behavior as my original model and code.

Definition:

type TestEntity struct {
    Email string
}


Code:

log.Debugf(ctx, ""Putting."")

email := ""anothertest@a.b""

te := &TestEntity{
        Email: email,
}

k := datastore.NewKey(ctx, ""TestEntity"", ""123"", 0, nil)
_, err = datastore.Put(ctx, k, te)
if err != nil {
    panic(err)
}

log.Debugf(ctx, ""Waiting."")
time.Sleep(1 * time.Second)

query := datastore.NewQuery(""TestEntity"")

var results []TestEntity
_, err = query.GetAll(ctx, &results)
log.Debugf(ctx, ""GetAll: %s"", results)

log.Debugf(ctx, ""Running query."")

query = datastore.NewQuery(""TestEntity"").Filter(""email ="", email)

te = &TestEntity{}
t := query.Run(ctx)
for ; ; {
    if _, err = t.Next(te); err == nil {
        log.Debugf(ctx, ""Found: [%s]"", te.Email)
    } else if err == datastore.Done {
        log.Debugf(ctx, ""Done."")
        break
    } else {
        panic(err)
    }
}


Results:

2016/08/09 02:11:36 DEBUG: Putting.
2016/08/09 02:11:36 DEBUG: Waiting.
2016/08/09 02:11:37 DEBUG: GetAll: [{anothertest@a.b}]
2016/08/09 02:11:37 DEBUG: Running query.
2016/08/09 02:11:37 DEBUG: Done.


Screenshot of Viewer:


"
37211325,"So, lets look at what's really going on in your source. You have two goroutines (there's more than two, but we're going to focus on the explicit ones), main and readFromChannel. 

Lets look at what readFromChannel does:

if channel `c` is not empty before `ti` has expired, print its contents and return, after signalling its completion to wait group.
if `ti` has expired before `c` is not empty, print ""TIMED OUT"" and return, after signalling its completion to wait group.


now Main:

adds to waitgroup 
make a channel `c`
start a goroutine `readFromChannel`
sleep for 5 seconds
send 10 to channel `c`
call wait for waitgroup


Now, lets go through the flow of execution for your code, concurrently (your code may/ may not execute in this order every time, keep that in mind)

1) wg.Add(1)
2) c := make(chan int)
3) go readFromChannel(c, time.After(time.Duration(2)*time.Second))
#timer ti starts#
4) time.Sleep(time.Duration(5) * time.Second)
#MAIN Goroutine begins sleep
#timer ti expires#
5) case <-ti:
6) fmt.Println(""TIMED OUT"")
7) wg.Done()
# readFromChannel Goroutine returns #
#MAIN Goroutine exits sleep#
8) c<-10
9) ......#DEADLOCK#


Now you can guess why you got a deadlock. In go, non buffered channels will block until something happens on the other end of the channel, regardless of whether you're sending or receiving. So c  will block until something reads from the other end of c, but the goroutine you had for that has dropped out of the picture 2 seconds ago. Therefore, c blocks forever, and since main is the last goroutine left, you get a Deadlock.

How to prevent it? When using channels, ensure that there's always a receive at the other end of the channel for every send. You can also use a buffered channel, but in your code above, it would not be the ""right"" solution. 

Here's my fix for the deadlock:

func main() {
    wg.Add(1)
    c := make(chan int)
    go readFromChannel(c, time.After(time.Duration(2)*time.Second))
    time.Sleep(time.Duration(5) * time.Second)
    c <- 10
    wg.Wait()
}

func readFromChannel(c chan int, ti <-chan time.Time) {
        // the forloop will run forever
    loop: // **
    for {
        select {
            case x := <-c:
                    fmt.Println(""Read"", x)
                    break loop // breaks out of the for loop and the select **
            case <-ti:
                    fmt.Println(""TIMED OUT"")
            }
    }
    wg.Done()
} 


** see this answer for details
"
36322866,"When you do encoder.Encode(d), you are encoding the marshaled result from previous step. So when you decode it back you don't get the go object, but a string.

Instead you can do, encoder.Encode(c). (Directly encode the object c).

This should help you understand: http://play.golang.org/p/qNxqOJcj_a
"
19414427,"http://play.golang.org/p/Opb7pRFyMf

    // func (f *File) Read(b []byte) (n int, err error)
    record, err := reader.Read()


Is the Read() function defined in os package?
I am trying to understand this code but cannot find where the Read() function is defined... if that is the one in os package, it returns integer for record variable. But how come it is able to print out the text in the text file?

Thanks~
"
6051028,"I know Caspar has already posted the link contained, but here is the list of community contributed packages:

http://godashboard.appspot.com/package

For completeness here are the official packages:

http://golang.org/pkg/

Also, since it is a VERY new language I don't feel too bad in saying, if it needs doing, I'm sure they would be happy for your contributions. (I try not to say ""submit a patch"" when we are talk about old languages/modules, however a new language is an exception)
"
45317241,"First, it's a slice not an array. Arrays and slices in Go are very different, arrays have a fixed size that is part of the type. I had trouble with this at first too :)


Not really. Any if the three is correct, and any difference should be too small to worry about. In my own code I generally use whatever is easiest in a particular case.
0
Nothing, until you need to add an item, then whatever it costs to allocate the storage needed.

"
26149656,"Another approach is using sync.Cond and atomic, something along the lines of:

type Server struct {
    s     chan int
    r     chan int
    c     *sync.Cond
    state uint32
}

const (
    sNormal       = 0
    sQuitting     = 1
    sReconnecting = 2
)

func New() *Server {
    s := &Server{
        s: make(chan int),
        r: make(chan int),
        c: sync.NewCond(&sync.Mutex{}),
    }
    go s.sender()
    // go s.receiver()
    return s
}
func (s *Server) sender() {
    //
    for {
        select {
        case data := <-s.s:
        //do stuff with data
        default:
            s.c.L.Lock()
        L:
            for {
                switch atomic.LoadUint32(&s.state) {
                case sNormal:
                    break L
                case sReconnecting:
                case sQuitting:
                    s.c.L.Unlock()
                    return
                }
                s.c.Wait()
            }
            s.c.L.Unlock()
        }
    }
}

//repeat for receiver

func (s *Server) Reconnect() {
    var cannotReconnect bool
    atomic.StoreUint32(&s.state, sReconnecting)
    //keep trying to reconnect
    if cannotReconnect {
        atomic.StoreUint32(&s.state, sQuitting)
    } else {
        atomic.StoreUint32(&s.state, sNormal)
    }
    s.c.Broadcast()
}


playground
"
15102643,"I'm having a hard time understanding how buffered channels work. Based on the following example, i'm trying to utilize 2 threads at a time to print out the current time, with approximately 2 second delays between every 2 go calls:

package main
import ""fmt""
import ""time""

func main() {
    returnCurrentTime := func() string  {
        return time.Now().String()
    }

    c := make(chan string, 2)

    asyncReturnCurrentTime := func(c chan string) {
        time.Sleep(2001 * time.Millisecond)
        c <- returnCurrentTime()
    }

    for i := 1; i != 7; i++ {
        go asyncReturnCurrentTime(c)
        if(i % 3 == 0) {
            fmt.Println(<- c)
            fmt.Println(<- c)
            fmt.Println(<- c)
            fmt.Println()
        }
    }
}


This produces

2013-02-27 03:17:50
2013-02-27 03:17:50
2013-02-27 03:17:50

2013-02-27 03:17:52
2013-02-27 03:17:52
2013-02-27 03:17:52


What i'm expecting regarding the seconds is 2 second delays between ever 2 go calls and in this case the following result

2013-02-27 03:17:50
2013-02-27 03:17:50
2013-02-27 03:17:52 <- 3rd call with 2 buffer slots

2013-02-27 03:17:54
2013-02-27 03:17:54
2013-02-27 03:17:56 <- 3rd call with 2 buffer slots


Obviously i misunderstood the concept of buffered channels, would somebody please be kind enough to explain the fault in my logic and how to achieve the expected result?

Thank you
"
12540134,"I'm not familiar with Perl and Dumper, but from what I understand of your post and the related C post (and the very name of the function!), it outputs the content of the data structure.

You can do this using the %v verb of the fmt package. I assume your JSON data is decoded into a struct or a map. Using fmt.Printf(""%v"", json_obj) will output the values, while %+v will add field names (for a struct - no difference if its a map, %v will output both keys and values), and %#v will output type information too.
"
20395562,"here is my snippet of code in Go which can be found here http://play.golang.org/p/L1AcgHf3E4.

package main

import (
    ""fmt""
    ""regexp""
)

func main() {
    reg := regexp.MustCompile(""([0-9]+[dh]){2}"")
    str := ""2d3h5d""

    fmt.Println(reg.FindAllStringSubmatch(str, -1))

}


I'd expect the result to be [[2d3h 3h] [3h5d 5d]], but it turned out to be [[2d3h 3h]]. Can you explain why? Thanks in advance.
"
28083629,"I'm trying to implement oauth-workflow for GitHub in golang and using https://github.com/franela/goreq to perform http(s) requests.

There is a section in which GitHub returns a code and you have to make a POST request to https://github.com/login/oauth/access_token with code, client_id and client_secret.

package main

import ""fmt""
import ""github.com/franela/goreq""

type param struct {
  code string
  client_id string
  client_secret string
}

func main() {
  params := param {code: ""XX"", client_id:""XX"", client_secret: ""XX""}
  req := goreq.Request{
    Method : ""POST"",
    Uri : ""https://github.com/login/oauth/access_token"",
    Body : params,
  }
  req.AddHeader(""Content-Type"", ""application/json"")
  req.AddHeader(""Accept"", ""application/json"")
  res, _ := req.Do()
  fmt.Println(res.Body.ToString())
}


It is giving 404 with {""error"":""Not Found""} message always.
While using Python, I'm getting the correct results with the same input data.
"
4279644,"For example,

package main

import (
    ""flag""
    ""fmt""
    ""os""
    ""strconv""
)

func main() {
    flag.Parse()
    s := flag.Arg(0)
    // string to int
    i, err := strconv.Atoi(s)
    if err != nil {
        // handle error
        fmt.Println(err)
        os.Exit(2)
    }
    fmt.Println(s, i)
}

"
12540057,"I've looked at the very similarly titled post (Is there a C equivalent to Perls' Dumper() method in Data::Dumper?), regarding a C equivalent to Data::Dumper::Dumper();. I have a similar question for the Go language.

I'm a Perl Zealot by trade, and am a progamming hobbyist, and make use of Data::Dumper and similar offspring literally hundreds of times a day. I've taken up learning Go, because it looks like a fun and interesting language, something that will get me out of the Perl rut I'm in, while opening my eyes to new ways of doing stuffz... One of the things I really want is something like:

fmt.Println(dump.Dumper(decoded_json))


to see the resulting data structure, like Data::Dumper would turn the JSON into an Array of Hashes. Seeing this in Go, will help me to understand how to construct and work with the data. Something like this would be considered a major lightbulb moment in my learning of Go.

Contrary to the statements made in the C counterpart post, I believe we can write this, and since I'll be passing Dumper to Println, after compilation what ever JSON string or XML page I pass in and decode. I should be able to see the result of the decoding, in a Dumper like state... So, does any more know of anything like this that exists? or maybe some pointers to getting something like this done? 
"
12575133,"You've got two things at work here.  The first of which is that Go is compiled to machine code and run directly on the CPU while Python is compiled to bytecode run against a (particularly slow) VM.

The second, and more significant, thing impacting performance is that the semantics of the two programs are actually significantly different.  The Go version makes a ""box"" called ""x"" that holds a number and increments that by 1 on each pass through the program.  The Python version actually has to create a new ""box"" (int object) on each cycle (and, eventually, has to throw them away).  We can demonstrate this by modifying your programs slightly:

package main

import (
    ""fmt""
)

func main() {
    for i := 0; i < 10; i++ {
        fmt.Printf(""%d %p\n"", i, &i)
    }
}


...and:

x = 0;
while x < 10:
    x += 1
    print x, id(x)


This is because Go, due to it's C roots, takes a variable name to refer to a place, where Python takes variable names to refer to things.  Since an integer is considered a unique, immutable entity in python, we must constantly make new ones.  Python should be slower than Go but you've picked a worst-case scenario - in the Benchmarks Game, we see go being, on average, about 25x times faster (100x in the worst case).

You've probably read that, if your Python programs are too slow, you can speed them up by moving things into C.  Fortunately, in this case, somebody's already done this for you.  If you rewrite your empty loop to use xrange() like so:

for x in xrange(1000000000):
    pass
print ""Done.""


...you'll see it run about twice as fast.  If you find loop counters to actually be a major bottleneck in your program, it might be time to investigate a new way of solving the problem.
"
44890804,"
The client ACKs (responds to server) that it has also updated local state to be synchronous with the server.


If 4. doesn't happen, then the server rolls back the transaction done in 1. and the entire operation of 1 - 4 is atomic.
"
20202666,"One solution is to make use of the html/template functionality, create all your pages to include the same  section like below.  I would however leave room to add tags to your head by leaving the  in each of your pages.

{{define ""page_template""}}

    My page template
    {{template ""template_css""}}
    
    

... etc ...


And the template_css:

{{define ""template_css""}}

{{end}}


A snippet of code for the template parsing

tp, err := template.ParseFiles(""page_template.html"", ""template_css.tp"")
err = tp.ExecuteTemplate(buf, ""page_template"", templateParameters)

"
1798455,"In looking at Go and Erlang's approach to concurrency, I noticed that they both rely on message passing.

This approach obviously alleviates the need for complex locks because there is no shared state.

However, consider the case of many clients wanting parallel read-only access to a single large data structure in memory -- like a suffix array.

My questions:


Will using shared state be faster and use less memory than message passing, as locks will mostly be unnecessary because the data is read-only, and only needs to exist in a single location?
How would this problem be approached in a message passing context? Would there be a single process with access to the data structure and clients would simply need to sequentially request data from it? Or, if possible, would the data be chunked to create several processes that hold chunks?
Given the architecture of modern CPUs & memory, is there much difference between the two solutions -- i.e., can shared memory be read in parallel by multiple cores -- meaning there is no hardware bottleneck that would otherwise make both implementations roughly perform the same?

"
2893994,"If you install web.go through goinstall, you need to do:

import ""github.com/hoisie/web.go""


Goinstall is still an experimental system. It would be nice if you didn't have to include the full path.
"
31473429,"Is it a good idea to create own type from a slice in Golang?

Example:

type Trip struct {
    From   string
    To     string
    Length int
}

type Trips []Trip // <-- is this a good idea?

func (trips *Trips) TotalLength() int {
    ret := 0
    for _, i := range *trips {
        ret += i.Length
    }

    return ret
}


Is it somehow a convention in Golang to create types like Trips in my example? Or it is better to use []Trip in the whole project? Any pros and cons?
"
45445211,"As others have said, there are no guarantees you can assume about the order of execution.

The Go scheduler has an internal algorithm that decides how to allocate the processor and there is little you can do to control this without resorting to synchronization (which would be the right approach to take here).

If you are interested in learning how to control synchronization between tasks, take a look at the sync package, and also at how channels work:

https://golang.org/pkg/sync/

https://tour.golang.org/concurrency/2

However, I want to add something that others have not mentioned, and while it does not allow you to control execution order, it might be worth commenting due to the nature of the question.

There is a runtime.Gosched function that you can use to hint the scheduler. It would yield the processor so it is likely that other threads will execute.

https://golang.org/pkg/runtime/#Gosched

If you add a call to Gosched instead of sleeping, in my tests it is much more likely that ""hello"" and ""world"" would output in order (though again, there is no guarantee and they will appear in random order at times).

Try it like this:

package main

import (
    ""fmt""
    ""runtime""
)

func say(s string) {
    for i := 0; i < 5; i++ {
        fmt.Println(s, i)
        runtime.Gosched()
    }
}

func main() {
    go say(""world"")
    say(""hello"")
}


Lastly, take a look at this article which you might find interesting as well:

http://container-solutions.com/surprise-golang-thread-scheduling/
"
42633344,"Have a look at the present tool, it does a similar thing using flat files and might even be useful for you.

https://godoc.org/golang.org/x/tools/present
"
26909443,"So I am trying to write some code that allows me to edit values in an array in a struct.  This example uses ""Status"" as a possible value to alter, but this is just a simplification to try to get my intent across.

package main

import(
  ""fmt""
)

type Parent struct {
  Children []Child
}

type Child struct {
  Status string
}

func (p *Parent) Add() *Child {
  var child Child
  child.Status = ""1""
  p.Children = append(p.Children, child)
  return &p.Children[len(p.Children)-1]
}

func main() {
  var p Parent
  child := p.Add()
  child.Status = ""2""
  fmt.Println(p)
  fmt.Println(child)
}


This doesn't feel ""proper"".  How should I do this in golang?  Certainly I could pass the value in as a parameter, but in my particular case I would like to edit function pointers that are inside the Child struct (not in this code to keep it short) after having added the child.  That feels nicer, but maybe I just need to pass them as parameters to the Add method?

eg

func (p *Parent) Add(fn1 func(), fn2 func()) *Child {


Anyway just wondering if anybody has any thoughts on this type of situation.
"
31541855,"Here's how you do it.


Assemble fromDate and toDate.
Create bson.ObjectId with bson.NewObjectIdWithTime()
Query for date range


Example: Query for posts created 2015

year := 2015
fromDate := time.Date(year, time.January, 1, 0, 0, 0, 0, time.UTC)
toDate := time.Date(year+1, time.January, 1, 0, 0, 0, 0, time.UTC)
fromId := bson.NewObjectIdWithTime(fromDate)
toId := bson.NewObjectIdWithTime(toDate)
posts := []*Post{}
if e := cPost.Find(bson.M{""_id"": bson.M{""$gte"": fromId, ""$lt"": toId}}).All(&posts); e != nil {
}


note: Because ObjectId isn't ISODate assemble ObjectId from ISODate
"
40132097,"There are quite a few errors in your code.

As a ""pre-first"", always check returned errors!

First, os.Open() opens the file in read-only mode. To be able to replace the file content on the disk,  you must open it in read-write mode instead:

file, err := os.OpenFile(fileName, os.O_RDWR, 0)


Next, when you open something that is an io.Closer (*os.File is an io.Closer), make sure you close it with the Close() method, best done as a deferred statement.

Next, *os.File is an io.Reader, but that is not the same thing as a byte slice []byte. An io.Reader may be used to read bytes into a byte slice. Use io.Copy() to copy the content from the file to the gzip stream (which will end up in the buffer).

In certain situation (where you don't close the gzip.Writer), you must call gzip.Writer.Flush() to ensure everything is flushed into its writer (which is the buffer in this case). Note that gzip.Writer.Close() also flushes, so this may seem like an unnecessary step, but must be done for example if the Close() of the gzip.Writer is also called as a deferred statemement, because then it may not be executed before we use the content of the buffer. Since in our examle we close the gzip writer after io.Copy(), that will take care of necessary flushes.

Next, to replace the content of the original file, you must seek back to the beginning of the file to replace. For that, you may use File.Seek().

Next, you may again use io.Copy() to copy the contents of the buffer (the gzipped data) to the file.

And last, since the gzipped content will most likely be shorter than the original file size, you must truncate the file at the size of the gzipped content (else uncompressed content of the original file may be left there).

Here's the complete code:

file, err := os.OpenFile(fileName, os.O_RDWR, 0)
if err != nil {
    log.Fatalf(""Error opening %q: %v"", fileName, err)
}
defer file.Close()

// Check if gzip should be applied
if *metaGzip {
    var b = &bytes.Buffer{}
    w := gzip.NewWriter(b)
    if _, err := io.Copy(w, file); err != nil {
        panic(err)
    }
    if err := w.Close(); err != nil { // This also flushes
        panic(err)
    }
    if _, err := file.Seek(0, 0); err != nil {
        panic(err)
    }
    if _, err := io.Copy(file, b); err != nil {
        panic(err)
    }
    if err := file.Truncate(int64(b.Len())); err != nil {
        panic(err)
    }
}


Note: The above code will replace the file content on your disk. If you don't want this and you just need the compressed data, you may do it like this. Note that I used a new input variable of type io.Reader, as a value of bytes.Buffer (or *bytes.Buffer) cannot be assigned to a variable of type *os.File, and we will most likely only need the result as a value of io.Reader (and this is implemented by both):

var input io.Reader

file, err := os.Open(fileName)
if err != nil {
    log.Fatalf(""Error opening %q: %v"", fileName, err)
}
defer file.Close()

// Check if gzip should be applied
if *metaGzip {
    var b = &bytes.Buffer{}
    w := gzip.NewWriter(b)
    if _, err := io.Copy(w, file); err != nil {
        panic(err)
    }
    if err := w.Close(); err != nil { // This also flushes
        panic(err)
    }
    input = b
} else {
    input = file
}

// Use input here


Note #2: If you don't want to ""work"" with the compressed data but you just want to send it e.g. as the web response, you don't even need the bytes.Buffer, you can just ""stream"" the compressed data to the http.ResponseWriter.

It could look like this:

func myHandler(w http.ResponseWriter, r *http.Request) {
    file, err := os.Open(fileName)
    if err != nil {
        http.NotFound(w, r)
    }
    defer file.Close()

    gz := gzip.NewWriter(w)
    defer gz.Close()

    if _, err := io.Copy(gz, file); err != nil {
        // handle error
    }
}


Proper content type will be detected and set automatically.
"
15862090,"In this code, no guarantees.

The main problem with the given sample code lies not in the channel behavior, but rather in the numerous created goroutines. All the goroutines are ""fired"" inside the same imbricated loop without further synchronization, so even before they start to send messages, we simply don't know which ones will execute first.

However this rises a legitimate question in general : if we somehow garantee the order of several blocking send instructions, are we guaranteed to receive them in the same order?

The ""happens-before"" property of the sendings is difficult to create. I fear it is impossible because :


Anything can happen before the sending instruction : for example, other goroutines performing their own sendings or not
A goroutine being blocked in a sending cannot simultaneously manage other sorts of synchronization


For example, if I have 10 goroutines numbered 1 to 10, I have no way of letting them send their own number to the channel, concurrently, in the right order. All I can do is use various kinds of sequential tricks like doing the sorting in 1 single goroutine.
"
6051270,"Initialize the type as you would initialize the underlying type. In your example, the underlying type is an int. For example,

package main

import (
    ""fmt""
)

type Num int

func main() {
    var m Num = 7
    n := Num(42)
    fmt.Println(m, n)
}

Output: 7 42


The built-in function make takes a type T, which must be a slice, map or channel type.
"
32486253,"The GOROOT is not set correctly in LiteIDE.  

In a terminal enter which go to know where gvm installed go.  Example:

/home/username/.gvm/gos/go1.6/bin/go


In LiteIDE, click on the grey box ""edit current environment"" right of the environment drop down menu.



Uncomment the GOROOT line in the system.env file and enter the correct path that you got from which go.  You omit ""/bin/go"".

GOROOT=/home/username/.gvm/gos/go1.6


Save the file.  If saving is greyed out, you might need to change the permission of LiteIDE's liteenv directory.  I installed mine to /opt/liteide/share/liteide/liteenv.

When the settings are configured correctly, this is what you should see in LiteIDE's Build Output window:

/home/username/.gvm/gos/go1.6/bin/go build -i [/home/username/go/src/project]
Success: process exited with code 0.
/home/username/go/src/bad/bad  [/home/username/go/src/project]
Hello World!
Success: process exited with code 0.


Instead of using the system environment config (the default in the drop down menu) I'm personally using the linux64-local.env file. My LiteIDE config file looks like this:

# native compiler linux amd64

GOROOT=/home/username/.gvm/gos/go1.6
#GOBIN=
GOARCH=amd64
GOOS=linux
CGO_ENABLED=1

PATH=$GOROOT/bin:$PATH

LITEIDE_GDB=gdb
LITEIDE_MAKE=make
LITEIDE_TERM=/usr/bin/gnome-terminal
LITEIDE_TERMARGS=
LITEIDE_EXEC=/usr/bin/xterm
LITEIDE_EXECOPT=-e

LITEIDE_SHELL=gnome-terminal;lxterminal;kconsole;xfce4-terminal;xterm

"
24421326,"I was recently reading on testing and examples in the go testing framework and did not really understand what they were for. I see that the documentation says:


  The package also runs and verifies example code. Example functions may include a concluding line comment that begins with ""Output:"" and is compared with the standard output of the function when the tests are run. (The comparison ignores leading and trailing space.)


However, I don't really appreciate the reason that this would exist. As I write my tests, it seems that it should be more than clear how to use the code just by reading the unit tests and the benchmarks. What additional motivation does the example section provide? It seems redundant to me, however, I am sure that the inventors of go put it for a good reason, specially because they seem to empathizes good programming practice by the design of their language. I hope to understand either their motivation or how this part of language can be used in a positive way in a golang project! :) 
"
27795117,"Using 2 different channels

You want to send values to 2 different channels. Sending a value to a channel is not an assignment, so you can't send on both channels in one step.

First store the values returned by boolInt(), then send the values to the 2 channels like this:

go func() {
    b, i := boolInt()
    chanBool <- b
    chanInt <- i
}()


Testing it:

go func() {
    b, i := boolInt()
    chanBool <- b
    chanInt <- i
}()

fmt.Println(""Received bool:"", <-chanBool)
fmt.Println(""Received int:"", <-chanInt)


Output:

Received bool: false
Received int: 1


Note: you first have to receive from chanBool because you created unbuffered channels, and because in the example we first send to chanBool, that blocks until the sent value is recevied and only then proceeds to send a value to the chanInt. Attempting to receive from chanInt first would cause a deadlock (""fatal error: all goroutines are asleep - deadlock!"").

Solution using only one channel

If you want to send multiple values on a channel, you can create a wrapper struct for the values:

type MyStruct struct {
    b bool
    i int
}


And using it:

ch := make(chan MyStruct)
go func() {
    b, i := boolInt()
    ch <- MyStruct{b, i}
}()

fmt.Println(""Received value:"", <-ch)


Output:

Received value: {false 1}


Note: You could also use a []interface{} slice as a wrapper, but a struct provides a clearer way and type safety to its fields.

Note #2: It would make things easier and clearer if the boolInt() function itself would return a MyStruct value:

func boolInt() MyStruct {
    return MyStruct{false, 1}
}


In which case code would be as simple as this:

ch := make(chan MyStruct)
go func() {
    ch <- boolInt()
}()


Alternative 1 channel solution

Another option is to make the channel type interface{} so it can receive values of any type, and just send/receive multiple values on it:

ch := make(chan interface{})
go func() {
    b, i := boolInt()
    ch <- b
    ch <- i
}()

fmt.Println(""Received values:"", <-ch, <-ch)


Output:

Received values: false 1

"
35487263,"Great question!

Looking at the source code of go/doc, we can see that it has to deal with this same case in readType function. There, it says:

324     func (r *reader) readType(decl *ast.GenDecl, spec *ast.TypeSpec) {
...
334     // compute documentation
335     doc := spec.Doc
336     spec.Doc = nil // doc consumed - remove from AST
337     if doc == nil {
338         // no doc associated with the spec, use the declaration doc, if any
339         doc = decl.Doc
340     }
...


Notice in particular how it needs to deal with the case where the AST does not have a doc attached to the TypeSpec. To do this, it falls back on the GenDecl. This gives us a clue as to how we might use the AST directly to parse doc comments for structs. Adapting the for loop in the question code to add a case for *ast.GenDecl:

for _, f := range d {
    ast.Inspect(f, func(n ast.Node) bool {
        switch x := n.(type) {
        case *ast.FuncDecl:
            fmt.Printf(""%s:\tFuncDecl %s\t%s\n"", fset.Position(n.Pos()), x.Name, x.Doc.Text())
        case *ast.TypeSpec:
            fmt.Printf(""%s:\tTypeSpec %s\t%s\n"", fset.Position(n.Pos()), x.Name, x.Doc.Text())
        case *ast.Field:
            fmt.Printf(""%s:\tField %s\t%s\n"", fset.Position(n.Pos()), x.Names, x.Doc.Text())
        case *ast.GenDecl:
            fmt.Printf(""%s:\tGenDecl %s\n"", fset.Position(n.Pos()), x.Doc.Text())
        }

        return true
    })
}


Running this gives us:

main.go:3:1:    GenDecl %!s(*ast.CommentGroup=)
main.go:11:1:   GenDecl &{[%!s(*ast.Comment=&{69 // FirstType docs})]}
main.go:11:6:   TypeSpec FirstType  %!s(*ast.CommentGroup=)
main.go:13:2:   Field [FirstMember] &{[%!s(*ast.Comment=&{112 // FirstMember docs})]}
main.go:17:1:   GenDecl &{[%!s(*ast.Comment=&{155 // SecondType docs})]}
main.go:17:6:   TypeSpec SecondType %!s(*ast.CommentGroup=)
main.go:19:2:   Field [SecondMember]    &{[%!s(*ast.Comment=&{200 // SecondMember docs})]}
main.go:23:1:   FuncDecl main   &{[%!s(*ast.Comment=&{245 // Main docs})]}
main.go:33:23:  Field [n]   %!s(*ast.CommentGroup=)
main.go:33:35:  Field []    %!s(*ast.CommentGroup=)


And, hey!

We've printed out the long-lost FirstType docs and SecondType docs! But this is unsatisfactory. Why is the doc not attached to the TypeSpec? The go/doc/reader.go file goes to extraordinary lengths to circumvent this issue, actually generating a fake GenDecl and passing it to the readType function mentioned earlier, if there is no documentation associated with the struct declaration! 

   503  fake := &ast.GenDecl{
   504   Doc: d.Doc,
   505   // don't use the existing TokPos because it
   506   // will lead to the wrong selection range for
   507   // the fake declaration if there are more
   508   // than one type in the group (this affects
   509   // src/cmd/godoc/godoc.go's posLink_urlFunc)
   510   TokPos: s.Pos(),
   511   Tok:    token.TYPE,
   512   Specs:  []ast.Spec{s},
   513  }


But why all this?

Imagine we changed the type definitions from code in the question slightly (defining structs like this is not common, but still valid Go):

// This documents FirstType and SecondType together
type (
    // FirstType docs
    FirstType struct {
        // FirstMember docs
        FirstMember string
    }

    // SecondType docs
    SecondType struct {
        // SecondMember docs
        SecondMember string
    }
)


Run the code (including the case for ast.GenDecl) and we get:

main.go:3:1:    GenDecl %!s(*ast.CommentGroup=)
main.go:11:1:   GenDecl &{[%!s(*ast.Comment=&{69 // This documents FirstType and SecondType together})]}
main.go:13:2:   TypeSpec FirstType  &{[%!s(*ast.Comment=&{129 // FirstType docs})]}
main.go:15:3:   Field [FirstMember] &{[%!s(*ast.Comment=&{169 // FirstMember docs})]}
main.go:19:2:   TypeSpec SecondType &{[%!s(*ast.Comment=&{215 // SecondType docs})]}
main.go:21:3:   Field [SecondMember]    &{[%!s(*ast.Comment=&{257 // SecondMember docs})]}
main.go:26:1:   FuncDecl main   &{[%!s(*ast.Comment=&{306 // Main docs})]}
main.go:36:23:  Field [n]   %!s(*ast.CommentGroup=)
main.go:36:35:  Field []    %!s(*ast.CommentGroup=)


That's right

Now the struct type definitions have their docs, and the GenDecl has its own documentation, too. In the first case, posted in the question, the doc was attached to GenDecl, since the AST sees the individual struct type definitions of ""contractions"" of the parenthesized-version of type definitions, and wants to handle all definitions the same, whether they are grouped or not. The same thing would happen with variable definitions, as in:

// some general docs
var (
    // v docs
    v int

    // v2 docs
    v2 string
)


So if you wish to parse comments with pure AST, you need to be aware that this is how it works. But the preferred method, as @mjibson suggested, is to use go/doc. Good luck!
"
38163481,"There's a certain edge case you are probably missing in your code. See https://getsatisfaction.com/codeeval/topics/bubble-sort-iterations-are-too-high-causing-solution-to-be-aborted-in-java
"
29444817,"Say I have the following code:

var x interface{}
y := 4
x = y
fmt.Println(reflect.TypeOf(x))


This will print int as the type. My question is how can I test for the type? I know there is the type switch which does this, so I could do:

switch x.(type) {
case int:
    fmt.Println(""This is an int"")
}


But if I only want to check for just one specific type the switch seems like the wrong tool. Is there a more direct method of doing this like

reflect.TypeOf(x) == int


or is the type switch the way to go?
"
34285040,"I need to insert two records in Oracle database from my go application using sqlx (https://github.com/jmoiron/sqlx) with go-oci8 (https://github.com/mattn/go-oci8) driver.
Second record references previous one by foreign key.
So I need to have primary key of first record (it is assigned from sequence with before insert trigger on first table) before I can insert second record.

So I experimented to get last inserted id:

create table t(x int primary key);
create sequence x_seq;


LastInsertId failed for me:

import(
    ""fmt""
    ""github.com/jmoiron/sqlx""
    _ ""github.com/mattn/go-oci8""
)

func main(){
    db, err := sqlx.Connect(""oci8"", ""integr/integr@localhost:49161/xe"")
    if err != nil {
       fmt.Println(err)
    }
    sql := ""insert into t values(x_seq.nextval)""
    r, err := db.Exec(sql)
    if err != nil {
       fmt.Println(err)
    }
    fmt.Println(r.RowsAffected())
    fmt.Println(r.LastInsertId())
}


Output:

1 
0 LastInsertId not supported


Then I tried to make stored function that inserts record and returns primary key.

create function f(x int) return int as
v int;
begin
    insert into t values(x)
    returning x into v;
    return v;
end;


But I failed to find a way to get its result. PostgreSQL style select fails:

SQL> select f(9) from dual;
select f(9) from dual
       *
ERROR at line 1:
ORA-14551: cannot perform a DML operation inside a query
ORA-06512: at ""INTEGR.F"", line 1


And OCI8 style variable binding does not work:

package main

import(
    ""fmt""
    ""github.com/jmoiron/sqlx""
    _ ""github.com/mattn/go-oci8""
)

func main(){
    db, err := sqlx.Connect(""oci8"", ""integr/integr@localhost:49161/xe"")
    if err != nil {
       fmt.Println(err)
    }
    sql := sqlx.Rebind(sqlx.NAMED,""begin ? := f(?); end;"")
    var a int
    _, err = db.Exec(sql, a, 333)
    if err != nil {
       fmt.Println(err)
    }
    fmt.Println(sql)
    fmt.Println(a)
}


Output:

begin :arg1 := f(:arg2); end;
0


How to get last inserted ID, or how to get value from stored funcion in Go from Oracle?
"
22824962,"You can only have one case statement for each value, so that code is illegal. Additionally, fallthrough only works once, so even if it worked as you wanted for 0, it would still fail for 1.

The simplest solution is to put the initial 0,1 case in its own switch or if before the main switch.
"
40843976,"Refactor your code, move the limit outside of your function which tests can change:

var limit = 1 << 32

var ErrTooLarge = errors.New(""String is too large!"")

func Process(s string) error {
    if len(s) > limit {
        return ErrTooLarge
    }
    // All OK
    return nil
}


Testing it:

func TestProcess(t *testing.T) {
    // Save limit and restore it at the end:
    old := limit
    defer func() { limit = old }()

    // Test success
    if err := Process(""123""); err != nil {
        t.Errorf(""Expected success, got: %v"", err)
    }

    // Test failure (too large string)
    limit = 5
    if err := Process(""123456""); err != ErrTooLarge {
        t.Errorf(""Expected ErrTooLarge, got: %v"", err)
    }
}


Running go test -cover:

PASS
coverage: 100.0% of statements
ok      play    0.001s

"
42473964,"No, there is not. The Go language specification specifies this clearly:


  Exported identifiers
  
  An identifier may be exported to permit access to it from another package. An identifier is exported if both:
  
  
  the first character of the identifier's name is a Unicode upper case letter (Unicode class ""Lu""); and
  the identifier is declared in the package block or it is a field name or method name.
  
  
  All other identifiers are not exported.

"
5367961,"Can anyone tell my why this wouldn't compile?

package main

type myint int
func set(a **myint) {
    i := myint(5)
    *a = &i 
}

func main() {
    var k *int
    set( (**myint)(&k) ) // cannot convert &k (type **int) to type **myint
    print( *k )
}


My reasoning so far is this. All types in Golang are different, but it allows to convert from one type to another with C-like cast syntax as long as underlying types are identical. In my example, converting 'int' to 'myint' is not a problem. '*int' to '*myint' isn't either. It's when you have pointer to pointer problems arise. I've been stuck on this for the second day now. Any help is appreciated.
"
26909828,"I think you should create the Child outside of the Add method and pass it in. If you want to manipulate the Child, do that before you passed it in. You might use methods on the Child struct to do that:

func (c *Child) Init(fn1 func(), fn2 func()) {
  c.Status = ""1""
  ...
}

func (p *Parent) Add(c *Child) *Child {
  p.Children = append(p.Children, c)
  return c
}

func main() {
  var p Parent
  var child Child
  child.Init(...)       // <- pass something in there...
  p.Add(&child)
  child.Status = ""2""
  fmt.Println(p)
  fmt.Println(child)
}

"
27397306,"I know this is very basic, but i think the official documentation at [beego website][1]

[1]: http://beego.me/docs/mvc/model/query.md doesn't give clear direction.

I made a RESTful API using beego framework. As it promised, it generates basic CRUD code for my app. The problem is READ method doesn't return all data. By all data  I mean data in a table including data from all tables related to it. 

this is the output from the generated code (i'm using swagger to call it):

{
  ""data"": [
    {
      ""Id"": 1,
      ""CustomerId"": {
        ""Id"": 2,
        ""Name"": """",
        ""Phone"": """",
        ""Email"": """",
        ""CreatedAt"": ""0001-01-01T00:00:00Z"",
        ""UpdatedAt"": ""0001-01-01T00:00:00Z""
      },
      ""Saldo"": 2500000,
      ""CreatedAt"": ""2014-12-10T08:10:10+07:00"",
      ""UpdatedAt"": ""2014-12-10T08:10:10+07:00""
    }
  ],
  ""totals"": 1
}


see, it doesn't return the Name, Phone, and Email.
so i look into documentation and found this method RelatedSel() but still I have no idea how to use it properly.

here's my code:

func GetAllCustomerSaldo(query map[string]string, fields []string, sortby []string, order []string,
    offset int64, limit int64) (ml []interface{}, err error, totals int64) {
    o := orm.NewOrm()
    qs := o.QueryTable(new(CustomerSaldo))
    qs.RelatedSel(""CustomerId__Customers"").All(&CustomerSaldo{})
...


after trying many parameter possibilities, i still get this error:

Handler crashed with error unknown model/table name `Customers`


Anyone here have same problem with me? any solution guys?
"
42197468,"I use regexp.FindAll() to get all the matches. I don't understand the parameter of n, and in the office reference, there is no explanation. How can I set the parameter.

// FindAll is the 'All' version of Find; it returns a slice of all successive
// matches of the expression, as defined by the 'All' description in the
// package comment.
// A return value of nil indicates no match.
func (re *Regexp) FindAll(b []byte, n int) [][]byte {}

"
35042360,"Here is the code, that calculates current offset between local and specified timezones. I agree with Ainar-G's comment that offset makes sense only with relation to specified moment in time:

package main

import (
    ""fmt""
    ""time""
)

func main() {
    loc, err := time.LoadLocation(""MST"")
    if err != nil {
        fmt.Println(err)
    }

    now := time.Now()
    _, destOffset := now.In(loc).Zone()
    _, localOffset := now.Zone()

    fmt.Println(""Offset:"", destOffset-localOffset)
}

"
19243431,"I found a strange problem in golang.The program executed by exec.Start() will quit if the parent program is interrupt by the signal os.Interrupt,while the child program will NOT quit if the parent program exit normally.What's the difference between that two conditions?
   For examples:

package main

import ""fmt""
import ""os""
import ""time""
import ""os/exec""

func main(){
    cmd := exec.Command(""sleep"", ""100000"")
    cmd.Env = os.Environ()
    fmt.Println(cmd.Env)
    cmd.Start()

    time.Sleep(1e9*20)
    return
} 


In the later condition the parent of sleep 100000 will be the init process after 20s if we didn't interrupt the main program.
"
35791164,"Please check this out difference between godep update and godep save.
I usually just use godep save unless I am updating a specific package. This grabs all the updated packages for the project from GOPATH. 
BTW: I am also fairly new to Godeps.
"
44853488,"I fully understood my question, it was about RSA_public_decrypt method of openssl: https://www.openssl.org/docs/man1.1.0/crypto/RSA_public_decrypt.html

I did not found any pure-golang realization. Realization with cgo: https://github.com/dgkang/rsa/blob/master/rsa/rsa.go

UPD, work for me:

func RSA_public_decrypt(pubKey *rsa.PublicKey, data []byte) []byte {
    c := new(big.Int)
    m := new(big.Int)
    m.SetBytes(data)
    e := big.NewInt(int64(pubKey.E))
    c.Exp(m, e, pubKey.N)
    out := c.Bytes()
    skip := 0
    for i := 2; i < len(out); i++ {
        if i+1 >= len(out) {
            break
        }
        if out[i] == 0xff && out[i+1] == 0 {
            skip = i + 2
            break
        }
    }
    return out[skip:]
}

"
43601858,"The following program runs fine.

package main

import (
    ""fmt""
)

type Person interface {
    Hello()
}

type Joker struct {
    Name string
}

func (j Joker) Hello() {
    fmt.Println(j.Name, ""says, \""Hello!\"""")
}

func main() {
    var j Joker = Joker{""Peter""}
    invokeHello(j)
}

func invokeHello(p Person) {
    p.Hello()
}


Here is the output.

$ go run foo.go
Peter says, ""Hello!""


But when I change the Hello method to receive a pointer, I get errors.

package main

import (
    ""fmt""
)

type Person interface {
    Hello()
}

type Joker struct {
    Name string
}

func (j *Joker) Hello() {
    fmt.Println(j.Name, ""says, \""Hello!\"""")
}

func main() {
    var j *Joker = &Joker{""Peter""}
    invokeHello(j)
}

func invokeHello(p *Person) {
    p.Hello()
}


Here are the errors.

$ go run bar.go
# command-line-arguments
./bar.go:21: cannot use j (type *Joker) as type *Person in argument to invokeHello:
    *Person is pointer to interface, not interface
./bar.go:25: p.Hello undefined (type *Person has no field or method Hello)


How can I fix the second program?
"
40216428,"I have started programming in Go and I was wondering when new(Object) is used it allocates memory to the size of that object right? If this is the case how do I free this memory once I have finished using the object? 

I ask this because in C++ when new is used on an object you can delete the object once there is no longer any need for the object to be stored.

I have been searching to see if Go does have delete or something similar to C++ but I have been unable to find anything.

Any help is much appreciated.
"
40688567,"I'm wrapping a Go library for Python. I need to be able to return None, but it's not finding it at compile time:

/*
#cgo pkg-config: python3
#define Py_LIMITED_API
#include 
*/
import ""C""

//export Nothing
func Nothing(self, args *C.PyObject) (status *C.PyObject) {
    C.Py_IncRef(C.Py_None)
    return C.Py_None
}


Here's the output of go build

go build -buildmode=c-shared -o mymodule.so
# example.com/mywrapper
/tmp/go-build293667616/example.com/mywrapper/_obj/_cgo_main.o:(.data.rel+0x0): undefined reference to `Py_None'
collect2: error: ld returned 1 exit status


I'm not understanding how it can be finding all of the other Py* functions and types (PyArgs_ParseTuple and PyLong_FromLong work just fine), but can't find Py_None. The Python library is obviously being loaded. What's going on here?
"
25325229,"I have an SDL2 go program which tries to write a pixel array to the screen. When I try and update the texture with the new pixels the program panics with a runtime error:

fatal error: unexpected signal during runtime execution


Unfortunately I can find little to no documentation about how to pass around unsafe pointers in Go and I'm not sure if I'm approaching this correctly, here is some example code that exhibits the problem:

func main() {
    window := sdl.CreateWindow(""test"", sdl.WINDOWPOS_UNDEFINED, sdl.WINDOWPOS_UNDEFINED,
        800, 600, sdl.WINDOW_SHOWN)
    renderer := sdl.CreateRenderer(window, -1, 0)
    texture := sdl.CreateTexture(renderer, sdl.PIXELFORMAT_ARGB8888,
        sdl.TEXTUREACCESS_STATIC, 800, 600)

    defer renderer.Destroy()
    defer texture.Destroy()
    defer window.Destroy()

    for {
        pixels := make([]uint32, 800*600)

        texture.Update(nil, unsafe.Pointer(&pixels), int(800*unsafe.Sizeof(pixels)))
        window.UpdateSurface()

        renderer.Clear()
        renderer.Copy(texture, nil, nil)
        renderer.Present()
    }

    sdl.Delay(1000)
    sdl.Quit()
}


This code will compile with no errors, but when ran it will produce a runtime panic, but I can't see what would cause that in this code.

I am using these SDL2 Go bindings: https://github.com/veandco/go-sdl2
"
31436063,"Use binary shift operators to load seven bits at a time into a bit buffer, and whenever the bit buffer has eight bits, output that.  At the end, if there are any bits leftover, output a final byte with what's in the buffer.

So something like (don't know Go, but this should be close):

bits = 0
bitbuf = 0
... some loop ...
    ...make your seven bits ...
    bitbuf |= sevenbits << bits
    bits += 7
    if bits >= 8 {
        output(bitbuf & 0xff)
        bitbuf >>= 8;
        bits -= 8;
    }
...
if bits > 0 {
    output(bitbuf)
}

"
1744135,"Differences? Pretty much everything!


Concurrency and channels.
Interfaces.
Static typechecking.
...

"
40843808,"In some code I have a test ensuring that a string length is smaller than 2^32. But it is difficult to test since generating a bigger string for testing would probably crash the test program with an out of memory error.

How may I achieve 100% test coverage but still testing for such case just to be safe?
"
19886142,"In the tutorial, you created the file TestPage previously.  Which is the page you should be navigating to when you first build the server.  In the tutorial, they have you navigate to view/test instead of view/TestPage as you should which is what creates the confusion.
"
38427250,"I would like to get a list of the wireless networks available inside a Go program running under Linux OS. It's pretty easy to get this information from a Linux command line with iwlist but I really want to have it done natively in Go. Any ideas of which package should be used? Thank you.
"
1801214,"One thing to realise is that the Erlang concurrency model does NOT really specify that the data in messages must be copied between processes, it states that sending messages is the only way to communicate and that there is no shared state. As all data is immutable, which is fundamental, then an implementation may very well not copy the data but just send a reference to it. Or may use a combination of both methods. As always, there is no best solution and there are trade-offs to be made when choosing how to do it.

The BEAM uses copying, except for large binaries where it sends a reference.
"
18170244,"There is not currently a better way than context.Errorf() and friends. Python just got pdb support in the 1.8.3 SDK. I have not heard of any similar debugger support for go. It is perhaps worth asking on the app engine go list about this.
"
35632942,"I am trying to write to 100000 files in parallel with Go.

I am not sure why, but this code below crashes ~30% of the time when I call it with the argv parameter ""100000"".

Here is the crash:

goroutine 3749 [chan send]:
main.CallShellCommand(0xc820016180, 0xea1)
        .../parallel.go:13 +0x1bf
created by main.main
        .../parallel.go:22 +0xbd


Here is the code:

package main

import ""fmt""
import ""io/ioutil""
import ""strconv""
import ""os""
import ""runtime""

func CallCommand(ch chan struct{}, id int) {
    ioutil.WriteFile(fmt.Sprintf(""/tmp/my_prefix_%d"", id), []byte(""HELLO\n""), 0644)
    ch <- struct{}{}
}

func main() {
    runtime.GOMAXPROCS(4)
    n, _ := strconv.Atoi(os.Args[1])
    ch := make(chan struct{})
    for i := 0; i < n; i++ {
        go CallCommand(ch, i+1)
    }
    for j := 0; j < n; j++ {
        <-ch
    }
}


For the record:


My computer has 4 cores
This is go 1.5.3

"
27469986,"My problem was that I run go file from random directory. To solve it I changed directory (cd) to parent of templates folder. 
"
25809786,"It is technically possible: you could create an if statement for the >170 case, then define an array of 170 function pointers and use an index operation for the other two cases. I can't think of a reasonable case where this solution is actually better than the one you already have though.
"
41887654,"When iterating over a map with a range loop, the iteration order is not specified and is not guaranteed to be the same from one iteration to the next.

You can't surely print by newest without storing key somewhere else.

Read this: doc

You can store key and maintain order. See this

Again, if you want to print in reverse order. Iterate array in reverse order.
"
18298762,"
To check if website is accessed from outside, check remote IP address. If it is not from 127.0.0.1 or ::1 (IPv6) then it is outside. Use function func (*IPConn) RemoteAddr.
To disable some functions check the above condition.
To hide the whole site, bind your service to the localhost interface (127.0.0.1) only.


Binding

net.Listen(""tcp"", ""localhost:8080"")


or

net.Listen(""tcp6"", ""ip6-localhost:8080"")


Using http package

http.ListenAndServe(""localhost:8080"", nil)

"
10839802,"You might try working directly with templates.  Example:

package main

import (
    ""bytes""
    ""encoding/xml""
    ""fmt""
    ""text/template""
)

type ele struct {
    Name  string
    Attrs []attr
}

type attr struct {
    Name, Value string
}

var x = `
`

func main() {
    // template function ""xml"" defined here does basic escaping,
    // important for handling special characters such as "".
    t := template.New("""").Funcs(template.FuncMap{""xml"": func(s string) string {
        var b bytes.Buffer
        xml.Escape(&b, []byte(s))
        return b.String()
    }})
    template.Must(t.Parse(x))
    e := ele{
        Name: ""Meh"",
        Attrs: []attr{
            {""hi"", ""there""},
            {""um"", `I said ""hello?""`},
        },
    }
    b := new(bytes.Buffer)
    err := t.Execute(b, e)
    if err != nil {
        fmt.Println(err)
        return
    }
    fmt.Println(b)
}


Output:




"
12224412,"I've just started learning go, and have been working through the tour. The last exercise is to edit a web crawler to crawl in parallel and without repeats.

Here is the link to the exercise: http://tour.golang.org/#70

Here is the code. I only changed the crawl and the main function. So I'll just post those to keep it neat.

    // Crawl uses fetcher to recursively crawl
    // pages starting with url, to a maximum of depth.
    var used = make(map[string]bool)
    var urlchan = make(chan string)
    func Crawl(url string, depth int, fetcher Fetcher) {
        // TODO: Fetch URLs in parallel.
        // Done: Don't fetch the same URL twice.
        // This implementation doesn't do either:
        done := make(chan bool)
        if depth <= 0 {
            return
        }
        body, urls, err := fetcher.Fetch(url)
        if err != nil {
            fmt.Println(err)
            return
        }
        fmt.Printf(""\nfound: %s %q\n\n"", url, body)
        go func() {
            for _, i := range urls {
                urlchan <- i
            }
            done <- true
        }()
        for u := range urlchan {
            if used[u] == false {
                used[u] = true
                go Crawl(u, depth-1, fetcher)
            }
            if <-done == true {
                break
            }
        }
        return
    }

    func main() {
        used[""http://golang.org/""] = true
        Crawl(""http://golang.org/"", 4, fetcher)
    }


The problem is that when I run the program the crawler stops after printing

    not found: http://golang.org/cmd/


This only happens when I try to make the program run in parallel. If I have it run linearly then all the urls are found correctly.

Note: If I am not doing this right (parallelism I mean) then I apologise.
"
21461032,"Admittedly, it's somewhat of a quirk, but there's an explanation for it.

Imagine an interface{} variable as a struct composed of two fields: one is the type and another is the data. ([]int and nil). Actually, it looks just like that in the Go runtime.

struct Iface                                                                                                                   
{                                                                                                                              
    Itab*   tab;                                                                                                               
    void*   data;                                                                                                              
};   


When you pass your nil slice to yes, only nil is passed as the value, so your comparison boils down to nil == nil. 

Meanwhile, calling no automatically wraps your variable in an interface{} type and the call becomes something akin to no(interface{[]int, nil}). So the comparison in no could be seen as interface{[]int, nil} == nil, which turns out to be false in go.

The issue is actually explained in the Go FAQ.
"
45089928,"Trying to make Go generic is one of the great pitfalls for new Go devs. Stop. You're saving five of lines of code:

for i := len(foos) - 1; i >= 0; i-- {
    if foos[i] == foo1 {
        foos = append(foos[:i], foos[i+1:]...)
    }
}


Yes, in generic languages, you would wrap those five lines up in to a nice stdlib method, but Go is not a generic language. Trying to do this with reflection is slow, but that's not the reason to avoid it. Reflection is very complicated. It's hard to get it right. You'll spend much more time figuring out Value and chasing weird corner cases than you'll spend rewriting those five lines of code 12 times (including fixing the time you accidentally cut/paste it wrong, and the one time you mess up i--). Just write them.

Just writing the code lets you decide what equality means. It lets you decide whether to stop searching at the first match, or keep going through the whole list. It lets you do what this program needs rather than focusing on what some generic program might someday need.

I love generic programming. Few things make me happier than creating an elegant fold in Haskell. But that's not the way of Go. In Go you generally just write the code, keep it simple and obvious, and move on.

Andy makes a good point that if you have to do this a lot, list may be a better data structure. And I often find that when I have three types that all seem to have parallel methods, it turns out that they should all have been part of a single struct (do you really need separate lists here at all?) But in any case, stay away from reflection unless you have a very specialized problem where you really mean ""anything"" rather than ""one of these short list of things.""

(It's noteworthy that you call out append(). I don't think it's possible to write append() in Go. That's why it had to be part of the language rather than a stdlib function. When I started working in Go, I took that as a significant flaw in the language. The longer I've worked in Go, the more I've found it not to matter so much. You just write the code and move on.)
"
36917148,"In order to be able to get the elements out you have to have ""exported"" fields, meaning that app_id and app_name in the App struct should start with a capital letter. In addition, your app_name field is also missing a ,attr in its xml field tag. See below for a working example of your code. I've added comments on the lines that require some changes.

package main

import (
    ""fmt""
    ""encoding/xml""
)

func main() {
    data:=`
    
    
        
        
    
    `

    type App struct {
        App_id   string  `xml:""app_id,attr""`    // notice the capitalized field name here
        App_name string  `xml:""app_name,attr""`  // notice the capitalized field name here and the `xml:""app_name,attr""`
    }

    type AppList struct {
        XMLName xml.Name `xml:""applist""`
        Apps  []App      `xml:""app""`
    }

    var portfolio AppList
    err := xml.Unmarshal([]byte(data), &portfolio)
    if err != nil {
        fmt.Printf(""error: %v"", err)
        return
    }
    fmt.Printf(""application ID:: %q\n"", portfolio.Apps[0].App_id)       // the corresponding changes here for App
    fmt.Printf(""application name:: %q\n"", portfolio.Apps[0].App_name)   // the corresponding changes here for App
}

"
33722676,"I do not believe you're doing what you think you are.

curl -X POST -d ""Screen Shot 2015-11-15 at 6.09.58 pm.png"" http://localhost:8000/image/agent123/property --header ""Content-Type:image/png"" --header ""X-User-Agent:agent-php"" 


Will not send the file ""Screen Shot 2015-11-15 at 6.09.58 pm.png"", it's gonig to send the literal text as the body. You probably want ""-d @'Screen Shot 2015-11-15 at 6.09.58 pm.png'"".

Which then your ""good"" result is not exactly good, so you have to figure out what the bug is at the receiving end on the server. As the GUI client you're using is probably sending the file, whereas cURL is not. And your backend seems to accept text, not files. 
"
32330631,"I'm passing argument from console. There are some flags too. Like:

go run test.go ""-IP=10.10.10.10"" ""-db=kite"" ""-wv=45"" ""-cv=75"" ""A = value1"" ""B = value2"" ""C = 100"" ""D := ((A-B)/A)*C"" ""D ?""


Here, -IP, -db, -wv, -wc these four are flags and others are passing as normal argument as I know.

Number of flags can be variable.

How can I know how many flags are passed to my program. In this case 4 flags are passed.
"
35084268,"I have one Golang struct shared among multiple goroutines.
For concurrent access to struct members, there is the mutex sync.RWMutex.
For struct member that is accessed by one single goroutine, is there need of mutex protection?

For example, in the code below, one single writer goroutine accesses the member shared.exclusiveCounter, without any lock protection. Is this correct/safe? Or is there need of mutex because the whole struct is accessed by multiple goroutines thru a shared pointer?

package main

import (
    ""fmt""
    ""sync""
    ""time""
)

func main() {
    s := &shared{mutex: &sync.RWMutex{}}

    readerDone := make(chan int)
    writerDone := make(chan int)

    go reader(s, readerDone)
    go writer(s, writerDone)

    <-readerDone
    <-writerDone
}

type shared struct {
    mutex            *sync.RWMutex
    sharedCounter    int // member shared between multiple goroutines, protected by mutex
    exclusiveCounter int // member exclusive of one goroutine -- is mutex needed?
}

func (s *shared) readCounter() int {
    defer s.mutex.RUnlock()
    s.mutex.RLock()
    return s.sharedCounter
}

func (s *shared) setCounter(i int) {
    defer s.mutex.Unlock()
    s.mutex.Lock()
    s.sharedCounter = i
}

func reader(s *shared, done chan<- int) {
    for {
        time.Sleep(2 * time.Second)
        counter := s.readCounter()
        fmt.Printf(""reader: read counter=%d\n"", counter)
        if counter > 5 {
            break
        }
    }
    fmt.Printf(""reader: exiting\n"")
    done <- 1
}

func writer(s *shared, done chan<- int) {
    s.exclusiveCounter = 0
    for {
        time.Sleep(1 * time.Second)
        s.exclusiveCounter++
        fmt.Printf(""writer: writing counter=%d\n"", s.exclusiveCounter)
        s.setCounter(s.exclusiveCounter)
        if s.exclusiveCounter > 5 {
            break
        }
    }
    fmt.Printf(""writer: exiting\n"")
    done <- 1
}


Run it on playground
"
28719523,"The following function does not work with Swedish characters, i.e å/Å/ä/Ä/ö/Ö.

func StartsWithUppercase(s string) bool {
    return (string(s[0]) == strings.ToUpper(string(s[0])))
}


How do I proceed to check if a string starts with upper case Swedish character? 

w := ""åÅäÄöÖ""
for i := 0; i < len(w); i++ {
    fmt.Println(i, w[i])
}


Results in:

 1. 195 
 2. 165
 3. 195
 4. 133
 5. 195 
 6. 164
 7. 195
 8. 132
 9. 195
 10. 182 
 11. 195
 12. 150

"
28472360,"os.Args[1] = ""-conf=my.conf""

flag.Parse()

Notice that the config file name is hard-coded.
"
33632446,"Your method of generating the random numbers is fine, however xs is empty, and Go doesn't automatically extend slices. You could use append, however since you know the size in advance, it's most efficient to replace

var xs []float64


with

xs := make([]float64, 10)


which will give it the right size initially.
"
41335088,"Ideally, whatever is constructing the Parent struct should initialize it so it's in a usable state. But since you have no control over it, the next best thing is to have a piece of code that lets you set the WithContext pointer in Parent, by providing a member function on Parent or just a piece of code in your application to set it, since WithContext field is exported.
"
42170463,"Alternative solution: use sed to insert additional field into the generated parser. Then, in your grammar action, assign the value.

go tool yacc -o parser.go -p Filter parser.y
sed -i '/type FilterParserImpl struct/a tree *treeNode' parser.go


The generated parser:

type FilterParserImpl struct {
tree *treeNode
    lval  FilterSymType
    stack [FilterInitialStackSize]FilterSymType
    char  int
}


Grammar action:

filter { Filterrcvr.tree = $1 }

"
42416871,"Prometheus is a TSDB. And it is intended to consume gigabytes and gigabytes of data.

On a Cloud Foundry platform, you are limited by available resources. 
So, why deploy Prometheus to Cloud Foundry?

Why not spin up a standalone bosh director and deploy Prometheus through the director as a Bosh deployment, and a standalone. Then inject it as a CUPS into Cloud Foundry?

I am just curious and trying to understand the use case.
"
44376544,"Why not use the windows registry?

https://godoc.org/golang.org/x/sys/windows/registry

How to return a default value from windows/registry with golang

package main

import (
    ""golang.org/x/sys/windows/registry""
    ""log""
    ""fmt""
)

func main() {

    k, err := registry.OpenKey(registry.LOCAL_MACHINE, `SOFTWARE\Microsoft\Windows NT\CurrentVersion`, registry.QUERY_VALUE)
    if err != nil {
        log.Fatal(err)
    }
    defer k.Close()

    cv, _, err := k.GetStringValue(""CurrentVersion"")
    if err != nil {
        log.Fatal(err)
    }
    fmt.Printf(""CurrentVersion: %s\n"", cv)

    pn , _, err := k.GetStringValue(""ProductName"")
    if err != nil {
        log.Fatal(err)
    }
    fmt.Printf(""ProductName: %s\n"", pn)

    maj, _, err := k.GetIntegerValue(""CurrentMajorVersionNumber"")
    if err != nil {
        log.Fatal(err)
    }
    fmt.Printf(""CurrentMajorVersionNumber: %d\n"", maj)

    min, _, err := k.GetIntegerValue(""CurrentMinorVersionNumber"")
    if err != nil {
        log.Fatal(err)
    }
    fmt.Printf(""CurrentMinorVersionNumber: %d\n"", min)

    cb, _, err := k.GetStringValue(""CurrentBuild"")
    if err != nil {
        log.Fatal(err)
    }
    fmt.Printf(""CurrentVersion: %s\n"", cb)    
}


This returns:

PS C:\Users\Adamar\Desktop> .\WindowsVersion.exe
CurrentVersion: 6.3
ProductName: Windows Server 2016 Standard Evaluation
CurrentMajorVersionNumber: 10
CurrentMinorVersionNumber: 0
CurrentVersion: 14393


Although in the newest version of windows you have to read the following keys to get the version: CurrentMajorVersionNumber & CurrentMinorVersionNumber
"
35029311,"I am writing a web app using Golang, and I am writing the file upload part now, but I don't know what is the most secure way to do it.

Can anyone give me some information? Thanks.

Edit: I mean how to prevent users upload their file to the position other than the position I want. User may modify the filename to cause it to be uploaded to a specific directory. Are there any way to prevent it?

And I want to ask if the hacking technique like web shell workable to the web app written in Golang? I think is not, but I want to check if my thinking is right.
"
45741268,"This:

for range <-md{


is not the same as:

for range md{


The latter ranges over the channel (what you want), while the former ranges over the value received from the channel when the loop starts, which happens to be a two-element array, hence the two executions. You're also ignoring the value received from the channel in the for statement, and reading from it again in the loop body, ignoring every other message on the channel (though this makes no difference in the example, since every value is identical, it would make a significant difference in practice). What you really want is:

for foo := range md{
    fmt.Println(foo)
}


Here's a working version of your playground example, slightly modified to avoid ""program took too long"" errors because in its current form it never stops: https://play.golang.org/p/RSUJFvluU5
"
42406445,"I created the private repository using the coding.net.
I use docker images alpine and centos.
I can go get git.coding.net/alphayan/orionv2.git successful from docker-centos, but I can't go get git.coding.net/alphayan/test.git from docker-alpine.It returns an error stating:  

/go/src # go get -u -v  git.coding.net/alphayan/test.git
# cd .; git ls-remote https://git.coding.net/alphayan/test
fatal: could not read Username for 'https://git.coding.net': terminal prompts disabled
# cd .; git ls-remote git+ssh://git.coding.net/alphayan/test
Permission denied (publickey).
fatal: Could not read from remote repository.

Please make sure you have the correct access rights
and the repository exists.
# cd .; git ls-remote ssh://git.coding.net/alphayan/test
Permission denied (publickey).
fatal: Could not read from remote repository.

Please make sure you have the correct access rights
and the repository exists.
package git.coding.net/alphayan/test.git: cannot download, git.coding.net/alphayan/test uses insecure protocol


From centos it let me use the username and password:

[root@83fc8067fc95 /]# go get -u -v git.coding.net/alphayan/test.git
Username for 'https://git.coding.net':


finally, I find it caused by the git's version, the centos with git 1.8.3 and the alpine with git 2.11.0.
then I change the centos git's version with 2.11.0, becomes the same wrong with alpine.
I think I can modify golang or git source file solve this problem,
could someone help me? thinks~!
"
27727469,"The approach I've found workable is git's submodule system. Using that you can submodule in a given version of the code and upgrading/downgrading is explicit and recorded - never haphazard.

The folder structure I've taken with this is:

+ myproject
++ src
+++ myproject
+++ github.com
++++ submoduled_project of some kind.

"
32217287,"To build an archive callable from C, you will need to mark them as exported CGo symbols.
For example, if I create a file foo.go with the following contents:

package main

import (
    ""C""
    ""fmt""
)

//export PrintInt
func PrintInt(x int) {
    fmt.Println(x)
}

func main() {}


The important things to note are:


The package needs to be called main
You need to have a main function, although it can be empty.
You need to import the package C
You need special //export comments to mark the functions you want callable from C.


I can compile it as a C callable static library with the following command:

go build -buildmode=c-archive foo.go


The results will be an archive foo.a and a header foo.h.  In the header, we get the following (eliding irrelevant parts):

...
typedef long long GoInt64;
...
typedef GoInt64 GoInt;
...
extern void PrintInt(GoInt p0);
...


So that's enough to call the exported function.  We can write a simple C program that calls it like so:

#include ""foo.h""

int main(int argc, char **argv) {
    PrintInt(42);
    return 0;
}


We can compile it with a command like:

gcc -pthread foo.c foo.a -o foo


The -pthread option is needed because the Go runtime makes use of threads.  When I run the resulting executable it prints 42.
"
10757939,"If I'm understanding you correctly, you want a way of routing the same URL to different handlers based on the request method rather than just the path? If that's the case...

For comparison, using Python + Django, the way you're doing this is pretty standard:

def my_django_view(request):
    if request.method == ""POST"":
        try_to_process_posted_data()
    elif request.method == ""GET"":
        show_a_form_to_user()


If you are trying to do fancier things like URL routing based on path and request method (GET, POST, DELETE, ...), then you might be interested in something like Gorilla.mux

It provides some friendly URL routing methods:

func main() {
    router := mux.NewRouter()
    router.HandleFunc(""/"", YourGETHandlerFunc).Methods(""GET"")
    router.HandleFunc(""/"", YourPOSTHandlerFunc).Methods(""POST"")
    http.Handle(""/"", router)
}


If you're looking for more resources for web development...


Mango: http://paulbellamy.com/2011/05/introducing-mango/
Web.go: http://www.getwebgo.com/tutorial
Twister: https://github.com/garyburd/twister/blob/master/examples/hello/main.go

"
24980225,"You will need to look at the following options and see if it works for you :


Looking at the large file size, you should consider using Google Cloud Storage for the file. You can use the command line utilities that GCS provides to upload your file to your bucket. Once uploaded, you can look at using the JSON API directly to work with the file and import it into your datastore layer. Take a look at the following: https://developers.google.com/storage/docs/json_api/v1/json-api-go-samples
If this is like a one time import of a large file, another option could be spinning up a Google Compute VM, writing an App there to read from GCS and pass on the data via smaller chunks to a Service running in App Engine Go, that can then accept and persist the data. 

"
32273218,"Here is a small example program with the basic architecture/flow that I am trying to get working.  How do I get all the numbers and ""end"" messages to print out?  I have tried putting close statements here and there, but it either doesn't work, or I get panics about trying to close an already closed channel...

package main

import (
    ""fmt""
    ""time""
)

func main() {
    d := make(chan uint)

    go bar(d)

    c1 := make(chan uint)
    c2 := make(chan uint)
    c3 := make(chan uint)

    go foo(c1, d)
    go foo(c2, d)
    go foo(c3, d)

    c1 <- 1
    c2 <- 2
    c3 <- 3

    c1 <- 4
    c2 <- 5
    c3 <- 6

    c1 <- 7
    c2 <- 8
    c3 <- 9
}

func foo(c chan uint, d chan uint) {
    fmt.Println(""foo start"")

    for stuff := range c {
        time.Sleep(1)
        d <- stuff * 2
    }

    fmt.Println(""foo end"")
}

func bar(d chan uint) {
    fmt.Println(""bar start"")

    for stuff := range d {
        fmt.Printf(""bar received %d\n"", stuff)
    }

    fmt.Println(""bar end"")
}


The output I am getting looks like this.  Notice the last set of numbers and the ""end"" outputs are missing.

foo start
bar start
foo start
foo start
bar received 6
bar received 2
bar received 4
bar received 12
bar received 8
bar received 10


In my actual program, each ""foo"" function is doing filtering and a bunch of heavy string regexp stuff.  And I need the ""bar"" function, because it has the job of reordering based on a timestamp, and serializing printing, so output doesn't get interlaced.
"
42770341,"Both versions are completely fine.

The fmt package has special support for the error interface (scroll down a couple screens from this link):


  
  If an operand implements the error interface, the Error method will be invoked to convert the object to a string, which will then be formatted as required by the verb (if any).
  


Your second version will probably run faster as it can avoid most of the special assertions the fmt package does, but the difference shouldn't be noticeable in most cases.

In general you should probably prefer the first version, which is more readable, especially with more arguments.
"
34232126,"I recently went through Golang's ""Language Specification"" https://golang.org/ref/spec#Order_of_evaluation but found the order of evaluation being different from what it is explained in this document.

For example, it says:

a := 1
f := func() int { a++; return a }
x := []int{a, f()}            // x may be [1, 2] or [2, 2]: evaluation order between a and f() is not specified


Then I tried with this code:

package main

import ""fmt""

func main() {
    for {
        result := evaluate()
        if result == 1 { 
            break
        }   
    }   
}

func evaluate() int {
    a := 1
    f := func() int { a++; return a } 
    x := []int{a, f()}
    fmt.Println(x)
    return x[0]
}


I found the value of slice x is always [2,2]. Is there anything I misunderstand?

Thanks in advance.
"
29166419,"Like that

package main

import (
    ""encoding/json""
    ""fmt""
)

func main() {
    data := make(map[string]string)
    data[""a""] = ""b""
    data[""c""] = ""d""
    bytes, err := json.Marshal(data)
    if err != nil {
        fmt.Println(err)
        return
    }
    text := string(bytes)
    fmt.Println(text)
}


Playground
"
19847868,"Detection at compile time

If you're doing this to have different implementations depending on the OS, it is more useful to 
have separate files with the implementation of that feature and add build tags to each
of the files. This is used in many places in the standard library, for example in the os package.

These so called 'Build constraints' or 'Build tags' are explained here.

Say you have the constant PATH_SEPARATOR and you want that platform dependant, you 
would make two files, one for windows and one for the (unix) rest:

/project/path_windows.go
/project/path_unix.go


The code of these files would then be:

path_windows.go

package project

const PATH_SEPARATOR = '\\'


path_unix.go

package project

const PATH_SEPARATOR = '/'


You can now access PATH_SEPARATOR in your code and have it platform dependant.

Detection at runtime

If you want to determine the operating system at runtime, use the runtime.GOOS
variable:

if runtime.GOOS == ""windows"" {
    fmt.Println(""Hello from Windows"")
}


While this is compiled into the runtime and therefore ignores the environment, 
you can nevertheless be relatively certain that the value is correct. 
The reason for this is that every platform that is worth distinguishing needs 
rebuilding due to different executable formats and thus has a new GOOS value.
"
22881549,"I have a map

myMap := map[string]string
myMap['hello'] = 'world'
myMap['foo'] = 'bar'


When I delete an element from myMap like,

delete(myMap['hello'])


Does it instantly frees up memory or does it frees memory after garbage collector is run. 
If it frees up memory after garbage collector is run, Does running runtime.GC() will clean up the memory instantly.

Also is runtime.GC() resource hungry ? or Its okay to run runtime.GC() after every delete() function

Update 2:
Forget what my program does (basically update 1)  
Check this link http://play.golang.org/p/Wb8-4qWyf4 
There is a subroutine to add to a Map every 10 Microsecond 
There is a subroutine to delete from map every 1 Microsecond (10 times faster that adding) 
Run this program in your local machine, you will find that its keeps on occupying more and more RAM slowly. (Slowly because I added a sleep time, otherwise computer will hang)


Update 1

My program fetches 5000 rows of data from database every minute and stores it in a map called datastore.
There are 100 subroutines running which processes each rows from datastore. It takes much time to process one row (less than a second)
If data is successfully processed it is deleted ""delete()"" from datastore, but within next minute next 5000 is fetched and added to datastore.
I am keeping maximum of 20,000 rows in datastore. Which is not much (200 MB at max) 
After processing millions of rows, application start taking 100% of RAM and gets Killed by kernal at the end.
It should not happen if delete() was clearing the memory instantly.
"
24211313,"Remember go build also defaults to static linking so for an apples to apples comparison you should give gccgo the -static or -static-libgo option.
"
43549158,"Go won't interpret $HOME. Use an explicit path such as /home/username/Documents/TEST/Login/.
"
44078189,"package main

import (
    ""fmt""
    ""log""
    ""net/http""
    ""time""
)


func handlerfunc(w http.ResponseWriter, r *http.Request) {
    fmt.Fprintf(w, ""Hello World"" )
    }

    http.ServeContent(w, r, str , time.Now(), f)
}

func PleaseStart(){
    http.HandleFunc(""/"" , handlerfunc )
    log.Fatal(http.ListenAndServe("":80"", nil))
}

func kill_server() {
    //How do I kill server from here
}


func main() {
    go PleaseStart()

    kill_server()
}


I start a http.server that responds with hello world, how do I kill it from kill_server function
Is this possible without rewritting everything?
"
38839094,"I saw this post by someone here but there are no answers: Redirecting https://www.domain.com to https://domain.com in Go

I tried to see if I could find a way to check if the request was made with a www url by checking the variables in *http.Request variable but all I got was relative paths and empty strings """".

I tried to fmt.Println() these variables:

func handleFunc(w http.ResponseWriter, r *http.Request) {
    fmt.Println(r.URL.string())
    fmt.Println(r.Host)
    fmt.Println(r.RequestURI)
}


But none of these variables contained the absolute path with the www part. How can I check if a request was made from a www url? I want to figure this out so that I can redirect from www to non-www.

Is this really not even possible in Go? Some people suggested putting nginx in front of Go, but there has to be a way without nginx right? Do I really need to install and use nginx in front of Go just to do a simple redirect from www to non-www? This does not seem like a good solution to a seemingly small problem.

Is there no way to achieve this?
"
21008698,"Because your worker only process one task and then exit. Thus, only first CONCURRENCY items proceed and then workQueue[i/WORK_PER_WORKER]  blocks indifinitely. Thus, completed chan never receive enough values and main also blocks forever.

Your worker should do work in loops, like this:

for i := 0; i < CONCURRENCY; i++ {
    go func(i int) {
        for anItem := range workQueue[i] {
            work()
            anItem.Done <- 1
        }
    }(i)
}

"
29428932,"I think it is an editing mistake.I guess that What you want to code is:  

""reflect.DeepEqual(p, want)""


but you actually wrote:

""reflect.DeepEqual(input, want)""

"
26299816,"In Your router You should serve index.html to all undefined elsewhere URLs. In mux package there is helpful handler:
http://www.gorillatoolkit.org/pkg/mux#Router
- look at NotFoundHandler

You can use it, to handle all 404's and serve index.html instead:

func main() {
    r := mux.NewRouter()
    r.HandleFunc(""/foo"", fooHandler)
    r.NotFoundHandler = http.HandlerFunc(notFound)
    http.Handle(""/"", r)

}


and define notFound function:

func notFound(w http.ResponseWriter, r *http.Request) {
    http.ServeFile(w, r, ""static/index.html"")
}

"
35576337,"I have a short program in Go with the following files part of it.
Program directory structure:

myprogram/
    main.go
    server.go
    routines.go
    structs.go


These different files contain different function. The structs.go file contains a list of structure type defined, and used in several files of my program. What I want to do, now is to split my program into package like in this example :

main/
    main.go // the main program
server/
    server.go // a package imported in main
routines/
    routines.go // a package imported in main


My problem, is that I do not know where to put structs.go because it contains structures used in several package, as in the 'main.go' code.

How to share efficiently this structs.go file ? Should I include it (via a symlink to the file) in each of the package I defined, i.e serverand routines and also in main ?

My method may be awkward because I'm a beginner in Go, and in programming generally. 
"
32730794,"in my ambitions to understand how gob work . i have severals question . 

i know that gob serialize a go type like struct map or interface(we must register it's real type) but : 

func (dec *Decoder) Decode(e interface{}) error
Decode reads the next value from the input stream and stores it in the data represented by the       
empty interface value.
If e is nil, the value will be discarded. 
Otherwise, the value underlying e must be a pointer to the correct type for the next data item received.
If the input is at EOF, Decode returns io.EOF and does not modify e.


i didn't understand nothing in this documentation . what they mean by ( reads the next value from the input stream ) they are one data that we could send it's a struct or a map but not many .what they mean by If e is nil, the value will be discarded.  please expert explain to me i'am disasperate all day and ididn't find nothing
"
20580808,"The file reflect/value.go states that the relevant field in the implementation of reflect.Value ""repeats typ.Kind() except for method values"". So, unless the value is a method, value.Kind() and value.Type().Kind() return the same number.
"
18425465,"I'm trying to enumerate over a list of values in the Windows registry using Go, but I'm running into some trouble.  I've tried two approaches: using both the Go-provided syscall library to call into RegEnumValue, as well as using a Windows API wrapper by lxn.  In both cases, I'm having the same issue.  This is the code I'm using (which is currently using the win library from lxn):

var root win.HKEY
rootpath, _ := syscall.UTF16PtrFromString(""HARDWARE\\DEVICEMAP\\SERIALCOMM"")
fmt.Println(win.RegOpenKeyEx(win.HKEY_LOCAL_MACHINE, rootpath, 0, win.KEY_READ, &root))

var name_length uint32 = 72
var name *uint16
var key_type uint32
var lpData *byte
var lpDataLength uint32 = 72
var zero_uint uint32 = 0
fmt.Println(win.RegEnumValue(root, zero_uint, name, &name_length, nil, &key_type, lpData, &lpDataLength))

win.RegCloseKey(root)


In this case, RegEnumValue always returns code 87, which MSDN's only explanation is ""The parameter is incorrect.""

Does anyone have any ideas that can point me in the right direction for this?
"
42770327,"If err implements the Error interface, then the Error() method will be invoked implicitly when using a valid format verb such as %s. The documentation for fmt has more on this.
"
39543478,"Go executes these commands a way that you can't use shell things, because it creates a new process.
So you should create a new shell process, for example:

package main

import (
    ""os""
    ""os/exec""
)

func main() {
    cmd := exec.Command(""sh"", ""-c"", ""value=`ls`; echo $value"")
    cmd.Stdout = os.Stdout
    err := cmd.Run()
    if err != nil {
        panic(err)
    }

}


Let me know if it's not what you want!
"
36770716,"I am working on Windows 10. I want to run a ""make build"" in MINGW64 but following error comes up:

$ make build
bash: make: command not found


I want to build Glide for Golang

I tried following:

$ sudo yum install build-essential
bash: sudo: command not found


As well as:

$ yum install build-essential
bash: yum: command not found


And:

$ apt-cyg build-essential
bash: apt-cyg: command not found


How can I ""work-around"" this problem?
"
30392103,"
  Is this Go code correct and portable


It is correct, as long as you work with unsigned integers of 64-bit width.

Portability in this case is provided by the sync/atomic packages to the architectures supported by the Go compiler. Note, however, that not all architectures support ""true"" atomic operations on 64-bit wide data. For example, the i386 implementation uses a CAS-loop:

TEXT ·AddUint64(SB),NOSPLIT,$0-20
    // no XADDQ so use CMPXCHG8B loop
    MOVL    addr+0(FP), BP
    TESTL   $7, BP
    JZ  2(PC)
    MOVL    0, AX // crash with nil ptr deref
    // DI:SI = delta
    MOVL    delta_lo+4(FP), SI
    MOVL    delta_hi+8(FP), DI
    // DX:AX = *addr
    MOVL    0(BP), AX
    MOVL    4(BP), DX
addloop:
    // CX:BX = DX:AX (*addr) + DI:SI (delta)
    MOVL    AX, BX
    MOVL    DX, CX
    ADDL    SI, BX
    ADCL    DI, CX

    // if *addr == DX:AX {
    //  *addr = CX:BX
    // } else {
    //  DX:AX = *addr
    // }
    // all in one instruction
    LOCK
    CMPXCHG8B   0(BP)

    JNZ addloop

    // success
    // return CX:BX
    MOVL    BX, new_lo+12(FP)
    MOVL    CX, new_hi+16(FP)
    RET


That may open the question: why not use a struct with a lock? 



Edit to answer question in comments: Yes, using a 32-bit integer would result in actual atomic operations on all Go-supported architectures because they all support XADDL (or analog) to the best of my knowledge.
"
34406811,"Use log.Fatal() instead. https://golang.org/pkg/log/#Fatal

You can use interface{} but it is not recommended because you lose all the benefits of type checking when you do that. The Go authors get to use interface{} because they understand the appropriate level of additional testing and checks to do when using interface{}. It's much easier (even for intermediate and advanced gophers) to use builtin and standard library functions when something like this is required.

Go does not have algebraic or/sum types either. The standard workaround is to define an and/product type with pointers (e.g. struct{*string, *error}) and go to the effort of making sure you only ever make one of the fields non nil at any point in time.
"
24643072,"You should, preferably, be using go build - to build a binary which you can then run as ./example. 

Go operates on packages, not files, and go run is ultimately just a convenience to be used when testing examples or simple programs (it builds the binary and discards it, effectively).
"
24954530,"According to your code .Data is array or slice. It does not have GetId() method
"
20714739,"Most reflect Value objects can be converted back to a interface{} value using the .Interface() method.

After obtaining this value, you can assert it back to the map you want. Example (play):

m := map[string]int{""foo"": 1, ""bar"": 3}
v := reflect.ValueOf(m)
i := v.Interface()
a := i.(map[string]int)

println(a[""foo""]) // 1


In the example above, m is your original map and v is the reflected value. The interface value i, acquired by the Interface method is asserted to be of type map[string]int and this value is used as such in the last line.
"
44398216,"I'm building a web application in Golang, and at the moment I'm struggling with the authentication/authorization mechanisms.

I want to deploy this app to different platforms (browsers, androids, etc). To achieve this I chosed to use oauth 2.0, namely this lib: https://github.com/golang/oauth2 .

The problem I'm facing is how to achieve this with my own database and users. The lib has a jwt package (https://github.com/golang/oauth2/tree/master/jwt) and also has a package clientcredentials (https://github.com/golang/oauth2/blob/master/clientcredentials/clientcredentials.go) that can be used for 2-legged Oauth 2.0, but I have no idea how to achieve this, and can't find any example showing it. Which package should I use? The token should be set when user sends a POST with its credentials at http://example.domain/login.

Can someone provide me some hints / show me a simple example?
"
26546559,"go get  is the Go package manager. It works in a completely decentralized way and how package discovery still possible without a central package hosting repository.

Besides locating and downloading packages, the other big role of a package manager is handling multiple versions of the same package. Go takes the most minimal and pragmatic approach of any package manager. There is no such thing as multiple versions of a Go package.

go get always pulls from the HEAD of the default branch in the repository. Always. This has two important implications:


As a package author, you must adhere to the stable HEAD philosophy. Your default branch must always be the stable, released version of your package. You must do work in feature branches and only merge when ready to release.
New major versions of your package must have their own repository. Put simply, each major version of your package (following semantic versioning) would have its own repository and thus its own import path.

e.g. github.com/jpoehls/gophermail-v1 and github.com/jpoehls/gophermail-v2.


As someone building an application in Go, the above philosophy really doesn't have a downside. Every import path is a stable API. There are no version numbers to worry about. Awesome!

For more details  : http://zduck.com/2014/go-and-package-versioning/
"
43040753,"There are several things to be aware of when using depends_on:


depends_on will not wait for db and redis to be “ready” before starting web - only until they have been started. If you need to wait for a service to be ready, see Controlling startup order for more on this problem and strategies for solving it.


Version 3 no longer supports the condition form of depends_on.

The depends_on option is ignored when deploying a stack in swarm mode with a version 3 Compose file.

"
40120128,"I had the same issue on OSX. Weird in my case was that process.env showed I am using normal bash. This was strange, because I am using zsh. The environment variables overall were wrong and did not match the environment in my terminal at all. 



Turned out I needed to set zsh as default shell. This added zsh to the list of known shells and made it the default for my user. Note that xh3b4sd is my username.

command -v zsh | sudo tee -a /etc/shells
chsh -s $(which zsh) xh3b4sd


After restarting my mac the environment in the output of process.env was correct and go-plus worked as expected.


"
40589596,"I guess what you are looking for is

timein := time.Now().Local().Add(time.Hour * time.Duration(Hours) +
                                 time.Minute * time.Duration(Mins) +
                                 time.Second * time.Duration(Sec))

"
25326736,"The pitch parameter expects the surface's width * sizeof(int32) as far as I can, this code works and prints random pixels every loop:

func main() {
    window, err := sdl.CreateWindow(""test"", sdl.WINDOWPOS_UNDEFINED,
        sdl.WINDOWPOS_UNDEFINED, 800, 600, sdl.WINDOW_SHOWN)
    if err != nil {
        log.Fatal(err)
    }
    defer window.Destroy()

    renderer, err := sdl.CreateRenderer(window, -1, 0)
    if err != nil {
        log.Fatal(err)
    }
    defer renderer.Destroy()

    texture, err := renderer.CreateTexture(sdl.PIXELFORMAT_ARGB8888,
        sdl.TEXTUREACCESS_STATIC, 800, 600)

    if err != nil {
        log.Fatal(err)
    }
    defer texture.Destroy()

    pixels := make([]uint32, 800*600)
L:
    for {
        for event := sdl.PollEvent(); event != nil; event = sdl.PollEvent() {
            if _, ok := event.(*sdl.QuitEvent); ok {
                break L
            }
        }
        for i := range pixels {
            pixels[i] = 0x00777777 + uint32(rand.Intn(0x00AAAAAA))
        }
        //4 == sizeof(int32), unsafe.Sizeof(pixels) returns the actual size of
        //the slice header which is 24
        texture.Update(nil, unsafe.Pointer(&pixels[0]), 800*4)
        window.UpdateSurface()

        renderer.Clear()
        renderer.Copy(texture, nil, nil)
        renderer.Present()
    }

    sdl.Delay(1000)
    sdl.Quit()
}


//edit it should be unsafe.Pointer(&pixels[0]) not unsafe.Pointer(&pixels).
"
