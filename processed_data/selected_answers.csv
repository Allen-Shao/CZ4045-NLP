,PostId,Body,ParentId
0,1743546,"GO introduces goroutines and channels. See language FAQ
",1743526
1,1744135,"Differences? Pretty much everything!


Concurrency and channels.
Interfaces.
Static typechecking.
...

",1743526
2,1748038,"My main reason for trying out go is the supposed ease of introducing concurrency into programs.  I think that will be the 'next big thing', as processor speeds will tail off, and increasingly multiple cores are available.  If you want to make use of multicore processors, you need to write your program so that it can run things concurrently.

I earlier looked at Erlang, but despite being used to Prolog I find it a bit strange still; it is so different from your 'average' programming language (of the C or Pascal family).  But its concurrency features are easy to use, once you get the hang of it.  With very little effort I was able to write a parallel parser, which does not use a stack, but spawns a new 'thread/process' every time there were multiple options.

So far go looks quite alright, despite some slight inconsistencies.  And it's also fast, which is a bonus.

So unless Cython also makes concurrency easy, I'd favour go...
",1743526
3,1749058,"Cython isn't really a language in the conventional sense. It is a preprocessor for building Python extensions that takes Python-like syntax (actually they strive for full Python compatibility) and produces C code (using the Python C API). Doing this they are able to include some special case optimisations, but the real benefits come when you add Cython specific static type information which is incorporated into the C code, bypassing the Python runtime for those operations and resulting in a high speed up. 

Go is a compiled programming language. The first thing that can be done in Go is producing an executable that doesn't include the Python runtime/start a Python interpreter - this is impossible in Cython. (May not be technically impossible - but there is really no point to use Cython if you are not working with Python). Since Cython just produces C most of your questions in the comment don't really apply - you can use any C debugger (although the fact that's a Python extension makes things a bit more complicated).
",1743526
4,1798578,"
Yes, shared state could be faster in this case.  But only if you can forgo the locks, and this is only doable if it's absolutely read-only.  if it's 'mostly read-only' then you need a lock (unless you manage to write lock-free structures, be warned that they're even trickier than locks), and then you'd be hard-pressed to make it perform as fast as a good message-passing architecture.
Yes, you could write a 'server process' to share it. With really lightweight processes, it's no more heavy than writing a small API to access the data.  Think like an object (in OOP sense) that 'owns' the data.  Splitting the data in chunks to enhance parallelism (called 'sharding' in DB circles) helps in big cases (or if the data is on slow storage).
Even if NUMA is getting mainstream, you still have more and more cores per NUMA cell.  And a big difference is that a message can be passed between just two cores, while a lock has to be flushed from cache on ALL cores, limiting it to the inter-cell bus latency (even slower than RAM access).  If anything, shared-state/locks is getting more and more unfeasible.


in short.... get used to message passing and server processes, it's all the rage.

Edit: revisiting this answer, I want to add about a phrase found on Go's documentation:


  share memory by communicating, don't communicate by sharing memory.


the idea is: when you have a block of memory shared between threads, the typical way to avoid concurrent access is to use a lock to arbitrate.  The Go style is to pass a message with the reference, a thread only accesses the memory when receiving the message.  It relies on some measure of programmer discipline; but results in very clean-looking code that can be easily proofread, so it's relatively easy to debug.

the advantage is that you don't have to copy big blocks of data on every message, and don't have to effectively flush down caches as on some lock implementations.  It's still somewhat early to say if the style leads to higher performance designs or not.  (specially since current Go runtime is somewhat naive on thread scheduling)
",1798455
5,1798930,"Most modern processors use variants of the MESI protocol. Because of the shared state, Passing read-only data between different threads is very cheap. Modified shared data is very expensive though, because all other caches that store this cache line must invalidate it.

So if you have read-only data, it is very cheap to share it between threads instead of copying with messages. If you have read-mostly data, it can be expensive to share between threads, partly because of the need to synchronize access, and partly because writes destroy the cache friendly behavior of the shared data.

Immutable data structures can be beneficial here. Instead of changing the actual data structure, you simply make a new one that shares most of the old data, but with the things changed that you need changed. Sharing a single version of it is cheap, since all the data is immutable, but you can still update to a new version efficiently.
",1798455
6,1801214,"One thing to realise is that the Erlang concurrency model does NOT really specify that the data in messages must be copied between processes, it states that sending messages is the only way to communicate and that there is no shared state. As all data is immutable, which is fundamental, then an implementation may very well not copy the data but just send a reference to it. Or may use a combination of both methods. As always, there is no best solution and there are trade-offs to be made when choosing how to do it.

The BEAM uses copying, except for large binaries where it sends a reference.
",1798455
7,1803219,"One solution that has not been presented here is master-slave replication. If you have a large data-structure, you can replicate changes to it out to all slaves that perform the update on their copy.

This is especially interesting if one wants to scale to several machines that don't even have the possibility to share memory without very artificial setups (mmap of a block device that read/write from a remote computer's memory?)

A variant of it is to have a transaction manager that one ask nicely to update the replicated data structure, and it will make sure that it serves one and only update-request concurrently. This is more of the mnesia model for master-master replication of mnesia table-data, which qualify as ""large data structure"".
",1798455
8,1804568,"In Erlang, all values are immutable - so there's no need to copy a message when it's sent between processes, as it cannot be modified anyway.

In Go, message passing is by convention - there's nothing to prevent you sending someone a pointer over a channel, then modifying the data pointed to, only convention, so once again there's no need to copy the message.
",1798455
9,1806674,"The problem at the moment is indeed that the locking and cache-line coherency might be as expensive as copying a simpler data structure (say a few hundert bytes). 

But most of the time a clever written new multithreaded algorithm that tries to eliminate  most of the locking will always be faster - and a lot faster with modern lock-free data structures. Especially when you have well designed cache systems like Sun's Niagara chip level multithreading.

If your system/problem is not easily broken down into few and simple data access then you have a problem. And not all problems can be solved by message passing. This is why there are still some Itanium based super computers sold because they have terabyte of shared RAM and upto 128 CPU's working on the same shared memory. They are a magnitude more expensive then a mainstream x86 cluster with the same cpu power but you don't need to break down your data.

But another reason not mentioned so far is that programs can became much easier to write and maintain when you use a multithreaded approch. And message passign and shared nothing makes it even more maintainable.

Erlang was for example never designed to make things faster but to use a large number of threads to structure complex data and event flows. 

I guess this was one of the main point in the design. In the web world of google you usually don't care about performance - as long as it can run in parallel in the cloud. And with message passing you ideally can just add more computers without changing the source code.
",1798455
10,1817627,"Usually message passing languages (this is especially easy in erlang, since it has immutable variables) optimise away the actual data copying between the processes (of course local processes only: you'll want to think your network distribution pattern wisely), so this isn't much an issue.
",1798455
11,1820363,"What is a large data structure?

One persons large is another persons small.

Last week I talked to two people - one person was making embedded devices he used the word
""large"" - I asked him what it meant - he say over 256 KBytes - later in the same week a
guy was talking about media distribution - he used the word ""large"" I asked him what he
meant - he thought for a bit and said ""won't fit on one machine"" say 20-100 TBytes

In Erlang terms ""large"" could mean ""won't fit into RAM"" - so with 4 GBytes of RAM
data structures > 100 MBytes might be considered large - copying a 500 MBytes data structure
might be a problem. Copying small data structures (say 

Really large data structures (i.e. ones that won't fit on one machine) have to be
copied and ""striped"" over several machines.

So I guess you have the following:

Small data structures are no problem - since they are small data processing times are
fast, copying is fast and so on (just because they are small)

Big data structures are a problem - because they don't fit on one machine - so copying is essential.
",1798455
12,1980849,"The other concurrent paradigm is STM, software transactional memory. Clojure's ref's are getting a lot of attention.  Tim Bray has a good series exploring erlang and clojure's concurrent mechanisms

http://www.tbray.org/ongoing/When/200x/2009/09/27/Concur-dot-next

http://www.tbray.org/ongoing/When/200x/2009/12/01/Clojure-Theses
",1798455
13,2893994,"If you install web.go through goinstall, you need to do:

import ""github.com/hoisie/web.go""


Goinstall is still an experimental system. It would be nice if you didn't have to include the full path.
",2893772
14,3125521,"In most cases they're the same as C arrays, but the compiler/interpreter hides the pointer from you. This is mainly because then the array can be relocated in memory in a totally transparent way, and so such arrays appear to have an ability to be resized.
On the other hand it is safer, because without a possibility to move the pointers you cannot make a leak.
",3125381
15,3129417,"Read The Go Programming Language Specification. In particular, the section on Struct types. The Go term to describe what you are looking for is an anonymous field.


  Such a[n] [anonymous] field type must
  be specified as a type name T or as a
  pointer to a type name *T, and T
  itself may not be a pointer type.


int is a type name. []int is neither a type name nor a pointer to a type name.
",3129324
16,3129440,"No, the type of an anonymous field must be a type name or a pointer to a type name. You could declare a new type name that is the same as an array type, and then it would work, but it wouldn't be exactly the same.
",3129324
17,3516388,"You're probably looking for a map.
",3516357
18,3516402,"The map type. http://golang.org/doc/effective_go.html#maps

There is some difference from python in that the keys have to be typed, so you can't mix numeric and string keys (for some reason I forgot you can), but they're pretty easy to use.

dict := make(map[string]string)
dict[""user""] = ""so_user""
dict[""pass""] = ""l33t_pass1""

",3516357
19,3536318,"To expand a little on answers already given:

A Go map is a typed hash map data structure. A map's type signature is of the form map[keyType]valueType where keyType and valueType are the types of the keys and values respectively.

To initialize a map, you must use the make function:

m := make(map[string]int)


An uninitialized map is equal to nil, and if read from or written a panic will occur at runtime.

The syntax for storing values is much the same as doing so with arrays or slices:

m[""Alice""] = 21
m[""Bob""] = 17


Similarly, retrieving values from a map is done like so:

a := m[""Alice""]
b := m[""Bob""]


You can use the range keyword to iterate over a map with a for loop:

for k, v := range m {
    fmt.Println(k, v)
}


This code will print:

Alice 21
Bob 17


Retrieving a value for a key that is not in the map will return the value type's zero value:

c := m[""Charlie""]
// c == 0


By reading multiple values from a map, you can test for a key's presence. The second value will be a boolean indicating the key's presence:

a, ok := m[""Alice""]
// a == 21, ok == true
c, ok := m[""Charlie""]
// c == 0, ok == false


To remove a key/value entry from a map, you flip it around and assign false as the second value:

m[""Bob""] = 0, false
b, ok := m[""Bob""]
// b == 0, ok == false


You can store arbitrary types in a map by using the empty interface type interface{}:

n := make(map[string]interface{})
n[""One""] = 1
n[""Two""] = ""Two""


The only proviso is that when retrieving those values you must perform a type assertion to use them in their original form:

a := n[""One""].(int)
b := n[""Two""].(string)


You can use a type switch to determine the types of the values you're pulling out, and deal with them appropriately:

for k, v := range n {
    switch u := v.(type) {
        case int:
            fmt.Printf(""Key %q is an int with the value %v.\n"", k, u)
        case string:
            fmt.Printf(""Key %q is a string with the value %q.\n"", k, u)
    }
}


Inside each of those case blocks, u will be of the type specified in the case statement; no explicit type assertion is necessary.

This code will print:

Key ""One"" is an int with the value 1.
Key ""Two"" is a string with the value ""Two"".


The key can be of any type for which the equality operator is defined, such as integers, floats, strings, and pointers. Interface types can also be used, as long as the underlying type supports equality. (Structs, arrays and slices cannot be used as map keys, because equality is not defined on those types.)

For example, the map o can take keys of any of the above types:

o := make(map[interface{}]int)
o[1] = 1
o[""Two""] = 2


And that's maps in a nutshell.
",3516357
20,3587284,"Arrays in Go are also values in that they are passed as values to functions(in the same way ints,strings,floats etc.)
Which requires copying the whole array for each function call.

This can be very slow for a large array, which is why in most cases it's usually better to use slices
",3125381
21,3779421,"gevent is a concurrent library that uses Cython at its core. It seems to be pretty fast: http://nichol.as/asynchronous-servers-in-python
",1743526
22,3864079,"I use pprof package, and Google perftools.
",3863972
23,3866546,"If you use the gccgo compiler instead of the 6g compiler, you'd probably be able to use the normal GNU tools, i.e. gprof.

I haven't actually done it with gprof, but I at least know that it works for gdb.
",3863972
24,4279644,"For example,

package main

import (
    ""flag""
    ""fmt""
    ""os""
    ""strconv""
)

func main() {
    flag.Parse()
    s := flag.Arg(0)
    // string to int
    i, err := strconv.Atoi(s)
    if err != nil {
        // handle error
        fmt.Println(err)
        os.Exit(2)
    }
    fmt.Println(s, i)
}

",4278430
25,4437778,"What about support. You are relying on a single compiler, provided by Google. What if Go folds or goes commercial?

With Cython you could always go back to Python (or port the C code) if the Cython project folded.

UPDATE: I must say that I am now upset with Cython. The lack of thread support is a major blow. Cython is thread-safe BUT at a serious cost. The global interpreter lock is held the whole time a function executes. Thereby disabling concurrent execution over an entire codebase!

Cython's C-like features are poorly documented and confusing to novices. I admit.

Cython's purpose is to support the Sage mathematics software; Go's is to support Google's ambitious plans for cutting-edge expensive $$ hardware.

In short, I no longer like either one of these languages. Going back to C++ (again). My favorite is Cython.
",1743526
26,4962889,"Note that your questions are technically non-sensical because message passing can use shared state so I shall assume that you mean message passing with deep copying to avoid shared state (as Erlang currently does).


  Will using shared state be faster and use less memory than message passing, as locks will mostly be unnecessary because the data is read-only, and only needs to exist in a single location?


Using shared state will be a lot faster.


  How would this problem be approached in a message passing context? Would there be a single process with access to the data structure and clients would simply need to sequentially request data from it? Or, if possible, would the data be chunked to create several processes that hold chunks?


Either approach can be used.


  Given the architecture of modern CPUs & memory, is there much difference between the two solutions -- i.e., can shared memory be read in parallel by multiple cores -- meaning there is no hardware bottleneck that would otherwise make both implementations roughly perform the same?


Copying is cache unfriendly and, therefore, destroys scalability on multicores because it worsens contention for the shared resource that is main memory.

Ultimately, Erlang-style message passing is designed for concurrent programming whereas your questions about throughput performance are really aimed at parallel programming. These are two quite different subjects and the overlap between them is tiny in practice. Specifically, latency is typically just as important as throughput in the context of concurrent programming and Erlang-style message passing is a great way to achieve desirable latency profiles (i.e. consistently low latencies). The problem with shared memory then is not so much synchronization among readers and writers but low-latency memory management.
",1798455
27,5372575,"Here's my analysis.

(**myint)(&k) -- cannot convert &k (type **int) to type **myint:

type **int and type **myint are unnamed pointer types and their pointer base types, type *int and type *myint, don't have identical underlying types.

If T (*int or *myint) is a pointer type literal, the corresponding underlying type is T itself.

(*myint)(k) -- can convert k (type *int) to type *myint:

type *int and type *myint are unnamed pointer types and their pointer base types, type int and type myint (type myint int), have identical underlying types.

If T (int) is a predeclared type, the corresponding underlying type is T itself. If T (myint) is neither a predeclared type or nor a type literal, T's underlying type is the underlying type of the type to which T refers in its type declaration (type myint int). 

(myint)(*k) -- can convert *k (type int) to type myint:

type int and type myint have identical underlying types. 

If T (int) is a predeclared type, the corresponding underlying type is T itself. If T (myint) is neither a predeclared type or nor a type literal, T's underlying type is the underlying type of the type to which T refers in its type declaration (type myint int). 

Here's the underlying type example from the Types section revised to use integers and int pointers.

type T1 int
type T2 T1
type T3 *T1
type T4 T3


The underlying type of int, T1, and T2 is int. The underlying type of *T1, T3, and T4 is *T1. 

References:

The Go Programming Language Specification

Conversions

Types

Properties of types and values

Type declarations

Predeclared identifiers

Pointer Type
",5367961
28,5372998,"Here are two functionally equivalent working versions of your program.

package main

type mypint *int

func set(a *mypint) {
    i := int(5)
    *a = &i
}

func main() {
    var k *int
    set((*mypint)(&k))
    print(*k)
}


http://play.golang.org/p/l_b9LBElie

package main

type myint int

func set(a *myint) *myint {
    i := myint(5)
    a = &i
    return a
}

func main() {
    var k *int
    k = (*int)(set((*myint)(k)))
    print(*k)
}


http://play.golang.org/p/hyaPFUNlp8
",5367961
29,5445231,"import web ""github.com/hoisie/web.go""

",2893772
30,6051028,"I know Caspar has already posted the link contained, but here is the list of community contributed packages:

http://godashboard.appspot.com/package

For completeness here are the official packages:

http://golang.org/pkg/

Also, since it is a VERY new language I don't feel too bad in saying, if it needs doing, I'm sure they would be happy for your contributions. (I try not to say ""submit a patch"" when we are talk about old languages/modules, however a new language is an exception)
",6000524
31,6051270,"Initialize the type as you would initialize the underlying type. In your example, the underlying type is an int. For example,

package main

import (
    ""fmt""
)

type Num int

func main() {
    var m Num = 7
    n := Num(42)
    fmt.Println(m, n)
}

Output: 7 42


The built-in function make takes a type T, which must be a slice, map or channel type.
",6051088
32,6119041,"I'm dumb, the file linked is 32 bit and I was using ""6g"" to compile because my system is 64 bit.  ""8g"" works to compile.
""8g myfile.go""
""8l myfile.8""
""myfile.out""
Works to get it running.
",6118919
33,6126684,"I haven't tried this, but maybe it's worth trying:

type Vote struct {
    User string
    Score int
}    

type Comment struct {
    Author  string
    Content string
    Date    datastore.Time
    Votes*  []Vote
}

",6125345
34,6192309,"The only types that are allowed for fields in the current version of the Go AppEngine SDK are as follows:


signed integers (int, int8, int16, int32 and int64),
bool,
string,
float32 and float64,
any type whose underlying type is one of the above predeclared types,
*Key,
appengine.BlobKey,
[]byte (up to 1 megabyte in length),
slices of any of the above (up to 100 elements in length).


Given that, there appear to be two ways to do this.  One is to maintain a slice of keys to point to the Votes of a given Comment.  However this is likely to run up against the 100 element limit for any reasonably popular comment.

The other approach is to store a ""pointer"" to the comment in each vote struct like this:

type Vote struct {
    User string
    Score int
    CommentKey *datastore.Key
}    

type Comment struct {
    Author  string
    Content string
    Date    datastore.Time
}


Then when you go to query it you need to do it in two steps. First you get the Comment you're interested in (in this case just the first one that happens to be returned).  Second, you query for all the votes that ""point"" to that comment:

q := datastore.NewQuery(""Comment"").Limit(1)
comments := make([]Comment, 0, 1)
var err os.Error
var keys []*datastore.Key
if keys, err = q.GetAll(c, &comments); err != nil {
    // handle the error
}

comment := comments[0]
vq := datastore.NewQuery(""Vote"").Filter(""CommentKey="", keys[0])

votes := make([]Vote, 0, 10)
if _, err := vq.GetAll(c, &votes); err != nil {
    // handle the error
}

",6125345
35,6241975,"It appears in the assembly generation routines in the 6g compiler:

case 256 + R_X86_64_64:
        if(targ->dynimpname != nil && !targ->dynexport)
                diag(""unexpected R_X86_64_64 relocation for dynamic symbol %s"",
                     targ->name);
        r->type = D_ADDR;
        return;


The R_X86_64_64 is a type of a symbol in the library. For more information about relocation in the amd64 architecture consult page ~70 here.

Is it possible that you mix 386 compiled library with amd64 code?

The compiler should report the exact symbol which caused the problem. Can you try linking with a minimal library containing other symbols, and try to locate a minimal example where it fails?

Did you manage to use cgo with any library at all?
",6163096
36,6385066,"The Go reflect package was substantially revised for the weekly.2011-04-13 and subsequent releases. For details, see revision 843855f3c026.
",6384824
37,6545842,"I agree with Elazar that it seems plausible that mixing of 32-bit and 64-bit code is involved.

Have you tried gccgo?
",6163096
38,7311456,"The easiest solution seems to save the image to disk, and execute convert from Image Magic to transform it. You can use a ram disk if you want extra performance.
",7309355
39,7314110,"The Moustachio example application for GAE by Andrew Gerrand contains a resize.go file with a native Go implementation. There was also a similar question on the go-nuts mailing list some days ago and Nigel has posted an updated version of this file there. You might want to try it :)
",7309355
40,7552319,"To fix this I ended up including the source for the package in the directory tree for my app, as mentioned in this thread on the google-appengine-go group http://groups.google.com/group/google-appengine-go/browse_thread/thread/1fe745debc678afb

Here is the important part of the thread:


  You may include as many packages as necessary.  Packages are imported
  by path relative to the base directory (the one that has your app.yaml
  file), so if you have the following:
  
  helloworld/app.yaml
  helloworld/hello/hello.go // package hello
  helloworld/world/world.go // package world   
  
  you can import ""world"" in hello and import ""hello"" in world.
  
  If you are including a third-party library, it might look something like this:  
  
  helloworld/app.yaml
  helloworld/hello/hello.go // package hello
  helloworld/world/world.go // package world
  helloworld/goprotobuf.googlecode.com/proto/*.go // package proto
  
  Then you can, as normal, import ""goprotobuf.googlecode.com/proto"".

",7535803
41,7613998,"The short answer is that Go and the GAE SDK do not integrate in the way that (I think) you are looking for.  The GAE SDK includes its own version of the Go toolchain that differs in some important ways to the standard tools.  Those differences are deep enough that it is unlikely you will derive much utility from trying to unify the two.  Here are the big differences:


GAE does not support some packages from the standard lib e.g. ""unsafe""
GAE does not support CGO
GAE often lags the main distribution by one or more major versions
You cannot use any binary libraries (go or otherwise) in a GAE project (you need source for everything)
goinstall is not intended for use with GAE projects


Because of this I treat my GAE and non-GAE tools as completely separate.  If you're only doing GAE development, you could do without the standard tools altogether.
",7599476
42,7847142,"In the new template package the template tag syntax changed, as you can see in the documentation. E.g. dot (.) is used instead of @ for referencing the ""current"" item and the template tags are indicated with two curly braces instead of one.

Edit: Oh, and there's no .section tag any more. You didn't provide the structure you pass to template's Execute() method so I can't provide details on how mitigate that exactly, but I guess you can use {{with}} tag like {{with One}}{.}{{end}} or maybe {{.One}}.
",7846846
43,8025349,"We don't use such low level API, we use net.Dial.  ex.

func main() {
        var (
                host          = ""127.0.0.1""
                port          = ""9998""
                remote        = host + "":"" + port
                msg    string = ""test""
        )

        con, error := net.Dial(""tcp4"", remote)
        if error != nil {
                fmt.Printf(""Host not found: %s\n"", error)
                os.Exit(1)
        } else {
                defer con.Close()
        }

        in, error := con.Write([]byte(msg))
        if error != nil {
                fmt.Printf(""Error sending data: %s, in: %d\n"", error, in)
                os.Exit(2)
        }

        fmt.Println(""Connection OK"")

}


Or, you could trace the code $GOROOT/src/pkg/net/dial.go
",7987154
44,8038951,"The cost of instances is only part of the cost of your app.  I only use the Java runtime right now, so I don't know how much more or less efficient things would be with Python or Go, but I don't imagine it will be orders of magnitude different.  I do know that instances are not the only cost you need to consider.  Depending on what your app does, you may find API or storage costs are more significant than any minor differences between runtimes.  All of the API costs will be the same with whatever runtime you use.

Language ""might"" affect these costs:


On-demand Frontend Instances
Reserved Frontend Instances
Backed Instances


Language Independent Costs:


High Replication Datastore (per gig stored)
Outgoing Bandwidth (per gig)
Datastore API (per ops)
Blobstore API storge (per gig)
Email API (per email)
XMPP API (per stanza)
Channel API (per channel)

",8037783
45,8039987,"It's probably more about how you allocate the resources than your language choice. I read that GAE was built the be language-agnostic so there is probably no builtin advantage for any language, but you can get an advantage from choosing the language you are comfortable and motivated with. I use python and what made my deployment much more cost-effective was the upgrade to python 2.7 and you can only make that upgrade if you use the correct subset of 2.6, which is good. So if you choose a language you're comfortable with, it's likely that you will gain an advantage from your ability using the language rather than the combo language + environment itself. 

In short, I'd recommend python but that's the only app engine language I tried and that's my choice even though I know Java rather well the code for a project will be much more compact using my favorite language python. 

My apps are small to medium sized and they cost like nothing:


",8037783
46,8044755,"I haven't used Go, but I would strongly suspect it would load and execute instances much faster, and use less memory purely because it is compiled. Anecdotally from the group, I believe that Python is more responsive than Java, at least in instance startup time. 

Instance load/startup times are important because when your instance is hit by more requests than it can handle, it spins up another instance. This makes that request take much longer, possibly giving the impression that the site is generally slow. Both Java and Python have to startup their virtual machine/interpreter, so I would expect Go to be an order of magnitude faster here.

There is one other issue - now Python2.7 is available, Go is the only option that is single-threaded (ironically, given that Go is designed as a modern multi-process language). So although Go requests should be handled faster, an instance can only handle requests serially. I'd be very surprised if this limitation last long, though.
",8037783
47,8341643,"Found this, although I'm not sure if it's what you want. Additionally it seems to lack an encoder + it may be outdated wrt current Go release/weekly versions.
",8340751
48,8868451,"hg -u (lower case) is definitely correct, check your version of mercurial.

$ hg help clone
...
options:

 -U --noupdate           the clone will include an empty working copy (only a repository)
 -u --updaterev REV      revision, tag or branch to check out
...
$ 

",8868077
49,9393711,"After sometime in exp/ssh, the official ssh package now resides in the crypto/ssh subrepo: http://code.google.com/p/go/source/browse?repo=crypto#hg%2Fssh
",6000524
50,9706515,"This seems to work with the latest weekly

package main

import (
        ""fmt""
        ""log""
        ""regexp""
        ""strings""
)

func main() {
        includeRegex, err := regexp.Compile(`^\s*include\(""(\\\""|[^""])+""\);`)
        if err != nil {
                log.Fatal(err)
        }

        for _, line := range strings.Split(`
foo
include ""abc.def""
include(""file.js"");
            include ""me\""to\""""
            include(""please\""!\"""");
        nothing here          
`, ""\n"") {
                if includeRegex.Match([]byte(line)) {
                        includeFile := includeRegex.FindString(line)
                        fmt.Println(""INCLUDE"", includeFile)
                } else {
                        fmt.Printf(""no match for \""%s\""\n"", line)
                }
        }
}


Output:

$ go build && ./tmp 
no match for """"
no match for ""foo""
no match for ""include ""abc.def""""
INCLUDE include(""file.js"");
no match for ""        include ""me\""to\""""""
INCLUDE       include(""please\""!\"""");
no match for ""  nothing here      ""
no match for """"
$ 

",9704895
51,9706827,"Try putting the following line at the start of your program:

println(runtime.Version())


It should print weekly.2012-03-13 or something close to that date.
",9704895
52,9748995,"I think you should use

v := p.Elem()   // Get the value that 'p' points to


instead of

v := reflect.ValueOf(p)

",9748196
53,9754958,"Working example with lots of assumptions and a trivial data format:

package main

import (
    ""fmt""
    ""reflect""
    ""strconv""
)

// example marshalled format.  lets say that marshalled data will have
// four bytes of a formatted floating point number followed by two more
// printable bytes.
type m42 []byte

// example struct we'd like to unmarshal into.
type packet struct {
    S string // exported fields required for reflection
    F float64
}

// example usage
func main() {
    var p packet
    if err := Unmarshal(m42(""3.14Pi""), &p); err == nil {
        fmt.Println(p)
    } else {
        fmt.Println(err)
    }
}

func Unmarshal(data m42, structPtr interface{}) error {
    vp := reflect.ValueOf(structPtr)
    ve := vp.Elem() // settable struct Value
    vt := ve.Type() // type info for struct
    nStructFields := ve.NumField()
    for i := 0; i < nStructFields; i++ {
        fv := ve.Field(i) // settable field Value
        sf := vt.Field(i) // StructField type information
        // struct field name indicates which m42 field to unmarshal.
        switch sf.Name {
        case ""S"":
            fv.SetString(string(data[4:6]))
        case ""F"":
            s := string(data[0:4])
            if n, err := strconv.ParseFloat(s, 64); err == nil {
                fv.SetFloat(n)
            } else {
                return err
            }
        }
    }
    return nil
}


Appropriate alternative solutions would depend heavily on the real data you need to support.
",9748196
54,9764087,"I'm going to bet that the reason f.Addr() has the problem because it actually isn't addressable.

the reflect package Type object has a method that will tell you if the type is addressable called CanAddr(). Assuming the field is addressable if it's not a string is not always true. If the struct is not passed in as a pointer to a struct then it's fields won't be addressable. For more details about what is and isn't addressable see: http://weekly.golang.org/pkg/reflect/#Value.CanAddr which outlines the correct rules.

Essentially for your code to work I think you need to ensure you always call it with a pointer to a struct.
",9748196
55,9863218,"I would do it like this:

package main

import (
""fmt""
    ""io/ioutil""
    ""strconv""
    ""strings""
)

// It would be better for such a function to return error, instead of handling
// it on their own.
func readFile(fname string) (nums []int, err error) {
    b, err := ioutil.ReadFile(fname)
    if err != nil { return nil, err }

    lines := strings.Split(string(b), ""\n"")
    // Assign cap to avoid resize on every append.
    nums = make([]int, 0, len(lines))

    for i, l := range lines {
        // Empty line occurs at the end of the file when we use Split.
        if len(l) == 0 { continue }
        // Atoi better suits the job when we know exactly what we're dealing
        // with. Scanf is the more general option.
        n, err := strconv.Atoi(l)
        if err != nil { return nil, err }
        nums = append(nums, n)
    }

    return nums, nil
}

func main() {
    nums, err := readFile(""numbers.txt"")
    if err != nil { panic(err) }
    fmt.Println(len(nums))
}

",9862443
56,9863449,"Your solution with fmt.Fscanf is fine.  There are certainly a number of other ways to do though, depending on your situation.  Mostafa's technique is one I use a lot (although I might allocate the result all at once with make.  oops! scratch that.  He did.) but for ultimate control you should learn bufio.ReadLine.  See go readline -> string for some example code.
",9862443
57,10022387,"I'm not really sure I understand what it is you want to do since your recursion code looks a little strange. However if I understand the structure of your TMyTreeNode then this is what I would do for a non recursive version.

// root is our root node
q := []*TMyTreeNode{root}
processed := make(map[*TMyTreeNode]bool
for {
  l := len(q)
  if l < 1 {
    break // our queue is empty
  }
  curr := q[l - 1]
  if !processed[curr] && len(curr.childNodes) > 0 {
    // do something with curr
    processed[curr] = true
    q = append(q, curr.childNodes...)
    continue // continue on down the tree.
  } else {
    // do something with curr
    processed[curr] = true
    q := q[:l-2] // pop current off the queue
  }
}


NOTE: This will go arbitrarily deep into the structure. If that's not what you want it will need some modifications.
",10022110
58,10045630,"Look here: https://github.com/nsf/gocode and there at 'Emacs setup'.
",10045481
59,10137141,"Use Nginx as the front-end and make sure that you are using the 64bit version of Go. The 32bit version has severe stability problems which are a show stopper for any long-running processes.
",10136478
60,10137199,"Why not using the Build in Webserver and set up a Reverse Proxy like Varnish, or let Nginx act as Proxy?

http://wiki.nginx.org/ReverseProxyCachingExample
",10136478
61,10138446,"There are no stability problem.

I have a few webservers 100% in go that run for months, serving about a million queries per month without any problem (mostly json, through GET, POST, and websockets).

They're on 64 bits ubuntu servers but I guess you would have difficulties producing the so much gossiped about 32 bits bug, especially with a web server.

Don't use a front-end if you have no specific reason : It's easy to make a complete web application just using Go. 

You will be far from alone. In my opinion Go is especially well suited to build long running servers. Goroutines and channels makes it really easy to handle both user requests and long term tasks (or, for example, do the postreatment of user queries after you answered the http query, which isn't so easy in php and is too many LOC in java if you want to do it properly).
",10136478
62,10152855,"This seems to work:

package main

import (
        ""fmt""
        ""io""
        ""log""
        ""net/http""
)

func main() {
        request, err := http.NewRequest(""GET"", ""http://www.example.com/"", nil)
        if err != nil {
                log.Fatal(err)
        }

        http_client := &http.Client{}
        response, err := http_client.Do(request)
        if err != nil {
                log.Fatal(err)
        }

        buf := make([]byte, 4096) // any non zero value will do, try '1'.
        for {
                n, err := response.Body.Read(buf)
                if n == 0 && err != nil { // simplified
                        break
                }

                fmt.Printf(""%s"", buf[:n]) // no need to convert to string here
        }
        fmt.Println()
}


Edit: Added forgotten error handling of NewRequest.
",10152478
63,10187062,"You don't need to create a new template with New and then use ParseFiles on it. There is also a function ParseFiles which takes care of creating a new template behind the scenes.Here is an example:

package main

import (
    ""fmt""
    ""html/template""
    ""os""
)

func main() {
    t, err := template.ParseFiles(""test.html"")
    if err != nil {
            fmt.Println(err);
    }
    t.Execute(os.Stdout, nil)
}

",10185942
64,10283180,"
  Will google Go use less resources than Python and Java on Appengine?
  Are the instance startup times for go faster than Java's and Python's
  startup times?


Yes, Go instances have a lower memory than Python and Java (

Yes, Go instances start faster than Java and Python equivalent because the runtime only needs to read a single executable file for starting an application.

Also even if being atm single threaded, Go instances handle incoming request concurrently using goroutines, meaning that if  1 goroutine is waiting for I/O another one can process an incoming request.


  Is the go program uploaded as binaries or source code and if it is
  uploaded as source code is it then compiled once or at each instance
  startup?


Go program is uploaded as source code and compiled (once) to a binary when deploying a new version of your application using the SDK.


  In other words: Will I benefit from using Go in app engine from a cost
  perspective?


The Go runtime has definitely an edge when it comes to performance / price ratio, however it doesn't affect the pricing of other API quotas as described by Peter answer.
",8037783
65,10351615,"OK.
After long searches, I can say that there still is no publicly available encoder even if a decoder was made ( https://github.com/golang/image/blob/master/webp/decode.go ).
",8340751
66,10370469,"The question is mostly irrelevant.

The minimum memory footprint for a Go app is less than a Python app which is less than a Java app.  They all cost the same per-instance, so unless your application performs better with extra heap space, this issue is irrelevant.

Go startup time is less than Python startup time which is less than Java startup time.  Unless your application has a particular reason to churn through lots of instance startup/shutdown cycles, this is irrelevant from a cost perspective.  On the other hand, if you have an app that is exceptionally bursty in very short time periods, the startup time may be an advantage.

As mentioned by other answers, many costs are identical among all platforms - in particular, datastore operations.  To the extent that Go vs Python vs Java will have an effect on the instance-hours bill, it is related to:


Does your app generate a lot of garbage?  For many applications, the biggest computational cost is the garbage collector.  Java has by far the most mature GC and basic operations like serialization are dramatically faster than with Python.  Go's garbage collector seems to be an ongoing subject of development, but from cursory web searches, doesn't seem to be a matter of pride (yet).
Is your app computationally intensive?  Java (JIT-compiled) and Go are probably better than Python for mathematical operations.


All three languages have their virtues and curses.  For the most part, you're better off letting other issues dominate - which language do you enjoy working with most?
",8037783
67,10534905,"I think it's a bit difficult to tell what you are asking about. Maybe you can elaborate on your question.

Goroutines are quite cheap, and are a perfect match for modern web applications which use XHR or Websockets heavily (and other I/O bound applications which have to wait for database responses and stuff like that). Additionally, the go runtime is also able to execute those goroutines in parallel, so that Go is also a good fit for CPU bound tasks, which should take advantage of multiple cores and the speed of a natively compiled language.

But you should also keep in mind, that goroutines and channels aren't for free. They still require some amount of memory and each synchronization point (e.g. a channel send or receive) comes with its cost. That's normally not a problem, since the synchronization is, in comparison to a database query for example, extremely cheap, but it might not be suited for building efficient Bayesian networks, especially if the actual work of each goroutine / node is negligible in comparison to the synchronization overhead.

Your primary goal for every concurrent program should be to avoid shared mutability as far as possible. So a Bayesian network modeled with goroutines and channels might be a good educational example and a great way to measure the performance of Go's channel implementation, but it's probably not the best fit for your problem.
",10529365
68,10757939,"If I'm understanding you correctly, you want a way of routing the same URL to different handlers based on the request method rather than just the path? If that's the case...

For comparison, using Python + Django, the way you're doing this is pretty standard:

def my_django_view(request):
    if request.method == ""POST"":
        try_to_process_posted_data()
    elif request.method == ""GET"":
        show_a_form_to_user()


If you are trying to do fancier things like URL routing based on path and request method (GET, POST, DELETE, ...), then you might be interested in something like Gorilla.mux

It provides some friendly URL routing methods:

func main() {
    router := mux.NewRouter()
    router.HandleFunc(""/"", YourGETHandlerFunc).Methods(""GET"")
    router.HandleFunc(""/"", YourPOSTHandlerFunc).Methods(""POST"")
    http.Handle(""/"", router)
}


If you're looking for more resources for web development...


Mango: http://paulbellamy.com/2011/05/introducing-mango/
Web.go: http://www.getwebgo.com/tutorial
Twister: https://github.com/garyburd/twister/blob/master/examples/hello/main.go

",10716433
69,10839802,"You might try working directly with templates.  Example:

package main

import (
    ""bytes""
    ""encoding/xml""
    ""fmt""
    ""text/template""
)

type ele struct {
    Name  string
    Attrs []attr
}

type attr struct {
    Name, Value string
}

var x = `
`

func main() {
    // template function ""xml"" defined here does basic escaping,
    // important for handling special characters such as "".
    t := template.New("""").Funcs(template.FuncMap{""xml"": func(s string) string {
        var b bytes.Buffer
        xml.Escape(&b, []byte(s))
        return b.String()
    }})
    template.Must(t.Parse(x))
    e := ele{
        Name: ""Meh"",
        Attrs: []attr{
            {""hi"", ""there""},
            {""um"", `I said ""hello?""`},
        },
    }
    b := new(bytes.Buffer)
    err := t.Execute(b, e)
    if err != nil {
        fmt.Println(err)
        return
    }
    fmt.Println(b)
}


Output:




",10828187
70,10869872,"See: http://golang.org/pkg/testing/#T.Fatal (and Fatalf)

The docs say: ""Fatal is equivalent to Log() followed by FailNow().""
",10869843
71,10870464,"I build a little helping package as part of my Tideland Common Go Library (see http://code.google.com/p/tcgl/). The API doc can found at http://go.pkgdoc.org/code.google.com/p/tcgl/asserts.
",10869843
72,10990287,"One defines a Car variable, the other returns a pointer to a Car.

var car Car      // defines variable car is a Car
car2 := new(Car) // defines variable car2 is a *Car and assigns a Car to back it


car := new(Car) can be implemented in relation to var car Car like this:

var x Car
car := &x

",10990174
73,10998318,"Just use a *int64. A pointer can either be nil or it can point to an int64 with an associated value and they work fine with Go's JSON package.
",10998222
74,11611782,"There's an ignored err at line 36. The error probably says open .txt: no such file or directory if you tested in browser using URL http://localhost:8080/view/ or open foo.txt: no such file or directory if you tested in browser using URL http://localhost:8080/view/foo. In the later case there must be a file ""foo.txt"" in your working directory for this example code to work. After that the code seems to work for me locally.

Someone should probably fill an issue about the ignored error value.
",11609583
75,11807674,"sweaters := Inventory{""wool"", 17}
tmpl, err := template.ParseFiles(""file.txt"")
if err != nil {
    panic(err)
}
err = tmpl.ExecuteTemplate(os.Stdout, ""file.txt"", sweaters)
if err != nil {
    panic(err)
}


If you have many files, you can use ParseGlob:

tmpl, err := template.ParseGlob(""*.txt"")
if err != nil {
    panic(err)
}
err = tmpl.ExecuteTemplate(os.Stdout, ""file.txt"", sweaters)
if err != nil {
    panic(err)
}
err = tmpl.ExecuteTemplate(os.Stdout, ""file2.txt"", sweaters)
if err != nil {
    panic(err)
}

",11805356
76,11902254,"Since then (2010), the article Slices: usage and internals is a bit more precise:


  The in-memory representation of [4]int is just four integer values laid out sequentially:





  Go's arrays are values.
  An array variable denotes the entire array; it is not a pointer to the first array element (as would be the case in C).
  This means that when you assign or pass around an array value you will make a copy of its contents. (To avoid the copy you could pass a pointer to the array, but then that's a pointer to an array, not an array.)
  One way to think about arrays is as a sort of struct but with indexed rather than named fields: a fixed-size composite value. 

",3125381
77,12225044,"
Be careful with goroutine. 
Because when the main routine, or main() func, returns, all others go routine would be killed immediately. 
Your Crawl() seems like recursive, however it is not, which means it would return immediately, not awaiting for other Crawl() routines. And you know that if the first Crawl(), called by main(), returns, the main() func regards its mission fulfilled. 
What you could do is to let main() func wait until the last Crawl() returns. The sync package, or a chan would help.
You could probably take a look at the last solution of this, which I did months ago:

var store map[string]bool

func Krawl(url string, fetcher Fetcher, Urls chan []string) {
    body, urls, err := fetcher.Fetch(url)
    if err != nil {
        fmt.Println(err)
    } else {
        fmt.Printf(""found: %s %q\n"", url, body)
    }
    Urls <- urls
}

func Crawl(url string, depth int, fetcher Fetcher) {
    Urls := make(chan []string)
    go Krawl(url, fetcher, Urls)
    band := 1
    store[url] = true // init for level 0 done
    for i := 0; i < depth; i++ {
        for band > 0 {
            band--
            next := <- Urls
            for _, url := range next {
                if _, done := store[url] ; !done {
                    store[url] = true
                    band++
                    go Krawl(url, fetcher, Urls)
                }
            }
        }
    }
    return
}

func main() {
    store = make(map[string]bool)
    Crawl(""http://golang.org/"", 4, fetcher)
}


",12224412
78,12374736,"Go isn't a scripting language. Like in C you have to compile your source code to make an executable.

From the ""Getting Started"" :


  Create a file named hello.go and put the following program in it:


package main

import ""fmt""

func main() {
    fmt.Printf(""hello, world\n"")
}



  Then run it with the go tool:


$ go run hello.go
hello, world


In the spirit of Python, there are attempts to make Go scripts kinda possible. Here's for example what you can do with gorun :

#!/usr/bin/gorun

package main

func main() {
    println(""Hello world!"")
}


But that's not really the logic of Go and that's not nearly as simple as what you typed in your question.
",12374718
79,12425590,"That's the same as in all languages of the C family : a bit shift.

See http://en.wikipedia.org/wiki/Bitwise_operation#Bit_shifts

This operation is commonly used to multiply or divide an unsigned integer by powers of 2 :

b := a >> 1 // divides by 2


1 is simply 2^100 (that's Big).

1 is 2⁶⁴-1, and that's the biggest integer you can represent in 64 bits (by the way you can't represent 1 as a 64 bits int and the point of table 15 is to demonstrate that you can have it in numerical constants anyway in Go).
",12425507
80,12425607,"They are Go's bitwise shift operators.

Here's a good explanation of how they work for C (they work in the same way in several languages).
Basically 1 corresponds to 2^64 -1, = 18446744073709551615.

Think of it this way. In decimal if you start from 001 (which is 10^0) and then shift the 1 to the left, you end up with 010, which is 10^1. If you shift it again you end with 100, which is 10^2. So shifting to the left is equivalent to multiplying by 10 as many times as the times you shift.

In binary it's the same thing, but in base 2, so 1
",12425507
81,12425614,"It's a logical shift:


  every bit in the operand is simply moved a given number of bit
  positions, and the vacant bit-positions are filled in, usually with
  zeros


Go Operators:

<<   left shift             integer << unsigned integer
>>   right shift            integer >> unsigned integer

",12425507
82,12425661,"The >> and 

http://en.wikipedia.org/wiki/Logical_shift

Also, you can check all the Go operators in their webpage
",12425507
83,12452721,"Not 100% clear on what you're trying to do, but this seems to break it down better?

type Member struct {
    Name string `xml:""name""`
    Value string `xml:""value>string""`
}

type Result struct {
        XMLName xml.Name `xml:""methodResponse""`
        FirstValue string `xml:""params>param>value>array>data>value>string""`
        Members []Member `xml:""params>param>value>array>data>value>struct>member""`
}


Note that the structure your parsing has a fairly insane level of depth. Might help to run the XML through a pretty printer that formats it for you with indent to see.
",12451898
84,12540127,"Hi and welcome to go I'm former perl hacker myself.

As to your question the encoding/json package is probably the closest you will find to a go data pretty printer. I'm not sure you really need it though. One of the reasons Data::Dumper was awesome in perl is because many times you really didn't know the structure of the data you were consuming without visually inspecting it. With go though everything is a specific type and every specific type has a specific structure. If you want to know what the data will look like then you probably just need to look at it's definition.

Some other tools you should look at include:


fmt.Println(""%#v"", data) will print the data in go-syntax form.
fmt.Println(""%T"", data) will print the data's type in go-syntax
form.
More fmt format string options are documented here: http://golang.org/pkg/fmt/

",12540057
85,12540134,"I'm not familiar with Perl and Dumper, but from what I understand of your post and the related C post (and the very name of the function!), it outputs the content of the data structure.

You can do this using the %v verb of the fmt package. I assume your JSON data is decoded into a struct or a map. Using fmt.Printf(""%v"", json_obj) will output the values, while %+v will add field names (for a struct - no difference if its a map, %v will output both keys and values), and %#v will output type information too.
",12540057
86,12562062,"iter.All() retrieves the whole result set at once into a slice.  If you just want one row, use iter.Next().  See https://groups.google.com/forum/#!msg/mgo-users/yUGZi70ik9Y/J8ktshJgF7QJ
",12558741
87,12566045,"It looks like it's working to me. notes is a slice of structs as you indicated.

for _, n := range notes {
  n.Title // do something with title
  n.Url // do something with url
}


or alternatively if you just want the first one:
notes[0].Title should work as well.

A slice of structs can't be indexed as if it were a struct itself because it isn't a struct.
",12558741
88,12568984,"your problem is here:

for note := range notes {
    fmt.Println(note.Title)
}


it should read:

for _, note := range notes {
    fmt.Println(note.Title)
}


using a range statement on a slice returns pairs of the form i, v, where i is the index in the slice, and v is the item at the index in that slice.  Since you omitted the second value, you're looping on indexes, not on Note values.

It's in the RangeClause section of the spec: http://golang.org/ref/spec#RangeClause
",12558741
89,12574928,"I'm not familiar with go, but I'd guess that go version ignores the loop since the body of the loop does nothing.  On the other hand, in the python version, you are incrementing x in the body of the loop so it's probably actually executing the loop.
",12574909
90,12575001,"This scenario will highly favor decent natively-compiled statically-typed languages. Natively compiled statically-typed languages are capable of emitting a very trivial loop of say, 4-6 CPU opcodes that utilizes simple check-condition for termination. This loop has effectively zero branch prediction misses and can be effectively thought of as performing an increment every CPU cycle (this isn't entirely true, but..)

Python implementations have to do significantly more work, primarily due to the dynamic typing. Python must make several different calls (internal and external) just to add two ints together. In Python it must call __add__ (it is effectively i = i.__add__(1), but this syntax will only work in Python 3.x), which in turn has to check the type of the value passed (to make sure it is an int), then it adds the integer values (extracting them from both of the objects), and then the new integer value is wrapped up again in a new object. Finally it re-assings the new object to the local variable. That's significantly more work than a single opcode to increment, and doesn't even address the loop itself - by comparison, the Go/native version is likely only incrementing a register by side-effect.

Java will fair much better in a trivial benchmark like this and will likely be fairly close to Go; the JIT and static-typing of the counter variable can ensure this (it uses a special integer add JVM instruction). Once again, Python has no such advantage. Now, there are some implementations like PyPy/RPython, which run a static-typing phase and should favor much better than CPython here ..
",12574909
91,12575041,"It is possible that the compiler realized that you didn't use the ""i"" variable after the loop, so it optimized the final code by removing the loop.

Even if you used it afterwards, the compiler is probably smart enough to substitute the loop with

i = 1000000000;


Hope this helps =)
",12574909
92,12575133,"You've got two things at work here.  The first of which is that Go is compiled to machine code and run directly on the CPU while Python is compiled to bytecode run against a (particularly slow) VM.

The second, and more significant, thing impacting performance is that the semantics of the two programs are actually significantly different.  The Go version makes a ""box"" called ""x"" that holds a number and increments that by 1 on each pass through the program.  The Python version actually has to create a new ""box"" (int object) on each cycle (and, eventually, has to throw them away).  We can demonstrate this by modifying your programs slightly:

package main

import (
    ""fmt""
)

func main() {
    for i := 0; i < 10; i++ {
        fmt.Printf(""%d %p\n"", i, &i)
    }
}


...and:

x = 0;
while x < 10:
    x += 1
    print x, id(x)


This is because Go, due to it's C roots, takes a variable name to refer to a place, where Python takes variable names to refer to things.  Since an integer is considered a unique, immutable entity in python, we must constantly make new ones.  Python should be slower than Go but you've picked a worst-case scenario - in the Benchmarks Game, we see go being, on average, about 25x times faster (100x in the worst case).

You've probably read that, if your Python programs are too slow, you can speed them up by moving things into C.  Fortunately, in this case, somebody's already done this for you.  If you rewrite your empty loop to use xrange() like so:

for x in xrange(1000000000):
    pass
print ""Done.""


...you'll see it run about twice as fast.  If you find loop counters to actually be a major bottleneck in your program, it might be time to investigate a new way of solving the problem.
",12574909
93,12575141,"One billion is not a very big number. Any reasonably modern machine should be able to do this in a few seconds at most, if it's able to do the work with native types. I verified this by writing an equivalent C program, reading the assembly to make sure that it actually was doing addition, and timing it (it completes in about 1.8 seconds on my machine).

Python, however, doesn't have a concept of natively typed variables (or meaningful type annotations at all), so it has to do hundreds of times as much work in this case. In short, the answer to your headline question is ""yes"". Go really can be that much faster than Python, even without any kind of compiler trickery like optimizing away a side-effect-free loop.
",12574909
94,12576824,"pypy actually does an impressive job of speeding up this loop

def main():
    x = 0
    while x < 1000000000:
        x+=1

if __name__ == ""__main__"":
    s=time.time()
    main()
    print time.time() - s




$ python count.py 
44.221405983
$ pypy count.py 
1.03511095047


~97% speedup!

Clarification for 3 people who didn't ""get it"". The Python language itself isn't slow. The CPython implementation is a relatively straight forward way of running the code. Pypy is another implementation of the language that does many tricky (especiallt the JIT) things that can make enormous differences. Directly answering the question in the title - Go isn't ""that much"" faster than Python, Go is that much faster than CPython.   

Having said that, the code samples aren't really doing the same thing. Python needs to instantiate 1000000000 of its int objects. Go is just incrementing one memory location.
",12574909
95,12613709,"According to the documentation for html/template the second argument to Execute should be the data you want to put in the template.

Add a {{.}} somewhere in your template and then pass the string you want printed in as the second argument. It should get rendered as part of the template.
",12612409
96,12615105,"Writing to the ResponseWriter (by calling Execute) before reading the value from the request is clearing it out.

You can see this in action if you use this request handler:

func GeneralHandler(w http.ResponseWriter, r *http.Request) {
   fmt.Println(r.Method)
   fmt.Println(r.URL)
   fmt.Println(""before"",r.FormValue(""username""))
   index.Execute(w, nil)
   if r.Method == ""POST"" {
     fmt.Println(""after"",r.FormValue(""username""))
   } 
 }


This will print out before and after. However, in this case:

func GeneralHandler(w http.ResponseWriter, r *http.Request) {
  fmt.Println(r.Method)
  fmt.Println(r.URL)
  index.Execute(w, nil)
  if r.Method == ""POST"" {
    fmt.Println(""after"",r.FormValue(""username""))
  }
}


The after value will be blank.
",12612409
97,12664785,"I never tried Go but I'll give it a shot:

k := datastore.NewKey(c, ""Activity"", """", id, nil)
q := datastore.NewQuery(""Article"").Filter(""__key__ ="", k)


Where c is your appengine.Context
",12659126
98,12888854,"Go uses a separate SDK from the python version you have installed. Please download it here:

Google App Engine SDK for Go

Be sure to execute it's dev_appserver.py script when you start the server.
",12885235
99,12889086,"Extending the answer from Kyle, this is what I did to get it working:


Download the SDK
Extract it to /Applications/GoogleAppEngineLauncher.app/Contents/Resources/GoogleAppEngine-default.bundle/Contents/Resources/google_appengine
Close (if its open) GAE Launcher and re-run it
Start your app and open it in the browser

",12885235
100,13020503,"None of the fmt print verbs support thousands separators.  
",13020308
101,13021942,"I wrote a library for this as well as a few other human-representation concerns.

Example results:

0 -> 0
100 -> 100
1000 -> 1,000
1000000000 -> 1,000,000,000
-100000 -> -100,000


Example Usage:

fmt.Printf(""You owe $%s.\n"", humanize.Comma(6582491))

",13020308
102,13292854,"You cannot make partial types. But you can define an interface which serves your purpose:

type SortableKeysValue interface {
    // a function that returns the strings to be sorted
    Keys() []string
}

func SortedKeys(s SortableKeysValue) []string {
    keys := s.Keys()
    sort.Strings(keys)
    return keys
}

type MyMap map[string]string

func (s MyMap) Keys() []string {
    keys := make([]string, 0, len(s))
    for k, _ := range s {
        keys = append(keys, k)
    }
    return keys
}


Try it here: http://play.golang.org/p/vKfri-h4Cp
",13291958
103,13330293,"Matching arbitrarily nested parentheses correctly is not possible with regular expressions because arbitrary (recursive) nesting cannot be described by a regular language.

Some modern regex flavor do support recursion (Perl, PCRE) or balanced matching (.NET), but Go is not one of them (the docs explicitly say that Perl's (?R) construct is not supported by the RE2 library that Go's regex package appears to be based on). You need to build a recursive descent parser, not a regex.
",13330274
104,13514395,"Use ioutil.ReadFile:

func ReadFile(filename string) ([]byte, error)



  ReadFile reads the file named by filename and returns the contents. A successful call
  returns err == nil, not err == EOF. Because ReadFile reads the whole file, it does not treat
  an EOF from Read as an error to be reported.


You will get a []byte instead of a string. It can be converted if really necessary:

s := string(buf)

",13514184
105,13515526,"I think the best thing to do, if you're really concerned about the efficiency of concatenating all of these files, is to copy them all into the same bytes buffer.

buf := bytes.NewBuffer(nil)
for _, filename := range filenames {
  f, _ := os.Open(filename) // Error handling elided for brevity.
  io.Copy(buf, f)           // Error handling elided for brevity.
  f.Close()
}
s := string(buf.Bytes())


This opens each file, copies its contents into buf, then closes the file.  Depending on your situation you may not actually need to convert it, the last line is just to show that buf.Bytes() has the data you're looking for.
",13514184
106,13544815,"The simplest way is to use the go command from the gc distribution, and run go build -compiler gccgo .

Your idea of copying pkg.a does not work because pkg.a was not built with gccgo.
",13508332
107,13815259,"My mistake i have to block the main function with e.g Scanln. Without it the program terminates before the goroutines can be executed.
",13814868
108,13846899,"Scanf is a bit finicky in that it uses spaces as a separator, and (at least for me) is rather unintuitive. Bufio does a good job of abstracting some of that:

func credentials() (string, string) {
    reader := bufio.NewReader(os.Stdin)

    fmt.Print(""Enter Username: "")
    username, _ := reader.ReadString('\n')

    fmt.Print(""Enter Password: "")
    password, _ := reader.ReadString('\n')

    return strings.TrimSpace(username), strings.TrimSpace(password) // ReadString() leaves a trailing newline character
}

",13846522
109,13870865,"The strconv package has FormatInt, which accepts an int64 and lets you specify the base.

n := int64(123)

fmt.Println(strconv.FormatInt(n, 2)) // 1111011


DEMO: http://play.golang.org/p/leGVAELMhv


  http://golang.org/pkg/strconv/#FormatInt
  
  func FormatInt(i int64, base int) string
  
  FormatInt returns the string representation of i in the given base, for 2 = 10. 

",13870845
110,14061714,"Channels can have a type indicating whether it is readonly, writeonly or both. 

Indicating a channel direction is done with 

So the  in  is part of the type, 

chan   time.Time  //Would be a read/writable channel
chan<- time.Time  // Would be a write only channel
<-chan time.Time  // Would be a read only channel


and time.Tick(1e8) returns a read only channel.

Read more in the language spec here
",14061633
111,14077292,"A good way to think of channels is as pipes with two ends. One end is where the events flow in and the other where they flow out. So declaring a channel, e.g.

var c = make(chan int)


creates a channel as a whole - i.e. with both ends. Conversely,

func consume(c <-chan int) {
    ...
}


defines a function with a channel input parameter - i.e. the readable end of a channel, and

func generate(c chan<- int) {
    ...
}


defines a function with a channel output parameter - i.e. the writable end of a channel. Both these functions can have the whole channel passed as their actual parameter, or just the end they need.

The same general principle applies when channels are used as local variables or as fields in structs.

It's good practice to use the channel-end syntax wherever possible, because the compiler will be able to check more thoroughly that you've written what you intended.

Interestingly, the occam programming language also has equivalent syntax to mark which end of a channel is which.
",14061633
112,14152326,"I don't see you populate the ID field anywhere so of course it's going to be 0 since that's the zero value for that field. AppEngine won't modify your struct when it stores it. The newly created key you get back when you Put the struct contains the generated IntId() when an incomplete key is used. I think your confusion was caused by assuming something the docs never said. Namely that AppEngine would auto-populate ID fields in your stored data for you.

Since in your case you want the ID field of the struct to store the id used in the key you probably want to generate you're own unique ids for when you create a Key instead of using incomplete keys.

When the doc says a string can be zero it's referring to the zero value of a string type which would the empty string """". You can read more about zero values here: http://golang.org/ref/spec#The_zero_value
",14151976
113,14152356,"I don't see where you actually change the value of ID prior to the Put? As far as I can tell, it's always going to be 0. I would have expected to see something like:

// PERSIST!
putKey, e := datastore.Put( c, key, participant)
if e != nil {
    // ...
}
// ...
participant.ID = putKey.IntID()
putKey, e = datastore.Put(c, putKey, participant)


Not tested, but you get the picture... otherwise ID will always be 0.
",14151976
114,14152422,"Without seeing your code, the best I can do is provide an example that shows your required functionality.

If I had to take a guess, I'd say the data you were passing in was a string, not a string pointer. A string cannot have a value of nil/null, only a string pointer can. Though that would yield a """", not a ""null"", (as demonstrated here), so I can only imagine that this is something weird you're doing in your code.

To prevent link-rot, I've duplicated the code examples below, though it's worth clicking through the links to see their output.

Required Functionality:

package main

import (
    ""log""
    ""os""
    ""html/template""
)

type TemplateData struct {
    Email *string
}

func main() {

    const temp = ""var email = {{.Email}};\n""

    t := template.Must(template.New(""email_template"").Parse(temp))
    email := ""somebody@somewhere.com""
    err := t.Execute(os.Stdout, TemplateData{
        Email: &email,
    })
    if err != nil {
        log.Println(""executing template:"", err)
    }
    err = t.Execute(os.Stdout, TemplateData{
        Email: nil,
    })
    if err != nil {
        log.Println(""executing template:"", err)
    }

}


Trying to use a ""null"" string:

package main

import (
    ""log""
    ""os""
    ""html/template""
)

type TemplateData struct {
    Email string
}

func main() {

    const temp = ""var email = {{.Email}};\n""

    t := template.Must(template.New(""email_template"").Parse(temp))
    email := ""somebody@somewhere.com""
    err := t.Execute(os.Stdout, TemplateData{
        Email: email,
    })
    if err != nil {
        log.Println(""executing template:"", err)
    }
    err = t.Execute(os.Stdout, TemplateData{
    })
    if err != nil {
        log.Println(""executing template:"", err)
    }

}

",14150985
115,14234709,"I tried to follow exactly all of the Manual Installation steps with no problems whatsoever.

(12:49) jnml@fsc-r550:~$ go version
go version go1.0.3
(12:49) jnml@fsc-r550:~$ go env
GOARCH=""amd64""
GOBIN=""/home/jnml/bin""
GOCHAR=""6""
GOEXE=""""
GOGCCFLAGS=""-g -O2 -fPIC -m64 -pthread""
GOHOSTARCH=""amd64""
GOHOSTOS=""linux""
GOOS=""linux""
GOPATH=""/home/jnml""
GOROOT=""/home/jnml/go""
GOTOOLDIR=""/home/jnml/go/pkg/tool/linux_amd64""
CGO_ENABLED=""1""
(12:49) jnml@fsc-r550:~$ 


Note: I have cloned the thrift4go repository into $GOPATH/src/github.com/pomack/thrift4go. This is not mentioned in the README.md.
",14234224
116,14236499,"Struct with zero fields are handy. Structs with many fields are handy even more. Structs with exactly one field are a bit special and I can't think of a reasonably ""good"" case where to use them - even though they are seen regularly ""in the wild"". I, for one, don't use them.

Anyway, if you really really need tighter/bulletproof safety about the DNAStrand slice content - then it is possible to to use the single field struct and define an argument checking setter method for this/such named type.

In that case, if the definition is later used from some other package, there's no way, modulo using package unsafe, to circumvent the checks and get a result equivalent to your DNAStrand{[]byte(""foo bar"")} example.
",14236263
117,14244569,"Taking your specific example I would probably do something like this:

type neucleotide char // unexported type users can't construct their own.

type DNAStrand []neucleotide // because users can't construct their own
                             // nucleotides they also can't construct their
                             // own DNAStrands.

const (
  // These are exported values so they can use these nucleotides to construct a
  // DNAStrand with.
  A nucleotide = 'A'
  C nucleotide = 'C'
  G nudleotide = 'G'
  T nucleotide = 'T'
)

// This function allows them to actually construct a DNAstrand with a list of
//  nucleotides from the constants above.
func New(nts ...nucleotide) DNAStrand {
    return nts
}


Since the nucleotide type is not exported users can't construct their own. You provide the only allowed instances of them in the exported consts so no user can provide their own new nucleotides.
",14236263
118,14247900,"I'd use type DNAStrand []byte because it's simple, and because I can use regexps on it. I'd probably use an initialisation function that checks that every byte is in ACGT though.

var validDNAStrandPat = regexp.MustCompile(""[ACTG]*"")

func DNAStrandForString(s string) DNAStrand {
    if !validDNAStrandPat.Match(s) {
        panic(""Invalid DNA Strand."")
    }
    return DNAStrand([]byte(s))
}

",14236263
119,14249946,"Code examples would help. But from your question it sounds like you've hardcoded a path to a config file somewhere when you probably wanted to pass it in instead.

Change the function you are testing to take a parameter defining the config file and then in your test code pass a different path in than you use in the non test code. It's bad practice for your code to have a different path when testing vs production.
",14249217
120,14256760,"One possibility would be to use build constraints.  If you run go test as:

go test -tags testing pkgname


Then you can use that tag to select which files will be included in a standard build of your package, and which will be used for testing.

If you put your standard configuration in a file of its own, then adding a line to the top like the following will ensure that it is not used for testing:

// +build !testing


You can then include the testing configuration in one of the *_test.go files, or in some other file that requires that the testing tag be set.
",14249217
121,14322756,"You can't do this directly with the users API but see this question for alternative options:


  Instead of using the UserService API to logout, you can manually remove the AppEngine specific cookies that are set. Check out this blog post that discusses how to so (written in Python, but you should be able to modify it for Java). This should effectively log the user out from your own app but not from other Google services (though I haven't tested this myself).
  
  The more robust approach would be to create your own User class and manage your own session cookies, while wrapping the UserService API. The downside of this approach is the extra work that is required to set it up, compared to the very easy to use UserService API. However, the advantage of maintaining your own Users is that you will be able to use other methods of authentication besides for Google (e.g. now you will be able to use a Facebook login as well, or even a native login if you choose to set that up).

",14322674
122,14427910,"According to this article:

package main

import (
    ""fmt""
    ""time""
)

func main() {
    value  := ""Thu, 05/19/11, 10:47PM""
    // Writing down the way the standard time would look like formatted our way
    layout := ""Mon, 01/02/06, 03:04PM""
    t, _ := time.Parse(layout, value)
    fmt.Println(t)
}

// => ""Thu May 19 22:47:00 +0000 2011""

",14427830
123,14427956,"You need time.Parse() and a format string that matches your supplied date string.

Here's an example using your date format.

package main

import (
    ""fmt""
    ""time""
    )

func main() {
    s := ""12-25-2012""
    format_string := ""01-02-2006""
    t, err := time.Parse(format_string, s)
    if err != nil {
        panic(err)
    }
    fmt.Printf(""%v\n"", t)
}


http://play.golang.org/p/YAeAJ3CNqO

You can read more about making custom format strings in this post.
",14427830
124,14440697,"I believe you should read, or re-read How to Write Go code

In short:

Set you GOPATH to somewhere and export it for good. Then put some package blah into directory

$GOPATH/src/foo/bar/baz/blah # (1)


or

$GOPATH/src/blah # (2)


or

$GOPATH/src/qux/blah # (3) etc.


Import blah into other packages as

import ""foo/bar/baz/blah"" // (1)


or

import ""blah"" // (2)


or

import ""qux/blah"" // (3)


The package in that directory will contain the package files. Say you have only one, blah.go. Then its location would be

$GOPATH/src/foo/bar/baz/blah/blah.go // (1)

$GOPATH/src/blah/blah.go // (2)

$GOPATH/src/qux/blah/blah.go // (3)


If the blah package source file is named, say proj.go instead, then

$GOPATH/src/foo/bar/baz/blah/proj.go // (1)

$GOPATH/src/blah/proj.go // (2)

$GOPATH/src/qux/blah/proj.go // (3)


But the import paths would be the same as in the previous case.
",14440369
125,14440906,"Ok, this seems to solve it:

export GOPATH=`pwd`


Apparently, it needs to be an absolute path. I still find the error message very confusing, though.
",14440369
126,14480383,"to get the Number of Columns (and also the names) just use the Columns() Function

http://golang.org/pkg/database/sql/#Rows.Columns

and as csv can only be a strings, just use a []byte type as dest type for Scanner.
according to docu:


  If an argument has type *[]byte, Scan saves in that argument a copy of
  the corresponding data. The copy is owned by the caller and can be
  modified and held indefinitely.


the data will not be transformed into its real type.
and from this []byte you can then convert it to string.

if your are sure your tables only use base types (string, []byte, nil, int(s), float(s), bool) you can directly pass string as dest

but if you use other types like arrays, enums, or so on, then the data cant be transformed to string. but this also depends how the driver handles this types. (some months ago as example, the postgres driver was not able to handle arrays, so he returned always []byte where i needed to transform it by my own) 
",14477941
127,14500756,"In order to directly Scan the values into a []string, you must create an []interface{} slice pointing to each string in your string slice.

Here you have a working example for MySQL (just change the sql.Open-command to match your settings):

package main

import (
    ""fmt""
    _ ""github.com/go-sql-driver/mysql""
    ""database/sql""
)

func main() {
    db, err := sql.Open(""mysql"", ""user:pass@tcp(localhost:3306)/test?charset=utf8"")
    defer db.Close()

    if err != nil {
        fmt.Println(""Failed to connect"", err)
        return
    }

    rows, err := db.Query(`SELECT 'one' col1, 'two' col2, 3 col3, NULL col4`)
    if err != nil {
        fmt.Println(""Failed to run query"", err)
        return
    }

    cols, err := rows.Columns()
    if err != nil {
        fmt.Println(""Failed to get columns"", err)
        return
    }

    // Result is your slice string.
    rawResult := make([][]byte, len(cols))
    result := make([]string, len(cols))

    dest := make([]interface{}, len(cols)) // A temporary interface{} slice
    for i, _ := range rawResult {
        dest[i] = &rawResult[i] // Put pointers to each string in the interface slice
    }

    for rows.Next() {
        err = rows.Scan(dest...)
        if err != nil {
            fmt.Println(""Failed to scan row"", err)
            return
        }

        for i, raw := range rawResult {
            if raw == nil {
                result[i] = ""\\N""
            } else {
                result[i] = string(raw)
            }
        }

        fmt.Printf(""%#v\n"", result)
    }
}

",14477941
128,14715693,"What about these solution, these way you dont need a query, neither an iterator is more direct way of solving the problem.

var article Article
k := datastore.NewKey(c, ""Article"", """", usrr.User, nil)
q := datastore.Get(c,k,&article)


What did you think?
",12659126
129,14777001,"Yes, that's the purpose of the projection parameter of find:

db.collection.find({_id: 1234}, {
    'parentfield1.childfield1': 1,
    'parentfield1.childfield2': 1,
    'parentfield1.childfield3': 1
});


If a specified field isn't present in a given doc, the other matching fields will still be included.

Build up the projection parameter object programmatically if you want it to be dynamic.
",14776879
130,15078106,"Running the gccgo-generated binary under Valgrind seems to indicate that gccgo has an inefficient memory allocator. This may be one of the reasons why gccgo 4.7.2 is slower than go 1.0.2. It is impossible to run a binary generated by go 1.0.2 under Valgrind, so it is hard to confirm for a fact whether memory allocation is gccgo's primary performance problem in this case.
",15073027
131,15103151,"Effectively, you are running:

package main

import (
    ""fmt""
    ""time""
)

func main() {
    returnCurrentTime := func() string {
        return time.Now().String()
    }

    c := make(chan string, 2)

    asyncReturnCurrentTime := func(c chan string) {
        time.Sleep(2001 * time.Millisecond)
        c <- returnCurrentTime()
    }

    go asyncReturnCurrentTime(c)
    go asyncReturnCurrentTime(c)
    go asyncReturnCurrentTime(c)
    fmt.Println(<-c)
    fmt.Println(<-c)
    fmt.Println(<-c)
    fmt.Println()
    go asyncReturnCurrentTime(c)
    go asyncReturnCurrentTime(c)
    go asyncReturnCurrentTime(c)
    fmt.Println(<-c)
    fmt.Println(<-c)
    fmt.Println(<-c)
    fmt.Println()
}


Output:

2013-02-26 21:28:22.069581655 -0500 EST
2013-02-26 21:28:22.069688722 -0500 EST
2013-02-26 21:28:22.069695217 -0500 EST

2013-02-26 21:28:24.070985411 -0500 EST
2013-02-26 21:28:24.070999309 -0500 EST
2013-02-26 21:28:24.071002661 -0500 EST



  Send statements
  
  Both the channel and the value expression are evaluated before
  communication begins. Communication blocks until the send can proceed.


The returnCurrentTime() expression (the timestamp) is evaluated immediately, before an attempt is made to send. It's not a timestamp for the send. The send may happen later if the buffer is full.

Also, measuring actual send and receive times, the buffering delay for chan c is going to be inconsequential: send, send, block, receive, unblock, send.  For example, 

c <-;  2013-02-26 23:29:34.505456624 -0500 EST
c <-;  2013-02-26 23:29:34.505467030 -0500 EST
<- c;  2013-02-26 23:29:34.505468497 -0500 EST
c <-;  2013-02-26 23:29:34.505518015 -0500 EST

c <-;  2013-02-26 23:31:36.506659943 -0500 EST
c <-;  2013-02-26 23:31:36.506664832 -0500 EST
<- c;  2013-02-26 23:31:36.506669302 -0500 EST
c <-;  2013-02-26 23:31:36.506696540 -0500 EST

",15102643
132,15297139,"if you call parseMultipartForm(0) this will write the entire file to disk instead of storing anything in memory, followed by f, _ := FormFile(""file"") then you can stat the file with fi, _ := f.(*os.File).Stat()
",15295522
133,15302979,"Depending on what you want to do with the data, the best thing to do may be to read the file into a byte slice with ioutil.ReadAll. (You might want the data as a byte slice eventually, anyway.) Once you've done that, you an find the length with len.
",15295522
134,15311116,"You can exploit the fact that multipart.File implements io.Seeker to find its size.

cur, err := file.Seek(0, 1)
size, err := file.Seek(0, 2)
_, err := file.Seek(cur, 0)


The first line finds the file's current offset. The second seeks to the end of the file and returns where it is in relation to the beginning of the file. This is the size of the file. The third seeks to the offset we were at before trying to find the size.

You can read more about the seek method here.
",15295522
135,15452023,"You have to make the fields that you want to marshal public.
Like this:

type Address struct {
  Street string
  Extended string
  City string
  State string
  Zip string
}


err is nil because all the exported fields, in this case there are none, were marshalled correctly.

Working example: http://play.golang.org/p/0Q8TIvZwuj

Check out the docs http://godoc.org/encoding/json/#Marshal
",15452004
136,15620256,"This is a naive approach (1GB):

package main

import (
    ""fmt""
    ""log""
    ""os""
)

func main() {
    myfile, err := os.OpenFile(""myfile"", os.O_WRONLY|os.O_CREATE, 0644)
    if err != nil {
        log.Fatal(err)
    }
    defer myfile.Close()
    var pos int
    var line string
    // sample: login:jbill:2013/3/25, 1
    line = fmt.Sprintf(""%s:%s:%s, %d\n"", ""login"", ""jbill"", ""2013/3/25"", 1)
    for pos < 1024*1024*1024 {
        bytes, err := myfile.Write([]byte(line))
        if err != nil {
            log.Fatal(err)
        }
        pos = pos + bytes
    }
}


which takes forever (1:16), because the output is not buffered. By adding bufio you can decrease the time dramatically

package main

import (
    ""bufio""
    ""fmt""
    ""log""
    ""os""
)

func main() {
    myfile, err := os.OpenFile(""myfile"", os.O_WRONLY|os.O_CREATE, 0644)
    if err != nil {
        log.Fatal(err)
    }
    defer myfile.Close()
    mybufferedfile := bufio.NewWriter(myfile)
    var pos int
    var line string
    // sample: login:jbill:2013/3/25, 1
    line = fmt.Sprintf(""%s:%s:%s, %d\n"", ""login"", ""jbill"", ""2013/3/25"", 1)
    for pos < 1024*1024*1024 {
        bytes, err := mybufferedfile.WriteString(line)
        if err != nil {
            log.Fatal(err)
        }
        pos = pos + bytes
    }
    err = mybufferedfile.Flush()
    if err != nil {
        log.Fatal(err)
    }
}


Still 26 sec on my machine, I'd like to see a faster solution.

BTW: you need to do the random fileds, but that is left as an exercise to the reader :)
",15619225
137,15622206,"For example,

package main

import (
    ""bufio""
    ""fmt""
    ""math/rand""
    ""os""
    ""strconv""
    ""time""
)

func main() {
    fileSize := int64(10e9) // 10GB
    f, err := os.Create(""/tmp/largefile"")
    if err != nil {
        fmt.Println(err)
        return
    }
    w := bufio.NewWriter(f)
    prefixes := []string{""login"", ""logout"", ""register""}
    names := []string{""jbill"", ""dkennedy""}
    timeStart := time.Date(2012, 1, 1, 0, 0, 0, 0, time.UTC)
    timeDur := timeStart.AddDate(1, 0, 0).Sub(timeStart)
    rand.Seed(time.Now().UnixNano())
    size := int64(0)
    for size < fileSize {
        // prefix:username:timestamp, number
        // login:jbill:2012/3/25, 1
        prefix := prefixes[int(rand.Int31n(int32(len(prefixes))))]
        name := names[int(rand.Int31n(int32(len(names))))]
        time := timeStart.Add(time.Duration(rand.Int63n(int64(timeDur)))).Format(""2006/1/2"")
        number := strconv.Itoa(int(rand.Int31n(100) + 1))
        line := prefix + "":"" + name + "":"" + time + "", "" + number + ""\n""
        n, err := w.WriteString(line)
        if err != nil {
            fmt.Println(n, err)
            return
        }
        size += int64(len(line))
    }
    err = w.Flush()
    if err != nil {
        fmt.Println(err)
        return
    }
    err = f.Close()
    if err != nil {
        fmt.Println(err)
        return
    }
    fmt.Println(""Size:"", size)
}


Output:

register:jbill:2012/8/24, 15
login:jbill:2012/10/7, 98
register:dkennedy:2012/8/29, 70
register:jbill:2012/6/1, 89
register:jbill:2012/5/24, 63
login:dkennedy:2012/3/29, 48
logout:jbill:2012/7/8, 93
logout:dkennedy:2012/1/12, 74
login:jbill:2012/4/12, 14
login:jbill:2012/2/5, 83

",15619225
138,15643592,"In C++, the simplest solution would be to us an
std::ostringstream to put the data in a string, and then an
std::istringstream to reread it.  Although deprecated,
strstream will allow you to avoid the dynamic allocations and
the copies (assuming you know the maximum size of the data
before hand).  Or you can easily write your own streambuf to
do it.  Or if you don't need formatting, of course, you can just
push the data into an std::vector.

IIRC, Java also has memory based streams (based on Byte[],
I think).
",15643388
139,15643594,"If using java : commons vfs supports a RAM file system type
",15643388
140,15643625,".Net has a MemoryStream class that you could use (System.IO):
http://msdn.microsoft.com/en-us/library/system.io.memorystream.aspx
",15643388
141,15745351,"I published a Go snippet over at Github of a function to render a number (float64 or int) according to user-specified thousand separator, decimal separator and decimal precision.

https://gist.github.com/gorhill/5285193


Usage: s := RenderFloat(format, n)

The format parameter tells how to render the number n.

Examples of format strings, given n = 12345.6789:

""#,###.##"" => ""12,345.67""
""#,###."" => ""12,345""
""#,###"" => ""12345,678""
""#\u202F###,##"" => ""12 345,67""
""#.###,###### => 12.345,678900
"""" (aka default format) => 12,345.67

",13020308
142,15802707,"integer to ASCII. It comes from the C language/UNIX. See this thread for more: Where did the name `atoi` come from?

In the C language, there is no concept such as strings, you have arrays of characters that are null terminated.

Thanks to @mvp!
",15802695
143,15835001,"Try this:   

fileHandler := http.StripPrefix(""/static/"", http.FileServer(http.Dir(""/absolute/path/static"")))
http.Handle(""/static/"", fileHandler)

",15834278
144,15835185,"I think you might be looking for PathPrefix... 

func main() {
    r := mux.NewRouter()
    r.HandleFunc(""/search/{searchTerm}"", Search)
    r.HandleFunc(""/load/{dataId}"", Load)
    r.PathPrefix(""/"").Handler(http.FileServer(http.Dir(""./static/"")))
    http.Handle(""/"", r)
    http.ListenAndServe("":8100"", nil)
}

",15834278
145,15858718,"No, there are no guarantees.

Even when the channel is not full, if two goroutines are started at about the same time to send to it, I don't think there is any guarantee that the goroutine that was started first would actually execute first. So you can't count on the messages arriving in order.
",15858658
146,15858897,"You can drop the message if the channel is full (and then set a flag to pause the client and send them a message that they're dropping messages or whatever).

Something along the lines of (untested):

type Client struct {
    Name string
    ch   chan<-string
}

func broadcast(c <-chan string, chans []*Client) {
    for msg := range c {
        for _, ch := range chans {
            select {
            case ch.ch <- msg:
            // all okay
            default:
                log.Printf(""Channel was full sending '%s' to client %s"", msg, ch.Name)
            }
        }
    }
}

",15858658
147,15862090,"In this code, no guarantees.

The main problem with the given sample code lies not in the channel behavior, but rather in the numerous created goroutines. All the goroutines are ""fired"" inside the same imbricated loop without further synchronization, so even before they start to send messages, we simply don't know which ones will execute first.

However this rises a legitimate question in general : if we somehow garantee the order of several blocking send instructions, are we guaranteed to receive them in the same order?

The ""happens-before"" property of the sendings is difficult to create. I fear it is impossible because :


Anything can happen before the sending instruction : for example, other goroutines performing their own sendings or not
A goroutine being blocked in a sending cannot simultaneously manage other sorts of synchronization


For example, if I have 10 goroutines numbered 1 to 10, I have no way of letting them send their own number to the channel, concurrently, in the right order. All I can do is use various kinds of sequential tricks like doing the sorting in 1 single goroutine.
",15858658
148,15864816,"This is an addition to the already posted answers.

As practically everyone stated, that the problem is the order of execution of the goroutines,
you can easily coordinate goroutine execution using channels by passing around the number of the 
goroutine you want to run:

func coordinated(coord chan int, num, max int, work func()) {
    for {
        n := <-coord

        if n == num {
            work()
            coord <- (n+1) % max
        } else {
            coord <- n
        }
    }
}

coord := make(chan int)

go coordinated(coord, 0, 3, func() { println(""0""); time.Sleep(1 * time.Second) })
go coordinated(coord, 1, 3, func() { println(""1""); time.Sleep(1 * time.Second) })
go coordinated(coord, 2, 3, func() { println(""2""); time.Sleep(1 * time.Second) })

coord <- 0


or by using a central goroutine which executes the workers in a ordered manner:

func executor(funs chan func()) {
    for {
        worker := <-funs
        worker()
        funs <- worker
    }
}

funs := make(chan func(), 3)

funs <- func() { println(""0""); time.Sleep(1 * time.Second) }
funs <- func() { println(""1""); time.Sleep(1 * time.Second) }
funs <- func() { println(""2""); time.Sleep(1 * time.Second) }

go executor(funs)


These methods will, of course, remove all parallelism due to synchronization. However,
the concurrent aspect of your program remains.
",15858658
149,15990066,"How about to store Votes as child items of Comment, using ancestor paths? I mean set parent key parameter pointing to parent Comment when you storing each new Vote struct. Something like this:

key, err := datastore.Put(context, datastore.NewIncompleteKey(context, model.DB_KIND_VOTE, commentKey), &vote)

",6125345
150,16142329,"One of the predefined global template functions is index.


  index   Returns the result of indexing its first argument by the
    following arguments. Thus index x 1 2 3 is, in Go syntax,
    x[1][2][3]. Each indexed item must be a map, slice, or array.


So you are on the right track. The only issue is that you are not accounting for the fact the dot has been reassigned within the range block.

So you need to get back to the original dot, for that we have the following


  When execution begins, $ is set to the data argument passed to Execute, that is, to the starting value of dot.


So (assuming there is nothing else going on in your template) you should be able to do:

{{range $i, $e := .First}}$e - {{index $.Second $i}}{{end}}


Personally though, I would create a template function called zip that accepts multiple slices and returns a slice of each pair of values. It would look cleaner in your template and probably get reused somewhere.
",16141467
151,16169115,"go list -f '{{join .Deps ""\n""}}' 


Will show import dependencies for package at  - or in current directory if  is left empty. Alternatively

go list -f '{{join .DepsErrors ""\n""}}' 


hopefully shows some useful information in your case. See also the output of

go help list


for additional information about the go list tool.
",16168601
152,16175509,"To complement on jnml's answer (which helps ""debug"" circular references problems), you can use dependency inversion to break those cycles, coupled with dependency injection. For an application, I always try to follow the guidelines of the Clean Architecture - see here for a Go-specific example - and I find that Go's ""non-declarative implementation"" of interfaces (that is, you don't have to explicitly say type MyStruct struct implements IfceSomething) makes this very simple.

So, if you have packages A -> B -> C -> A, you create InterfaceA (some relevant name, obviously, more behaviour-related than package-related :) in package C and make it depend on this interface instead of on package A, and you make sure package A ""implements"" this interface.

Then you just have to provide a concrete implementation of A to C at some point (many possibilities here, I usually do this ""glue"" code in the main package that knows about all dependencies).
",16168601
153,16683592,"While you can declare an actual ""read only"" or ""write only"" channel variable, it's useless to do so, because you can't do anything with them.  

The ""read only"" and ""write only"" syntax is for function parameters.  This syntax is more like ""const"" in C or ""in"" and ""out"" in Ada. 

Nor do Go channels have two ""ends"". UNIX pipes have two file descriptors, one for each end. The same variable of channel type is used for both reading and writing.  
",14061633
154,16916602,"You are getting the correct answer. The answer you want to get is wrong.

In

func (f *Fish) WhatAmI() string {
        return reflect.TypeOf(f).String()
}


f is of type *main.Fish, it's even declared to be of that type (f *Fish). Thus it cannot ever be of type *main.Cod.

The probable source of confusion: The method set of Cod inherites the method set of its embedded, anonymous field Fish and doesn't override it. Thus invoking WhatAmI on an instance of Cod ""delegates"" the call to Fish.WhatAmI, but the receiver is now the embedded field of type *main.Fish.

Example with overriding the inherited method:

package main

import (
        ""fmt""
)

type Fish struct {
}

func (f *Fish) WhatAmI() string {
        return fmt.Sprintf(""%T"", f)
}

type Cod struct {
        Fish
}

func (c *Cod) WhatAmI() string {
        return fmt.Sprintf(""%T"", c)
}

func main() {
        c := new(Cod)
        fmt.Println(""I am a"", c.WhatAmI())
}


Playground



Output:

I am a *main.Cod

",16916464
155,16917647,"For a fairly generic solution, you could separate the WhatAmI function from the Fish type and use an empty interface (see Andrew Gerrand's ""The Laws of Reflection""), and just check the type on that:

package main

import (
    ""fmt""
    ""reflect""
)

type Fish struct {
}

type Cod struct {
    Fish
}

func WhatAmI (self interface{}) string {
    return reflect.TypeOf(self).String()
}

func main() {
    c := new(Cod)
    fmt.Println(""I am a"", WhatAmI(c))
}


Gives:

I am a *main.Cod

",16916464
156,16931866,"This code has many errors in it. To start with, the json isn't valid json. You are missing the commas in between key pairs in your top level object. I added the commas and pretty printed it for you:

{
   ""1001"":{
      ""level"":10,
      ""monster-id"":1001,
      ""skill-level"":1,
      ""aimer-id"":301
   },
   ""1002"":{
      ""level"":12,
      ""monster-id"":1002,
      ""skill-level"":1,
      ""aimer-id"":302
   },
   ""1003"":{
      ""level"":16,
      ""monster-id"":1003,
      ""skill-level"":2,
      ""aimer-id"":303
   }
}




Your next problem (the one you asked about) is that m := data.(map[string]interface{}) makes m a map[string]interface{}. That means when you index it such as the v in your range loop, the type is interface{}. You need to type assert it again with v.(map[string]interface{}) and then type assert each time you read from the map.



I also notice that you next attempt mc.Pool[i] = monster when i is an int and mc.Pool is a map[string]Monster. An int is not a valid key for that map.



Your data looks very rigid so I would make unmarshall do most of the work for you. Instead of providing it a map[string]interface{}, you can provide it a map[string]Monster.

Here is a quick example. As well as changing how the unmarshalling works, I also added an error return. The error return is useful for finding bugs. That error return is what told me you had invalid json.

type Monster struct {
    MonsterId  int32 `json:""monster-id""`
    Level      int32 `json:""level""`
    SkillLevel int32 `json:""skill-level""`
    AimerId    int32 `json:""aimer-id""`
}

type MonsterCollection struct {
    Pool map[string]Monster
}

func (mc *MonsterCollection) FromJson(jsonStr string) error {
    var data = &mc.Pool
    b := []byte(jsonStr)
    return json.Unmarshal(b, data)
}


I posted a working example to goplay: http://play.golang.org/p/4EaasS2VLL
",16931499
157,16937083,"Just wrap your call to fmt.Scan in a for loop.
",16931561
158,17004417,"This is impossible in Go, by design - if you don't have data, the Template package is unnecessary overhead. 

If you have no data, just read the file using the io package, instead of using templates.
",17004405
159,17004517,"If your template doesn't (yet) use any variables, you can just pass any value as data to render the template. So, to render the template to stdout, you could for example use:

tpl.Execute(os.Stdout, nil)


If you really want to render the template to a string, you can use a bytes.Buffer as an intermediary:

var buf bytes.Buffer
tpl.Execute(&buf, nil)
str := buf.String()

",17004405
160,17091172,"I assume you are talking about web development.

As you correctly noted, the directory structure is meant for the code, and the go tool suite only takes care of building binaries and putting them in a conventional place (pkg or bin).

What you want is a complete deployment procedure for a binary + resource files.

You should either roll your own deployment procedure, or use an existing framework.

A sketch of a homemade procedure :


put all the resources under a specific directory in your project (e.g. resources/)
use git archive resources/ to bundle the files
copy the files next to your executable
choose a way to adjust the local parameters (db server, db name, etc..)
choose a way to make to have your server reload the resources (restart your server / systematically re-read the resources / check modification dates / ... )


If you are looking for an existing web framework :

Revel is one option, which takes care of a good number of points, among which hot recompilation during development, and a deployment procedure.
",17086309
161,17209029,"I guess following lines work slower in go.

    fmt.Fscanf(input,""%f"",&p)
    fmt.Fprintln(output,gain+10000)


Go's magic happens when you do IO. They look like synchronous but in fact they are async.
Go rotine does async request and returns control to scheduler. Scheduler looks for another goroutine waiting for taking control but there is only one waiting io.
So scheduler loops doing nothing.

If you had 2, 10 or 100 concurrent goroutines then will see a better performance.
",17208763
162,17209612,"Like Max, my strong suspicion was that the slowness in Go was related to poor I/O performance.  I tested this hypothesis:

package main

import ""fmt""
import ""os""
import ""time""

func main(){
    now := time.Now()
    input,_ := os.Open(""testing/test_cases.txt"")
    defer input.Close()
    output,_ := os.Create(""testing/Goutput.txt"")
    defer output.Close()

    var ncases int
    var p float64
    fmt.Fscanf(input,""%d"",&ncases)

    fmt.Println(""Opened files in "", time.Since(now), ""seconds"")
    now = time.Now()

    cases := make([]float64, ncases)
    fmt.Println(""Made array in "", time.Since(now), ""seconds"")
    now = time.Now()

    for i := 0; i < ncases; i++ {
        fmt.Fscanf(input,""%f"",&cases[i])
    }

    fmt.Println(""Read data in "", time.Since(now), ""seconds"")
    now = time.Now()

    for i := 0; i < ncases; i++ {
        p = cases[i]
        if p >= 0.5 {
            cases[i] = 10000 * (1-p) * (2*p-1) + 10000
        } else {
            cases[i] = p*(1-2*p)*10000 + 10000
        }
    }

    fmt.Println(""Processed data in "", time.Since(now), ""seconds"")
    now = time.Now()

    for i := 0; i < ncases; i++ {
        fmt.Fprintln(output, cases[i])
    }

    fmt.Println(""Output processed data in "", time.Since(now), ""seconds"")
}


Running it produced this output:


Opened files in  2.011228ms seconds
Made array in  109.904us seconds
Read data in  4.524544608s seconds
Processed data in  10.083329ms seconds
Output processed data in  1.703542918s seconds


So it appears that on my machine, all of the math occurs in about 10ms, but the I/O is slow, confirming the hypothesis.  As pointed out by Janne in the comments, there are likely faster options than fmt.

Update: For example, wrapping input and output with bufio's Readers and Writers:

binput := bufio.NewReader(input)
boutput := bufio.NewWriter(output)


and using binput and boutput for buffered I/O, your original version runs in 2.1 seconds on my machine, somewhat faster than Python's 2.7.

Update 2: I noticed that I was getting different results by just switching to buffered I/O.


It turns out that you also need to adjust your format strings to include the \n, as you do in the C version.  I think this is actually more correct either way, but it looks like you can get away with it while unbuffered.
It's also important to Flush() your buffered output, which I did but didn't mention before.


Here's my complete buffered solution:

package main

import ""fmt""
import ""os""
import ""bufio""
import ""time""

func main(){
    now := time.Now()

    nbinput, _ := os.Open(""testing/test_cases.txt"")
    defer nbinput.Close()

    nboutput, _ := os.Create(""testing/Goutput.txt"")
    defer nboutput.Close()

    binput := bufio.NewReader(nbinput)
    boutput := bufio.NewWriter(nboutput)

    var ncases int
    var gain, p float64
    fmt.Fscanf(binput,""%d\n"",&ncases)

    for i := 0; i < ncases; i++ {
        fmt.Fscanf(binput, ""%f\n"", &p)
        if p >= 0.5 {
            gain = 10000 * (1-p) * (2*p -1)
        } else {
            gain = p*(1-2*p)*10000
        }
        fmt.Fprintln(boutput, gain+10000)
    }
    boutput.Flush()
    fmt.Println(""Took "", time.Since(now), ""seconds"")
}

",17208763
163,17222252,"inside your handler function call r.RemoteAddr to receive ip:port

like this:

func renderIndexPage(w http.ResponseWriter, r *http.Request) {
  ip := strings.Split(r.RemoteAddr,"":"")[0] 

}


update 02/15/2017
as @Aigars Matulis pointed out, in current version there is already a function todo this

ip, _, _ := net.SplitHostPort(r.RemoteAddr)

",17222021
164,17266948,"There are two that I know of:


http://godoc.org/code.google.com/p/go-html-transform/css/selector is one.
https://github.com/PuerkitoBio/goquery is another


go-html-transform also comes with some tools to transform the html that matches selectors.
",17266532
165,17326373,"You should check out this resize library: github.com/nfnt/resize. It has 6 good interpolation functions to choose from.
",7309355
166,17383819,"your Items have to be an array of interface

like this:

Items []interface{}


here is a complete example:
http://play.golang.org/p/LOXCiSmUET

when you unmarshal your json, and want to iterate over your Items you need to identify the type. when doing be aware that complex types are represented as  map[string]interface and not as struct, in such case your need to create the struct by your self
",17383554
167,17518473,"I wrote go-eldoc. You can install go-eldoc with package.el from MELPA.
",10045481
168,17575156,"Although it is definitely not idiomatic Go, you could do something like this:

type Response map[string]interface{}

func (r *Response) New() {
  *r = make(map[string]interface{})
  (*r)[""hello""] = ""World""
  (*r)[""high""] = 5
}

func main() {
  var r Response
  r.New()
  for k, v := range r {
    fmt.Printf(""%s = %v\n"", k, v)
  }
}


But really, there's nothing wrong with func NewResponse() Response.
",17574770
169,17575176,"It doesn't. Go doesn't have constructors. To create an ""empty"" object is to create a zero value of the type of the object.

What you're trying to do is a Response method named New to be called on an existing Response object that would return a (different) Response object. 

resp := Response{} or resp := make(Response) is fine if you need to create an empty Response.
",17574770
170,17575641,"When you write Go programs, use idiomatic Go. Then, other people will be able to read your programs. For example,

package main

import ""fmt""

type Response map[string]interface{}

func NewResponse() Response {
    metadata := map[string]string{
        ""base"": ""api/v1"",
        ""self"": ""/crawler/jobs/add"",
    }
    r := Response{
        ""status"":   200,
        ""msg"":      ""Added jobs to queue"",
        ""metadata"": metadata,
    }
    return r
}

func main() {
    resp := NewResponse()
    fmt.Println(resp)
}


Output:

map[status:200 msg:Added jobs to queue metadata:map[base:api/v1 self:/crawler/jobs/add]]

",17574770
171,17595735,"Both usage are good, but it depends on your needs.

If you find it useful to attach additional data to the error that doesn't show in the error message, then the approach in crypto/x509 is preferable.

But I think in most cases, the simple error string as found in the errors package is sufficient.

Edit

An error can have different ""attributes"":

Describing
The Error() method should return a short describing error message

Identifiable
By letting a package export the different errors it might return, you can identify them. This is either done like in the io package by exporting initialized error variables of same type:

if err == io.EOF { ... } // That's easy


Or like in the encoding/json package by exporting the different error types:

if mErr, ok := err.(*json.MarshalerError); ok { ... } // That's fairly easy


Or by doing like they do in the crypto/x509 package, by exporting the different Reasons (error codes):

if e, ok := err.(x509.CertificateInvalidError); ok && e.Reason == x509.Expired  { ... } // Well, it works


Unique error code
If errors should have specific codes due to a protocol spec, these could be embedded in the error variable. The crypto/x509 package might be used for that, even though it is probably not the case.

But when it comes to how to solve it, I think there is no best approach, nor any clearly idiomatic one. The examples above shows you ways to do it and ways it is done in the standard libraries. Take your pick.

.. but maybe not using switch statements.
",17595502
172,17947530,"Hope that helps (go-1.1):

package main

import (
    ""fmt""
""reflect""
)

var m = map[string]int{""a"": 3, ""b"": 4}

func MapKeys(m interface{}) (keys []string) {
    v := reflect.ValueOf(m)
    for _, k := range v.MapKeys() {
        keys = append(keys, k.Interface().(string))
    }
    return
}

func main() {
    fmt.Printf(""%#v\n"", MapKeys(m))
}

",13291958
173,18013987,"Please note, that goroutines are also limited to your local maschine and that channels are not natively network enabled, i.e. your particular case is probably not biting go's chocolate site.

Also: What did you expect from throwing (suposedly) every transfer into a goroutine? IO-Operations tend to have their bottleneck where the bits hit the metal, i.e. the physical transfer of the data to the medium. Think of it like that: No matter how many Threads or (Goroutines in this case) try to write to Networkcard, you still only have one Networkcard. Most likely hitting it with to many concurrent write calls will only slow things down, since the involved overhead increases

If you think this is not the problem or want to audit your code for optimized performance, go has neat builtin features to do so: profiling go programs (official go blog)
But still the actual bottleneck might well be outside your go program AND/OR in the way it interacts with the os.

Adressing your actual problem without code is pointless guessing. Post some and everyone will try their best to help you.
",18006533
174,18022615,"You will probably have to post your source code to get any real input, but just to be sure, you have increased number of cpus to use?

import ""runtime""

func main() {
    runtime.GOMAXPROCS(runtime.NumCPU())
}

",18006533
175,18170244,"There is not currently a better way than context.Errorf() and friends. Python just got pdb support in the 1.8.3 SDK. I have not heard of any similar debugger support for go. It is perhaps worth asking on the app engine go list about this.
",18169071
176,18188477,"You can get proxy info using ProxyFromEnvironment function. Then you create http client using transport (represented by RoundTripper interface) that has info about your proxy settings:

var PTransport RoundTripper = &http.Transport{Proxy: http.ProxyFromEnvironment}

client := http.Client{Transport: PTransport}


Then you just do http request using the info transport gets from passed function to Proxy struct field. Proxy info will be taken from $HTTP_PROXY environment variable.
",18187136
177,18208542,"This is what I would do (untested code):

func eq(a, b map[string]int) bool {
        if len(a) != len(b) {
                return false
        }

        for k, v := range a {
                if w, ok := b[k]; !ok || v != w {
                        return false
                }
        }

        return true
}

",18208394
178,18211675,"The Go library has already got you covered. Do this:

import ""reflect""
// m1 and m2 are the maps we want to compare
eq := reflect.DeepEqual(m1, m2)
if eq {
    fmt.Println(""They're equal."")
} else {
    fmt.Println(""They're unequal."")
}


If you look at the source code for reflect.DeepEqual's Map case, you'll see that it first checks if both maps are nil, then it checks if they have the same length before finally checking to see if they have the same set of (key, value) pairs.

Because reflect.DeepEqual takes an interface type, it will work on any valid map (map[string]bool, map[struct{}]interface{}, etc). Note that it will also work on non-map values, so be careful that what you're passing to it are really two maps. If you pass it two integers, it will happily tell you whether they are equal.
",18208394
179,18275547,"I just red about your topic in this blog:

http://joshua.themarshians.com/hardcore-google-unit-testing.html

I can't give you an example but maybe it will help.
",18169071
180,18298762,"
To check if website is accessed from outside, check remote IP address. If it is not from 127.0.0.1 or ::1 (IPv6) then it is outside. Use function func (*IPConn) RemoteAddr.
To disable some functions check the above condition.
To hide the whole site, bind your service to the localhost interface (127.0.0.1) only.


Binding

net.Listen(""tcp"", ""localhost:8080"")


or

net.Listen(""tcp6"", ""ip6-localhost:8080"")


Using http package

http.ListenAndServe(""localhost:8080"", nil)

",18298223
181,18343326,"sort.Ints is a convenient function to sort a couple of ints. Generally you need to implement the sort.Interface interface if you want to sort something and sort.Reverse just returns a different implementation of that interface that redefines the Less method.

Luckily the sort package contains a predefined type called IntSlice that implements sort.Interface:

keys := []int{3, 2, 8, 1}
sort.Sort(sort.Reverse(sort.IntSlice(keys)))
fmt.Println(keys)

",18343208
182,18343362,"package main

import (
        ""fmt""
        ""sort""
)

func main() {
        example := []int{1, 25, 3, 5, 4}
        sort.Sort(sort.Reverse(sort.IntSlice(example)))
        fmt.Println(example)
}


Playground



Output:

[25 5 4 3 1]

",18343208
183,18399983,"It's a loose way to say that channels have an explicit size, and sends block if they're full. By itself ""bounded"" is not a well-defined term in software development, though.
",18398200
184,18426453,"A member of the Golang sub-reddit pointed out that I was not actually allocating any memory to the buffers passed in to RegEnumValue.  As such, I've corrected the above example to the following:

var name_length uint32 = 72
var key_type uint32
var lpDataLength uint32 = 72
var zero_uint uint32 = 0
name := make([]uint16, 72)
lpData := make([]byte, 72)

win.RegEnumValue(root, zero_uint, &name[0], &name_length, nil, &key_type, &lpData[0], &lpDataLength)


Obviously, the ""magic number"" of 72 should probably be replaced with something else.  There is another method called RegQueryInfoKey that can retrieve information about the registry key to allocate the correct number of bytes for the largest name and value in the key.
",18425465
185,18923274,"No it is not safe, yes you will need locking of some form.
Each connection is handled in its own goroutine. See the Serve() implementation for details.

A general pattern is to use a goroutine which checks for a channel and accepts changes
via a channel:

var counterInput = make(chan int)

func handler(w http.ResponseWriter, r *http.Request) {
    counterInput <- 1
}

func counter(c <- chan int) {
    cur := 0
    for v := range c {
        cur += v
    }
}

func main() {
    go counter(counterInput)
    // setup http
}


Related: Is ""net/http""'s use of global variables considered a good practice in golang?.
",18923123
186,18923725,"Unless I'm overlooking something, in this case, instead of using a lock (or a channel), you could use the tools found in the sync/atomic package (though you'll need to make your type either int32 or int64)

The documentation itself recommends you otherwise, though.


  These functions require great care to be used correctly. Except for special, low-level applications, synchronization is better done with channels or the facilities of the sync package. Share memory by communicating; don't communicate by sharing memory.

",18923123
187,18927729,"After you've retrieved the reflect.Value of the field by using Field(i) you can get a
interface value from it by calling Interface(). Said interface value then represents the 
value of the field.

There is no function to convert the value of the field to a concrete type as there are,
as you may know, no generics in go. Thus, there is no function with the signature GetValue() T
with T being the type of that field (which changes of course, depending on the field).

The closest you can achieve in go is GetValue() interface{} and this is exactly what reflect.Value.Interface()
offers.

The following code illustrates how to get the values of each exported field in a struct
using reflection (play):

import (
    ""fmt""
    ""reflect""
)

func main() {
    x := struct{Foo string; Bar int }{""foo"", 2}

    v := reflect.ValueOf(x)

    values := make([]interface{}, v.NumField())

    for i := 0; i < v.NumField(); i++ {
        values[i] = v.Field(i).Interface()
    }

    fmt.Println(values)
}

",18926303
188,18931215,"Using a bufio.Scanner makes things nice. I've also used an io.Reader rather than taking a filename. Often that's a good technique, since it allows the code to be used on any file-like object and not just a file on disk. Here it's ""reading"" from a string.

package main

import (
    ""bufio""
    ""fmt""
    ""io""
    ""strconv""
    ""strings""
)

// ReadInts reads whitespace-separated ints from r. If there's an error, it
// returns the ints successfully read so far as well as the error value.
func ReadInts(r io.Reader) ([]int, error) {
    scanner := bufio.NewScanner(r)
    scanner.Split(bufio.ScanWords)
    var result []int
    for scanner.Scan() {
        x, err := strconv.Atoi(scanner.Text())
        if err != nil {
            return result, err
        }
        result = append(result, x)
    }
    return result, scanner.Err()
}

func main() {
    tf := ""1\n2\n3\n4\n5\n6""
    ints, err := ReadInts(strings.NewReader(tf))
    fmt.Println(ints, err)
}

",9862443
189,18973915,"Since this is a C library wrapper, you might also need the equivalent of:

glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);

on OS X. But, more importantly, you should call glfwInit (or it's equivalent glfw.Init) prior to calling any other GLFW3 function. AFAIK, only glfwSetErrorCallback can be used prior to this call.
",18969572
190,19088749,"
  but I suspect there should be some idiom or best practice for simulating this.


No there isn't.

If something like that does come up (and it doesn't very often in real code, but mostly in translations of Java/Ruby/whatever code): interface Named { Name() string } and interface Sounder { Sound() } combined to interface Animal {Named, Sounder} and pass those animals around.

Again: The ""prefered way"" is to remodel the solution without inheritance.
",19087603
191,19090667,"I think the confusion may be coming from constructing the instances using composite literals.

These are perfect for creating complex types in single lines, and manage, as the previous link suggests, to cut down on boiler-plate code.

Sometimes however, the code may be simpler and more readable by doing things more explicitly. I find this is sometimes the case when taking advantage of Embedding.

To quote the previous link:


  
    The methods of embedded types come along for free
  


You aren't delegating to the sub-class's sound method, but the setting and getting of the ""sub-class"" sound transparently uses the sound field of Animal

So my preferred way of doing this would be something like:

package main

import ""fmt""

type Animal struct {
    name  string
    sound string
}

type Cow struct {
    Animal
}

type Dog struct {
    Animal
}

func (a *Animal) Speak() string {
    return fmt.Sprintf(""%s"", a.sound)
}

func main() {
    c := new(Cow)
    d := new(Dog)
    c.name, c.sound = ""Bessie"", ""mooo""
    d.name, d.sound = ""Sparky"", ""woof""
    fmt.Println(c.Speak())
    fmt.Println(d.Speak())
}


Produces:


  
    mooo
    woof
  


Playgound link

EDIT: There's a quote from Rob Pike regarding this subject:


  
    Go takes an unusual approach to object-oriented programming, allowing methods on any type, not just classes, but without any form of type-based inheritance like subclassing. This means there is no type hierarchy. This was an intentional design choice. Although type hierarchies have been used to build much successful software, it is our opinion that the model has been overused and that it is worth taking a step back.
  

",19087603
192,19092690,"What about this?

package main

import (
    ""fmt""
)

type Sounder interface {
    Sound() string
}

type Animal struct {
    Name    string
    Sounder Sounder
}

func (a *Animal) Speak() {
    fmt.Printf(""%s says %s.\n"", a.Name, a.Sounder.Sound())
}

type StringSounder string

func (f StringSounder) Sound() string {
    return string(f)
}


func main() {
    d := &Animal{""Sparky"", StringSounder(""woof"")}
    c := &Animal{""Bessie"", StringSounder(""mooo"")}

    d.Speak()
    c.Speak()
}

",19087603
193,19100993,"You can't attach non-interface methods to an interface. If an animal is to speak they need both a name and a sound. Also you can embed private types and what you've embedded is an implementation detail. Given these insights I think this is what you're after.

package farm

type Animal interface {
    Name() string
    Sound() string
}

func Speak(a Animal) string {
    return a.Name() + "" says "" + a.Sound()
}

type animal struct {
    name string
}

func (a *animal) Name() string {
    return a.name
}

type Cow struct {
    animal
}

func NewCow(name string) *Cow {
    return &Cow{animal{name}}
}

func (c *Cow) Sound() string {
    return ""mooo""
}

type Dog struct {
    animal
}

func NewDog(name string) *Dog {
    return &Dog{animal{name}}
}

func (c *Dog) Sound() string {
    return ""woof""
}


with a main like this:


package main

import ""fmt""
import ""farm""

func main() {
    c := farm.NewCow(""Betsy"")
    d := farm.NewDog(""Sparky"")
    //""In classic OOO you'd write c.Speak()""
    fmt.Println(farm.Speak(c))
    fmt.Println(farm.Speak(d))
}


Play link w/ main: http://play.golang.org/p/YXX6opX8Cy
",19087603
194,19122746,"By looking at the .Weekday() of the time, you can compute the first Monday.

package main

import (
    ""fmt""
    ""time""
)

// FirstMonday returns the day of the first Monday in the given month.
func FirstMonday(year int, month time.Month) int {
    t := time.Date(year, month, 1, 0, 0, 0, 0, time.UTC)
    return (8-int(t.Weekday()))%7 + 1
}

func main() {
    for m := 1; m <= 12; m++ {
        fmt.Println(m, FirstMonday(2013, time.Month(m)))
    }
}

",19122477
195,19244880,"I think this is because you're using Start instead of Run.


  
    Start starts the specified command but does not wait for it to complete.
  


whereas:


  
    Run starts the specified command and waits for it to complete.
  


Therefore Start will just handover the process to the operating system when the Go (parent) process exits.
",19243431
196,19245284,"What's happening is that if you send a process SIGINT (as e.g. os.Interrupt does), all proceses in the same process group will also get that signal (which includes child processes) - SIGINT will by default terminate a process. 

If however a parent process exits normally, not because of SIGINT or similar, a process in the same process group does not get any signal - it will continue to run, but be adopted by the init process. This is not specific to Go. 
",19243431
197,19414475,"Working backwords, you end up here

http://golang.org/pkg/encoding/csv/#Reader.Read

reader is of type csv.Reader, which has Read defined on it.
",19414427
198,19440853,"It is not clear what you want , but perhaps http://play.golang.org/p/YfGDtIuuBw will help. It uses EnumWindows to find window with a particular title.

Alex
",19436860
199,19445765,"Works like a charm :

root@Ubuntu-1304-raring-64-minimal:/etc# uname -a
Linux Ubuntu-1304-raring-64-minimal 3.8.13.4 #2 SMP Mon Jul 8 23:59:05 CEST 2013 x86_64 x86_64 x86_64 GNU/Linux


do this sequence :

cd /usr/local
mkdir /var/go
apt-get install mercurial
hg clone https://code.google.com/p/go/


After that create a /etc/profile.d/go.sh with the follewing contents and make it executable:

export GOPATH=/var/go
export GOROOT=/usr/local/go
export GOBIN=$GOPATH/bin
export PATH=$PATH:$GOBIN
export GOROOT_FINAL=/var/go
export GOHOSTARCH=amd64
export GOARCH=amd64
export CGO_ENABLED=1


And then restart your shell. NO source xxx will be working properly - be warned! In a new shell do this :

cd /usr/local/go/src
./make.bash


do the thing, and then copy all the things from /usr/local/go to /var/go - or there's a way to merge both directories by symlink, whatever you prefer. After that comment GOROOT_FINAL in go.sh script above AND restart your shell again. And you're ok with latest working Go language!

root@Ubuntu-1304-raring-64-minimal:/usr/work/golang/go/src# go version
go version devel +35d5bae6aac8 Fri Oct 18 10:45:19 2013 +0400 linux/amd64


Note bene : Two shell restarts are required - found it myself in a hard way.
",6163096
200,19579529,"Sadly, that example isn't going to work for you unless you get a date.exe from somewhere (Cygwin?) and put in on your %PATH%.

What's going on, I believe, is that date is a builtin in Powershell. It works for you because your shell is interpreting it.

You may be able to do

out, err := exec.Command(""cmd"", ""/C"", ""date"").Output()


as suggested here; I don't know, I don't have a Windows machine handy.



Sidenote:


  Get-Command date says ""The term 'date' is not recognized as the name of a cmdlet""


There are exactly two Google results for that phrase. One of them leads me to this, which helped me figure this out.
",19579238
201,19579557,"On windows since date is not a executable, I changed your code to run as follows:

out, err := exec.Command(""cmd.exe"", "" /c date /t"").Output()
if err != nil {
    log.Fatal(err)
}
fmt.Printf(""The date is %s\n"", out)


The output:

The date is Fri 25/10/2013

",19579238
202,19580785,"You need to use the go/doc package to extract documentation from the ast:

package main

import (
    ""fmt""
    ""go/doc""
    ""go/parser""
    ""go/token""
)

// FirstType docs
type FirstType struct {
    // FirstMember docs
    FirstMember string
}

// SecondType docs
type SecondType struct {
    // SecondMember docs
    SecondMember string
}

// Main docs
func main() {
    fset := token.NewFileSet() // positions are relative to fset

    d, err := parser.ParseDir(fset, ""./"", nil, parser.ParseComments)
    if err != nil {
        fmt.Println(err)
        return
    }

    for k, f := range d {
        fmt.Println(""package"", k)
        p := doc.New(f, ""./"", 0)

        for _, t := range p.Types {
            fmt.Println(""  type"", t.Name)
            fmt.Println(""    docs:"", t.Doc)
        }
    }
}

",19580688
203,19847766,"Have you looked at the runtime package? It has a GOOS const: http://golang.org/pkg/runtime/#pkg-constants
",19847594
204,19847868,"Detection at compile time

If you're doing this to have different implementations depending on the OS, it is more useful to 
have separate files with the implementation of that feature and add build tags to each
of the files. This is used in many places in the standard library, for example in the os package.

These so called 'Build constraints' or 'Build tags' are explained here.

Say you have the constant PATH_SEPARATOR and you want that platform dependant, you 
would make two files, one for windows and one for the (unix) rest:

/project/path_windows.go
/project/path_unix.go


The code of these files would then be:

path_windows.go

package project

const PATH_SEPARATOR = '\\'


path_unix.go

package project

const PATH_SEPARATOR = '/'


You can now access PATH_SEPARATOR in your code and have it platform dependant.

Detection at runtime

If you want to determine the operating system at runtime, use the runtime.GOOS
variable:

if runtime.GOOS == ""windows"" {
    fmt.Println(""Hello from Windows"")
}


While this is compiled into the runtime and therefore ignores the environment, 
you can nevertheless be relatively certain that the value is correct. 
The reason for this is that every platform that is worth distinguishing needs 
rebuilding due to different executable formats and thus has a new GOOS value.
",19847594
205,19860606,"This error message implies a roundtrip to the database took longer than the timeout period you defined. Just increasing that timeout should get rid of the problem, assuming you don't have any real issues that are causing the application to behave in a sluggish manner.

In general, this error doesn't imply you have any kind of scale issues, other than the fact maybe you have an increasing amount of data in some collections and certain queries may be getting too slow and need re-thinking (indexes, etc).

There's also no need to restart the application. You can either Refresh the problematic session, or Close and re-create the session in case you're using copies of a master session. The state of mgo and the pool of connections is still fine. It's just warning you that this specific session observed an issue on the wire, and so you have to acknowledge it before the session will be valid again.

As usual, also make sure to be using the latest release to avoid problems that have already been fixed, if any.
",19858664
206,19886142,"In the tutorial, you created the file TestPage previously.  Which is the page you should be navigating to when you first build the server.  In the tutorial, they have you navigate to view/test instead of view/TestPage as you should which is what creates the confusion.
",11609583
207,19908214,"None that I am aware of. You can define your own though:

import ""math""

func arange(start, stop, step float64) []float64 {
    N := int(math.Ceil((stop - start) / step));
    rnge := make([]float64, N, N)
    i := 0
    for x := start; x < stop; x += step {
        rnge[i] = x;
        i += 1
    }
    return rnge
}


which returns:

arange(0., 10., 0.5)
[0 0.5 1 1.5 2 2.5 3 3.5 4 4.5 5 5.5 6 6.5 7 7.5 8 8.5 9 9.5]


Corresponding to the Python:

>>> np.arange(0., 10., 0.5)
array([ 0. ,  0.5,  1. ,  1.5,  2. ,  2.5,  3. ,  3.5,  4. ,  4.5,  5. ,
    5.5,  6. ,  6.5,  7. ,  7.5,  8. ,  8.5,  9. ,  9.5])


Note that because of the way I defined the iteration, you cannot use negative steps in my simple Go version, but you can define something a bit more robust if you need to.
",19906544
208,19923071,"Based on val's solution, I would suggest to avoid using ""x+=step"" because depending on the limits and the step, rounding errors will accumulate and you may leave the last value undefined or even worse, try to define the N+1 value, causing a panic.

This could be solved with:

func arange2(start, stop, step float64) []float64 {
    N := int(math.Ceil((stop - start) / step))
    rnge := make([]float64, N)
    for x := range rnge {
        rnge[x] = start + step*float64(x)
    }
    return rnge
}

http://play.golang.org/p/U67abBaBbv
",19906544
209,19958942,"For example:

func serveHTTP() { http.ListenAndServe(...) }
func serveCustom() { net.Listen(""tcp"", ...) }

go serveHTTP()
go serveCustom()

",19958767
210,20024383,"Why wouldn't calling the function work? The data for mux.Vars() is stored in a global context that maps requests into the relevant data. As long as you pass the same request pointer into the handler, it will be able to access mux.Vars().
",20023944
211,20107241,"Originally I thought that fmt.Fprintf may be changing the request data on the way out, but this  example seems to work OK.

However, I would still recommend using the lower-level Write/Read instead of fmt.Fprintf/ioutil.ReadAll:

req := []byte { 0x01, 0x03, 0x00, 0x01, 0x00, 0x01, 0xd5, 0xca }

n, err := conn.Write(req)

if err != nil {
    fmt.Println(""write error:"", err)
    return
}

fmt.Printf(""wrote %d bytes for request: %#v"", n, req)

rsp := make([]byte, 64)

n, err = conn.Read(rsp)

fmt.Printf(""received %d bytes in response: %#v"", n, rsp[:n])

if err != nil {
    fmt.Println(""read error:"", err)
}

",20086504
212,20154730,"type Response2 struct {
    method string
    bc string
    gc []string
}


The name of the fields Must be Uppercase otherwise the Json module can't access them (they are private to your module).
You can use the json tag to specify a match between Field and name

type Response2 struct {
    Method string `json:""method""`
    Bc string `json:""bc""`
    Gc []string `json:""gc""`
}

",20154606
213,20165159,"The very short answer to your (long) question is: No.

I don't think that your solution of ConvertToStatment and Replay taking an empty interface is a ""nice"" solution: I'd prefer func Replay([]Statement) and callers must provide a slice of Statments. This is much clearer and callers can either convert their stuff to []Statement or directly construct a []Statement.
",20163660
214,20168565,"The in-memory layout of a []Quote slice is different to a []Statement slice, so this is not possible.

The backing array of the []Quote slice will consist of the sequential Quote structs, while the []Statement slice's backing array consists of interface variables.  As well as holding the Quote struct (or whatever other type implements the interface), the interface variable also stores a pointer to type information for the contained value.  This is needed to determine how to dispatch the Say method call.

The different data layout means that you can't interchange the two slice types, not even through unsafe casts: if you have one type and need the other you'll need to manually convert between them.
",20163660
215,20202666,"One solution is to make use of the html/template functionality, create all your pages to include the same  section like below.  I would however leave room to add tags to your head by leaving the  in each of your pages.

{{define ""page_template""}}

    My page template
    {{template ""template_css""}}
    
    

... etc ...


And the template_css:

{{define ""template_css""}}

{{end}}


A snippet of code for the template parsing

tp, err := template.ParseFiles(""page_template.html"", ""template_css.tp"")
err = tp.ExecuteTemplate(buf, ""page_template"", templateParameters)

",20197563
216,20221694,"I think it's easy to implement this simple asset pipeline feature, you can use path.filepath to walk through your css directory, read all the css files, generate a temp css file by join all lines together, then serve the client with the generated file

import (
""path/filepath""
""os""
""io/ioutil""
)

func Generate(path string) *os.File{
f,err := ioutil.TempFile("""",""all"")
if err!=nil{
    return nil
}

filepath.Walk(path,func(p string,info os.FileInfo,err error)error{
    if err!=nil{
        return err
    }
    if !info.IsDir(){
        data,err := ioutil.ReadFile(info.Name())
        if err!=nil{
            return err
        }
        f.Write(data)
    }
    return err
})
return f
}

",20197563
217,20396438,"the reason is that you can not obtain overlapping results. With regex engines that support lookahead you can use the trick: (?=([0-9]+[dh]){2}) but go language does not support it.

If you want to obtain all results, I suggest you to use FindAllStringIndex() with ([0-9]+[dh]) and then determine all contiguous substrings with the offset.
",20395562
218,20403220,"For example,

package main

import (
    ""fmt""
    ""unicode/utf8""
)

func main() {
    s := ""a\xc5z""
    fmt.Printf(""%q\n"", s)
    if !utf8.ValidString(s) {
        v := make([]rune, 0, len(s))
        for i, r := range s {
            if r == utf8.RuneError {
                _, size := utf8.DecodeRuneInString(s[i:])
                if size == 1 {
                    continue
                }
            }
            v = append(v, r)
        }
        s = string(v)
    }
    fmt.Printf(""%q\n"", s)
}


Output:

""a\xc5z""
""az""



  Unicode Standard
  
  FAQ - UTF-8, UTF-16, UTF-32 & BOM
  
  Q: Are there any byte sequences that are not generated by a UTF? How
  should I interpret them?
  
  A: None of the UTFs can generate every arbitrary byte sequence. For
  example, in UTF-8 every byte of the form 110xxxxx2 must be followed
  with a byte of the form 10xxxxxx2. A sequence such as <110xxxxx2
  0xxxxxxx2> is illegal, and must never be generated. When faced with
  this illegal byte sequence while transforming or interpreting, a UTF-8
  conformant process must treat the first byte 110xxxxx2 as an illegal
  termination error: for example, either signaling an error, filtering
  the byte out, or representing the byte with a marker such as FFFD
  (REPLACEMENT CHARACTER). In the latter two cases, it will continue
  processing at the second byte 0xxxxxxx2.
  
  A conformant process must not interpret illegal or ill-formed byte
  sequences as characters, however, it may take error recovery actions.
  No conformant process  may use irregular byte sequences to encode
  out-of-band information.

",20401873
219,20455991,"You can, as siritinga suggested, use a third signalling or counter channel, eg signal chan boolean, where the produceWork goroutine would add a value before each job entered into the jobs channel. So, an equal count of values will be passed to signal as to jobs:

func produceWork(vf string, jobs chan *utils.DigSigEntries, signal chan boolean) {
    defer close(jobs)

    // load file with jobs
    file, err := ini.LoadFile(vf)

    // get data for processing
    for data, _ := range file {
        // ...
        signal <- true
        jobs <- &myStruct{data1, data2, data3, false}
    }

    close(signal)
}


The consume would then start by reading from the  signal channel. If there is a value, it can be certain there will be a value to read from the out channel (once a worker has passed it on). If the signal is closed, then all is done. We can close the remaining done channel: 

func consumeWork(done chan *myStruct, signal chan boolean) {
    for _ := range signal {
        val <- done
        if !val.status {
            fmt.Println(val)
        }
    }

    close(done)
} 


While this is possible, I would not really recommend it. It doesn't make the code more clear than when using a sync.WaitGroup. After all, the signal channel would basically only work as a counter. A WaitGroup would have the same purpose and would do it cheaper.

But your question was not about how to solve the problem, but rather if it was possible to do it with pure channels.
",20455116
220,20456325,"Sorry, i didn't notice that you wanted to skip /sync :/
I'll leave the answer, maybe someone is looking for this. 

import (
    ""sync""
)


func main() {
    jobs := make(chan *myStruct, workers)
    done := make(chan *myStruct, workers)

    var workerWg sync.WaitGroup   // waitGroup for workers
    var consumeWg sync.WaitGroup  // waitGroup for consumer
    consumeWg.Add(1) // add one active Consumer

    for i := 0; i < runtime.NumCPU(); i++ {
        go Worker(&workerWg, jobs, done)
        workerWg.Add(1)
    }
    go consumeWork(&consumeWg, done)

    produceWork(file_with_jobs, jobs)

    close(jobs)
    workerWg.Wait()

    close(done)
    consumeWg.Wait()

}

func produceWork(vf string, jobs chan *utils.DigSigEntries) {

    // load file with jobs
    file, err := ini.LoadFile(vf)

    // get data for processing
    for data, _ := range file {
        // ...
        jobs <- &myStruct{data1, data2, data3, false}
    }
}


func Worker(wg *sync.WaitGroup, done chan *myStruct) {

    defer wg.Done()
    for job := range jobs {

        result := process(job)
        out <- result
    }

   // close(out)   --> tried closing the out channel, but then not all items are processed
   //                  though no panics occur.
}

func process(item *myStruct) {
    //...modify the item
    item.status = true
}

func consumeWork(wg *sync.WaitGroup, done chan *myStruct) {
    defer wg.Done()
    for val := range done {
        if !val.status {
            fmt.Println(val)
        }
    }
}

",20455116
221,20571405,"well you should cast your division result as float
",20571280
222,20571416,"You have to convert the types to floats first.

In general, if you have some non-float numeric types (such as ints) a and b, in order to get a float division you use float32(a)/ float32(b) (or float64 as the case may be). This applies to any other numeric type too, if you want to treat floats as integers or integers as complex numbers convert the operands. In this case, if a is 3 and b is 2, float32(a)/float32(b) will be 1.5.

If you want integer division to be done, but the result to be a float, then covert the result as in float32(a/b). In this case, if a is 3 and b is 2, then float32(a/b) will get you 1.0.
",20571280
223,20571539,"There are no implicit type casts for variables in Go, so you must convert to float:

fmt.Printf(""%f"", float32(a)/float32(b))


or

fmt.Printf(""%f"", float32(a/b))


Depending upon what you want.  Also check out float64 -- if that floats your boat.
",20571280
224,20572190,"They contain the same value, but do not seem to refer to the same thing:


type.go source
value.go source


A Type is usually implemented by unexported struct rtype (via TypeOf), while the Value contains a *rtype and extends flag, which is itself a reduced form of the Kind:

// flag holds metadata about the value.
// The lowest bits are flag bits:
//  - flagRO: obtained via unexported field, so read-only
//  - flagIndir: val holds a pointer to the data
//  - flagAddr: v.CanAddr is true (implies flagIndir)
//  - flagMethod: v is a method value.
// The next five bits give the Kind of the value.
// This repeats typ.Kind() except for method values.
// The remaining 23+ bits give a method number for method values.
// If flag.kind() != Func, code can assume that flagMethod is unset.
// If typ.size > ptrSize, code can assume that flagIndir is set.


When getting the ValueOf something:

// ValueOf returns a new Value initialized to the concrete value
// stored in the interface i.  ValueOf(nil) returns the zero Value.
func ValueOf(i interface{}) Value {
    [...]
    // For an interface value with the noAddr bit set,
    // the representation is identical to an empty interface.
    eface := *(*emptyInterface)(unsafe.Pointer(&i))
    typ := eface.typ


    /** Flag is built from the type, then kept separate (my comment) */

    fl := flag(typ.Kind()) << flagKindShift
    if typ.size > ptrSize {
        fl |= flagIndir
    }
    return Value{typ, unsafe.Pointer(eface.word), fl}
}


And so when you get the kind of a Value (remember it extends its flag):

func (v Value) Kind() Kind {
    return v.kind()
}

func (f flag) kind() Kind {
    return Kind((f >> flagKindShift) & flagKindMask)
}


While getting the kind of a type: (Type is an interface, usually implemented by *rtype)

func (t *rtype) Kind() Kind { return Kind(t.kind & kindMask) }


So although they seem to be equal in most of the cases, v.Kind() is not v.Type().Kind()
",20571822
225,20580808,"The file reflect/value.go states that the relevant field in the implementation of reflect.Value ""repeats typ.Kind() except for method values"". So, unless the value is a method, value.Kind() and value.Type().Kind() return the same number.
",20571822
226,20580856,"it's been an update and I thought to add what is the current state of affair.

The good news is the go tools now no longer strip debug symbols so if you are running on your local machine you can now get gdb support!

It's a bit of a process and ripe for some more automation (suggestions welcome)

in short:


look for the _app_go process
cd to the directory that it's running from 
Attach to the process with the '-pid' command to gdb
Tell gdb the directory of source


Boom -- debugging.
",18169071
227,20629533,"[Update: as of Go 1.8, GOPATH defaults to $HOME/go, but you may still find this useful if you want to understand the GOPATH layout, customize it, etc.]

The official Go site discusses GOPATH and how to lay out a workspace directory.

export GOPATH=""$HOME/your-workspace-dir/"" -- run it in your shell, then add it to ~/.bashrc or equivalent so it will be set for you in the future. Go will install packages under src/, bin/, and pkg/, subdirectories there. You'll want to put your own packages somewhere under $GOPATH/src, like $GOPATH/src/github.com/myusername/ if you want to publish to GitHub. You'll also probably want export PATH=$PATH:$GOPATH/bin in your .bashrc so you can run compiled programs under $GOPATH. 

Optionally, via Rob Pike, you can also set CDPATH so it's faster to cd to package dirs in bash: export CDPATH=.:$GOPATH/src/github.com:$GOPATH/src/golang.org/x means you can just type cd net/html instead of cd $GOPATH/src/golang.org/x/net/html. 

Keith Rarick notes you can set GOPATH=$HOME to put Go's src/, pkg/ and bin/ directories right under your homedir. That can be nice (for instance, you might already have $HOME/bin in your path) but of course some folks use multiple workspaces, etc.
",20628918
228,20629537,"Just do export GOPATH=""/whatever/you/like/your/GOPATH/to/be"".
",20628918
229,20656980,"Watch a Video

In general, I always recommend this official video from Go to get a quick overview on the matter:

http://www.youtube.com/watch?v=XCsL89YtqCs

It's easier to be shown than to be told.

@jwfearn paraphrased the important part of the video:


  export GOPATH=""${HOME}/gocode""; export PATH=""${PATH}:${GOPATH}/bin""; mkdir -p ""${GOPATH}""

",20628918
230,20714739,"Most reflect Value objects can be converted back to a interface{} value using the .Interface() method.

After obtaining this value, you can assert it back to the map you want. Example (play):

m := map[string]int{""foo"": 1, ""bar"": 3}
v := reflect.ValueOf(m)
i := v.Interface()
a := i.(map[string]int)

println(a[""foo""]) // 1


In the example above, m is your original map and v is the reflected value. The interface value i, acquired by the Interface method is asserted to be of type map[string]int and this value is used as such in the last line.
",20714004
231,20714742,"To turn the value in a reflect.Value into an interface{}, you use iface := v.Interface(). Then, to access that, you use a type assertion or type switch.

If you know you're getting a map[string]string the assertion is simply m := iface.(map[string]string). If there's a handful of possibilities, the type switch to handle them all looks like:

switch item := iface.(type) {
case map[string]string:
    fmt.Println(""it's a map, and key \""key\"" is"", item[""key""])
case string:
    fmt.Println(""it's a string:"", item)
default:
    // optional--code that runs if it's none of the above types
    // could use reflect to access the object if that makes sense
    // or could do an error return or panic if appropriate
    fmt.Println(""unknown type"")
}


Of course, that only works if you can write out all the concrete types you're interested out in the code. If you don't know the possible types at compile time, you have to use methods like v.MapKeys() and v.MapIndex(key) to work more with the reflect.Value, and, in my experience, that involves a long time looking at the reflect docs and is often verbose and pretty tricky.
",20714004
232,20743558,"ReadString takes the delimiter byte. In your case, that's a newline, not a dot. Simply replace the line

input, err := reader.ReadString('.')


with

input, err := reader.ReadString('\n')


and it will work.
",20743400
233,20909764,"$ python --version
Python 2.7.2
$ python --version 1>/dev/null # hide stdout
Python 2.7.2
$ python --version 2>/dev/null # hide stderr


We can conclude that the output goes to stderr. Now I took a look at Go's docs, and guess what, cmd.Output only captures stdout (docs). You should use cmd.CombinedOutput (docs) :


  CombinedOutput runs the command and returns its combined standard output and standard error.

",20909598
234,20930522,"I think you're going to end up needing to manually handle different types in this case. AFAIK, type assertions must be real types at compile time. Here's my best try in play: http://play.golang.org/p/J8RdHF2MVV
",20930447
235,20993391,"You code is racy: You write to the same memory location from different, unsynchronized goroutines without any locking. The result is basically undefined. You must either a) make sure that all the goroutine writes after each other in a nice, ordered way, or b) protect each write by e.g. e mutex or c) use atomic operations.

If you write such code: Always try it under the race detector like $ go run -race main.go and fix all races. 
",20993139
236,20994420,"First of all: prior to Go 1.5 it runs on a single processor, only using multiple threads for blocking system calls. Unless you tell the runtime to use more processors by using GOMAXPROCS.

As of Go 1.5 GOMAXPROCS is set to the number of CPUS. See 6, 7 .

Also, the operation *cptr = *cptr + 1 is not guaranteed to be atomic. If you look carefully, it can be split up into 3 operations: fetch old value by dereferencing pointer, increment value, save value into pointer address.

The fact that you're getting 508/510 is due to some magic in the runtime and not defined to stay that way. More information on the behaviour of operations with concurrency can be found in the Go memory model.
You're probably getting the correct values for 

Generally, what you're trying to do is neither recommendable in any language, nor the ""Go"" way to do concurrency. A very good example of using channels to synchronize is this code walk: Share Memory By Communicating (rather than communicating by sharing memory)

Here is a little example to show you what I mean: use a channel with a buffer of 1 to store the current number, fetch it from the channel when you need it, change it at will, then put it back for others to use.
",20993139
237,21004078,"A nice alternative to using channels in this case might be the sync/atomic package, which contains specifically functions for atomically incrementing/decrementing numbers.
",20993139
238,21008698,"Because your worker only process one task and then exit. Thus, only first CONCURRENCY items proceed and then workQueue[i/WORK_PER_WORKER]  blocks indifinitely. Thus, completed chan never receive enough values and main also blocks forever.

Your worker should do work in loops, like this:

for i := 0; i < CONCURRENCY; i++ {
    go func(i int) {
        for anItem := range workQueue[i] {
            work()
            anItem.Done <- 1
        }
    }(i)
}

",21007259
239,21008704,"Your code go func(i int) { anItem :=  removes juste 1 item from workQueue[i] but you are trying to stuff WORK_PER_WORKER items into it. You will work on CONCURRENCY many items and after that all reading goroutines have terminated and you have your deadlock.

Looping in the worker goroutines ""solves"" your deadlock: http://play.golang.org/p/j2pavqnBDv
Just ""solves"" because these worker goroutines will never terminate. Maybe you can experiment with closeing your channels to notify the worker goroutines when nothing will be sent.
",21007259
240,21077980,"The go-runtime doesn't immediately release unused memory to the OS (it might be needed again soon).
So looking at the OS-level, you see only a part of the overall picture.
Using http://golang.org/pkg/runtime/#ReadMemStats you can see another part of the picture.

pkg/runtime/malloc.goc shows the freelist, and pkg/runtime/mgc0.c shows the garbage collector.

If memory-usage goes down in a stable situation that seems normal, after loading finishes, you can force a GC, and you might want to print the Memstats regularly for more info.
",21064426
241,21203662,"To do that you should study the part 14.16 — Content-Range — of the RFC document describing the HTTP/1.1 protocol and then apply that knowledge to manipulate the set of HTTP headers sent when the client request is executed — see the documentation and examples there.

To calculate the range to request, to continue downloading, you should get the current file's size. This can be found in the results returned by the Stat() function which can be called on an opened file — *os.File returned by a call to os.Open().

You should open your file in append mode and then use something like io.Copy() to stream the data from the Body HTTP response member to the file object.

Do your own research on how to read data from HTTP responses in Go — they are abundant on the Internet.
",21201808
242,21268855,"
  Is there a way to unmarshal the nested bar property and assign it directly to a struct property without creating a nested struct?


No, encoding/json cannot do the trick with "">some>deep>childnode"" like encoding/xml can do.
Nested structs is the way to go.
",21268000
243,21269578,"Like what Volker mentioned, nested structs is the way to go. But if you really do not want nested structs, you can override the UnmarshalJSON func. 

http://play.golang.org/p/T0aZEDL0Nu

type A struct {
    FooBar string // takes foo.bar
    FooBaz string // takes foo.baz
    More   string `json:""more""`
}

func (a *A) UnmarshalJSON(b []byte) error {
    var f interface{}
    json.Unmarshal(b, &f)

    m := f.(map[string]interface{})

    foomap := m[""foo""]
    v := foomap.(map[string]interface{})

    a.FooBar = v[""bar""].(string)
    a.FooBaz = v[""baz""].(string)

    return nil
}


Please ignore the fact that I'm not returning a proper error.  I left that out for simplicity.  
",21268000
244,21352256,"Environmental configs are best kept in environment variables, in my experience.  You can rely on global variables like so:

var envSetting = os.Getenv(""TEST_ENV"")


Alternatively, if using flags is a requirement, you could place your initialization code inside a function called init().

func init() {
    flags.Parse()
    myEnv = *envFlag
    // ...
}

",21350962
245,21461032,"Admittedly, it's somewhat of a quirk, but there's an explanation for it.

Imagine an interface{} variable as a struct composed of two fields: one is the type and another is the data. ([]int and nil). Actually, it looks just like that in the Go runtime.

struct Iface                                                                                                                   
{                                                                                                                              
    Itab*   tab;                                                                                                               
    void*   data;                                                                                                              
};   


When you pass your nil slice to yes, only nil is passed as the value, so your comparison boils down to nil == nil. 

Meanwhile, calling no automatically wraps your variable in an interface{} type and the call becomes something akin to no(interface{[]int, nil}). So the comparison in no could be seen as interface{[]int, nil} == nil, which turns out to be false in go.

The issue is actually explained in the Go FAQ.
",21460787
246,21488512,"I found a couple packages to help visualize data in Go.

My personal favourite - https://github.com/davecgh/go-spew

There's also - https://github.com/tonnerre/golang-pretty
",12540057
247,21528010,"If you declare the PrintColour method on the Animal type, it will be ""inherited"" when you include Animal in Dog.

This is known as ""Embedding"" in the Go world. See The ""Embedding"" section of Effective Go for more info.

Try something like:

package main

import ""log""

type Animal struct {
    Colour string
    Name string
}

type Dog struct {
    Animal
}

func (a *Animal) PrintColour() {
    log.Printf(""%s\n"", a.Colour)
}


func main () {
    a := new (Animal)
    a.Colour = ""Void""
    d := new (Dog)
    d.Colour = ""Black""

    a.PrintColour()
    d.PrintColour()
}


Produces:


  2009/11/10 23:00:00 Void
  2009/11/10 23:00:00 Black


Playground
",21527489
248,21530413,"You could try it with interface{}

package main

import (""fmt""
       ""reflect"")

type Animal struct {
    Colour string
    Name string
}

type Dog struct {
    Animal
}

func PrintColour(a interface{}) {
    switch a.(type){
        case *Dog:
            fmt.Printf(""Dog %s\n"", a.(*Dog).Colour)
        case *Animal:
            fmt.Printf(""Aimal %s\n"", a.(*Animal).Colour)
        default:        
            fmt.Printf(""hmm %s\n"", reflect.TypeOf(a))

    }
}


func main () {
    a := new (Animal)
    a.Colour = ""Void""
    d := new (Dog)
    d.Colour = ""Black""

    PrintColour(a)
    PrintColour(d)

}

",21527489
249,21530419,"The embedded (anonymous) field can still be explicitly accessed by using its typename :

package main

import ""log""

type Animal struct {
    Colour string
    Name   string
}

type Dog struct {
    Animal
}

func PrintColour(a *Animal) {
    log.Printf(""%s\n"", a.Colour)
}

func main() {
    a := new(Animal)
    a.Colour = ""Void""
    PrintColour(a)

    d := new(Dog)
    d.Colour = ""Black""
    // you can access the underlying ""Animal"" through ""d.Animal""
    PrintColour(&d.Animal)
}


playground

In the reference : the sentence after the second code block explains how you can declare an ""anonymous"" field, and states :


  The unqualified type name acts as the field name. 

",21527489
250,21532866,"
  I'm trying to learn interfaces and how I can write a single function to work with different types.


then it's probably simpler to avoid the whole reflection package, and just define an interface for your specific purpose.. and types that implement your interface. something like this:

package main

import ""fmt""
import ""math""


// Homegrown types
type IntArray []int
type Float32Array []float32


// Max defined for type IntArray
func (a IntArray) Max() float64 {
    max := math.MinInt32;
    for i := 0; i < len(a); i++ {
        if a[i] > max {
            max = a[i]
        }
    }
    return float64(max)
}


// Max defined for type Float32Array
func (a Float32Array) Max() float64 {
    max := float32(-1 * math.MaxFloat32)
    for i := 0; i < len(a); i++ {
        if a[i] > max {
            max = a[i]
        }
    }
    return float64(max)
}


// Define an interface that works for any type
// containing a Max function returning a float64 
type Maxing interface {
    Max() float64
}


// Define a function that works with your interface type
func maxer(m Maxing) float64 {
    return m.Max();
}


func main(){

    // Declare a new IntArray
    i := IntArray([]int{1,2,3})

    // Declare a new Float32Array
    f := Float32Array([]float32{1.0,2.0,3.0})

    // Use any type implementing the Max interface with the 'maxer' func
    fmt.Printf(""maxer(IntArray)     = %f\n"", maxer(i));
    fmt.Printf(""maxer(Float32Array) = %f\n"", maxer(f));

}

",20930447
251,21540581,"My example might not be great but you can do what you want this way:

http://play.golang.org/p/JoAlOvJthr

Essentially use an interface to define the common functionality you want to expose to the outside world for all your types and embedded types.

(My example may not be the best but it works)
",21527489
252,21551995,"I like the answers here so far and I want to add one that allows you to do static type checking on the interface you pass in using an interface:

package main

import (
    ""fmt""
)

type Animalizer interface {
    GetColour() string
}

type Animal struct {
    Colour string
    Name   string
}

type Dog struct {
    Animal
}

func (a *Animal) GetColour() string {
    return a.Colour
}

func PrintColour(a Animalizer) {
    fmt.Print(a.GetColour())
}

func main() {
    a := new(Animal)
    a.Colour = ""Void""
    d := new(Dog)
    d.Colour = ""Black""

    PrintColour(a)
    PrintColour(d)
}


On the playground

It will be possible to add further fields to Dog. The difference to Uriel's Answer is that calls to PrintColour will fail at compile time if something else than a struct implementing Animalizer is passed in. 

Also you won't have to use a typeswitch since the compiler knows an Animalizer is implementing GetColour.

And, finally, the behaviour (printing) is separated from the struct, GetColour just returns the colour.
",21527489
253,21615321,"Use net.SplitHostPort:

ip, _, _ := net.SplitHostPort(r.RemoteAddr)

",17222021
254,21643545,"bufio.Reader implements the ByteReader interface.

Wrapping conn using bufio.NewReader(conn) should work.
",21642991
255,21644134,"The problem is that the underlying net.TCPConn returned by net.Dial as net.Conn only implements the Read(byte[]) (int, err) method. This means that the returned net.Conn satisfies the io.Reader interface, but it does not satisfy the io.ByteReader interface because net.TCPConn doesn't have a ReadByte() (c byte, err error) method. 

You can use the bufio.NewReader function to wrap the net.Conn in a type that does implement the io.ByteReader interface. 

Example:

package main

import (
    ""bufio""
    ""encoding/binary""
    ""fmt""
    ""net""
)

func main() {
    conn, err := net.Dial(""tcp"", ""google.com:80"")
    if err != nil {
        panic(err)
    }
    defer conn.Close()

    fmt.Fprintf(conn, ""GET / HTTP/1.0\r\n\r\n"")

    length, err := binary.ReadVarint(bufio.NewReader(conn))
    if err != nil {
    panic(err)
    }
    fmt.Println(length)
}

",21642991
256,21655525,"You are nearly there:

package main

import (
    ""fmt""
)

var months = [12]string{
    ""January"", ""February"", ""March"", ""April"", ""May"", ""June"",
    ""July"", ""August"", ""September"", ""October"", ""November"", ""December"",
}

func main() {
    for _, month := range months {
        fmt.Printf(""%s\n"", month)
    }
}


The only tricky part is to use _ instead of i, to avoid an error ""i declared and not used"" when you try to build your program.
_ is called the blank identifier, you can learn more in the go documentation.
",21655408
257,21656121,"For example,

package main

import (
    ""fmt""
    ""time""
)

func main() {
    for i := time.January; i <= time.December; i++ {
        fmt.Printf(""%s\n"", i)
    }
}


Output:

January
February
March
April
May
June
July
August
September
October
November
December

",21655408
258,21863024,"From the go documentation:

Get downloads and installs the packages named by the import paths, along with their dependencies.

To expand on that: 
go get will clone the code you're requesting from the repository (in this case github.com/codegangsta/martini) as well as any code that that code imports and store it in your local $GOPATH/src/ directory then build it and store it so that is available to call via import, so you should never have to call go get more than once unless your GOPATH is being changed and it should always be available locally after the initial go get.
",21862622
259,21918434,"The code looks roughly ok, except that it really should be stricter with error checking. Panicking on error is better then no error checking at all (because it will usually segfault sometimes later).

The problem is that the implementation of Signature.SignUserId() inside code.google.com/p/go.crypto/openpgp is wrong. It is using the algorithm that signs a key (which is use to certify that the subkey belongs to the primary key) instead of the algorithm that signs a user id.

In addition, while exploring this I realized that PublicKey.VerifyUserIdSignature() is implemented in such a way that it only works for self-signed user ids, because it doesn't use the right public key in the hash.

Bug report, with patch https://code.google.com/p/go/issues/detail?id=7371
",21494035
260,22027473,"Can you share an example of the json you are trying to decode?  I suspect that it is an annotations issue.  Most json is lowercase due to the javascript syntax.

For instance, I suspect your json looks like this:

{""pid"":""0"", ""msgId"":""500"", ""msg"":""this is the message""}


If that is the case, then you need annotations on your struct like this:

type Envelope struct {
    Pid   int         `json:""pid""`
    MsgId int64       `json:""msgId""`
    Msg   interface{} `json:""msg""`
}


Again, without an example, I'm only guessing that this is your problem.
",21373558
261,22107462,"We have used http://www.gorillatoolkit.org/pkg/mux for over a year in our production stack and have been very happy with it.

For some really simple sites I host I use the built in routing something like this:

package main

import (
  ""flag""
  ""fmt""
  ""net/http""
  ""os""
)

const (
  version = ""0.1.0""
)

var (
  port   uint
)

func init() {
  flag.UintVar(&port, ""port"", 8000, ""the port to listen on"")
  flag.UintVar(&port, ""p"", 8000, ""the port to listen on"")
}

func main() {
  flag.Parse()

  // Retrieve the current working directory.
  path, err := os.Getwd()
  if err != nil {
    panic(err)
  }
  http.HandleFunc(""/gallery/view.aspx"", handleGallery)
  http.HandleFunc(""/gallery/viewLarge.aspx"", handleViewLarge)
  http.HandleFunc(""/ir.ashx"", handleImageResize)
  http.Handle(""/"", http.FileServer(http.Dir(path)))

  panic(http.ListenAndServe(fmt.Sprintf("":%d"", port), nil))
}


Let me know what you want your routes to be and I could give you a more specific example to what you are looking for.
",21978883
262,22128462,"how about you use something like this:

if err := json.Unmarshal(input, temp_object); err != nil {
    fmt.Println(""it's normal string!"")
} else {
    fmt.Println(""it's json!"")
}

",22128282
263,22128517,"For example,

package main

import (
    ""encoding/json""
    ""fmt""
)

func isJSONString(s string) bool {
    var js string
    err := json.Unmarshal([]byte(s), &js)
    return err == nil
}

func main() {
    fmt.Println(isJSONString(`""Platypus""`))
    fmt.Println(isJSONString(`Platypus`))
}


Output:

true
false

",22128282
264,22129435,"I was unclear if you needed to know about just a ""quoted string"" or if you needed to know about json, or the difference between both of them, so this shows you how to detect both scenarios so you can be very specific.

I posted the interactive code sample here as well: http://play.golang.org/p/VmT0BVBJZ7

package main

import (
    ""encoding/json""
    ""fmt""
)

func isJSONString(s string) bool {
    var js string
    return json.Unmarshal([]byte(s), &js) == nil

}

func isJSON(s string) bool {
    var js map[string]interface{}
    return json.Unmarshal([]byte(s), &js) == nil

}

func main() {
    var tests = []string{
        `""Platypus""`,
        `Platypus`,
        `{""id"":""1""}`,
    }

    for _, t := range tests {
        fmt.Printf(""isJSONString(%s) = %v\n"", t, isJSONString(t))
        fmt.Printf(""isJSON(%s) = %v\n\n"", t, isJSON(t))
    }

}


Which will output this:

isJSONString(""Platypus"") = true
isJSON(""Platypus"") = false

isJSONString(Platypus) = false
isJSON(Platypus) = false

isJSONString({""id"":""1""}) = false
isJSON({""id"":""1""}) = true

",22128282
265,22132076,"The log.SetOutput(ioutil.Discard) statement changes the standard logger output destination. The defer log.SetOutput(os.Stdout) statement attempts to reset the output destination back to its initial value when the function ends. However, it should have reset it back to os.Stderr.

src/pkg/log/log.go

var std = New(os.Stderr, """", LstdFlags)

",22131865
266,22214673,"Go does not have latency-free garbage collection. If you can point out where those claims are, I'd like to try to correct them.

One advantage that we believe Go has over Java is that it gives you more control over memory layout. For example, a simple 2D graphics package might define:

type Rect struct {
    Min Point
    Max Point
}

type Point struct {
    X int
    Y int
}


In Go, a Rect is just four integers contiguous in memory. You can still pass &r.Max to function expecting a *Point, that's just a pointer into the middle of the Rect variable r. 

In Java, the equivalent expression would be to make Rect and Point classes, in which case the Min and Max fields in Rect would be pointers to separately allocated objects. This requires more allocated objects, taking up more memory, and giving the garbage collector more to track and more to do. On the other hand, it does avoid ever needing to create a pointer to the middle of an object.

Compared to Java, then, Go gives you the programmer more control over memory layout, and you can use that control to reduce the load on the garbage collector. That can be very important in programs with large amounts of data. Control over memory layout may also be important for extracting performance from the hardware due to cache effects and such, but that's tangential to the original question.

The collector in the current Go distributions is reasonable but by no means state of the art. We have plans to spend more effort improving it over the next year or two. To be clear, 
Go's garbage collector is certainly not as good as modern Java garbage collectors, but we believe it is easier in Go to write programs that don't need as much garbage collection to begin with, so the net effect can still be that garbage collection is less of an issue in a Go program than in an equivalent Java program.
",14322724
267,22234956,"Yes. Please remember that you will still need the main goroutine alive for these to finish before the program ends. You can use something like sync.WaitGroup:

wg := new(sync.WaitGroup)
for key := range Map {
  wg.Add(1)
  go func() {
    subroutine(Map[key])
    wg.Done()
  }
}
wg.Wait()


Or if you have something like a server loop going on in the main routine you may not need that at all since your program won't finish until a relevant signal is externally sent to it.

Hope that helps.
",22181660
268,22298485,"This will not be possible without actually /not/ allocating the unused parts.
The way a slice is defined in Go, is through a reflect.SliceHeader

type SliceHeader struct {
    Data uintptr
    Len  int
    Cap  int
}


It contains no starting index field. Merely a reference to an underlying, fixed size array.
It is this underlying array which holds your actual data. The slice is simply a 'window' into that array, which always begins at index 0. Wherever 0 may be in the underlying array.

For instance, consider the following code:

a := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
b := a[2:8]
c := a[8:]
d := b[2:4]


This yields a memory layout as follows:

fixed array: [ 0 1 2 3 4 5 6 7 8 9 ]  > [10]int at address 273785072
slice a    :   . . . . . . . . . .    > SliceHeader{Data:273785072 Len:10 Cap:10}
slice b    :       . . . . . .        > SliceHeader{Data:273785080 Len:6 Cap:8}
slice c    :                   . .    > SliceHeader{Data:273785104 Len:2 Cap:2}
slice d    :           . .            > SliceHeader{Data:273785088 Len:2 Cap:6}


The values for Data are simply address offsets into the fixed array and all four slices share the underlying storage.

a =:= $273785072
b =:= $273785080 =:= $a + sizeof(int)*2 =:= $a + 8
c =:= $273785104 =:= $a + sizeof(int)*8 =:= $a + 32
d =:= $273785088 =:= $b + sizeof(int)*2 =:= $a + sizeof(int)*4 =:= $a + 16


At whatever index you re-slice an existing slice, the new slice will always be indexed from 0 to len(s), because the address in the underlying fixed array it points to puts it there.

Memory mapping

If your data is loaded from file on a disk, you can have a different option: use syscall.Mmap to provide access to the data through a slice, starting at the desired index. The returned slice is now index from 0 and it covers only the range you specified.

func mmap(fd *os.File, start, size int) ([]byte, error) {
    _, err := fd.Seek(0, 0)
    if err != nil {
        return nil, err
    }

    return syscall.Mmap(int(fd.Fd()), start, size,
        syscall.PROT_READ, syscall.MAP_SHARED)
}


Do not forget to call syscall.Munmap on the returned slice, when you are done using it.
",22296232
269,22314814,"You are benchmarking RandStrings, which, not surprisingly, is very slow. For example, how long does this take to run?

package main

import (
    ""fmt""
    ""math/rand""
)

const chars = ""ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890 abcdefghijklmnopqrstuvwxyz"" +
    ""~!@#$%^&*()-_+={}[]\\|.?/\""';:`""

const Maxlen = 1024

func RandStrings(N int) []string {
    r := make([]string, N)
    ri := 0
    buf := make([]byte, Maxlen)
    known := map[string]bool{}

    for i := 0; i < N; i++ {
    retry:
        l := rand.Intn(Maxlen)
        for j := 0; j < l; j++ {
            buf[j] = chars[rand.Intn(len(chars))]
        }
        s := string(buf[0:l])
        if known[s] {
            goto retry
        }
        known[s] = true
        r[ri] = s
        ri++
    }
    return r
}

func runbench(t string, n int) {
    for i := 0; i < n; i++ {
        r := RandStrings(2)
        _ = r
    }
}

func main() {
    iter := 64000000
    incr := 1000
    for i := incr; i < iter+1; i = incr {
        runbench(""t"", i)
        incr = 2 * i
    }
}


Adapted from http://pastebin.com/0HwHPXFq.
",22313317
270,22316226,"Prepare your random strings outside of the benchmark, before starting to measure the time.  

Also, you count the file opening, db opening, db closing and file deletion as part of the benchmark.  All this means that you're very unlikely to measure the performance of db.Set(k, v) with any precision.

Retry your benchmark by first generating iter random strings, then using those within your benchmark loop.

type Pair struct { key, value string }

var randString = make([]Pair, iter)

func setupRandomPairs() {
    known := make(map[string]bool)
    for i := range randString {
        randString[i] = Pair {
            key:   genRandomString(known),
            value: genRandomString(known),
        }
    }
}


Then in your benchmark code:

setupRandomPairs()
// start timing
for _, pair := range randString {
    db.Set(pair.key, pair.value)
}
// stop timing
cleanup()

",22313317
271,22352160,"It's perhaps true than the behavior is not well defined in the documentation.

If you check the code: https://code.google.com/p/appengine-go/source/browse/appengine/file/write.go#133

In each call to Write the data is sent to the cloud (line 139). So you don't need to save. (You should close the file when you're done, through.)

Anyway, I'm confused with your wording: ""The package's Create function requires the io.WriteCloser interface."" That's not true. The package's Create functions returns a io.WriteCloser, that is, a thingy you can write to and close.

yourFile, _, err := Create(ctx, ""filename"", nil)
// Check err != nil here.

defer func() {
    err := yourFile.Close()
    // Check err != nil here.
}()

yourFile.Write([]byte(""This will be sent to the file immediately.""))
fmt.Fprintln(yourFile, ""This too."")
io.Copy(yourFile, someReader)


This is how interfaces work in Go. They just provide you with a set of methods you can call, hiding the actual implementation from you; and, when you just depend on a particular interface instead of a particular implementation, you can combine in multiple ways, as fmt.Fprintln and io.Copy do.
",22351780
272,22591419,"In an interpreted language like PHP, implementing eval is fairly simple. But Go is a compiled language. To implement eval in Go would require writing an interpreter for Go. This would not be impossible, but it would be a big job.

-Edit
You can have a look at https://godoc.org/bitbucket.org/binet/go-eval/pkg/eval which might do what you want. If it doesn't you could then maybe expand on it a bit. It isn't a full interpreter though.
",22591198
273,22596117,"Based on the examples you gave it seems like it'd be trivial-ish to build a bit of go code that knows how to evaluate checkGeo() or checkOs() rules; I think that'd be the best approach.

But that's not what you asked...

Another option would be to write the rules in Lua and run them with https://github.com/aarzilli/golua or in Javascript and use https://github.com/robertkrimen/otto
",22591198
274,22603364,"You don't need to pull in a full-blown interpreter for this sort of thing: write a simple parser that would pull your script apart into the syntax tree, and then write code that would walk that tree and ""evaluate"" it.  It's not really that hard for simplistic cases like yours.  And of course, your syntax might be made way simpler than PHP's since you don't want the full power of PHP's evaluator.

One simple example is rpn, but you can go simpler and invent a way to store your queries in, say, JSON.

Also note that Go has a Go parser in the form of a Go package — go/parser so you can write your queries using (minimal) Go syntax, parse them with go/parser and only implement an evaluator which would walk the AST produced by the parser and calculate the result.  But I think this would be an overengeneering, given the example you've provided.

And a minor nitpick: storing the code which is to be evaluated by a full-blown evaluator, like PHP, is dangerous: if someone somehow manages to inject a call to exec() or something like this in your table, the result will be suboptimal.  So having a primitive parser/evaluator is an upside from the security standpoint as well.
",22591198
275,22800641,"It just so happens I wrote an example for someone recently.

https://gist.github.com/freeeve/9167240

The meat is in here, replace Post with Message and Comments with Friends:

msgs := []Message{}
for rows.Next() {
    msg := Message{}
    friend := Friend{}
    err := rows.Scan(&msg.Id, &msg.Name, &msg.Street, &msg.City, &msg.Zip, &msg.State, &msg.Email, &msg.Phone, &friend.Id, &friend.Name)
    if err != nil {
        log.Fatal(err)
    }
    if len(msgs) == 0 || msgs[len(msgs)-1].Id != msg.Id {
        msg.Friends = append(msg.Friends, friend)
        msgs = append(msgs, msg)
    } else {
        msgs[len(msgs)-1].Friends = append(msgs[len(msgs)-1].Friends, friend)
    }
}

",22800353
276,22824962,"You can only have one case statement for each value, so that code is illegal. Additionally, fallthrough only works once, so even if it worked as you wanted for 0, it would still fail for 1.

The simplest solution is to put the initial 0,1 case in its own switch or if before the main switch.
",22824917
277,22825063,"The reason for this behavior, in the current Go, is that the switch is implemented like an if-else-if.  Obviously, if (1) else if (1) doesn't make sense, thus you get this error.

Right now, there is no way to force the compiler to do this.  You have to rewrite your statements to get the effect you want.

Per this bug report comment supposedly quoting Rob Pike, this restriction will be lifted in a future Go version. 
",22824917
278,22882847,"You are executing your deleter only once. In addition, map access is not concurrent-safe so you need to add Mutex around your code.

Here is a fix, that will not grow with time: http://play.golang.org/p/GWQ2hJiySP

package main

import (
    ""fmt""
    ""sync""
    ""time""
)

var datastore = make(map[int64]string)

var m sync.Mutex

func adder() {
    var count int64 = 0
    for {
        m.Lock()
        datastore[count] = ""kjnbhjsdhgvsaghbsdbasjsabjhsabasbdjashdbashdbjasbdhasbdjbdjbdjhabjds""
        m.Unlock()
        count++
        time.Sleep(10 * time.Microsecond)

    }
}

func deleter() {
    for {
        m.Lock()
        for key, _ := range datastore {
            delete(datastore, key)
            time.Sleep(1 * time.Microsecond)
        }
        m.Unlock()
    }
}

func main() {
    // Start adding stuff to datastore (with MORE sleep time = 10 Microsecond)
    go adder()

    // Wait for some time
    time.Sleep(1 * time.Second)

    // Start deleting stuff from datastore (With LESS sleep time = 1 Microsecond)
    go deleter()

    time.Sleep(1 * time.Hour)
    fmt.Println(""Done"")
}


I have put the lock in the deleter around the whole loop. It should be only necessary around the delete, however, you should not delete entries that way, with a range, because modifying the map can change the order of the iteration, so this structure should not be used in a real-life program.
",22881549
279,22883255,"You should not try to get value from sC channel in main function because the only value you send to it is  consumed by getC function in seperate go routine. While trying to read sC channel main function blocks waiting for something and it never ends. Go routine getS is finished, go routine getC has consumed value from channel sC and has also finished. There is nothing in channel sC anymore.

The possible solution is to create another channel s2C and send to it value received from sC channel. 

The complete correct code would look like this:

package main

func main() {
    sC := make(chan string)
    go getS(sC)

    s2C := make(chan string)
    cC := make(chan string)
    go getC(s2C, cC)

    s := <-sC
    println(s)
    s2C <- s

    c := <-cC
    println(c)
}

func getS(sC chan string) {
    s :=  "" simple completed ""
    sC <- s
}

func getC(sC chan string, cC chan string) {
    s := <-sC
    c := s + "" more ""
    cC <- c
}

",22882934
280,22939850,"If you run into this problem after having $GOPATH set up, it may be because you're running it with an unsupported shell. I was using fish and it did not work, launching it with bash worked fine.
",20628918
281,22962115,"The documentation is not clear about how to pass additional data directly; perhaps simply use a closure instead.

https://godoc.org/github.com/mattn/go-gtk/glib#CallbackContext
",22960592
282,23002384,"Based on response from the amazing mattn on GitHub:

https://github.com/mattn/go-gtk/blob/master/example/demo/demo.go#L58

Adopted, tested and working:

import(
... 
""github.com/mattn/go-gtk/glib""
)

...

func ButtonHandler(ctx *glib.CallbackContext) {
    fmt.Printf(""Button Handler: %v\n"", ctx.Data().(*gtk.RadioButton).GetState())
}

aRadioButton.Connect(""toggled"", ButtonHandler, aRadioButton)

...


Thedatasarguments inconnect()must be passed using*glib.CallbackContext in the handler's signature, then, in the handler code, use type assertion to grab the actual arguments .
",22960592
283,23010085,"Can't you just wrap policy in an anonymous function that would do the conversion for you? Something like this:

func (s *SuperAgent) RedirectPolicy(policy func(req Request, via []Request) error) *SuperAgent {
   s.Client.CheckRedirect = func(r *http.Request, v []*http.Request) error {
       return policy(Request(r), []Request(v))
   }
   return s
}


I'm not actually sure you can convert the []*http.Request slice to a []Request, but if not, you could create a temporary slice and do the interface conversion one by one:

func (s *SuperAgent) RedirectPolicy(policy func(req Request, via []Request) error) *SuperAgent {
   s.Client.CheckRedirect = func(r *http.Request, v []*http.Request) error {
       vv := make([]Request, len(v))
       for i, r := range v {
           vv[i] = Request(r)
       }
       return policy(Request(r), vv)
   }
   return s
}


That should do it.
",23009221
284,23025720,"There is not. Go does not provide a logical exclusive-OR operator (i.e. XOR over booleans) and the bitwise XOR operator applies only to integers.

However, an exclusive-OR can be rewritten in terms of other logical operators. When re-evaluation of the expressions (X and Y) is ignored,

X xor Y -> (X || Y) && !(X && Y)


Or, more trivially as Jsor pointed out,

X xor Y  X != Y

",23025694
285,23144809,"As per http://golang.org/cmd/cgo/#hdr-Using_cgo_with_the_go_command


  When the Go tool sees that one or more Go files use the special import
  ""C"", it will look for other non-Go files in the directory and compile
  them as part of the Go package. Any .c, .s, or .S files will be
  compiled with the C compiler. Any .cc, .cpp, or .cxx files will be
  compiled with the C++ compiler.


So you can include the C library source in your repository and go will build it automatically. That page also explains how to pass build flags to the compilers and probably anything else you might need to know.
",23144556
286,23193925,"The below samples from the App Engine docs would indicate that all your delay tasks created via delay.Function#Call should go to the default queue, and thus be deletable via the admin interface. If not, I would call it bug.

In fact, our delay tasks went to the default queue, and we could delete them with the admin interface.

https://developers.google.com/appengine/docs/go/taskqueue/delay#Function.Call


  func (f *Function) Call(c appengine.Context, args ...interface{})


Call invokes a delayed function.


  f.Call(c, ...)


is equivalent to


  t, _ := f.Task(...)
  taskqueue.Add(c, t, """")


https://developers.google.com/appengine/docs/go/taskqueue/reference#Add


  func Add(c appengine.Context, task *Task, queueName string) (*Task, error)


Add adds the task to a named queue. An empty queue name means that the default queue will be used. Add returns an equivalent Task with defaults filled in, including setting the task's Name field to the chosen name if the original was empty.
",20380157
287,23211837,"To answer the question the in the title to post:


  Go does not use classes, but provides many of the same features:

* message passing with methods
* automatic message delegation via embedding
* polymorphism via interfaces
* namespacing via exports



From: http://nathany.com/good/

Solving the code you supplied, I will leave to some more learned Gopher
",23211648
288,23212996,"Here is a corrected version of your code (playground).  This isn't exactly Polymorphism, but the use of an interface is good Go style.

package main

import ""fmt""

type MyInterfacer interface {
    Get() int
    Set(i int)
}

type MyStruct struct {
    data int
}

func (this *MyStruct) Get() int {
    return this.data
}

func (this *MyStruct) Set(i int) {
    this.data = i
}

func main() {
    s := &MyStruct{123}
    fmt.Println(s.Get())

    s.Set(456)
    fmt.Println(s.Get())

    var mi MyInterfacer = s
    mi.Set(789)
    fmt.Println(mi.Get())
}

",23211648
289,23223156,"I once found this example of how to do polymorphism in Go:

http://play.golang.org/p/6Ip9scm4c3

package main

import ""fmt""

type Talker interface {
        Talk(words string)
}

type Cat struct {
        name string
}

type Dog struct {
        name string
}

func (c *Cat) Talk(words string) {
        fmt.Printf(""Cat "" + c.name + "" here: "" + words + ""\n"")
}

func (d *Dog) Talk(words string) {
        fmt.Printf(""Dog "" + d.name + "" here: "" + words + ""\n"")
}

func main() {
        var t1, t2 Talker

        t1 = &Cat{""Kit""}
        t2 = &Dog{""Doug""}

        t1.Talk(""meow"")
        t2.Talk(""woof"")
}

",23211648
290,23255749,"At the time I wrote the question, my function looked like the following:

(shown mostly to demonstrate its verbosity)

func loadModule(moduleName, fileRoot string) (module []byte) {
    if strings.HasSuffix(moduleName, "".md"") {
        module, err := readConvertMDFile(fileRoot + ""htdocs/md/"" + moduleName)
        if err != nil {
            log.Println(err)
        }
        return module
    } else if strings.HasSuffix(moduleName, "".html"") {
        module, err := ioutil.ReadFile(fileRoot + ""htdocs/html/"" + moduleName)
        if err != nil {
            log.Println(err)
        }
        return module
    } else if strings.HasSuffix(moduleName, "".js"") {
        module, err := ioutil.ReadFile(fileRoot + ""htdocs/js/"" + moduleName)
        if err != nil {
            log.Println(err)
        }
        return module
    } else if strings.HasSuffix(moduleName, "".css"") {
        module, err := ioutil.ReadFile(fileRoot + ""htdocs/css/"" + moduleName)
        if err != nil {
            log.Println(err)
        }
        return module
    } else {
        module = []byte{}
        return
    }
}


This uses my suggested solution 1. It has a lot of repeated code (I'm still something of a beginner). If I instead use suggested solution 2 (but not in the way I originally thought of it) by putting var err error at the top of then function, the code is improved in two ways:

func loadModule(moduleName, fileRoot string) (module []byte) {
    var err error
    switch {
    case strings.HasSuffix(moduleName, "".md""):
        module, err = readConvertMDFile(fileRoot + ""htdocs/md/"" + moduleName)
    case strings.HasSuffix(moduleName, "".html""):
        module, err = ioutil.ReadFile(fileRoot + ""htdocs/html/"" + moduleName)
    case strings.HasSuffix(moduleName, "".js""):
        module, err = ioutil.ReadFile(fileRoot + ""htdocs/js/"" + moduleName)
    case strings.HasSuffix(moduleName, "".css""):
        module, err = ioutil.ReadFile(fileRoot + ""htdocs/css/"" + moduleName)
    default:
        module = []byte{}
    }
    if err != nil {
            log.Println(err)
        }
    return
}


There are no shadowed variables any more, and both the error logging and the return can be moved out of each if statement, resulting in much clearer code.

There may well be a way to improve on this. EDIT: ...and there is, following @ANisus' suggestion, the if-else chain has been replaced with a switch statement.
",23255748
291,23256051,"I always use your suggested solution 2 - add an extra var statement.

func loadModule(moduleName, fileRoot string) (module []byte) {
    var err error
    if strings.HasSuffix(moduleName, "".md"") {
        module, err = readConvertMDFile(fileRoot + ""htdocs/md/"" + moduleName)
        if err != nil {
            log.Println(err)
        }
        return
    } else {
        // no need for this as module will be nil if it isn't written to
        // a nil slice is perfectly legal and has len()=0
        // and can be appended to etc
        // module = []byte{}
        return
    }
}


Option 2 is the most efficient solution too.  Remember that go returns all values on the stack so a named return value is equivalent to a stack allocated variable.

If in option 1 or option 3 you don't have a naked return, then there is an implicit module = module or module = moduleT statement in there anyway.

Unfortunately variable shadowing is something which bites every Go programmer after a while. I'd quite like the compiler to disallow all shadowing within a function as it is a source of real bugs.
",23255748
292,23258993,"The commit you've highlighted was from February last year, which is from before the Go 1.1 release.  It also references issue 4435, which is tagged Go1.1.

I'm not sure what people did to get around the restriction previously (if it was indeed possible), but for the last two released versions of the language, there has been no need to employ work arounds.  I've made use of the ability in a number of my projects without incident.
",23252387
293,23363971,"See also the fmt package:

n := int64(123)
fmt.Printf(""%b"", n)  // 1111011

",13870845
294,23501877,"The fluctuations are likely due to the amount of garbage your program is creating that the garbage collector has to eventually collect. The frequency of the fluctuation is going to depend on how much / how often you are creating garbage and when the garbage collector collects it.

Whether a variable is allocated to the stack or the heap is determined by the compiler. Generally pointers, maps, and slices can be allocated to the heap, but this only happens if the compiler's escape analysis determines that a variable escapes. Anything that is allocated to the heap will need to be garbage collected.

Even though Go handles the stack vs heap details, creating as little garbage as possible can be of great benefit. You can read about an extreme case where the garbage collector paused for 10 seconds. The Go garbage collector isn't perfect, but it is improving. The more it improves less you'll have to worry about it. But you should at least be aware of it.

You can run the following to determine what the compiler will allocate to the heap:

go build -gcflags=-m program.go


You may be surprised by what actually gets allocated to the heap. For example, even if you use a bytes.Buffer locally it still gets allocated to the heap, due to bytes.Buffer.buf being re-sliced. Regardless of whether that's supposed to happen or not, there may be situations where you think you're not creating any garbage, but in reality you are.
",21064426
295,23506978,"I had tried a hell lot for weeks.

This one worked

Setting up Go development environment on Ubuntu, and how to fix $GOPATH / $GOROOT

Steps

mkdir ~/go


Set $GOPATH in .bashrc,

export GOPATH=~/go
export PATH=$PATH:$GOPATH/bin

",20628918
296,23563534,"response, error := http.Get(""http://another.service.com/image.jpg"")

if error != nil {
    // handle error
}

_, error = http.Post(""http://max.com/upimg"", ""image/jpg"", response.Body)

if error != nil {
    // handle error
}


If you need to post multipart you'll have to encode the response's Body;

buffer := bytes.NewBuffer(nil)

encoder := multipart.NewWriter(buffer)

field, error := encoder.CreateFormField(""image"") // Set ""image"" to correct field name

if error != nil {
    // handle error
}

_, error = io.Copy(field, response.Body) 

if error != nil {
    // handle error
}

// and then Post buffer instead of response.Body


Remember to set the correct Content-Type header in your POST request (e.g. http.Post's second argument) to something like:

""multipart/form-data; boundary="" + encoder.Boundary()

",23561379
297,23656689,"float64 and int are different types, but conversions are allowed under specific circumstances. (http://golang.org/ref/spec#Conversions)

Your literal 5 in the code is an untyped constant (http://golang.org/ref/spec#Constants), and the proper type is determined by the expression during compilation.

Simply use float64(len(test_scores))
",23656621
298,23656874,"This lines

fmt.Printf(""%T\n"", total)
fmt.Printf(""%T\n"", 5)
fmt.Printf(""%T\n"", 5.0)
fmt.Printf(""%T\n"", len(test_scores))


prints

float64
int
float64
int


Maybe compiler perceives 5 as 5.0.. Anyway you should use conversion to float64.
",23656621
299,23658470,"When you write 5 directly in the source-code that's called a constant. Same goes for writing true. The only difference is that the former is an untyped constant and the latter a typed constant.

The difference lies in that there's no ambiguity about what type true should have – it'll always be bool but in the case of 5 that's not so obvious and depends on the context.

The Go compiler will figure out what type to give the constant on compilation. The details of this are described in Go's language specification.

Edit:

I realized that there's a mistake in my answer: true is in fact also untyped according to the spec because it may be utilized anywhere where a type deriving from bool is expected. That means:

type MyBool bool

func DoNothing(b MyBool) {}

DoNothing(true) // true is coerced to MyBool


The answer is still valid, though. The distinction between typed and untyped constants holds.
",23656621
300,23747151,"As an answer and a follow-up of comments I received on the first post, I developed  Indenter, a small proof of concept based on the idea proposed of a service discovery daemon (I use etcd instead of ZooKeepr for simplicity however).

I wrote an article about it and release the code if someone may be interested one day:

Indenter: a scalable, fault-tolerant, distributed web service copying the go playground architecture.
",23664069
301,23760913,"Change filter to ""Phone ="", ...
",23755985
302,23783295,"There is a Google developped library called JimFS for creating an in-memory File System using the Java NIO it's open source under the Apache 2 License and available on GitHub 
it is very easy to use

try (FileSystem fs = Jimfs.newFileSystem(Configuration.unix())) {
  Path foo = fs.getPath(""/foo"");
  Files.createDirectory(foo);

  Path hello = foo.resolve(""hello.txt""); // /foo/hello.txt
  Files.write(hello, ImmutableList.of(""hello world""), StandardCharsets.UTF_8);

  // Close the FileSystem when you're done with it so it can be garbage collected.
}

",15643388
303,24200239,"I would modify the Unzip function from https://gist.github.com/hnaohiro/4572580 to the following:

package main

import (
    ""archive/zip""
    ""io""
    ""log""
    ""os""
    ""path/filepath""
)

func unzipFile(f *zip.File, dest string) error {
    rc, err := f.Open()
    if err != nil {
        return err
    }
    defer rc.Close()

    path := filepath.Join(dest, f.Name)
    if f.FileInfo().IsDir() {
        err := os.MkdirAll(path, f.Mode())
        if err != nil {
            return err
        }
    } else {
        f, err := os.OpenFile(
            path, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, f.Mode())
        if err != nil {
            return err
        }
        defer f.Close()

        _, err = io.Copy(f, rc)
        if err != nil {
            return err
        }
    }
    return nil
}

func Unzip(src, dest string) error {
    r, err := zip.OpenReader(src)
    if err != nil {
        return err
    }
    defer r.Close()

    for _, f := range r.File {
        err := unzipFile(f, dest)
        if err != nil {
            return err
        }
    }

    return nil
}

func main() {
    err := Unzip(""./sample.zip"", ""./out"")
    if err != nil {
        log.Fatal(err)
    }
}

",24197011
304,24211313,"Remember go build also defaults to static linking so for an apples to apples comparison you should give gccgo the -static or -static-libgo option.
",15073027
305,24292325,"just rename your .go files. The compiler is trying to write to 'client' but 'client' is already taken by the directory.

$ tree
.
├── client
│   └── main.go
└── server
    └── main.go

2 directories, 4 files


And/Or create a script that outputs them with a different name go build -o client client/main.go
",24292133
306,24313458,"Using rsa_test.go as a base I managed to create a small end to end decryption program.
From the informations you provided is hard to tell where the error is, but I hope reading this program you can find the bug yourself. Probably you don't need to provide a Reader in the DecryptOAEP. 

http://play.golang.org/p/7VVCHJOB7R

package main

import (
    ""bytes""
    ""crypto/rsa""
    ""crypto/sha1""
    ""log""
    ""math/big""
)

func main() {
    sha1 := sha1.New()
    n := new(big.Int)
    d := new(big.Int)

    rsa_modulus := ""a8b3b284af8eb50b387034a860f146c4919f318763cd6c5598c8ae4811a1e0abc4c7e0b082d693a5e7fced675cf4668512772c0cbc64a742c6c630f533c8cc72f62ae833c40bf25842e984bb78bdbf97c0107d55bdb662f5c4e0fab9845cb5148ef7392dd3aaff93ae1e6b667bb3d4247616d4f5ba10d4cfd226de88d39f16fb""
    rsa_d := ""53339cfdb79fc8466a655c7316aca85c55fd8f6dd898fdaf119517ef4f52e8fd8e258df93fee180fa0e4ab29693cd83b152a553d4ac4d1812b8b9fa5af0e7f55fe7304df41570926f3311f15c4d65a732c483116ee3d3d2d0af3549ad9bf7cbfb78ad884f84d5beb04724dc7369b31def37d0cf539e9cfcdd3de653729ead5d1""

    n.SetString(rsa_modulus, 16)
    d.SetString(rsa_d, 16)
    public := rsa.PublicKey{n, 65537}
    d.SetString(rsa_d, 16)
    private := new(rsa.PrivateKey)
    private.PublicKey = public
    private.D = d

    seed := []byte{0x18, 0xb7, 0x76, 0xea, 0x21, 0x06, 0x9d, 0x69,
        0x77, 0x6a, 0x33, 0xe9, 0x6b, 0xad, 0x48, 0xe1, 0xdd,
        0xa0, 0xa5, 0xef,
    }
    randomSource := bytes.NewReader(seed)

    in := []byte(""Hello World"")

    encrypted, err := rsa.EncryptOAEP(sha1, randomSource, &public, in, nil)
    if err != nil {
        log.Println(""error: %s"", err)
    }

    plain, err := rsa.DecryptOAEP(sha1, nil, private, encrypted, nil)
    if err != nil {
        log.Println(""error: %s"", err)
    }

    log.Println(string(plain))
}

",24311575
307,24421402,"In Go, the source code is also used to generate documentation. Examples are not meant for testing but rather for the documentation. By having compiled examples, you can make sure they are working properly for anyone using them.

Examples found in the standard libraries can be run directly in the browser when using golang.org to browse the documentation. Godoc.org instead links your example code directly to play.golang.org where you can try it out.

As an example or Example usage, see:  http://golang.org/pkg/sort/
",24421326
308,24426137,"Your Goroutine doesn't have enough time to execute, as the main function exits after printing Done!.

You need to do something to make the program wait for the Goroutine.

The easiest way is to add a time.Sleep() to the end. 

package main

import (
    ""fmt""
    ""time""
)

func main() {

    messages := make(chan string, 3)

    messages <- ""one""
    messages <- ""two""
    messages <- ""three""

    go func(m *chan string) {
        fmt.Println(""Entering the goroutine..."")
        for {
            fmt.Println(<-*m)
        }
    }(&messages)
    time.Sleep(5 * time.Second)
    fmt.Println(""Done!"")
}



  Entering the goroutine...
  one
  two
  three
  Done!


Playground

While this works, it's recommended to use channels, or functions from the sync package, in addition to goroutines, to synchronize concurrent code.

Example:

package main

import (
    ""fmt""
)

func main() {

    messages := make(chan string, 3)
    go func(m chan string) {
        defer close(m)
        fmt.Println(""Entering the goroutine..."")
        messages <- ""one""
        messages <- ""two""
        messages <- ""three""
    }(messages)
    for message := range messages {
        fmt.Println(""received"", message)
    }
    fmt.Println(""Done!"")
}



  Entering the goroutine...
  received one
  received two
  received three
  Done!


Playground
",24425987
309,24426151,"The fact is that your goroutine starts, but is ended before doing anything because your program stop right after printing Done!: execution of goroutines is independant of the main program, but will be stopped at the same than the program. So basically, you need some process to make the program wait for them. It could be another channel waiting for a number of messages, a sync.WaitGroup, or other tricks. 

You should read the excellent post about concurrency in go in the golang blog.
",24425987
310,24491458,"You can assign to os.Stdin, os.Stdout, and os.Stderr.

import ""os""

os.Stdin, err = os.OpenFile(""input.txt"",
    os.RDONLY | os.O_CREATE, 0666)
os.Stdout, err = os.OpenFile(""output.txt"",
    os.O_WRONLY | os.O_CREATE | os.O_TRUNC, 0666)

",24491325
311,24519448,"godoc is very picky regarding the names, your Example function name needs to correlate with an actual function name, type name or other. See http://golang.org/pkg/testing/#hdr-Examples for reference.

Example of godoc exmaple: https://godoc.org/github.com/creack/multio#example-Multiplexer--ReadWriter, code: https://github.com/creack/multio/blob/master/example_test.go

You will notice, that the Example are called ExampleMultiplexer_simple  ExampleMultiplexer_readWriter. This is because I wanted two example, I could have simply use ExampleMultiplexer. This works because I have a type called (exactly) Multiplexer. If you have a function, you can do the same, but the name needs to match.

When using a suffixe, it is very important that the suffix begins with a lowercase, otherwise godoc will discard it.

So to answer your question: yes you can use arbitrary name, but you still need to follow the godoc style of ExampleTypeName_suffix (lower case suffix first letter)
",24519347
312,24640489,"Just use go run or go run *.go you are running/compiling only main.go the other files are not included.
",24640352
313,24643072,"You should, preferably, be using go build - to build a binary which you can then run as ./example. 

Go operates on packages, not files, and go run is ultimately just a convenience to be used when testing examples or simple programs (it builds the binary and discards it, effectively).
",24640352
314,24703382,"jpeg.Encode can't procede, because it's blocked writing to the pipe (pipes don't buffer).

You either need to buffer the encoded image, or run the Encode and http request concurrently.

// make sure to buffer this channel, so the goroutine can exit if we return early
errChan := make(chan error, 1)

r, w := io.Pipe()
go func() {
    errChan <- jpeg.Encode(w, img, &jpeg.Options{80})
}()

req, err := http.NewRequest(""PUT"", myUrl, r)
if err != nil {
    return nil, err
}
err := http.DefaultClient.Do(req)
if err != nil {
    return nil, err
}

// check for an encoding error
err := <-errChan
if err != nil {
    return nil, err
}

",24702774
315,24703499,"Just use a buffer

var w bytes.Buffer

jpeg.Encode(&w, img, &jpeg.Options{80})

req, e := http.NewRequest(""PUT"", myUrl, &w)
if e != nil {
    log.Fatal(e)
}
http.DefaultClient.Do(req)

",24702774
316,24706229,"You could use interface{}, for example :

type JSONDoc struct {
    Count   int           `json:""count""`
    Objects []interface{} `json:""objects""`
}

func main() {
    doc := JSONDoc{Count: 2}
    doc.Objects = append(doc.Objects, &ObjectA{""A""}, &ObjectB{""B""}) 
    b, err := json.MarshalIndent(&doc, """", ""\t"")
    fmt.Println(string(b), err)
}


playground
",24706034
317,24762569,"You're not using pointers throughout. Start off with a Registry of type:

type Registry []*Broker


and work from there

Working example

As far as debugging tricks, this was my process:


Value isn't being changed, so something is being copied by value
Notice that Registry is type []Broker, but we want to modify Brokers, so it needs to be a pointer
Change type Registry to []*Broker
Keep attempting to compile, letting the compiler tell me every place we are using a value where we need a pointer (woohoo fast compile times and static typing)

",24762418
318,24775499,"According to http://golang.org/doc/effective_go.html#defer:


  The arguments to the deferred function (which include the receiver if the function is a method) are evaluated when the defer executes, not when the call executes. Besides avoiding worries about variables changing values as the function executes, this means that a single deferred call site can defer multiple function executions.


So argument of defer function (trace(""b"") in your case) evaluates first
",24775306
319,24777143,"Simplifying,

package main

import ""fmt""

func trace(s string) string {
    fmt.Println(""entering:"", s)
    return s
}

func un(s string) {
    fmt.Println(""leaving:"", s)
}

func b() {
    defer un(trace(""b""))
    fmt.Println(""in b"")
}

func main() {
    b()
}


Output:

entering: b
in b
leaving: b


Since ""arguments to deferred functions are evaluated when the defer executes"", the 

defer un(trace(""b""))


statement in function b is, using explicit scope, equivalent to

{
    unarg := trace(""b"")
    defer un(unarg)
}


Therefore, equivalently,

package main

import ""fmt""

func trace(s string) string {
    fmt.Println(""entering:"", s)
    return s
}

func un(s string) {
    fmt.Println(""leaving:"", s)
}

func b() {
    {
        unarg := trace(""b"")
        defer un(unarg)
    }
    fmt.Println(""in b"")
}

func main() {
    b()
}


Output:

entering: b
in b
leaving: b


Equivalently, for your complete example,

package main

import ""fmt""

func trace(s string) string {
    fmt.Println(""entering:"", s)
    return s
}

func un(s string) {
    fmt.Println(""leaving:"", s)
}

func a() {
    {
        unarg := trace(""a"")
        defer un(unarg)
    }
    fmt.Println(""in a"")
}

func b() {
    {
        unarg := trace(""b"")
        defer un(unarg)
    }
    fmt.Println(""in b"")
    a()
}

func main() {
    b()
}


Output:

entering: b
in b
entering: a
in a
leaving: a
leaving: b

",24775306
320,24838866,"The second form is mainly for grouping several constant declarations.

If you have only one constant, the first form is enough.

for instance archive/tar/reader.go:

const maxNanoSecondIntSize = 9


But in archive/zip/struct.go:

// Compression methods.
const (
        Store   uint16 = 0
        Deflate uint16 = 8
)


That doesn't mean you have to group all constants in one const (): when you have constants initialized by iota (successive integer), each block counts.
See for instance cmd/yacc/yacc.go

// flags for state generation
const (
    DONE = iota
    MUSTDO
    MUSTLOOKAHEAD
)

// flags for a rule having an action, and being reduced
const (
    ACTFLAG = 1 << (iota + 2)
    REDFLAG
)




dalu adds in the comments:


  it can also be done with import, type, var, and more than once.


It is true, but you will find iota only use in a constant declaration, and that would force you to define multiple const () blocks if you need multiple sets of consecutive integer constants.
",24838846
321,24845867,"You cannot do such stuff. The slive does not contain the variables but their values, so you cannot get their name. Just use a map.
",24836696
322,24849574,"instead of working with the variable names, you might work with a slice with (string converted) pointers to the variables to reach your original aim:

package main

import ""fmt""
import ""unsafe""
import ""strconv""

func castStr(v *string) string {
    return fmt.Sprint(uintptr(unsafe.Pointer(v)))
}

func uncastStr(s string) string {
    p, _ := strconv.ParseInt(s, 10, 64)
    return *((*string)(unsafe.Pointer(uintptr(p))))
}

func main() {
    onevar := ""something""
    other := ""something else""
    sa := []string{castStr(&onevar), castStr(&other)}

    for _, v := range sa {
        fmt.Printf(""{{%s}}\n"", v)
        fmt.Printf(""%v\n"", uncastStr(v))
    }

    //for _, v := range sa {
    //  vName := fmt.Sprintf(""{{%s}}"", v)
    //  msg = strings.Replace(msg, vName, uncastStr(v) -1)
    //}
}


(Don't see a problem working with unsafe here because any casting is not being based of uncontrolled content and unsafe.Pointer is only used for reading. 
Attention!: Have in mind that pointer-values might vary between program runs. Thus, replacing the templates {{xxx}} in a second run of the program might fail. Moreover: that scenario (second run) might be ""unsafe"" since unrelated memory might be assessed.) 
",24836696
323,24854488,"Yes, in the flag package documentation, it says that one of the possible command line flag syntaxes is -flag.  You should try making a boolean flag with the Bool or BoolVar functions and see if it works the expected way.
",24854410
324,24863769,"From the documentation:


  When execution begins, $ is set to the data argument passed to Execute, that is, to the starting value of dot.


Therefore, you can use this:

{{range .notes}}
    {{$.Email}} {{.sf}}
{{end}}

Email {{.Email}}


(Note the dollar sign inside the range)

Playground link: http://play.golang.org/p/XiQFcGJEyR

Side note: Next time try to provide proper code and a better explanation. As it stands, I think I've answered this, but I cannot be sure. Your code doesn't compile - for example, type names are wrong/mixed with members and you have unexported fields so they cannot be accessed by the templates.
",24863585
325,24877796,"You just need to dereference the pointer (so you're not iterating over a pointer - you're iterating over a slice):

for _, chicken := range *chickens {
    // ...
}


Playground link: http://play.golang.org/p/NBv9sooqEV
",24877566
326,24877925,"There are few problems with your code.


You're returning a pointer to a reflect.Value, 99% sure that's not what you're trying to achive.
You're not dereferencing the slice like Simon mentioned.
Slices are pointer types, if you're returning *[]interface{} for performance reasons, you're actually hurting not helping.


So let's rewrite the code and optimize it! (it's late night SO, time to party):

// pass the size to preallocate the slice, also return the correct slice type.
func GetaDynamiclyTypedSlice(ptrItemType interface{}, size int) (col []interface{}) {
    col = make([]interface{}, size)
    itemtyp := reflect.TypeOf(ptrItemType).Elem()
    for i := range col { //prettier than for i := 0; etc etc
        item := reflect.New(itemtyp)
        item.Elem().FieldByName(""Weight"").SetFloat(rand.ExpFloat64())
        col[i] = item.Interface() //this is the magic word, return the actual item, not reflect.Value
    }
    return
}


playground
",24877566
327,24954530,"According to your code .Data is array or slice. It does not have GetId() method
",24952983
328,24958024,"problem is that i needed to make instance of my struct like this 

var warehouse = new(models.Warehouse) // works


instead of

var warehouse models.Warehouse // fails

",24952983
329,24958673,"You can't use + on a slice, however you can use append:

 ioutil.WriteFile(""testOutput.txt"", append(contents, cnvrtUserProfile), 0x777)

",24958569
330,24980225,"You will need to look at the following options and see if it works for you :


Looking at the large file size, you should consider using Google Cloud Storage for the file. You can use the command line utilities that GCS provides to upload your file to your bucket. Once uploaded, you can look at using the JSON API directly to work with the file and import it into your datastore layer. Take a look at the following: https://developers.google.com/storage/docs/json_api/v1/json-api-go-samples
If this is like a one time import of a large file, another option could be spinning up a Google Compute VM, writing an App there to read from GCS and pass on the data via smaller chunks to a Service running in App Engine Go, that can then accept and persist the data. 

",24977231
331,24983086,"func main() {
    http.Handle(""/"", http.FileServer(http.Dir(""static"")))
    http.ListenAndServe("":4747"", nil)
}


You don't need static/home, just static.

FileServer is using directory listing and since you don't have an index.html in /static, the directory content is shown instead.

A quick fix would be to just rename home.html to index.html. This would allow you to access index.html through http://localhost:4747/ and edit.html with http://localhost:4747/edit.html.

There's no need to use html/template if you only need to serve static files.

But a clean solution depends on what you are actually trying to do.
",24980927
332,25002758,"You could write a custom io.Reader that you feed to json.Decoder and that will pre-read your json file and skip that specific field.

The other option is to write your own decoder, more complicated and messy.

//edit it seemed like a fun exercise, so here goes:

type IgnoreField struct {
    io.Reader
    Field string
    buf   bytes.Buffer
}

func NewIgnoreField(r io.Reader, field string) *IgnoreField {
    return &IgnoreField{
        Reader: r,
        Field:  field,
    }
}
func (iF *IgnoreField) Read(p []byte) (n int, err error) {
    if n, err = iF.Reader.Read(p); err != nil {
        return
    }
    s := string(p)
    fl := `""` + iF.Field + `""`
    if i := strings.Index(s, fl); i != -1 {
        l := strings.LastIndex(s[0:i], "","")
        if l == -1 {
            l = i
        }
        iF.buf.WriteString(s[0:l])

        s = s[i+1+len(fl):]
        i = strings.Index(s, `""`)
        if i != -1 {
            s = s[i+1:]
        }
        for {
            i = strings.Index(s, `""`) //end quote
            if i != -1 {
                s = s[i+1:]
                fmt.Println(""Skipped"")
                break
            } else {
                if n, err = iF.Reader.Read(p); err != nil {
                    return
                }
                s = string(p)
            }
        }
        iF.buf.WriteString(s)
    }
    ln := iF.buf.Len()
    if ln >= len(p) {
        tmp := iF.buf.Bytes()
        iF.buf.Reset()
        copy(p, tmp[0:len(p)])
        iF.buf.Write(p[len(p):])
        ln = len(p)
    } else {
        copy(p, iF.buf.Bytes())
        iF.buf.Reset()
    }
    return ln, nil
}

func main() {
    type MyStruct struct {
        Field1 string
        Field2 string
    }
    fi, err := os.Open(""myJSONFile.json"")
    if err != nil {
         os.Exit(2)
    }
    // create an instance and populate
    var mystruct MyStruct
    err := json.NewDecoder(NewIgnoreField(fi, ""Field3"")).Decode(&mystruct)
    if err != nil {
        fmt.Println(err)
    }
    fmt.Println(mystruct)
}


playground
",25002575
333,25012943,"If you're only interested in writing a simple server that serves static content and not just as a learning experience I'd take a look at Martini (http://martini.codegangsta.io/).

The quintessential Martini app to serve static files from a folder named 'public' would be:

package main

import (
    ""github.com/go-martini/martini""
)

func main() {
    m := martini.Classic()
    m.Run()
}


to add a new static folder called 'static' to the list of static folders searched for content is also simple:

package main

import (
    ""github.com/go-martini/martini""
)

func main() {
    m := martini.Classic()
    m.Use(martini.Static(""static"")) // serve from the ""static"" directory as well
    m.Run()
}


Martini provides lots more functionality as well, such as session, template rendering, route handlers etc...

We're using Martini in production here and have been more than happy with it and it's surrounding infrastructure.
",24980927
334,25028189,"Not a the solution I hoped for, but I ended up splitting the large files into 32MB pieces, uploading each to blob storage, then parsing each in a task.

It aint' pretty. But it took less time than the other options. 
",24977231
335,25094332,"You need to use Format for this. time.RFC1123Z is just a layout string.

t := time.Now()
s := t.Format(time.RFC1123Z) // Format t to a string using the given layout
fmt.Println(s)

",25094243
336,25181475,"
  Is the best way to compare Foods to not use map[Food]bool and instead use something like map[FoodKey], where any struct that satsifies Food provides a FoodKey() comparisonStruct method that returns a struct meant strictly for comparison?


I suspect it is a better approach, considering:


comparing interface is slow (issue 6105)
(and that supposes comparison operators are defined: see Map Types)
using an Equaler (as in this thread) isn't easy
you might need to distinguish between the actual types included in the interface instances you are comparing.

",25180509
337,25181637,"You have two options to determine or compare the underlying structs of interfaces.

1- Use the reflect package, specifically the reflect.TypeOf function, which will return the dynamic type of the interface, such as:

x := Food(fruit{""banana"", 0})
y := Food(vegetable{""potato, 45})
return reflect.TypeOf(x) == reflect.TypeOf(y)


This piece of code will return false.

2- Use type assertions or a type switch, such as:

value, ok := yourInterface.(possibleType)

",25180509
338,25182837,"I believe the most efficient path here is to add an extra function to your interface like Is(f Food) bool, it's easy to implement, no overhead of using reflection or comparing interfaces or using a map somewhere.

Example:

type Food interface {
    Name() string
    Tastiness() int
    Is(f Food) bool
}
//....
func (*fruit) Is(f Food) bool   { _, ok := f.(*fruit); return ok }
//....
func (*vegetable) Is(f Food) bool   { _, ok := f.(*vegetable); return ok }


playground
",25180509
339,25249682,"The flag package does not use GNU parsing rules. The rules are explained in the documentation for flag the package. Your question is answered there:


  Flag parsing stops just before the first non-flag argument (""-"" is a non-flag argument) or after the terminator ""--"".

",25248534
340,25266597,"With := you are declaring a new variable (not writing to the global) and that new variable at function scope is unused. (Has nothing to do with globals.)
",25266304
341,25266601,"You're re-declaring Reqs with the := operator. Drop the colon.

You should probably start with the basics first:


Tour of Go
How to Write Go Code
Effective Go

",25266304
342,25266750,"Okay first of all I'd recommend you to read Effective Go before continuing.

You are declaring your global variable using:

var Reqs []Req


Then re-declaring a variable with the same name using:

Reqs := ......


You are declaring two different variables.



var Name type also initializes the variable:

var s string


Is equivalent to:

s := """"


So this makes the following line useless:

Reqs = make([]Req, 0)




You can try your fixed code here (Golang Play).
",25266304
343,25297743,"It depends on which driver you are using, some drivers / databases don't support transactions at all.

For example go-sql-driver/mysql supports transactions just fine.

Your code should work, or you could change it a little to:

tx, err := db.Begin()
...
stmt, err := tx.Prepare(`INSERT INTO balance set money=?, id=? ON DUPLICATE UPDATE balance SET money=money+? WHERE id=?`)
res, err := stmt.Exec(123.45, 1, 123.45, 1)
res, err := stmt.Exec(67.89, 2, 67.89, 2)
res, err := stmt.Exec(10.23, 3, 10.23, 3)
...
tx.Commit()


Also check this answer which goes into a lot of details about transactions.
",25289593
344,25325342,"In general yes, but you have to define the level of safety that you require. The three standard phenomena that can occur in a transaction are:

- Dirty reads (read uncommitted data)
- Nonrepeatable reads (a row is retrieved twice and the values within the row differ between reads)
- Phantom reads ( two identical queries are executed, and the collection of rows returned by the second query is different from the first)


Dependent of what behavior that is accepted you can use different isolation levels:

- Read uncommitted (all phenomena possible)
- Read committed (dirty read prevented)
- Repeatable reads (phantom read can occur)
- Serializable (non of the phenomena is possible)


In general the ""higher"" isolation level you use, the poorer concurrency you get. Poorer in the sense that more locks are used and blocks concurrent queries from other transactions. If you know that you shall update a row that is selected you can select ... for update.

See for example http://en.wikipedia.org/wiki/Isolation_%28database_systems%29 for a more thorough explanation.
",25325114
345,25326736,"The pitch parameter expects the surface's width * sizeof(int32) as far as I can, this code works and prints random pixels every loop:

func main() {
    window, err := sdl.CreateWindow(""test"", sdl.WINDOWPOS_UNDEFINED,
        sdl.WINDOWPOS_UNDEFINED, 800, 600, sdl.WINDOW_SHOWN)
    if err != nil {
        log.Fatal(err)
    }
    defer window.Destroy()

    renderer, err := sdl.CreateRenderer(window, -1, 0)
    if err != nil {
        log.Fatal(err)
    }
    defer renderer.Destroy()

    texture, err := renderer.CreateTexture(sdl.PIXELFORMAT_ARGB8888,
        sdl.TEXTUREACCESS_STATIC, 800, 600)

    if err != nil {
        log.Fatal(err)
    }
    defer texture.Destroy()

    pixels := make([]uint32, 800*600)
L:
    for {
        for event := sdl.PollEvent(); event != nil; event = sdl.PollEvent() {
            if _, ok := event.(*sdl.QuitEvent); ok {
                break L
            }
        }
        for i := range pixels {
            pixels[i] = 0x00777777 + uint32(rand.Intn(0x00AAAAAA))
        }
        //4 == sizeof(int32), unsafe.Sizeof(pixels) returns the actual size of
        //the slice header which is 24
        texture.Update(nil, unsafe.Pointer(&pixels[0]), 800*4)
        window.UpdateSurface()

        renderer.Clear()
        renderer.Copy(texture, nil, nil)
        renderer.Present()
    }

    sdl.Delay(1000)
    sdl.Quit()
}


//edit it should be unsafe.Pointer(&pixels[0]) not unsafe.Pointer(&pixels).
",25325229
346,25327191,"DB is safe to be accessed from multiple goroutines:


  DB is a database handle representing a pool of zero or more underlying connections.
  
  It's safe for concurrent use by multiple goroutines.


Also Stmt is safe to be used from multiple goroutines:


  Stmt is a prepared statement. Stmt is safe for concurrent use by multiple goroutines.


You should use only one sql.Tx per goroutine:


  Once DB.Begin is called, the returned Tx is bound to a single connection

",25325114
347,25334843,"Compressing each line individually is just going to be very slow, and provide relatively inefficient compression to boot.

Is there a reason you're not simply compressing the entire file? Or at least one ""block"" at a time?
",25333683
348,25342976,"The proper way of doing this is passing the handle in main to SetupLogging:

func SetupLogging(lf *os.File) {
    log.SetOutput(io.MultiWriter(os.Stderr, logFile))
    log.Println(""Started"")
}

func main() {
    logFile, err := os.OpenFile(""test.log"", os.O_APPEND|os.O_CREATE, 0666)
    if err != nil {
        log.Panicln(err)
    }
    defer logFile.Close()
    SetupLogging(logFile)
    log.Println(""Test message"")
}


Another option is to use runtime.SetFinalizer, but it's not always guaranteed to run before main exits.

func SetupLogging() {
    logFile, err := os.OpenFile(""test.log"", os.O_APPEND|os.O_CREATE, 0666)
    if err != nil {
        log.Panicln(err)
    }
    runtime.SetFinalizer(logFile, func(h *os.File) {
        h.Close()
    })

    log.SetOutput(io.MultiWriter(os.Stderr, logFile))
}

",25342806
349,25351051,"You would be surprised how fast and efficient looping over a small slice is, and you can implement sorting on top of it fairly simple.

I recommend reading http://golang.org/pkg/sort/ SortWrapper.

type Letter struct {
    Value rune
    Score int
}

type LetterList []*Letter

func (ll *LetterList) FindOrAdd(r rune) (l *Letter) {
    for _, l = range *ll {
        if l.Value == r {
            return
        }
    }
    l = &Letter{Value: r, Score: 0}
    *ll = append(*ll, l)
    return
}

func (ll LetterList) SortByScore() LetterList {
    sort.Sort(llByScore{ll})
    return ll
}

func (ll LetterList) SortByValue() LetterList {
    sort.Sort(llByValue{ll})
    return ll
}

func (ll LetterList) String() string {
    var b bytes.Buffer
    b.WriteByte('[')
    for _, v := range ll {
        b.WriteString(fmt.Sprintf(""{%q, %d}, "", v.Value, v.Score))
    }
    b.WriteByte(']')
    return b.String()

}

func New(s string) (ll LetterList) {
    ll = LetterList{}
    for _, r := range s {
        ll.FindOrAdd(r).Score++
    }
    return
}

func (ll LetterList) Len() int      { return len(ll) }
func (ll LetterList) Swap(i, j int) { ll[i], ll[j] = ll[j], ll[i] }

type llByScore struct{ LetterList }

func (l llByScore) Less(i, j int) bool {
    return l.LetterList[i].Score > l.LetterList[j].Score
}

type llByValue struct{ LetterList }

func (l llByValue) Less(i, j int) bool {
    return l.LetterList[i].Value > l.LetterList[j].Value
}

func main() {
    ll := New(`Let's say I have a string and I would like to count each letter's frequency and then sort the table by the frequency. Desired output of ""hello larry"" would be`)
    fmt.Println(ll)
    fmt.Println(ll.SortByScore())
    fmt.Println(ll.SortByValue())
}


playground

Another approach is to use a map then for sorting generate a list out of it and sort it.
",25350710
350,25376707,"The article mentions:


  Many server frameworks provide packages and types for carrying request-scoped values.
  We can define new implementations of the Context interface to bridge between code using existing frameworks and code that expects a Context parameter.
  
  For example, Gorilla's github.com/gorilla/context package allows handlers to associate data with incoming requests by providing a mapping from HTTP requests to key-value pairs.
  In gorilla.go, we provide a Context implementation whose Value method returns the values associated with a specific HTTP request in the Gorilla package.
  
  Other packages have provided cancellation support similar to Context.
  For example, Tomb provides a Kill method that signals cancellation by closing a Dying channel. Tomb also provides methods to wait for those goroutines to exit, similar to sync.WaitGroup.
  In tomb.go, we provide a Context implementation that is canceled when either its parent Context is canceled or a provided Tomb is killed. 


You will find other examples of Context, like context.go in goweb.
",25376313
351,25391509,"It looks like a permission problem, changing the ownership on $GOPATH should fix it.

sudo chown -R $USER $GOPATH


I'm guessing that you somehow installed something as root that changed the permission of $GOPATH/pkg.
",25391051
352,25431804,"So while we weren't able to do separate queries for each upsert, we did write valid mysql for bulk upserts in a single statement...

INSERT INTO balance (id, money) VALUES (1, 123.45), (2, 67.89), (3, 10.23)
ON DUPLICATE KEY UPDATE money = money + values(money)


So for anyone who wants to do a bulk upsert, there is a pattern to work around any limitations of the mysql driver.
",25289593
353,25476750,"Use proper error handling and you should see what is going on. For some reason it is either loading a blank file or no able to find the file and that is why the results page is blank.

As mentioned in the comments:

In renderTemplate, do a panic(err) and check the return value of t.Execute(). In viewHandler do a panic(err) as well. Same in editHandler, do a panic(err).

See what those panics say and go from there.
",25475003
354,25487392,"You will have to create a struct to hold your map and provide custom get/put/delete funcs to access it.

Note that 2-5k accesses per second is not really that much at all, so you don't have to worry about that.

Here's a simple implementation:

type item struct {
    value      string
    lastAccess int64
}

type TTLMap struct {
    m map[string]*item
    l sync.Mutex
}

func New(ln int, maxTTL int) (m *TTLMap) {
    m = &TTLMap{m: make(map[string]*item, ln)}
    go func() {
        for now := range time.Tick(time.Second) {
            m.l.Lock()
            for k, v := range m.m {
                if now.Unix() - v.lastAccess > int64(maxTTL) {
                    delete(m.m, k)
                }
            }
            m.l.Unlock()
        }
    }()
    return
}

func (m *TTLMap) Len() int {
    return len(m.m)
}

func (m *TTLMap) Put(k, v string) {
    m.l.Lock()
    it, ok := m.m[k]
    if !ok {
        it = &item{value: v}
        m.m[k] = it
    }
    it.lastAccess = time.Now().Unix()
    m.l.Unlock()
}

func (m *TTLMap) Get(k string) (v string) {
    m.l.Lock()
    if it, ok := m.m[k]; ok {
        v = it.value
        it.lastAccess = time.Now().Unix()
    }
    m.l.Unlock()
    return

}


playground
",25484122
355,25496227,"That is just a plain make file and not even well written.


running just make will execute the commands under test
make dependencies will download all the dependencies of the current packages
make cover will do coverage testing and output an html file 

",25496170
356,25496238,"You can find enough info and documentation on golang page. There is a ""search"" in upper right corner, inserting ""cover"" or ""-cover"" yielded very useful info, such as this:


  Cover is a program for analyzing the coverage profiles generated by
  'go test -coverprofile=cover.out'.
  Cover is also used by 'go test -cover' to rewrite the source code with
  annotations to track which parts of each function are executed. It
  operates on one Go source file at a time, computing approximate basic
  block information by studying the source. It is thus more portable
  than binary-rewriting coverage tools, but also a little less capable.
  For instance, it does not probe inside && and || expressions, and can
  be mildly confused by single statements with multiple function
  literals.
  
  For usage information, please see:


go help testflag
go tool cover -help

",25496170
357,25498741,"Golang function are first-class, as illustrated in this go-example page.  

It is a named type, which means you can use ApplyFunc anywhere where a func(commitIndex uint64, cmd []byte) []byte is expected: see ""Golang: Why can I type alias functions and use them without casting?"".

It means, as commented by Volker, it isn't a function or a ""pointer to a function"".
It is a type which allows you to declare a variable storing any function which respects the same func signature as its declared type, like a function literal (or ""anonymous function"").

var af ApplyFunc = func(uint64,[]byte) []byte {return nil}
                 // (function literal or ""anonymous function"")


See ""Anonymous Functions and Closures"": you can define a function which returns another function, taking advantage of closure:


  Function literals are closures: they may refer to variables defined in a surrounding function.
  Those variables are then shared between the surrounding function and the function literal, and they survive as long as they are accessible. 


(see playground example)

type inc func(digit int) int

func getIncbynFunction(n int) inc {
    return func(value int) int {
        return value + n
    }
}

func main() {
    g := getIncbynFunction
    h := g(4)
    i := g(6)
    fmt.Println(h(5)) // return 5+4, since n has been set to 4
    fmt.Println(i(1)) // return 1+6, since n has been set to 6
}




Also, As illustrated in ""Golang function pointer as a part of a struct"", you can define functions on a func receiver ApplyFunc(!).
",25498505
358,25499760,"
GOROOT must reference the folder where you installed GO
GOPATH must reference an empty folder which will be your workspace (src/pkg/bin for your projects)


Add those two variables in your user environment variables.

A go get github.com/coreos/etcd should:


download the sources in %GOPATH%/src/github.com/coreos/etcd (src is created for you)
compile it in %GOPATH%/pkg/windows_amd64 (pkg/ is created for you, windows_amd64 reflects your windows architecture)
with go install, install it in %GOPATH%/bin (bin/ is also created for you)


Note: with Go 1.8+ (Q2 2017), GOPATH might be set for you by default to (on Windows) %USERPROFILE%/go.
On Linux, it would be $HOME/go: see issue 17262.
",25499670
359,25519765,"Isolating in a playgroud, it compiles just fine, and has the expected output:

c := camera{}
res := c.SwitchToCartesianThreeSpace(2, 3)
// res is [0 2 -3]


You need to try with a camera.go including only that code, or check how the camera.go file fits in your current workspace.
",25519638
360,25595027,"The installation page does mention:


  Once downloaded it can be run from anywhere. You don’t need to install it into a global location.
  Ideally you should install it somewhere in your path for easy use. /usr/local/bin is the most probable location.


As long as:


you chose the right release for your architecture (linux, Mac or Windows)
rename the executable to hugo (or make a symlink to it, named hugo)
your $PATH (or %PATH% on Windows) environment variable references the executable hugo, you can start using it.

hugo new site /path/to/site


",25595011
361,25596117,"Extract hugo_0.11_linux_amd64.tar.gz to a directory. In that directory you should find three files:

hugo_0.11_linux_amd64  LICENSE.md  README.md


Make sure either hugo is in your path or provide a path to it. For example, rename the hugo_0.11_linux_amd64 executable file to hugo. Move the hugo executable file to /usr/local/bin.

Run

$ hugo help


Continue to follow the instructions for Using Hugo.

References:

Hugo

Hugo Documentation: Getting Started
",25595011
362,25652169,"I'm not familiar enough with Java but wouldn't this do the same thing:

// w = io.Writer
io.WriteString(""stuff"")

// r = io.Reader
sc := bufio.NewScanner(r)
for scanner.Scan() {
    fmt.Println(sc.Text())
}


strings are a readonly []byte more or less.

//edit

After reading the comments, I think you're looking for https://code.google.com/p/go-charset:

r, err := charset.NewReader(""latin1"", r)
if err != nil {
        log.Fatal(err)
}
result, err := ioutil.ReadAll(r)
if err != nil {
        log.Fatal(err)
}
fmt.Printf(""%s\n"", result)

",25651501
363,25669593,"You could use something like this skipping the cgo all together, I can't test it right now:

const (
    netNS = ""/run/netns/""
    mntNS = ""/run/mntns/""
)
func ChangeNamespace(name string) error {
    fd, err := syscall.Open(netNS+name, syscall.O_RDONLY, 0666)
    if err != nil {
        return err
    }
    defer syscall.Close(fd)
    if _, _, err := syscall.RawSyscall(syscall.SYS_SETNS, uintptr(fd), 0, 0); err != nil {
        return err
    }

    fd1, err := syscall.Open(mntNS+name, syscall.O_RDONLY, 0666)
    if err != nil {
        return err
    }
    defer syscall.Close(fd1)
    if _, _, err := syscall.RawSyscall(syscall.SYS_SETNS, uintptr(fd1), 0, 0); err != nil {
        return err
    }
    return nil
}

",25668980
364,25712559,"Slightly off to one side - you asked for an array of objects when you needed a map

If you need an array (actually a slice) 

http://ioblocks.blogspot.com/2014/09/loading-arrayslice-of-objects-from-json.html
",16931499
365,25728030,"Just a shot in the dark - what is the system CCSID set to?  DSPSYSVAL QCCSID.  If it is 65535, that means the system language is 'binary - do not translate'.  You might need to set the CCSID in your connection string if that's the case.
",25715581
366,25745513,"It is possible that err is nil when returning from ValidateName(), ValidateEmail() or ValidatePassword() calls.

You should check err != nil before adding it to the map.

if err != nil {
    mutex.Lock()
    errMsg[""xxx""] = err.Error()
    mutex.Unlock()
}


In other words, this isn't the map errMsg which is the issue, but the value you want to put in it.
",25745374
367,25806298,"I don't see how you would refactor the code, and somehow keep it clear and expressive enough.

If you have only three cases to consider, making them in three separate if/else is the easiest way to code those cases.
",25806133
368,25809786,"It is technically possible: you could create an if statement for the >170 case, then define an array of 170 function pointers and use an index operation for the other two cases. I can't think of a reasonable case where this solution is actually better than the one you already have though.
",25806133
369,25837128,"No, but it might be simpler to apply strings.Index on a slice of the string

strings.Index(s[1:], ""go"")+1
strings.Index(s[n:], ""go"")+n


See example (for the case where the string isn't found, see OneOfOne's answer), but, as commented by Dewy Broto, one can simply test it with a 'if' statement including a simple statement:
(also called 'if' with an initialization statement)

if i := strings.Index(s[n:], sep) + n; i >= n { 
    ...
}

",25837030
370,25837141,"It's an annoying oversight, you have to create your own function.

Something like:

func indexAt(s, sep string, n int) int {
    idx := strings.Index(s[n:], sep)
    if idx > -1 {
        idx += n
    }
    return idx
}

",25837030
371,25838625,"In case you don't want to use an ORM, try a SQL generator like Squirrel, and check every argument before modifying the sql statement:

import (
    sq ""github.com/lann/squirrel""
    ""fmt""
)

statement := sq.Update(""user"").Where(sq.Eq{""Id"": &u.Id})
if &u.Name != nil {
    statement = statement.Set(""Name"", ""Jack"")
}
sql, args, err := statement.ToSql()
fmt.Println(sql)


In some scenarios you may need to query the DB first to make sure the input data is not trying to explicitly set column ´Name´ to null (like update user set Name = null ...).

A different approach will be to use an 'ORM-ish' package like gorp or gorm, both should handle sql updates properly.
",25090797
372,25861731,"You hit a tricky aspect of function definition syntax in Go. You can't have an unnamed argument, and you can name an argument int, and func f(x, y, z Type) is a shortcut to declare all three variables to be of type Type. For example, func f(int, x string) counterintuitively declares an f that accepts two strings, one of which happens to be named int. 

package main

import ""fmt""

func f(int, x string) {
    fmt.Println(""int is:"", int)
    fmt.Println(""x is:"", x)
}

func main() {
    f(""foo"", ""bar"")
}


When you run it, the output is

int is: foo
x is: bar


Yes, that's a little mind-bending. I've never heard the specific thinking explained, but maybe they kept builtin type names un-reserved so they could later introduce new builtin types without breaking code that's already out there.

Anyway, it means your first function definition doesn't actually accept an int and a *StructObj but a *StructObj named int and another named reply. So the error message from net/rpc actually means that the client passed a 0 when it expected a *StructObj. Pretty fun.
",25861389
373,25942472,"They aren't equal because it's comparing the pointer not the value of the pointer.
You have few options.


Don't use pointers and you won't be able to use slices either in either structs, you can use fixed size arrays.
Write your own func (p *packet) Equals(o *packet) bool and compare stuff yourself.
use reflect.DeepEqual, this is by far the slowest / least efficient solution, I'd personally go with #2.


Simple implementation of #2:

func (h *header) Equal(o *header) bool {
    return h != nil && o != nil &&
        h.dataLength == o.dataLength &&
        h.optDataLength == o.optDataLength &&
        h.packetType == o.packetType
}

func (p *packet) Equal(o *packet) bool {
    return p != nil && o != nil &&
        p.header.Equal(o.header) &&
        p.syncByte == o.syncByte &&
        p.headerCrc == o.headerCrc &&
        p.dataCrc == o.dataCrc &&
        bytes.Equal(p.data, o.data) &&
        bytes.Equal(p.optData, o.optData)
}


playground
",25941791
374,25942593,"Each call to Decode allocates a new value of type header. You are observing the different addresses for these allocated headers. The two headers values have the same contents, but they are at different addresses.
",25941791
375,25972959,"The following code has two different structure types that both implement the Say() function. You can create an array containing both types and call Replay()and have it do what you want:

package main

import ""fmt""

type Statement interface {
    Say() string
}
type Statements []Statement

type Quote struct {
    quote string
}
type Quotes []Quote

func (p Quote) Say() string {
    return p.quote
}

type Attributed struct {
    who   string
    quote string
}

func (p Attributed) Say() string {
    return p.who + "": "" + p.quote
}


func Replay(conversation []Statement) {
    for _, s := range conversation {
        fmt.Println(s.Say())
    }
}

func (q Quotes) toStatements() Statements {
    conv := make(Statements, len(q))
    for i, v := range q {
        conv[i] = Statement(v)
    }
    return conv
}

func main() {
    conversation := Statements{
        Quote{""Nice Guy Eddie: C'mon, throw in a buck!""},
        Quote{""Mr. Pink: Uh-uh, I don't tip.""},
        Attributed{""Nice Guy Eddie"", ""You don't tip?""},  // <= another type
        Quote{""Mr. Pink: Nah, I don't believe in it.""},
        Quote{""Nice Guy Eddie: You don't believe in tipping?""},
    }

    myquotes := Quotes{
        Quote{""Nice Guy Eddie: C'mon, throw in a buck!""},
        Quote{""Mr. Pink: Uh-uh, I don't tip.""},
        Quote{""Nice Guy Eddie: You don't tip?""},
        Quote{""Mr. Pink: Nah, I don't believe in it.""},
        Quote{""Nice Guy Eddie: You don't believe in tipping?""},
    }

    Replay(conversation)
    Replay(myquotes.toStatements())
}


Replay() doesn't change or know anything about Attributed{}.
You do have to introduce types for the slices Quotes & Statements.
",20163660
376,26000374,"Make sure the actual error isn't related to an import issue (as in issues 266)

Check (to be sure you are using the latest versions, as in this issue):


your Go-MySQL-Driver version (or git SHA)
your Go version (run go version in your console)


If the error isn't directly in the Open step, but when accessing the Rows, check this comment out:


  Use either a for loop (for rows.Next() { ... }) or something like this:


if rows.Next() {
     // whatever
} else {
     // catch error with rows.Err()
}
rows.Close() // <- don't forget this if you are not iterating over ALL results

",25999714
377,26011449,"You should keep i18n decoupled from your currency implementation. So no, don't bundle everything in a struct and call it a day. Mark what currency the amount represents but nothing more. Let i18n take care of formatting, stringifying, prefixing, etc.

Use an arbitrary precision numerical type like math/big.Rat. If that is not an option (because of serialization limitations or other barriers), then use the biggest fixed-size integer type you can use to represent the amount of atomic money in whatever currency you are representing – cents for USD, yens for JPY, rappen for CHF, cents for EUR, and so forth.

When using the second approach take extra care to not incur in overflows and define a clear and meaningful rounding behaviour for division.
",26008004
378,26016960,"You might want to check out http.MaxBytesReader. It limitates the maximum amount of data which can be received from/sent by a single request. 


  MaxBytesReader prevents clients from accidentally or maliciously sending a large request and wasting server resources. 

",26015235
379,26058668,"Virtual Inheritance solves a problem which does not exist if you don't have multiple inheritance. Consider the following inheritance tree:

  A
 / \
B   C
 \ /
  D


If classes B and C both provide a data-member (or method for that matter) with the same name then when accessing said member in D, you need a way to disambiguate whose ancestor's data-member (or method) you wish to access.

Virtual Inheritance is C++'s solution.

In Go you don't have inheritance to begin with; only composition and you can embed at most 1 member of any given type at once.

http://play.golang.org/p/1iYzdoFqIC

package main

type B struct {
}

func (b B) Foo() {}

type C struct {
}

func (c C) Foo() {}

type D struct {
    B
    C
}

func main() {
    d := D{B{}, C{}}
    // d.Foo() // <- ambiguous
    d.B.Foo()  // <- ok
    d.C.Foo()  // <- ok
}

",26058133
380,26093701,"""Virtual Inheritance"" is something more like this

http://play.golang.org/p/8RvPmB3Pof

package main

type A struct {
    virtual int
}

func (a *A) set(v int) {
     a.virtual = v
}

func (a *A) get() int {
    return a.virtual
}

type B struct {
    *A
}

type C struct {
    *A
}

type D struct {
    *B
    *C
}

func main() {
    a := &A{}
    b := &B{a}
    c := &C{a}
    d := &D{b, c}
    d.B.set(3)
    println(d.C.get())
    return
}

",26058133
381,26143288,"It is not possible to empty a channel without a loop. If you don't have any concurrent receivers, then you can use this simple loop:

for len(ch) > 0 {
  <-ch
}


If you do have concurrent receivers, then use the loop:

L:
for {
    select {
    case <-c:
    default:
       break L
    }
}

",26143091
382,26143528,"What you're describing is inherently racy, since there may be legitimate requests to reconnect on the channel. Rather than trying to drain the channel, I would recommend keeping track of timing.

On your reconnect channel, post the time. When finished with the reconnect, note the time. While consuming the reconnect channel, throw away any messages that are older than your last reconnect.

Another more lockstep solution to achieve this is to make the reconnect channel a bool. Post ""true"" to reconnect. When the reconnect completes, post ""false"". Then consume the channel until you find ""false.""
",26143091
383,26143596,"It sounds like instead of a reset channel, you want a reset goroutine.  It would have an input from the side sending the reset signal, and an output to the receiver.  When this goroutine receives a request to reconnect, it passes it to the receiver.  Then it waits to receive an acknowledgement back from the receiver on a third channel, throwing away any reconnect requests it receives in the meantime.  So 3 channels total, 1 input, 1 output, 1 ack.
",26143091
384,26146146,"lines = append(lines[:i], 
           append([]string{""MY INSERTED TEXT HERE""}, lines[i:]...)...)


or

lines = append(lines, """")
copy(lines[i+1:], lines[i:])
lines[i] = ""MY INSERTED TEXT HERE""


The second approach is more efficient. The two approaches are listed on the useful SliceTricks page.
",26146081
385,26146150,"If you want to do this with a slice, you can insert the string you want at the correct index.

// make the slice longer
lines = append(lines, """")
// shift each element back
copy(lines[i+1:], lines[i:])
// now you can insert the new line at i
lines[i] = x

",26146081
386,26149656,"Another approach is using sync.Cond and atomic, something along the lines of:

type Server struct {
    s     chan int
    r     chan int
    c     *sync.Cond
    state uint32
}

const (
    sNormal       = 0
    sQuitting     = 1
    sReconnecting = 2
)

func New() *Server {
    s := &Server{
        s: make(chan int),
        r: make(chan int),
        c: sync.NewCond(&sync.Mutex{}),
    }
    go s.sender()
    // go s.receiver()
    return s
}
func (s *Server) sender() {
    //
    for {
        select {
        case data := <-s.s:
        //do stuff with data
        default:
            s.c.L.Lock()
        L:
            for {
                switch atomic.LoadUint32(&s.state) {
                case sNormal:
                    break L
                case sReconnecting:
                case sQuitting:
                    s.c.L.Unlock()
                    return
                }
                s.c.Wait()
            }
            s.c.L.Unlock()
        }
    }
}

//repeat for receiver

func (s *Server) Reconnect() {
    var cannotReconnect bool
    atomic.StoreUint32(&s.state, sReconnecting)
    //keep trying to reconnect
    if cannotReconnect {
        atomic.StoreUint32(&s.state, sQuitting)
    } else {
        atomic.StoreUint32(&s.state, sNormal)
    }
    s.c.Broadcast()
}


playground
",26143091
387,26150590,"for {
    value, _ := FuncX()
    if value == 0 {
        break
    }
}

",26150553
388,26150621,"You can use a loop like:

value, _ := FuncX()
for value == 0 {
    value, _ = FuncX() // note using the = not :=
}

",26150553
389,26150953,"A more complex loop header than others have offered, although having nothing in the loop body may trigger coder OCD.

for value,_ := FuncX(); value != 0; value,_ = FuncX() {
}


In fact, this is usually how I read files line by line in Go

// Assume we have some bufio.Reader named buf already created
for line,err := buf.ReadString('\n'); err == nil; line,err = buf.ReadString('\n') {
    // Do stuff with the line.
}


If you need line or err outside the loop you just predeclare them and replace the := with =.
",26150553
390,26185296,"From the documentation you linked:


  // It is recommended to use an authentication key with 32 or 64 bytes.
  
  // The encryption key, if set, must be either 16, 24, or 32 bytes to select AES-128, AES-192, or AES-256 modes.


So you could use something like this:

//replace 16 with 24 for 192bit or 32 for 256bit.
var store = sessions.NewCookieStore(securecookie.GenerateRandomKey(16), 
                                    securecookie.GenerateRandomKey(16))


// edit

Also @elithrar made a very valid point in comments, so keep it in mind:


  Also note that restarting your application means that it cannot read existing sessions (as new keys are generated every time) when using this method. 

",26185201
391,26223739,"The answers above neglect to check if user's IP is forwarded by a proxy. In a lot of cases, the IP that you will find in the RemoteAddr is the IP of a proxy that is forwarding the user's request to you - not the user's IP address! 

A more accurate solution would look like this:

package main

import (
    ""net""
    ""net/http""
)

func GetIP(r *http.Request) string {
    if ipProxy := r.Header.Get(""X-FORWARDED-FOR""); len(ipProxy) > 0 {
        return ipProxy
    }
    ip, _, _ := net.SplitHostPort(r.RemoteAddr)
    return ip
}

",17222021
392,26299816,"In Your router You should serve index.html to all undefined elsewhere URLs. In mux package there is helpful handler:
http://www.gorillatoolkit.org/pkg/mux#Router
- look at NotFoundHandler

You can use it, to handle all 404's and serve index.html instead:

func main() {
    r := mux.NewRouter()
    r.HandleFunc(""/foo"", fooHandler)
    r.NotFoundHandler = http.HandlerFunc(notFound)
    http.Handle(""/"", r)

}


and define notFound function:

func notFound(w http.ResponseWriter, r *http.Request) {
    http.ServeFile(w, r, ""static/index.html"")
}

",24855388
393,26332619,"There are only 2 ways to do that currently:


use swig, the official example is in $GOROOT/misc/swig/callback.
Write hand-made wrapper like you'd do for any other language that doesn't support C++.

",26332292
394,26415155,"You need to tell it to match against new lines .. by specifying the s flag:

r := regexp.MustCompile(`(?s)(.)`)


Try it in the playground: http://play.golang.org/p/MK-UECa9AV

The s flag tells the parser to let . match a new line.
",26415117
395,26457906,"@troq

I'm a little late to the party but I'd say the answer is yes and no.  As @gnibbler pointed out, CPython is slower in the simple implementation but pypy is jit compiled for much faster code when you need it.

If you're doing numeric processing with CPython most will do it with numpy resulting in fast operations on arrays and matrices.  Recently I've been doing a lot with numba which allows you to add a simple wrapper to your code.  For this one I just added @njit to a function incALot() which runs your code above.  

On my machine CPython takes 61 seconds, but with the numba wrapper it takes 7.2 microseconds which will be similar to C and maybe faster than Go.  Thats an 8 million times speedup.

So, in Python, if things with numbers seem a bit slow, there are tools to address it - and you still get Python's programmer productivity and the REPL.

def incALot(y):
    x = 0
    while x < y:
        x += 1

@njit('i8(i8)')
def nbIncALot(y):
    x = 0
    while x < y:
        x += 1
    return x

size = 1000000000
start = time.time()
incALot(size)
t1 = time.time() - start
start = time.time()
x = nbIncALot(size)
t2 = time.time() - start
print('CPython3 takes %.3fs, Numba takes %.9fs' %(t1, t2))
print('Speedup is: %.1f' % (t1/t2))
print('Just Checking:', x)

CPython3 takes 58.958s, Numba takes 0.000007153s
Speedup is: 8242982.2
Just Checking: 1000000000

",12574909
396,26526822,"You can define a slice type:

type MySliceType []SomeType



You can still use append and slicing operations on values of MySliceType.
You can define methods on MySliceType.


You can't, however, monkeypatch []SomeType's methods.
",26526736
397,26546559,"go get  is the Go package manager. It works in a completely decentralized way and how package discovery still possible without a central package hosting repository.

Besides locating and downloading packages, the other big role of a package manager is handling multiple versions of the same package. Go takes the most minimal and pragmatic approach of any package manager. There is no such thing as multiple versions of a Go package.

go get always pulls from the HEAD of the default branch in the repository. Always. This has two important implications:


As a package author, you must adhere to the stable HEAD philosophy. Your default branch must always be the stable, released version of your package. You must do work in feature branches and only merge when ready to release.
New major versions of your package must have their own repository. Put simply, each major version of your package (following semantic versioning) would have its own repository and thus its own import path.

e.g. github.com/jpoehls/gophermail-v1 and github.com/jpoehls/gophermail-v2.


As someone building an application in Go, the above philosophy really doesn't have a downside. Every import path is a stable API. There are no version numbers to worry about. Awesome!

For more details  : http://zduck.com/2014/go-and-package-versioning/
",24855081
398,26573513,"The problem is that router.PathPrefix(""/"").Handler(fs) will match every route and the NotFoundHandler is never executed.
The NotFoundHandler is only executed when the router can't find a matching route.

When you explicitly define your routes it works as expected.

You could do something like:

router.Handle(""/foo"", fooHandler())
router.PathPrefix(""/assets"").Handler(fs)
router.HandleFunc(""/"", index)
router.HandleFunc(""/about"", about)
router.HandleFunc(""/contact"", contact)
router.NotFoundHandler = http.HandlerFunc(notFound)

",26573394
399,26580721,"It looks like user.Current() ultimately calls getuid from libc, does he have it installed? Is it the 64 bit rpm? 
",26575662
400,26610702,"There is an open issue related to it. As a temporary workaround, I am running sed in between collecting and visualizing the coverage results.

goapp test -cover -test.v=true -test.coverprofile=c.out
sed -i -e ""s#.*/\(.*\.go\)#\./\\1#"" c.out
goapp tool cover -html c.out -o coverage.html

",26565794
401,26647875,"The code of your static lib isn't really obfuscated: see ""What about protection for Golang source code"".

But you wouldn't be able to get back the exact Go code from the binary, so in that respect, you have ""some"" protection.
",26646802
402,26771938,"You can do this using channels, here is my approach

type InfoLog struct {
    InfoChan chan string
    CloseChan chan struct{} //empty signal
    log *log.Logger
    file *os.File
}

func NewInfoLog(file *os.File) *InfoLog {
    return &InfoLog{
        InfoChan: make(chan string),
        CloseChan: make(chan struct{}),
        log: log.New(file, ""TAG"", log.Ldate|log.Ltime),
        file: file,
    }
}

func (i *InfoLog) listen() {
    for {
        select {
        case infoMsg := <-i.InfoChan:
            i.log.Println(infoMsg)
        case <-i.CloseChan:
            i.file.Close()
            close(i.InfoChan)
        }
    }
}


then in main

func main() {
    infoLog := NewInfoLog(ANY_OPEN_FILE_HERE)
    go infoLog.listen()
    infoLog.InfoChan <- ""msg""
    infoLog.InfoChan <- ""msg""
    infoLog.InfoChan <- ""msg""
    infoLog.CloseChan <- struct{}{}
    // exits normaly
}


you can see an asynchronous log system i have made for a complete example: https://github.com/sescobb27/ciudad-gourmet/blob/master/services/log_service.go
",25342806
403,26810553,"This is a bug in fedora: Bug 1135152

If you compile the Go program using gccgo, rather than golang it will work.
",26575662
404,26832241,"go get does not not display anything while downloading and installing libraries. So as long as you are connected to the internet just wait. If there are troubles connecting to the server it will display an error.

Depending on your platform: Check if you have installed git and hg.
",26832168
405,26832979,"I hope this will help others. I spent almost 3 hours figuring this out. Apparently, 

[developer@machine gocode]$ go get gopkg.in/wantedpackage


will not not work with git version < 1.7.9.5. 
The trick is to upgrade your git version. I upgraded my git version to 1.7.12.4 and it works.
",26832168
406,26889480,"As of now, the encoding/gob package doesn't work with recursive values:


  Recursive types work fine, but recursive values (data with cycles) are problematic. This may change.


Until this is changed, you'll have to either not use cyclic data, or use a different approach to serialisation.
",26889287
407,26906705,"Running the benchmark with the -m gcflag gives the possible answer:

./main_test.go:16: BenchmarkWithoutPointer []int literal does not escape
(...)
./main_test.go:25: []int literal escapes to heap


Your []int in the second example escapes to heap, which is slower than stack. If you use separate x and y fields for your arguments instead of a slice

type Adder struct {
    x, y int
}

func (a *Adder) add() int {
    return a.x + a.y
}


the benchmark shows the expected behaviour:

BenchmarkWithoutPointer 1000000000               2.27 ns/op
BenchmarkWithPointer    2000000000               1.98 ns/op

",26906323
408,26909828,"I think you should create the Child outside of the Add method and pass it in. If you want to manipulate the Child, do that before you passed it in. You might use methods on the Child struct to do that:

func (c *Child) Init(fn1 func(), fn2 func()) {
  c.Status = ""1""
  ...
}

func (p *Parent) Add(c *Child) *Child {
  p.Children = append(p.Children, c)
  return c
}

func main() {
  var p Parent
  var child Child
  child.Init(...)       // <- pass something in there...
  p.Add(&child)
  child.Status = ""2""
  fmt.Println(p)
  fmt.Println(child)
}

",26909443
409,26909891,"I'd suggest doing this in the simplest way possible. Remember the KISS principle. One part of the system does one and only one thing.

Following this logic, your Add(c *Child) method should only add a child. Creating a Child should be done separately, same for giving a Child some unique properties.

For your OpenGL menu system, this approach fits nicely as well:

m := NewMenu()
t := NewText(text)
t.OnClick = someCallback
// Some other t initialisation.
m.Add(t)
// Some time later you can still change t if it's a pointer and m.Add
// doesn't copy.
t.OnHover = someOtherCallback


The decision on whether to keep your labels exported, or hide them and provide getters/setters is up to you, and depends solely on your system's design and consistency requirements.
",26909443
410,26921970,"Ok the following works for me.  The code is changed again to try to focus more clearly on the particular issue I was having.  It all comes down to properly using pointers.  Thanks for the suggestions.

package main

import (
    ""fmt""
)

type HairColor func() string
type Parent struct {
    Children []*Child
}

type Child struct {
    Age           int
    ShowHairColor HairColor
}

func (p *Parent) Add(c *Child) {
    p.Children = append(p.Children, c)
}

func main() {
    var parent Parent
    var child Child

    child.Age = 10
    parent.Add(&child)

    child.ShowHairColor = func() string {
        return ""red""
    }
    fmt.Printf(""%v\n"", parent.Children[0])
    fmt.Printf(""%v\n"", child)

    fmt.Println(parent.Children[0].ShowHairColor())
}

",26909443
411,26939091,"Here is a function that takes an integer and grouping separator and returns a string delimited with the specified separator.  I have tried to optimize for efficiency, no string concatenation or mod/division in the tight loop.  From my profiling it is more than twice as fast as the humanize.Commas implementation (~680ns vs 1642ns) on my Mac.  I am new to Go, would love to see faster implementations!

Usage: s := NumberToString(n int, sep rune)

Examples 

Illustrates using different separator (',' vs ' '), verified with int value range.

s:= NumberToString(12345678, ',')

=> ""12,345,678""

s:= NumberToString(12345678, ' ')

=> ""12 345 678""

s: = NumberToString(-9223372036854775807, ',')

=> ""-9,223,372,036,854,775,807""

Function Implementation

func NumberToString(n int, sep rune) string {

    s := strconv.Itoa(n)

    startOffset := 0
    var buff bytes.Buffer

    if n < 0 {
        startOffset = 1
        buff.WriteByte('-')
    }


    l := len(s)

    commaIndex := 3 - ((l - startOffset) % 3) 

    if (commaIndex == 3) {
        commaIndex = 0
    }

    for i := startOffset; i < l; i++ {

        if (commaIndex == 3) {
            buff.WriteRune(sep)
            commaIndex = 0
        }
        commaIndex++

        buff.WriteByte(s[i])
    }

    return buff.String()
}

",13020308
412,26960404,"Just pass a pointer to your struct and not its value to the function. The pointer is still interface{} but a pointer to the interface is meaningless. 
",26960243
413,26966454,"It sounds like you want to send non-pointer values over a chan interface{} and have a custom MarshalJSON method work as expected. In that case, just don't define the method on the pointer type. 

See here

package main

import (
    ""encoding/json""
    ""fmt""
    ""log""
    ""time""
)

func printer(in chan interface{}) {
    for val := range in {
        buf, err := json.Marshal(val)
        if err != nil {
            log.Println(err.Error())
        }
        log.Println(string(buf))
    }
}

type MyType struct {
    name string
}

func (m MyType) MarshalJSON() ([]byte, error) {
    return []byte(fmt.Sprintf(`""%s""`, m.name)), nil
}

func main() {
    ch := make(chan interface{})

    go printer(ch)
    ch <- ""string value""
    ch <- 25
    ch <- MyType{
        name: ""foo"",
    }

    time.Sleep(time.Second)
}


The only real difference is the method receiver. func (m MyType) MarshalJSON ([]byte, error) instead of func (m *MyType) MarshalJSON ([]byte, error)
",26960243
414,27098764,"I'd recommend defining setter and getter methods on the type, and store the values in a slice in the struct.

For example:

package main

import ""fmt""

type kv struct {
    k, v string
}

type mybasket struct {
    Coupons  string
    Amount   int
    Contents []kv
}

func (t *mybasket) SetContents(c ...kv) {
    t.Contents = c
    return
}

func (t *mybasket) GetContents() []kv {
    return t.Contents
}

func main() {
    T := &mybasket{""couponlist"", 100, []kv{}} // New Basket
    kvs := []kv{{""foo"", ""bar""}, {""baz"", ""bat""}} // Contents
    T.SetContents(kvs...) // Set Contents
    fmt.Printf(""%v"", T.GetContents()) // Get Contents
}


Prints:

[{foo bar} {baz bat}]


Playground
",27098062
415,27140645,"Create a dummy template, set the delimiters and then parse the files:

 tmpl, err := template.New("""").Delims(""[["", ""]]"").ParseFiles(""base.tmpl"", ""homepage/inner.tmpl"")


This aspect of the API is quirky and not very obvious. The API made more sense in the early days when the template package had the additional Set type
",27115076
416,27165762,"The Go Authors actually (2014/11) added webp to their additional go ""image"" repo (bmp/tiff/webP) here:

https://github.com/golang/image

EDIT: Obviously the repo does not contain any webp encoder / seems to be the reader - only.

(Haven't tested the webp code so far. Maybe leave some more time 4 testing before using in production.)
",8340751
417,27187685,"You could check out the implementation of PuerkitoBio/throttled, presented in this article:


  throttled, a Go package that implements various strategies to control access to HTTP handlers.
  Out-of-the-box, it supports rate-limiting of requests, constant interval flow of requests and memory usage thresholds to grant or deny access, but it also provides mechanisms to extend its functionality.


The rate limit isn't exactly what you need, but can give a good idea for implementing a similar feature. 
",27187617
418,27190130,"There's a token bucket algorithm that can be helpful to implement such the rate limit. I found an example implementation, which you can use: https://github.com/juju/ratelimit

package main

import (
    ""bytes""
    ""fmt""
    ""io""
    ""time""

    ""github.com/juju/ratelimit""
)

func main() {
    // Source holding 1MB
    src := bytes.NewReader(make([]byte, 1024*1024))
    // Destination
    dst := &bytes.Buffer{}

    // Bucket adding 100KB every second, holding max 100KB
    bucket := ratelimit.NewBucketWithRate(100*1024, 100*1024)

    start := time.Now()

    // Copy source to destination, but wrap our reader with rate limited one
    io.Copy(dst, ratelimit.Reader(src, bucket))

    fmt.Printf(""Copied %d bytes in %s\n"", dst.Len(), time.Since(start))
}


After running it, the output is:

Copied 1048576 bytes in 9.239607694s


You can use different bucket implementations to provide desired behaviour. In your code, after setting up right token bucket, you would call:

_, err = io.Copy(out, ratelimit.Reader(file, bucket))

",27187617
419,27201340,"If depends on the format you will chose for the serialization.

One well-suited for over-the-network communication is MessagePack (an efficient binary serialization format. It lets you exchange data among multiple languages like JSON. But it's faster and smaller)

A Go library like philhofer/msgp can serializaze any struct (like one with a map), including composite types like maps and arrays.

However, it uses Go1.4 go generate command. (go 1.4rc1 is already out)

From there, a library like docker/libchan can help: Libchan is an ultra-lightweight networking library which lets network services communicate in the same way that goroutines communicate using channels. 
",27201256
420,27211124,"With booleans an xor is simply:

if boolA != boolB {

}


In this context not equal to performs the same function as xor: the statement can only be true if one of the booleans is true and one is false.
",23025694
421,27214494,"I'm not sure that this is your problem, although reading your code it seems you're not leaking anything - but you can tune GC behavior a bit with SetGCPercent() http://golang.org/pkg/runtime/debug/#SetGCPercent

According to TFM, a collection is triggered when the ratio of freshly allocated data to live data remaining after the previous collection reaches this percentage.. The default rate is 100%, meaning for programs that make lots of small allocations and hold lots of RAM, the overhead can be huge. I had an HTTP cache take up over 200% the cache size once. Try tuning the percentage to somewhere around 10% and see if it helps.
",27210030
422,27259783,"My problem was solved by using a third party dns library, specifically miekg/dns (https://github.com/miekg/dns).
",20845256
423,27379160,"The best way is not maintaining a list at all.

Each connection should connect to a hub with a given identifier (eg:user id, connection id, etc...), subscribe for messages for such identifier and publish messages with that identifier. Also subscribe for global messages and group messages if you want.

UPDATE:

To scale to 50K+ connections you are going to need a more distributed approach rather than a simple map with a mutex.  For example: https://github.com/bitly/nsq (made in GO) ""NSQ is a realtime distributed messaging platform designed to operate at scale, handling billions of messages per day."" 
",27370217
424,27392755,"This problem can be stated more generally: You have a collection of values. You need to iterate over the collection, add to the collection and remove from the collection with high concurrency. 

I would start with what you propose: use a map protected by a mutex.

If you find that there's high contention on the mutex, then consider lock striping. This is where you use N mutex and map pairs where the pair is selected by a hash of the key.
",27370217
425,27448765,"First, you need to split off the executable from it's base path as it's returned from osext

exePath, _ := osext.Executable()
base, _ := filepath.Split(exePath)


(or use osext.ExecutableFolder())

Then you need to create the directory with the permissions 0755. Directories need the executable bit set in order to traverse them.
",27447305
426,27468580,"
   
     
    
        {{template ""left"" .}}
    
    
        {{template ""right"" .}}
    



Make correct html close tag after 

That`s it:


   
     
    
        {{template ""left"" .}}
    
    
        {{template ""right"" .}}
    



",27468281
427,27469986,"My problem was that I run go file from random directory. To solve it I changed directory (cd) to parent of templates folder. 
",27468281
428,27485744,"This is already explained in this question. In short - you can create your own Marshaller implementation if you need to preserve these characters, but even encoded the json output will be a perfectly valid one and should not break anything.
",27485256
429,27528721,"The question ""Properly pass arguments to Go Exec"" mentions:


  exec.Command(...) adds double quotes to the parameters if there is spaces in them, so you only need to escape \"" where you need them.


In your case, -cp ""/minecraft/bin/*"" would be passed to exec.Command as two separate parameters.  

If you need quotes within one parameter, you could use a string literal to keep them (as commented in ""How do you add spaces to exec.command in golang"").

But if, in your case, you need the cp (classpath) to be expended by the shell (as mentioned in ""double quotes escaping in golang exec""), then remove the quotes:

exec.Command(..., ""-cp"", `/minecraft/bin/*`, ...)

",27528430
430,27658174,"Put that in the ~/.vimrc file to make the settings permanent.
Here's a wiki article on this - http://vim.wikia.com/wiki/Indent_with_tabs,_align_with_spaces
",27658081
431,27690792,"
Marshal() defined here https://golang.org/src/net/mockicmp_test.go?h=Marshal#L32 
And icmpMessage struct here https://golang.org/src/net/mockicmp_test.go?h=icmpMessage#L17

",27686338
432,27727469,"The approach I've found workable is git's submodule system. Using that you can submodule in a given version of the code and upgrading/downgrading is explicit and recorded - never haphazard.

The folder structure I've taken with this is:

+ myproject
++ src
+++ myproject
+++ github.com
++++ submoduled_project of some kind.

",24855081
433,27795117,"Using 2 different channels

You want to send values to 2 different channels. Sending a value to a channel is not an assignment, so you can't send on both channels in one step.

First store the values returned by boolInt(), then send the values to the 2 channels like this:

go func() {
    b, i := boolInt()
    chanBool <- b
    chanInt <- i
}()


Testing it:

go func() {
    b, i := boolInt()
    chanBool <- b
    chanInt <- i
}()

fmt.Println(""Received bool:"", <-chanBool)
fmt.Println(""Received int:"", <-chanInt)


Output:

Received bool: false
Received int: 1


Note: you first have to receive from chanBool because you created unbuffered channels, and because in the example we first send to chanBool, that blocks until the sent value is recevied and only then proceeds to send a value to the chanInt. Attempting to receive from chanInt first would cause a deadlock (""fatal error: all goroutines are asleep - deadlock!"").

Solution using only one channel

If you want to send multiple values on a channel, you can create a wrapper struct for the values:

type MyStruct struct {
    b bool
    i int
}


And using it:

ch := make(chan MyStruct)
go func() {
    b, i := boolInt()
    ch <- MyStruct{b, i}
}()

fmt.Println(""Received value:"", <-ch)


Output:

Received value: {false 1}


Note: You could also use a []interface{} slice as a wrapper, but a struct provides a clearer way and type safety to its fields.

Note #2: It would make things easier and clearer if the boolInt() function itself would return a MyStruct value:

func boolInt() MyStruct {
    return MyStruct{false, 1}
}


In which case code would be as simple as this:

ch := make(chan MyStruct)
go func() {
    ch <- boolInt()
}()


Alternative 1 channel solution

Another option is to make the channel type interface{} so it can receive values of any type, and just send/receive multiple values on it:

ch := make(chan interface{})
go func() {
    b, i := boolInt()
    ch <- b
    ch <- i
}()

fmt.Println(""Received values:"", <-ch, <-ch)


Output:

Received values: false 1

",27795036
434,27795708,"If you want to send two values down a channel together, one option is to use a struct to pack both values together.  For example:

type BoolPlusInt struct {
    B bool
    I int
}


You can then create a value of this type holding the two values before sending it down the channel.  For instance:

c := make(chan BoolPlusInt)
go func() {
    var v BoolPlusInt
    v.B, v.I = boolInt()
    c <- v
}()


This solution might be preferable if you have multiple goroutines sending or receiving on the channel.  Since the two values are packed together you don't need to worry about bugs in one place leading to the two channels getting out of sync.

You can experiment with this suggestion here: http://play.golang.org/p/I_Apg4ciFI
",27795036
435,27819409,"The reason for the different output is that in the first case 912 * 0.01 is the multiplication of 2 untyped constant values which is of arbitrary precision, and only the result is converted to float64 when the value is passed to Println(). (See Constant expressions section of the Language specification for details.)

In the second case float64(912) * 0.01 first 912 is converted to float64, then the untyped constant 0.01 is converted to float64 and these two values having float64 are multiplied which is not an arbitrary precision, and will not give exact result.

Note:

In the first case the result will be converted to float64 when passed to the Println():

fmt.Printf(""%T %v\n"", 912 * 0.01, 912 * 0.01)


Output:

float64 9.12


Test it on Go Playground
",27819137
436,27819483,"As per spec:


  Constant expressions are always evaluated exactly; intermediate values and the constants themselves may require precision significantly larger than supported by any predeclared type in the language.


Since

912 * 0.01


is a constant expression, it is evaluated exactly. Thus, writing fmt.Println(912 * 0.01) has the same effect as writing fmt.Println(9.12). When you pin 912 to float64, the other operand of the floating-point multiplication is implicitly pinned to float64, too. Thus, the expression float64(912) * 0.01 behaves like float64(912) * float64(0.01). 0.01 is not exactly representable in a float64, thus precision is lost in a different place than in the expression float64(912 * 0.01) which arises in the argument of fmt.Println() in your first example, explaining the different results.
",27819137
437,27853130,"As background, Go doesn't come with the zlib library, and compress/zlib is only has its name 'cause it works with zlib format data. Though the format's the same, the details of the compression algorithm aren't (leading, for example, to worse speed and slightly worse compression for the Go library). So output won't typically match, even at the same compression level and with the same wrapper.

The answer from an author of zlib (Mark Adler) raises the essential point that different output doesn't mean the output can't be decompressed by zlib. I think that's your real answer here, but leaving the rest of this around because it has some non-overlapping information about what Go's doing/your options in Go.



The Vitess project (YouTube's internal MySQL proxy) needed the speed of C zlib for their application, so they wrote an adapter, cgzip. You didn't say what format you wanted the output in; if the answer is not gzip, you'll have to fork and modify cgzip so it calls the right bits of zlib to produce what you need.

The upside of using cgzip or similar is that it'll act like zlib because it's using zlib. The downside is that you'll no no longer have a pure-Go app, so you lose the trivial cross-compiles and gain an additional dependency on the environment your program's built and run in (though in zlib's case, the ubiquity and stable API mean it's much less of an issue to take it as a dep than some libraries).
",27852940
438,27853778,"Just because the compressed data is different doesn't mean that it can't be decompressed.  zlib-compliant compressed data generated anywhere can be decompressed by a compliant zlib decoder anywhere else.  Did you try decompressing?

As for the difference, @twotwotwo points out that compress/zlib in Go is not the original zlib library, but rather a different implementation written in Go.  So it would be expected to generate different output if it uses different algorithms to find matches and/or emit blocks.
",27852940
439,27871599,"There is an updated version of the package on github

You use it by wrapping an io.Reader

Here is a complete example which will show the homepage of Google veeeery sloooowly.

This wrapping an interface to make new functionality is very good Go style, and you'll see a lot of it in your journey into Go.

package main

import (
    ""io""
    ""log""
    ""net/http""
    ""os""

    ""github.com/mxk/go-flowrate/flowrate""
)

func main() {
    resp, err := http.Get(""http://google.com"")
    if err != nil {
        log.Fatalf(""Get failed: %v"", err)
    }
    defer resp.Body.Close()

    // Limit to 10 bytes per second
    wrappedIn := flowrate.NewReader(resp.Body, 10)

    // Copy to stdout
    _, err = io.Copy(os.Stdout, wrappedIn)
    if err != nil {
        log.Fatalf(""Copy failed: %v"", err)
    }
}

",27869858
440,27878678,"Thirdparty packages have convenient wrappers. But if you interested in how things work under the hood - it's quite easy.

package main

import (
    ""io""
    ""net/http""
    ""os""
    ""time""
)

var datachunk int64 = 500       //Bytes
var timelapse time.Duration = 1 //per seconds

func main() {
    responce, _ := http.Get(""http://google.com"")
    for range time.Tick(timelapse * time.Second) {
        _, err :=io.CopyN(os.Stdout, responce.Body, datachunk)
        if err!=nil {break}
    }
}


Nothing magic.
",27869858
441,27933786,"Is an inplace bitwise OR operator https://golang.org/ref/spec#Operators.

There are many others:

+    &     +=    &=     &&    ==    !=        
-    |     -=    |=     ||    <     <=        
*    ^     *=    ^=          >=        
/    <<    /=    <<=    ++    =     :=        
%    >>    %=    >>=    --    !            
&^   &^=

",27933739
442,27949612,"Prepared statement already bound to concrete connection to DB, contains low-level driver.Stmt and can be used concurrently by multiple go-routings. So it's quite handy to prepare and use, and things work faster.
",27948469
443,27950620,"I think the best answer comes from the wikipedia article on Prepared Statements.

Quoting: 


  The overhead of compiling and optimizing the statement is incurred
  only once, although the statement is executed multiple times. Not all
  optimization can be performed at the time the prepared statement is
  compiled, for two reasons: the best plan may depend on the specific
  values of the parameters, and the best plan may change as tables and
  indexes change over time.`enter code here
  
  Prepared statements are resilient against SQL injection, because
  parameter values, which are transmitted later using a different
  protocol, need not be correctly escaped. If the original statement
  template is not derived from external input, SQL injection cannot
  occur.

",27948469
444,27985538,"You need to pass a pointer to WrapObj to the findKFromLastRecr() function.

Similar to the languages in the C family, everything in Go is passed by value. That is, a function always gets a copy of the thing being passed, as if there were an assignment statement assigning the value to the parameter.

For instance, passing a WrapObj value to a function makes a copy of the WrapObj, but not the WrapObj it points to.

Therefore, without a pointer to WrapObj, each findKFromLastRecr() function gets a copy of WrapObj and the increase can not be shared by the outer findKFromLastRecr() functions.

It could be useful to check the pointers section from golang-book.

package main    
import (
    ""container/list""
    ""fmt""
)

var sMap map[int]bool

func main() {
    l := list.New()
    for i := 1; i < 100; i++ {
        l.PushBack(i)
    }    
    kFromLastElemRec := findKFromLastRecr(l.Front(), 3, &WrapObj{0})
    fmt.Println(kFromLastElemRec.Value.(int))    
}
//Object to store the count 
type WrapObj struct {
    count int
}
//ERROR
//recursive function to find the kth from last element
func findKFromLastRecr(head *list.Element, k int, wrapper *WrapObj) *list.Element {
    if head == nil {
        return nil
    }

    resNode := findKFromLastRecr(head.Next(), k, wrapper)
    wrapper.count = (wrapper.count) + 1
    if wrapper.count == k {
        return head
    }
    return resNode
}


Output

97

",27984992
445,27986874,"The range variant of the for loop is not extendable to custom collections that are not just renamed slices, maps, strings, or channels. There is no Ranger interface or anything like that. If you want to range over a custom type, consider using a for-loop like this:

for x, eof := col.Next(); x, eof = col.Next(); !eof {
    // ...
}


where Next() is a method that iterates through your collection with a signature like this:

func (*MyCollection) Next() (ItemType x, bool eof)

",27986534
446,27995703,"It is not possible to construct a loop using the container/list List type. The List type methods ensure that there's no loop. Because the list Element's next and previous pointers are not exported, the application cannot create a loop by modifying the elements directly.

You can define your own type to create a list with a loop:

package main

import ""fmt""

type node struct {
    v    int
    next *node
}

func main() {
    // Create list with 1, 2, 3 and print.

    l := &node{1, &node{2, &node{3, nil}}}
    for n := l; n != nil; n = n.next {
        fmt.Println(n.v)
    }

    // Create list with loop and print at most 100 steps down the list.

    n3 := &node{3, nil}
    l = &node{1, &node{2, n3}}
    n3.next = l

    for i, n := 0, l; n != nil && i < 100; n, i = n.next, i+1 {
        fmt.Println(n.v)
    }

}


playground example
",27995531
447,28008290,"The source to tools/pos.go called by ParseQueryPos says

// parsePosFlag parses a string of the form ""file:pos"" or
// file:start,end"" where pos, start, end match #%d and represent byte
// offsets, and returns its components.


If you really had to convert from line:column strings, you'd look at the file contents and count up bytes (including newlines) leading to that line:column. But since you're working with a token.Position, it looks like you can get what you need from token.Position.Offset.
",28008164
448,28023772,"string is one of the predeclared type in the builtin package.

Those functions in strings couldn't have been defined as method using a predeclared type as a receiver: that would have required to define a type alias (to the underlying type string, in order to attach methods to it).  

A method declaration uses a receiver which has a Type, which in turn does not include any of the predeclared types (bool byte complex64 complex128 error float32 float64 int int8 int16 int32 int64 rune string uint uint8 uint16 uint32 uint64 uintptr).

Or (which is done here), one uses functions in a dedicated package 'strings'.
That seems coherent with the fact that the type string itself has no fields: its content doesn't have to ""receive"" the method, it can simply be used by a function.
",28023566
449,28023872,"The short answer is: ""To keep the language simple.""

Go as a language only allows methods to be defined on types that are in the same package, but because string (like other builtin types) is implemented in the language itself, there is no way to add methods to it, without complicating the language / compiler.

It's also partly, because of how Go was designed.

See this mail from Rob Pike (one of the creators of Go) for more information:


  Go does not have methods on basic types because the designers of the 
  language did not want methods defined for basic types, in part because 
  of the knock-on effect they might have on interfaces. I believe we are 
  all still comfortable with that decision. Others may feel differently. 
  
  -rob 


And this one too:


  We simply didn't understand what the implications would be; there's 
  nothing to explain. Go was designed with caution. 
  
  In that vein, look at the size of the strings library. Making all that 
  functionality methods on the basic type would, as Andrew said, 
  complicate the language. Why complicate the language with such trivial 
  things when it can be achieved by a library, which is more 
  maintainable, easier to extend, and more flexible? The language is 
  much simpler the way things are. 
  
  -rob 

",28023566
450,28034936,"It's not pretty, but you can use the w32 binding: (github.com/AllenDang/w32)

package main

import (
    ""fmt""
    ""github.com/AllenDang/w32""
    ""unsafe""
)

func GetProcessName(id uint32) string {
    snapshot := w32.CreateToolhelp32Snapshot(w32.TH32CS_SNAPMODULE, id)
    if snapshot == w32.ERROR_INVALID_HANDLE {
        return """"
    }
    defer w32.CloseHandle(snapshot)

    var me w32.MODULEENTRY32
    me.Size = uint32(unsafe.Sizeof(me))
    if w32.Module32First(snapshot, &me) {
        return w32.UTF16PtrToString(&me.SzModule[0])
    }

    return """"
}

func ListProcesses() []uint32 {
    sz := uint32(1000)
    procs := make([]uint32, sz)
    var bytesReturned uint32
    if w32.EnumProcesses(procs, sz, &bytesReturned) {
        return procs[:int(bytesReturned)/4]
    }
    return []uint32{}
}

func FindProcessByName(name string) (uint32, error) {
    for _, pid := range ListProcesses() {
        if GetProcessName(pid) == name {
            return pid, nil
        }
    }
    return 0, fmt.Errorf(""unknown process"")
}

func main() {
    fmt.Println(FindProcessByName(""chrome.exe""))
}

",28033957
451,28047625,"You cannot, but if they are the same length you can use the index from range.

package main

import (
    ""fmt""
)

func main() {
    r1 := []int{1, 2, 3}
    r2 := []int{11, 21, 31}

    for i, _ := range r1 {
        fmt.Println(r1[i])
        fmt.Println(r2[i])
    }
}


It returns

1
11
2
21
3
31

",28047311
452,28047701,"If your slices are the same length, use range like this:

for i := range x {
    fmt.Println(x[i], y[i])
}

",28047311
453,28084332,"You should double check your 'client_secret' and 'client_id' (must be right because you get the code) if it is correct, apparently Github returns HTTP status code 404 if it is wrong.
",28083629
454,28085169,"You are generating empty JSON objects. Your struct fields should start in capitals for the JSON encoder to be able to encode them.

type goodparam struct {
    Code         string `json:""code""`
    ClientId     string `json:""client_id""`
    ClientSecret string `json:""client_secret""`
}


See this in action.
",28083629
455,28197489,"If you import a package with _ as first argument, you cannot use any function or type of that package. _ means that you are importing the package only for its secondary effects of calling the init() functions. 

In addition, you need to use the package name before the function, mapstructure.Decode in this case.

Alternatively, as pointed out by Ainar-G, you may use ""."" instead of _ when importing the package. This way you will be importing the names to the ""default"" namespace, allowing to use Decode directly. However, this is not recommended because you are polluting the namespace with other names and there may be conflicts, now or in the future.
",28197443
456,28301545,"It looks like you are trying to to read from a file and then split the work across multiple workers (fan out). I do not see any closing of channels in your code. See https://gist.github.com/kylewolfe/7c54018a9ed16517c0dd for an example of the pattern I'm referring to. For each line of your file, you would read into the one channel, where x workers would read from it (and reflect / do work).
",28300581
457,28455077,"^(\+|-)?(((\d{1,3}[, ])(\d{3}[ ,])*\d{3})|\d+)( ?[\.,] ?(\d{3}[, ])*\d+)?$


Try with anchors.^$ will disable partial matching.See demo.

https://regex101.com/r/qH1uG3/4
",28454756
458,28472360,"os.Args[1] = ""-conf=my.conf""

flag.Parse()

Notice that the config file name is hard-coded.
",21350962
459,28506418,"One of the most common needs for context passing is correlating outgoing requests to incoming requests. I have used this for a variety of purposes, for example:


I want error logs for my database component to include the full url from the http request it is a result of.
Incoming http requests contain a set of headers that I need to preserve and pass on to other http services I call downstream (maybe for tracking reasons).
I want to examine the incoming http request in some other component to do access control or user authentication or whatever. This could be at the http handler layer, or some other part of my application.


Many languages and platforms have convenient/magical ways to get the current Http request. C# has HttpRequest.Current which is globally available (via thread local storage) to anyone who wants to know the context of the current http request. You can set arbitrary data on it to communicate various context data. Other platforms have similar facilities.

Since go has no facilities for goroutine local storage, there is no way to store a global variable in the context of the current http request. Instead, it is idiomatic to initialize the context at the boundary of your system (an incoming request), and pass it as an argument to any downstream components that need access to that information. 

One super simple way to do this would be to make a context object with the current http request and pass that around:

func someHandler(w http.ResponseWriter, r * http.Request){
   ctx := context.WithValue(context.Background(),""request"",r)
   myDatabase.doSomething(ctx,....)
}


You can of course limit it to a more targeted set of data you need to pass around rather than the entire request. 

The other thing that the context package helps with (and I think that blog does an ok job of pointing out), is a common framework for timeouts or deadlines. 

Note that the context package does not enforce timeouts for you. It is up to the components receiving a context object to watch the Done channel and self-cancel their own http request or database call or calculation or whatever.

edit - on timeouts

It is extremely useful to be able to manage timeouts from the outside of a component. If I have a database module, I don't need to hardcode timeout values, just be able to handle a timeout triggered from the outside. 

One way I have done this is in a service that makes multiple db / service calls per incoming request. If the total time exceeds 1 second, I want to abort all outbound operations and return a partial or error result. Initializing the context with a timeout at the top level and passing it to all dependencies is a really easy way to manage this.

It is not always pretty for the dependency to listen to the Done channel and abort it's work, but as the blog shows, it is not terribly painful either. 
",28486324
460,28528330,"Without seeing the code to timeoutDial, my wild guess is that you don't close the connection when you're done with it.
",28528060
461,28531524,"To more explicitly state what Not_a_Golfer and OneOfOne have said, when you're done with the response, you need to close the connection which has been left open (through the Body field which is an io.ReadCloser). So basically, one simple though would be to change the code pertaining to making an http request to:

var resp *http.Response
if data.Redirect {
    c := &http.Client{
        Transport: t,
    }
    resp, err = c.Do(req)
} else {
    resp, err = t.RoundTrip(req)
}
if err == nil {
    defer resp.Body.Close() // we need to close the connection
}

",28528060
462,28719641,"Indexing a string indexes its bytes not its runes (a rune is a unicode codepoint).

What you want to do is check the first character (rune) of the string, not its first byte in its UTF-8 encoded form. And for this there is support in the standard library: unicode.IsUpper().

To get the first rune, you can convert the string to a slice of runes, and take the first element (at index 0).

ins := []string{
    ""å/Å/ä/Ä/ö/Ö"",
    ""Å/ä/Ä/ö/Ö""}

for _, s := range ins {
    fmt.Println(s, unicode.IsUpper([]rune(s)[0]))
}


Output:

å/Å/ä/Ä/ö/Ö false
Å/ä/Ä/ö/Ö true

",28719523
463,28786936,"The answer to this self-answered question might help:

Golang write input and get output from terminal process

at least, he mentions in the answer that he ""was able to get ssh access working with a password"", which is not mentioned explicitly in the question - that's why you probably didn't find it while searching the site?
",28786190
464,28791744,"In short, second expression is invalid their types are incompatible.

Every operations in Go, arguments are must be same type. The second expression

template.HTML(""test"") == htmlString


is invalid since it's comparing template.HTML and string. Although template.HTML is driven from string, but it is incompatible. You should cast the variable like template.HTML(htmlString).

But the first expression

template.HTML(""test"") == ""test""


is valid because the type of constant ""test"" interpreted as template.HTML. Untyped constant has default type, but it can be any driven type by context at compile time. This article explains about constant in detail. Maybe this article make your question clear.
",28791568
465,28885389,"RabbitMQ will only return a basic.nack if


  an internal error occurs in the Erlang process responsible for a queue.


So, the basic.ack/basic.nack is only confirming if the RabbitMQ broker received the message, not if a ""final"" consumer did.  See the last sentence of ""Negative Acknowledgement"" on this page.
",28885109
466,28902682,"This logic introduces an infinite recursion:

func (rcv *Session) SetBSON(raw bson.Raw) error {
    return raw.Unmarshal(rcv)
}


Session implements the Setter interface, which means its unmarshaling happens via its SetBSON method, which is implemented by asking the bson package to unmarshal itself, which will do that by calling its SetBSON method. This never ends, until the stack space is over.

The solution is, of course, to not implement custom unmarshaling of Session by just asking the bson package to unmarshal it again. 
",28901604
467,28944539,"Does removing and re go getting google.golang.org/appengine from your GOPATH fixes the issue ?

Edit: Also, a colleague of mine said that after rebooting all went well.
",28188504
468,28984118,"If you look at the documentation of ReadString you will notice that the string returned will include the delimiter (in your case \n).


  ReadString reads until the first occurrence of delim in the input,
  returning a string containing the data up to and including the
  delimiter.


And because the length of the line after reading 10 is 4 I would assume that the lines are delimited by \r\n. The easiest way to remove it is using one of the Trim functions (like TrimSpace).
",28983831
469,28984161,"From the documentation: ""ReadString reads until the first occurrence of delim in the input, returning a string containing the data up to and including the delimiter.""

Because of this, i suggest you use a scanner, which handles this case like you would expect:

scanner := bufio.NewScanner(file)
for scanner.Scan() {
    lineStr := scanner.Text()
    num, _ := strconv.Atoi(lineStr)
    fmt.Println(lineStr, num)
}

",28983831
470,28984217,"Citing the documentation of bufio.Reader.ReadString (emphasis mine):


  ReadString reads until the first occurrence of delim in the input, returning a string containing the data up to and including the delimiter.


Now, the documentation of strconv.ParseInt


  The errors that ParseInt returns have concrete type *NumError and include err.Num = s. If s is empty or contains invalid digits, err.Err = ErrSyntax and the returned value is 0


Your problem is that the ReadString method return also the \n that terminate the line, which is an invalid character for the ParseInt function.

You can check the real error with the following snippet

i, err := strconv.ParseInt(line, 10, 64)
if err != nil {
    switch err.(*strconv.NumError).Err {
        case strconv.ErrSyntax:
            fmt.Println(""syntax error"")
        case strconv.ErrRange:
            fmt.Println(""out of range value"")
    }
}


Advice: use strings.TrimSpace to clean your input.
",28983831
471,29166419,"Like that

package main

import (
    ""encoding/json""
    ""fmt""
)

func main() {
    data := make(map[string]string)
    data[""a""] = ""b""
    data[""c""] = ""d""
    bytes, err := json.Marshal(data)
    if err != nil {
        fmt.Println(err)
        return
    }
    text := string(bytes)
    fmt.Println(text)
}


Playground
",29165973
472,29190369,"The program stops receiving on the channels when a difference is detected. 

The walk goroutines run until they block sending to the channels. They never exit. This is the leak.
",29190333
473,29269960,"
  The Go Programming Language Specification
  
  Close
  
  For a channel c, the built-in function close(c) records that no more
  values will be sent on the channel.
  After calling close, and after any previously sent values have been
  received, receive operations will return the zero value for the
  channel's type without blocking.


In the channel buffer there are 5 previously sent values followed by a close.

For example,

package main

import (
    ""fmt""
    ""sync""
    ""time""
)

func main() {
    iCh := make(chan int, 99)
    var wg sync.WaitGroup
    go func() {
        for i := 0; i < 5; i++ {
            wg.Add(1)
            go func(i int) {
                defer wg.Done()
                iCh <- i
            }(i)

        }
        wg.Wait()
        close(iCh)
    }()

    time.Sleep(5 * time.Second)
    fmt.Println(""previously sent values"", len(iCh))
    for i := range iCh {
        fmt.Printf(""%v\n"", i)
    }
    print(""the channel should be closed by now\n"")
    print(""done"")
}


Output:

previously sent values 5
0
1
2
3
4
the channel should be closed by now
done

",29269850
474,29270134,"I should have sent s from getS. Code below

package main

import ""time""

func main() {

    //simple function and complex function/channel
    sC := make(chan string)
    go getS(sC)

    cC := make(chan string)
    go getC(sC, cC)

    //collect the functions result

    s := <-sC
    //do something with `s`. We print but we may want to use it in a `func(s)`
    print(s)
    //after a while we do soemthing with `c`
    c := <-cC

    print(c)
}

func getS(sC chan string) {
    s := "" simple completed \n""
    sC <- s
    print(""sent s back so that main can read it too"")
    sC <- s
}

func getC(sC chan string, cC chan string) {
    time.Sleep(1 * time.Second)
    //we do some complex stuff
    print(""complex is not complicated\n"")
    //Now  we need the simple value so we try wait for the s channel.
    s := <-sC


    c := s + "" more ""
    cC <- c //send complex value
}

",22882934
475,29284050,"Im not familiar with mustache but from looking at it I think the {{#DataKey}} is wrong.

From the docs:

Template:

{{#repo}}
  {{name}}
{{/repo}}


Hash:

{
  ""repo"": [
    { ""name"": ""resque"" },
    { ""name"": ""hub"" },
    { ""name"": ""rip"" }
  ]
}


Output:

resque
hub
rip


I'd suggest trying the following

viewModel := struct{
    items []DataKey{}
}{
    data
}

mustache.RenderFileInLayout(""templates/datakeys.html.mustache"", ""templates/layout.html.mustache"", user, viewModel )))


and then replace the template with

{{#items}}
    
        {{Id}}
        {{UserId}}
        {{Data}}
        {{CreatedAt}}
    
{{/items}}


This is untested and might not be correct, but might be worth trying. My guess is that DataKey isn't a property on the model hence it's failing to evaluate.

Edit for more clarity: In theory

viewModel := struct{
    items []DataKey{}
}{
    data
}


will become

{
    ""items"": [
        {...},{...} ... etc
    ]
}

",29282728
476,29288854,"When you upload/deploy your application, application files and static files are stored separately. Static files are served by specialized/dedicated servers, not by your frontend instances.

That means if you have a file which you want to read from your Go code, that file must not match any static file pattern and cannot be in a folder specified as a static directory, else the file will be considered a static file and will not be deployed next to your Go code.

This is detailed on the Application configuration page, Section Static file handlers. Quoting the relevant part:


  For efficiency, App Engine stores and serves static files separately from application files. Static files are not available in the application's file system. If you have data files that need to be read by the application code, the data files must be application files, and must not be matched by a static file pattern.


If there is a file which you want to be both a static file and an application file, you have 2 options:

1) You may duplicate it, e.g. put it next to your code and to a separate folder (e.g. static) which you can mark as a static dir.

Or (preferred):

2) Specify the application_readable option to the static file handler which includes/applies to the file. Quoting from the documentation:


  Optional. By default, files declared in static file handlers are uploaded as static data and are only served to end users, they cannot be read by an application. If this field is set to true, the files are also uploaded as code data so your application can read them. Both uploads are charged against your code and static data storage resource quotas.

",29285670
477,29323726,"The fact is that a channel without a buffer, called synchronous, will block both the sender and the receiver until they can complete their exchange.

Much like if you had to hand over something to your mate and you both knew the meeting place, but not the time. The first one to get there will wait for the other, whether it's the sender or the receiver. Now, given that computers are stupid :-) if one of them forgets about the appointment, the other will verily wait forever.

The specific bug here is that when the select chooses the time.After (that is, the timeout occurs) nobody will be there to receive from  anymore. Not ever. So the poor go func() will sit there forever, waiting for someone to take her *Response, but nobody will ever show up.

This does not actually waste any CPU power, but it wastes memory: that needed to keep track of the channel, of the goroutine, of her stack—however small—and her local variables. The memory will never be reclaimed until the entire process terminates or is killed.

In a server, serving a lot of clients, this will build up quickly until the application eats all the memory of the server and—if you're lucky—gets killed by the OS safety measures, without taking down the entire machine.

Using a buffered channel is one way to solve the issue, because then, whenever the poor go func() has her *Response ready, she will be able to store it into the channel's buffer, even if nobody is there to get it, and terminate peacefully. As soon as that happens, Go's garbage collector will notice that no live goroutine is holding any pointers to that channel anymore, so it will collect the channel and the *Response it points to and recycle all those bytes.
",29323560
478,29378153,"For example,

package main

import (
    ""bytes""
    ""io""
)

var items []*bytes.Buffer

func f(items []io.Reader) {}

func main() {
    readers := make([]io.Reader, len(items))
    for i, item := range items {
        readers[i] = item
    }
    f(readers)
}

",29377477
479,29404617,"Similar to peterSO's answer.

package main

import (
    ""bytes""
    ""io""
)

type Foo struct{}
type Foos []Foo


func (f Foos) toReaders() []io.Reader {
    readers := make([]io.Reader, len(f))
    for i, item := range f {
        readers[i] = item
    }
    return  readers
}

func f(items []io.Reader) {}

func main() {
    var x Foos
    f(x.toReaders())
}

",29377477
480,29422795,"DeepEqual returns false because you're comparing two instances of a type which is not comparable. Type ResultResponse is not comparable because not all of its fields are comparable. The Result field is a slice and slices are specified by the language to be not comparable.
",29422602
481,29428932,"I think it is an editing mistake.I guess that What you want to code is:  

""reflect.DeepEqual(p, want)""


but you actually wrote:

""reflect.DeepEqual(input, want)""

",29422602
482,29431214,"I had to run an application as root (to open a webserver on port 80), this produced the error for me, because the sudo user has a different environment than the normal user, hence GOPATH was not set.

If someone else is having this problem, add -E to the command, this will preserve the user environment.

sudo -E go run main.go

For more infos see discussion here: Google Groups – GOPATH Problem
",20628918
483,29444890,"Type assertions return two values .. the first is the converted value, the second is a bool indicating if the type assertion worked properly.

So you could do this:

_, ok := x.(int)

if ok {
    fmt.Println(""Its an int"")
} else {
    fmt.Println(""Its NOT an int"")
}


..or, shorthand:

if _, ok := x.(int); ok {
    fmt.Println(""Its an int"")
}


See it in the playground
",29444817
484,29444894,"I just figured out another way of doing this based on this:

if _, ok := x.(int); ok {
    fmt.Println(""This is an int"")
}

",29444817
485,29444964,"In Effective Go you can find a really simple example of what you're trying to achieve. 

var t interface{}
t = functionOfSomeType()

switch t := t.(type) {
default:
    fmt.Printf(""unexpected type %T"", t)       // %T prints whatever type t has
case bool:
    fmt.Printf(""boolean %t\n"", t)             // t has type bool
case int:
    fmt.Printf(""integer %d\n"", t)             // t has type int
case *bool:
    fmt.Printf(""pointer to boolean %t\n"", *t) // t has type *bool
case *int:
    fmt.Printf(""pointer to integer %d\n"", *t) // t has type *int
}


If you have a single type that you have to check, use a simple if, otherwise use a switch for better readability.
",29444817
486,29447927,"I'm not seeing the error, but I did notice some issues with the code. For this:

w.Header().Set(""Content-Type"", r.Header.Get(""Content-Type""))


You should use the mime package's:

func TypeByExtension(ext string) string


To determine the content type. (if you end up with the empty string default to application/octet-stream)

For:

w.Header().Set(""Content-Length"", r.Header.Get(""Content-Length""))


You need to get the content length from the file itself. By using the request content length, for a GET this basically ends up as a no-op, but for a POST you're sending back the wrong length, which might explain the error you're seeing. After you open the file, do this:

fi, err := file.Stat()
if err != nil {
    http.Error(w, err.Error(), 500)
    return
}
w.Header().Set(""Content-Length"", fmt.Sprint(fi.Size()))


One final thing, when you open the file, if there's an error, you don't need to close the file handle. Do it like this instead:

file, err := os.Open(...)
if err != nil {
    http.NotFound(w, r)
    return
}
defer file.Close()

",29445173
487,29450292,"Rather than mucking around with getting the correct the content type and length headers yourself it'd probably be much better to use http.ServeContent which will do that for you (as well as support ""If-Modified-Since"", range requests, etc. If you can supply an ""ETag"" header it can also handle ""If-Range"" and ""If-None-Match"" requests as well).

As mentioned previously, it's often preferable to limit on the write side but it's awkward to wrap an http.ResponseWriter since various http functions also check for optional interfaces such as http.Flusher and http.Hijacker. It's much easier to wrap the io.ReadSeeker that ServeContent needs.

For example, something like this perhaps:

func pathFromID(fileID string) string {
    // replace with whatever logic you need
    return ""../../bin/files/test.txt""
}

// or more verbosely you could call this a ""limitedReadSeeker""
type lrs struct {
    io.ReadSeeker
    // This reader must not buffer but just do something simple
    // while passing through Read calls to the ReadSeeker
    r io.Reader
}

func (r lrs) Read(p []byte) (int, error) {
    return r.r.Read(p)
}

func newLRS(r io.ReadSeeker, bucket *ratelimit.Bucket) io.ReadSeeker {
    // Here we know/expect that a ratelimit.Reader does nothing
    // to the Read calls other than add delays so it won't break
    // any io.Seeker calls.
    return lrs{r, ratelimit.Reader(r, bucket)}
}

func serveFile(w http.ResponseWriter, req *http.Request) {
    fileID := req.URL.Query().Get(""fileID"")
    if len(fileID) == 0 {
        http.Error(w, ""invalid request"", http.StatusBadRequest)
        return
    }

    path := pathFromID(fileID)
    file, err := os.Open(path)
    if err != nil {
        http.NotFound(w, req)
        return
    }
    defer file.Close()
    fi, err := file.Stat()
    if err != nil {
        http.Error(w, ""blah"", 500) // XXX fixme
        return
    }

    const (
        rate     = 100 << 10
        capacity = 100 << 10
    )
    // Normally we'd prefer to limit the writer but it's awkward to wrap
    // an http.ResponseWriter since it may optionally also implement
    // http.Flusher, or http.Hijacker.
    bucket := ratelimit.NewBucketWithRate(rate, capacity)
    lr := newLRS(file, bucket)
    http.ServeContent(w, req, path, fi.ModTime(), lr)
}

",29445173
488,29504544,"stdlib version

package main

import (
    ""log""
    ""net/http""
    ""net/http/httputil""
    ""net/url""
)

func main() {
    target, err := url.Parse(""http://192.168.2.8:8000"")
    if err != nil {
        log.Fatal(err)
    }
    http.Handle(""/users/"", http.StripPrefix(""/users/"", httputil.NewSingleHostReverseProxy(target)))
    http.Handle(""/public/"", http.StripPrefix(""/public/"", http.FileServer(http.Dir(""./Documents""))))
    log.Fatal(http.ListenAndServe("":8080"", nil))
}


Wrap http.StripPrefix with a function that logs before calling it if you need logging.
",29476611
489,29621608,"My bad, I should read the response.Body first, for example:

response, err = client.Get(`https://accounts.google.com/.well-known/openid-configuration`)
body, err := ioutil.ReadAll(response.Body)
response.Body.Close()


According to this document, we should fetch from that URL first, then fetch from userinfo_endpoint from the result above to retrieve the e-mail, for example:

// json := json_to_map(body)
// get json[`userinfo_endpoint`]
// response, err = client.Get(json[`userinfo_endpoint`])
// body, err := ioutil.ReadAll(response.Body)
// response.Body.Close()
// json = json_to_map(body)
// json[`email`]


For the second question, the oauth2.Config struct is reusable.
",29620344
490,29654409,"As noted by the people in the comments to your question, it's implementation-specific.

gc does remove it. You can build your program with -gcflags '-S' and see that the ASSERT part is not in the binary.

E.g. compile the following code with -gcflags '-S', and you'll see that the code on lines 8 and 9 is included, but change Assert to be false, and they won't be there in the asm listing.

package main

const Assert = true

var cond = true

func main() {
    if Assert && !cond {
        panic(""failed"")
    }
}


EDIT:

As for gccgo, it removes this code at -O1 and above. You can see it by compiling the same code with

go build -compiler gccgo -gccgoflags '-O1' main.go


and then doing

objdump -S main


to see the annotated assembly.
",29654175
491,29659664,"This is actually the intended behavior,

You can even call go get on a github repo and it will create this same directory structure
",29659626
492,29659794,"The behavior is correct. The packages names in Go provide unique global name space. 

github.com/user/repo therefore identifies a package, which is easily go get -able (download and install the package) and also provides much needed separation. You can also create packages without a hostname (in this case github.com) but effectively preventing users from using go get and resorting to manual management.

Having a username in GitHub case allows you to use forks of other libraries and maintain the separation. The full package name is then used for importing

import ""github.com/user/repo""

",29659626
493,29670260,"The regexp does not accept digits, s/[a-z ]/[a-z0-9 ]/

http://play.golang.org/p/ov_zoxBenV
",29669835
494,29670299,"First off, the pattern will not match the digits. You might want to change it to:

var re = regexp.MustCompile(`query=""(.*)""`)


Then, in order to get the substring, you can just use FindStringSubmatch:

match := re.FindStringSubmatch(`query=""tag1 tag2""`)
if len(match) == 2 {
    fmt.Printf(""Found: [%s]\n"", match[1])
} else {
    fmt.Println(""No match found"", match)
}


Output:


  Found: [tag1 tag2]


Then, in order to split the string into seperate tags, I recommend using strings.Split
",29669835
495,29670705,"It only unmarshals exported and thus Caps fields. Also Loc shouldn't be a struct but can be a string directly.

package main

import (
    ""encoding/xml""
    ""fmt""
)

type Query struct {
    XMLName xml.Name `xml:""urlset""`
    Locs    []Loc    `xml:""url>loc""`
}

type Loc string

var data = []byte(`

   http://www.konga.com/mobile-recharge
   2015-04-14
   daily
   0.5


   http://www.konga.com/beauty-health-personal-care
   2015-04-14
   daily
   0.5

`)

func main() {

    var q Query
    xml.Unmarshal(data, &q)
    fmt.Println(q.Locs)
}

",29670462
496,29674185,"You can extract the whole tag string and then Split() it.

package main

import (
    ""fmt""
    ""regexp""
    ""strings""
)

func main() {
    var str string = `query=""tag1 tag2 tag3"" foo=""wee""`
    re := regexp.MustCompile(`query=""(.+?)""`)
    match := re.FindStringSubmatch(str)

    if len(match) == 2 {
        fmt.Println(strings.Split(match[1], "" ""))
    }
}


Output: [tag1 tag2 tag3]
",29669835
497,29738472,"Each map value is a pointer to the single local variable thing.

One fix is to add an pointer to the slice element:

func toRegistry(things []Thing) Registry {

  registry := make(Registry)

  for i := range things {
    registry[things[i].Name] = &things[i]
  }
  return registry
}


playground

Another option is to store pointers to Thing in the slice:

func toRegistry(things []*Thing) Registry {
  registry := make(Registry)
  for _, thing := range things {
    registry[thing.Name] = thing
  }
  return registry
}

func main() {
  things := []*Thing{&Thing{""thingA"", 1}, &Thing{""thingB"", 2}}
  registry := toRegistry(things)
  fmt.Println(registry)
}


playground

I changed the function argument from a pointer to a slice to a slice. This change has no impact on the issue raised on the question, but it's generally how Go code is written. Pointers to slices are rarely used in Go.
",29738391
498,29738513,"You may reassign thing to another local variable on each iteration and store new variable in registry.

package main

import ""fmt""

type Thing struct {
    Name  string
    Value int
}

type Registry map[string]*Thing

func toRegistry(things *[]Thing) Registry {

    registry := make(Registry)

    for _, thing := range *things {
        t := thing
        registry[thing.Name] = &t
    }
    return registry
}

func main() {

    things := []Thing{{""thingA"", 1}, {""thingB"", 2}}
    registry := toRegistry(&things)
    fmt.Println(registry)

}


Playground
",29738391
499,29840479,"Until I see more information, this is simply a guess based on what I could gather from the code you posted.

The call

res.Body.Close()


should come after your check for error, not before.  So change:

 res, err := httpClient.Do(req)
 defer res.Body.Close()
 if err != nil {
     ...
 }


to 

 res, err := httpClient.Do(req)
 if err != nil {
     ...
 }
 defer res.Body.Close()

",29840375
500,29841190,"Converting Simple strings

The easiest way is to use the strconv.Atoi() function.

Note that there are many other ways. For example fmt.Sscan() and strconv.ParseInt() which give greater flexibility as you can specify the base and bitsize for example. Also as noted in the documentation of strconv.Atoi():


  Atoi is shorthand for ParseInt(s, 10, 0).


Here's an example using the mentioned functions (try it on the Go Playground):

flag.Parse()
s := flag.Arg(0)

if i, err := strconv.Atoi(s); err == nil {
    fmt.Printf(""i=%d, type: %T\n"", i, i)
}

if i, err := strconv.ParseInt(s, 10, 64); err == nil {
    fmt.Printf(""i=%d, type: %T\n"", i, i)
}

var i int
if _, err := fmt.Sscan(s, &i); err == nil {
    fmt.Printf(""i=%d, type: %T\n"", i, i)
}


Output (if called with argument ""123""):

i=123, type: int
i=123, type: int64
i=123, type: int


Parsing Custom strings

There is also a handy fmt.Sscanf() which gives even greater flexibility as with the format string you can specify the number format (like width, base etc.) along with additional extra characters in the input string.

This is great for parsing custom strings holding a number. For example if your input is provided in a form of ""id:00123"" where you have a prefix ""id:"" and the number is fixed 5 digits, padded with zeros if shorter, this is very easily parsable like this:

s := ""id:00123""

var i int
if _, err := fmt.Sscanf(s, ""id:%5d"", &i); err == nil {
    fmt.Println(i) // Outputs 123
}

",4278430
501,29873144,"The closest thing you will get to do it without adding a lot of printf's is using godebug, which pretty much adds the printfs for you.
",29871585
502,29873754,"You are correct in assesing that the arguments to a deferred function are evaluated at the point the defer is queued, not when it is executed. 

Your method of making an anonymous function that refers to named returns is valid. Another approach is to pass in the address of the return values:

func try() (i int) {
    defer printReturns(time.Now(), &i)
    time.Sleep(10 * time.Millisecond)
    i = 10
    return i + 1
}

func printReturns(start time.Time, rets ...interface{}) {
    fmt.Println(time.Now().Sub(start))
    for _,ret := range rets{
        fmt.Println(ret)
    }
}


The problem with this approach is that your logging function now has a pointer instead of the real type and must unwrap the pointers to do anything with them. But if you are using reflect, that is not horribly difficult.
",29871585
503,29885554,"urlfetch.Client(ctx) returns an HTTP client (http://godoc.org/google.golang.org/appengine/urlfetch#Client)

The http.Client has methods for Get, Post, etc... It also has Do which you can hand an arbitrary request. Create a request using http.NewRequest:

req, err := http.NewRequest(""GET"", ""http://www.google.com"", nil)


Then you can add a header like this:

req.Header.Set(""Authorization"", ""whatever"")


And call Do:

res, err := client.Do(req)

",29871954
504,29948833,"Maybe this will do what you want. Disclaimer: I am not an expert in openpgp; I don't know whether this is correct or not. But it does work with gpg --import.

package main

import (
        ""fmt""
        ""os""

        ""golang.org/x/crypto/openpgp""
        ""golang.org/x/crypto/openpgp/armor""
)

func main() {
        var e *openpgp.Entity
        e, err := openpgp.NewEntity(""itis"", ""test"", ""itis@itis3.com"", nil)
        if err != nil {
                fmt.Println(err)
                return
        }

        // Add more identities here if you wish

        // Sign all the identities
        for _, id := range e.Identities {
                err := id.SelfSignature.SignUserId(id.UserId.Id, e.PrimaryKey, e.PrivateKey, nil)
                if err != nil {
                        fmt.Println(err)
                        return
                }
        }

        w, err := armor.Encode(os.Stdout, openpgp.PublicKeyType, nil)
        if err != nil {
                fmt.Println(err)
                return
        }
        defer w.Close()

        e.Serialize(w)
}

",29929750
505,29962554,"You could use the PortAudio Go bindings (go get github.com/gordonklaus/portaudio) for this.

You will have to build or install PortAudio on your system. Consult http://portaudio.com/docs/v19-doxydocs/tutorial_start.html for this.

A complete example for playing back a sound file is located at https://github.com/gordonklaus/portaudio/blob/master/examples/play.go
",28591664
506,30046137,"The gob package seems like a good solution for your problem. There is a great article on the Go blog that explains how and why. A short excerpt:


  The gob package was designed with a number of goals in mind.
  
  First, and most obvious, it had to be very easy to use. First, because
  Go has reflection, there is no need for a separate interface
  definition language or ""protocol compiler"". The data structure itself
  is all the package should need to figure out how to encode and decode
  it. On the other hand, this approach means that gobs will never work
  as well with other languages, but that's OK: gobs are unashamedly
  Go-centric.
  
  Efficiency is also important. Textual representations, exemplified by
  XML and JSON, are too slow to put at the center of an efficient
  communications network. A binary encoding is necessary.
  
  Gob streams must be self-describing. Each gob stream, read from the
  beginning, contains sufficient information that the entire stream can
  be parsed by an agent that knows nothing a priori about its contents.
  This property means that you will always be able to decode a gob
  stream stored in a file, even long after you've forgotten what data it
  represents.


Further down the article is an example that shows how easy it is to use and how versatile it is.
",30041461
507,30106057,"You can use a map:

example := map[string]interface{}{ ""Key1"": 123, ""Key2"": ""value2"" }
js, _ := json.Marshal(example)


You can also create types inside of a function:

func f() {
    type Example struct { }
}


Or create unnamed types:

func f() {
    json.Marshal(struct { Key1 int; Key2 string }{123, ""value2""})
}

",30105798
508,30106093,"You could use an anonymous struct type.

example := struct {
    Key1 int
    Key2 string
}{
    Key1: 123,
    Key2: ""value2"",
}
js, err := json.Marshal(&example)


Or, if you are ready to lose some type safety, map[string]interface{}:

example := map[string]interface{}{
    ""Key1"": 123,
    ""Key2"": ""value2"",
}
js, err := json.Marshal(example)

",30105798
509,30217870,"You're copying your Stream and List values in the Append method.

Either make Append a pointer receiver

func (s *Stream) Append(value interface{}) {


or make Stream.list a *list.List

type Stream struct {
    list *list.List
}

",30217782
510,30233728,"ev.detail.response is just a string response, it is not a parsed json object.

First you need to parse it using JSON.parse() and then you can access its content.

See this Javascript example:

var json = '{""trial-data"":[{""trial"":{""index"": 0}},{""trial"":{""index"":1}}]}'

alert(JSON.parse(json)['trial-data'])


To access the value of the first ""index"" field, for example:

var idx0 = JSON.parse(json)['trial-data'][0]['trial']['index']

",30233217
511,30237486,"With all RDBMS, the SQL standard mandates that a condition involving a comparison with a NULL value is always false. The following query therefore always returns an empty result:

select * from XXX where deleted_at = NULL


If you want to search for NULL values, you are supposed to write:

select * from XXX where deleted_at is null


I think you can fix the issue by making sure GORM generates the correct query. For instance, this should work (untested):

db.Where(""deleted_at is null"").Find(&users)

",30234610
512,30242906,"The C header file foo.h is missing:

// foo.h
int fortythree();


Reference the header file from Go like this:

// foo.go
package main

/*
#include ""foo.h""

int fortytwo() {
    return 42;
}
*/
import ""C""
import ""fmt""

func main() {
    fmt.Printf(""forty-two == %d\n"", C.fortytwo())
    fmt.Printf(""forty-three == %d\n"", C.fortythree())
}


Behold, the power of foo.h:

$ go install
$ foo
forty-two == 42
forty-three == 43

",30242905
513,30290367,"You cannot cast pointers to arbitrary types in Go. If you really want to do that, you should use unsafe.Pointer:

type varAttrib1b struct {
    vaHeader uint8
    vaData   []string
}

func varAttIs1B(ptr uintptr) bool {
    return ((*varAttrib1b)(unsafe.Pointer(ptr)).vaHeader & 0x01) == 0x01
}


It compiles and works, but are you sure there is no safe way of doing that in go? Can't you just define an interface:

type Attr interface {
    AttrIs1B() bool
}

func (b varAttrib1b) AttrIs1B() bool {
    return b.vaHeader & 0x01 == 0x01
}

func varAttIs1B(attr Attr) bool {
    return attr.AttrIs1B()
}


Or implement it with type casts?

func varAttIs1B(ptr interface{}) bool {
    switch a := ptr.(type) {
    case varAttrib1b:
        return a.vaHeader & 0x01 == 0x01
    }
    return false
}

",30287218
514,30340045,"You may want to set the request content type

req.Header.Set(""Content-Type"", ""application/x-www-form-urlencoded"")


reference http://golang.org/src/net/http/client.go?s=14234:14316#L450
",30339877
515,30340071,"
To fix your print output you need to change this:

fmt.Printf(fmt.Sprintf(""%s\n"", nutils.ReaderToString(req.Body)))


Into this:

fmt.Printf(""%s"", fmt.Sprintf(""%s\n"", nutils.ReaderToString(req.Body)))


Or this:

fmt.Println(fmt.Sprintf(""%s\n"", nutils.ReaderToString(req.Body)))

By printing out the request body you are consuming it. Use a TeeReader:

req, _ := http.NewRequest(r.Method, fmt.Sprintf(""%s%s"", apiUrl, u.Path), io.TeeReader(r.Body, os.Stdout))


And get rid of the nutils.ReaderToString call. You can only read once from a Reader (unless it's also a Seeker but then you still need to  Seek it before reusing it)

",30339877
516,30340366,"Got it. The problem was my endpoint in Python's Flask server does not support chunked encoding, which Go's Request insists on.

When I manually specified the ContentLength like req.ContentLength = 25, it worked.

Lesson learnt: It might not always be your Go code be the problem.
",30339877
517,30369694,"Apparently you can't. The Request.Proto field is ignored when making the request by the Client.

Quoting from the doc of http.Request:

// The protocol version for incoming requests.
// Client requests always use HTTP/1.1.
Proto      string // ""HTTP/1.0""



  Client requests always use HTTP/1.1.

",30369575
518,30392103,"
  Is this Go code correct and portable


It is correct, as long as you work with unsigned integers of 64-bit width.

Portability in this case is provided by the sync/atomic packages to the architectures supported by the Go compiler. Note, however, that not all architectures support ""true"" atomic operations on 64-bit wide data. For example, the i386 implementation uses a CAS-loop:

TEXT ·AddUint64(SB),NOSPLIT,$0-20
    // no XADDQ so use CMPXCHG8B loop
    MOVL    addr+0(FP), BP
    TESTL   $7, BP
    JZ  2(PC)
    MOVL    0, AX // crash with nil ptr deref
    // DI:SI = delta
    MOVL    delta_lo+4(FP), SI
    MOVL    delta_hi+8(FP), DI
    // DX:AX = *addr
    MOVL    0(BP), AX
    MOVL    4(BP), DX
addloop:
    // CX:BX = DX:AX (*addr) + DI:SI (delta)
    MOVL    AX, BX
    MOVL    DX, CX
    ADDL    SI, BX
    ADCL    DI, CX

    // if *addr == DX:AX {
    //  *addr = CX:BX
    // } else {
    //  DX:AX = *addr
    // }
    // all in one instruction
    LOCK
    CMPXCHG8B   0(BP)

    JNZ addloop

    // success
    // return CX:BX
    MOVL    BX, new_lo+12(FP)
    MOVL    CX, new_hi+16(FP)
    RET


That may open the question: why not use a struct with a lock? 



Edit to answer question in comments: Yes, using a 32-bit integer would result in actual atomic operations on all Go-supported architectures because they all support XADDL (or analog) to the best of my knowledge.
",30391141
519,30425069,"There is no difference except for the amount of typing you have to do. A good sized program or package can easily have a dozen or more imported packages so why keep typing the same word time and again when you can achieve the same with a pair of ().

Though most people probably use GoImports nowadays anyway.
",30424935
520,30427459,"There is absolutely no difference for a go compiler. The difference is only for a go programmer in how many times he has to copy/type import. You can look at it in the same way as:

func f1(n1, n2, n3 int){
    ...
}


vs

func f1(n1 int, n2 int, n3 int){
    ...
}


or var n1, n2, n3 int vs

var n1 int
var n2 int
var n3 int


both will produce the same result.
",30424935
521,30474723,"http.HandleFunc() can not be used to register a pattern to match a regular expression. In short, the pattern specified at HandleFunc() can match a fixed, rooted path (like /favico.ico) or rooted subtrees (like /images/), longer patterns take precedence over shorter ones. You can find more details at the doc of the ServeMux type.

What you can do is register your handler to a rooted subtree which may be  everything with the / pattern, and inside your handler you can do further regexp matching and routing.

For example:

func main() {
    http.HandleFunc(""/"", route) // Match everything
    http.ListenAndServe("":8080"", nil)
}

var rNum = regexp.MustCompile(`\d`)  // Has digit(s)
var rAbc = regexp.MustCompile(`abc`) // Contains ""abc""

func route(w http.ResponseWriter, r *http.Request) {
    switch {
    case rNum.MatchString(r.URL.Path):
        digits(w, r)
    case rAbc.MatchString(r.URL.Path):
        abc(w, r)
    default:
        w.Write([]byte(""Unknown Pattern""))
    }
}

func digits(w http.ResponseWriter, r *http.Request) {
    w.Write([]byte(""Has digits""))
}

func abc(w http.ResponseWriter, r *http.Request) {
    w.Write([]byte(""Has abc""))
}


Or use an external library like Gorilla MUX.
",30474313
522,30474731,"Golang doesn't have built-in regex support for URL matching. And it's somewhat complicated to implement from scratch.

Maybe using a framework would be a better choice, such as beego or martin, etc.
",30474313
523,30489243,"I think import ""github.com/rdegges/ipify-api/api"" is being built from the copy on Github, not from the local copy. The most recent commit of the api package doesn't have the extraneous fmt statements. Also, the log statement in main.go works fine, as does the fmt.Fprintf already in the api package. Try to verify the api package is getting built from the source you think it is. 

EDIT 6/1/2015: 

All my tests indicate this is a problem stemming from having an internal subpackage, and the remote service having trouble with that. The api package is not getting built from the local copy. fmt.Print works just fine from main.go, and moving GetIP from the api package to the main package lets fmt print just fine to stdout during web requests. 

Basically, all changes made to the local api subpackage are getting ignored.

The EB logs probably say something about which packages are being downloaded remotely; mine did.

I'm not a Godep pro, so maybe a Godep pro can elaborate. But FWIW, it seems like it might be related to this issue, tangentially. It might also be a problem with the remote service not building with godep go build, but like I said, I'm not a Godep pro, so I'm unsure.
",30428926
524,30503061,"MyFunc0 is a function declaration (https://golang.org/ref/spec#Function_declarations)

MyFunc1 is not a function declaration. It is a variable (https://golang.org/ref/spec#Variable_declarations) of type func (see https://golang.org/ref/spec#Function_types, https://golang.org/ref/spec#Function_literals). It has an initial value, but can be changed to hold a different value/function (as long as function signatures match).
",30502933
525,30528755,"After a lot of trial and error, both above answers helped me in coming up with what worked for me. I have static folder in web app's root directory. 

Along with PathPrefix I had to use StripPrefix for getting route to work recursively.

package main

import (
    ""log""
    ""net/http""
    ""github.com/gorilla/mux""
)

func main() {
    r := mux.NewRouter()
    s := http.StripPrefix(""/static/"", http.FileServer(http.Dir(""./static/"")))
    r.PathPrefix(""/static/"").Handler(s)
    http.Handle(""/"", r)
    err := http.ListenAndServe("":8081"", nil)
}


I hope it helps somebody else having problems.
",15834278
526,30559462,"This is kind of the role filled by #cgo pkgconfig: foobar. If the library had been written that way, it would pick up the correct paths from foobar's pkgconfig definition.

I realise its not a direct answer to the question, and that pkgconfig isn't exactly a native windows tool... I'd be interested to hear if any other solutions exist.
",28710276
527,30600955,"If you don't want to use a library (for whatever reason), I knocked this up. It seems to work and can use any specified rune as a delimiter:

import (
    ""strconv""
)

func delimitNumeral(i int, delim rune) string {

    src := strconv.Itoa(i)
    strLen := utf8.RuneCountInString(src)
    outStr := """"
    digitCount := 0
    for i := strLen - 1; i >= 0; i-- {

        outStr = src[i:i+1] + outStr
        if digitCount == 2 {
            outStr = string(delim) + outStr
            digitCount = 0
        } else {
            digitCount++
        }
    }

    return outStr
}


Note: after further testing, this function doesn't work perfectly. I would suggest using the solution posted by @IvanTung, and welcome any edits from anyone who can get mine to work perfectly.
",13020308
528,30620573,"I have this code here that works quite nice and is re-usable.

func ServeStatic(router *mux.Router, staticDirectory string) {
    staticPaths := map[string]string{
        ""styles"":           staticDirectory + ""/styles/"",
        ""bower_components"": staticDirectory + ""/bower_components/"",
        ""images"":           staticDirectory + ""/images/"",
        ""scripts"":          staticDirectory + ""/scripts/"",
    }
    for pathName, pathValue := range staticPaths {
        pathPrefix := ""/"" + pathName + ""/""
        router.PathPrefix(pathPrefix).Handler(http.StripPrefix(pathPrefix,
            http.FileServer(http.Dir(pathValue))))
    }
}
router := mux.NewRouter()
ServeStatic(router, ""/static/"")

",15834278
529,30737590,"Using brew

I installed it using brew.

$ brew install go


When it was done if you run this brew command it'll show the following info:

$ brew info go
go: stable 1.4.2 (bottled), HEAD
Go programming environment
https://golang.org
/usr/local/Cellar/go/1.4.2 (4676 files, 158M) *
  Poured from bottle
From: https://github.com/Homebrew/homebrew/blob/master/Library/Formula/go.rb
==> Options
--with-cc-all
    Build with cross-compilers and runtime support for all supported platforms
--with-cc-common
    Build with cross-compilers and runtime support for darwin, linux and windows
--without-cgo
    Build without cgo
--without-godoc
    godoc will not be installed for you
--without-vet
    vet will not be installed for you
--HEAD
    Install HEAD version
==> Caveats
As of go 1.2, a valid GOPATH is required to use the `go get` command:
  https://golang.org/doc/code.html#GOPATH

You may wish to add the GOROOT-based install location to your PATH:
  export PATH=$PATH:/usr/local/opt/go/libexec/bin


The important pieces there are these lines:


  /usr/local/Cellar/go/1.4.2 (4676 files, 158M) *
  
  export PATH=$PATH:/usr/local/opt/go/libexec/bin


Setting up GO's environment

That shows where GO was installed. We need to do the following to setup GO's environment:

$ export PATH=$PATH:/usr/local/opt/go/libexec/bin
$ export GOPATH=/usr/local/opt/go/bin


You can then check using GO to see if it's configured properly:

$ go env
GOARCH=""amd64""
GOBIN=""""
GOCHAR=""6""
GOEXE=""""
GOHOSTARCH=""amd64""
GOHOSTOS=""darwin""
GOOS=""darwin""
GOPATH=""/usr/local/opt/go/bin""
GORACE=""""
GOROOT=""/usr/local/Cellar/go/1.4.2/libexec""
GOTOOLDIR=""/usr/local/Cellar/go/1.4.2/libexec/pkg/tool/darwin_amd64""
CC=""clang""
GOGCCFLAGS=""-fPIC -m64 -pthread -fno-caret-diagnostics -Qunused-arguments -fmessage-length=0 -fno-common""
CXX=""clang++""
CGO_ENABLED=""1""


Setting up json2csv

Looks good, so lets install json2csv:

$ go get github.com/jehiah/json2csv
$


What just happened? It installed it. You can check like this:

$ $ ls -l $GOPATH/bin
total 5248
-rwxr-xr-x  1 sammingolelli  staff  2686320 Jun  9 12:28 json2csv


OK, so why can't I type json2csv in my shell? That's because the /bin directory under $GOPATH isn't on your $PATH.

$ type -f json2csv
-bash: type: json2csv: not found


So let's temporarily add it:

$ export PATH=$GOPATH/bin:$PATH


And re-check:

$ type -f json2csv
json2csv is hashed (/usr/local/opt/go/bin/bin/json2csv)


Now it's there:

$ json2csv --help
Usage of json2csv:
  -d="","": delimiter used for output values
  -i="""": /path/to/input.json (optional; default is stdin)
  -k=[]: fields to output
  -o="""": /path/to/output.json (optional; default is stdout)
  -p=false: prints header to output
  -v=false: verbose output (to stderr)
  -version=false: print version string


Add the modifications we've made to $PATH and $GOPATH to your $HOME/.bash_profile to make them persist between reboots.
",20628918
530,30744362,"Running wbemtest.exe as an administrator you can open the MSFT_DSCLocalConfigurationManager class and use Show MOF to see it's class definition:

[ClassVersion(""1.0.0""), locale(1033), dynamic: ToInstance, provider(""dsccore""): ToInstance]
class MSFT_DSCLocalConfigurationManager
{
    [implemented, static: DisableOverride ToSubClass] uint32 SendConfiguration([In, Octetstring: DisableOverride ToSubClass] uint8 ConfigurationData[], [In] boolean force);
    [implemented, static: DisableOverride ToSubClass] uint32 SendConfigurationApply([In, Octetstring: DisableOverride ToSubClass] uint8 ConfigurationData[], [In] boolean force);
    [implemented, static: DisableOverride ToSubClass] uint32 GetConfiguration([In, Octetstring: DisableOverride ToSubClass] uint8 configurationData[], [Stream: DisableOverride ToSubClass, EmbeddedInstance(""OMI_BaseResource""): ToSubClass, Out] OMI_BaseResource configurations[]);
    [implemented, static: DisableOverride ToSubClass] uint32 TestConfiguration([In, Octetstring: DisableOverride ToSubClass] uint8 configurationData[], [Out] boolean InDesiredState, [Out, EmbeddedInstance(""MSFT_ResourceInDesiredState""): ToSubClass] MSFT_ResourceInDesiredState ResourcesInDesiredState[], [Out, EmbeddedInstance(""MSFT_ResourceNotInDesiredState""): ToSubClass] MSFT_ResourceNotInDesiredState ResourcesNotInDesiredState[]);
    [implemented, static: DisableOverride ToSubClass] uint32 ApplyConfiguration([In] boolean force);
    [implemented, static: DisableOverride ToSubClass] uint32 SendMetaConfigurationApply([In, Octetstring: DisableOverride ToSubClass] uint8 ConfigurationData[]);
    [implemented, static: DisableOverride ToSubClass] uint32 GetMetaConfiguration([Out, EmbeddedInstance(""MSFT_DSCMetaConfiguration""): ToSubClass] MSFT_DSCMetaConfiguration MetaConfiguration);
    [implemented, static: DisableOverride ToSubClass] uint32 RollBack([In] uint8 configurationNumber);
    [implemented, static: DisableOverride ToSubClass] uint32 PerformRequiredConfigurationChecks([In] uint32 Flags);
    [implemented, static: DisableOverride ToSubClass] uint32 StopConfiguration([In] boolean force);
    [implemented, static: DisableOverride ToSubClass] uint32 GetConfigurationStatus([In] uint32 Flags, [Stream: DisableOverride ToSubClass, EmbeddedInstance(""MSFT_DSCConfigurationStatus""): ToSubClass, Out] MSFT_DSCConfigurationStatus configurationStatus[]);
    [implemented, static: DisableOverride ToSubClass] uint32 SendConfigurationApplyAsync([In, Octetstring: DisableOverride ToSubClass] uint8 ConfigurationData[], [In] boolean force, [In] string jobId);
    [implemented, static: DisableOverride ToSubClass] uint32 GetConfigurationResultOutput([In] string jobId, [In, Octetstring: DisableOverride ToSubClass] uint8 resumeOutputBookmark[], [Out, Stream: DisableOverride ToSubClass, EmbeddedInstance(""MSFT_DSCConfigurationOutput""): ToSubClass] MSFT_DSCConfigurationOutput output[]);
    [implemented, static: DisableOverride ToSubClass] uint32 RemoveConfiguration([In] uint32 Stage, [In] boolean Force);
    [implemented, static: DisableOverride ToSubClass] uint32 ResourceGet([In] string ResourceType, [In] string ModuleName, [In, Octetstring: DisableOverride ToSubClass] uint8 resourceProperty[], [Stream: DisableOverride ToSubClass, EmbeddedInstance(""OMI_BaseResource""): ToSubClass, Out] OMI_BaseResource configurations[]);
    [implemented, static: DisableOverride ToSubClass] uint32 ResourceSet([In] string ResourceType, [In] string ModuleName, [In, Octetstring: DisableOverride ToSubClass] uint8 resourceProperty[], [Out] boolean RebootRequired);
    [implemented, static: DisableOverride ToSubClass] uint32 ResourceTest([In] string ResourceType, [In] string ModuleName, [In, Octetstring: DisableOverride ToSubClass] uint8 resourceProperty[], [Out] boolean InDesiredState);
};


GetConfiguration is a method used to return the current configuration document, not the status of the last DSC run. You may be using an older version of DSC, make sure $psversiontable in powershell shows at least 5.0.10018.0.

wbemtest.exe will also let you use IWbemServices to execute a method (similar to the code you have above)



and it shows the output parameters are of type:

[abstract]
class __PARAMETERS
{
    [Stream: DisableOverride ToSubClass, EmbeddedInstance(""MSFT_DSCConfigurationStatus""): ToSubClass, Out, ID(1): DisableOverride ToInstance] MSFT_DSCConfigurationStatus configurationStatus[] = {
instance of MSFT_DSCConfigurationStatus
{
    DurationInSeconds = 33;
    HostName = ""GBRAY02"";

",30744205
531,30793913,"Use https://github.com/dustin/go-humanize .. it has a bunch of helpers to deal with those things.  In addition to bytes as MiB, MB, and other goodies.
",13020308
532,30857066,"Ended up using a special ""boolean"" type, and where I was using a normal bool, swapped for this:

type ConvertibleBoolean bool

func (bit ConvertibleBoolean) UnmarshalJSON(data []byte) error {
    asString := string(data)
    if asString == ""1"" || asString == ""true"" {
        bit = true
    } else if asString == ""0"" || asString == ""false"" {
        bit = false
    } else {
        return errors.New(fmt.Sprintf(""Boolean unmarshal error: invalid input %s"", asString))
    }
    return nil
}

",30856454
533,30950396,"your yaml file must be 

 hits: 5
 time: 5000000


your code should look like this:

package main

import (
    ""fmt""
    ""gopkg.in/yaml.v2""
    ""io/ioutil""
    ""log""
)

type conf struct {
    Hits int64 `yaml:""hits""`
    Time int64 `yaml:""time""`
}

func (c *conf) getConf() *conf {

    yamlFile, err := ioutil.ReadFile(""conf.yaml"")
    if err != nil {
        log.Printf(""yamlFile.Get err   #%v "", err)
    }
    err = yaml.Unmarshal(yamlFile, c)
    if err != nil {
        log.Fatalf(""Unmarshal: %v"", err)
    }

    return c
}

func main() {
    var c conf
    c.getConf()

    fmt.Println(c)
}


the main error was capital letter for your struct.
",30947534
534,30956460,"You're misusing the Sum method. The docs for the hash.Hash interface clearly say that


  Sum appends the current hash to b and returns the resulting slice.


(Emphasis added.)

You need to either write the data to the hash and use h.Sum like this

h.Write([]byte(password))
b := h.Sum(nil)


or just use sha256.Sum256

h := sha256.Sum256([]byte(password))


Playground: http://play.golang.org/p/oFBePRQzhN.
",30956244
535,31046325,"The fmt package does not support grouping decimals.

We have to implement one ourselves (or use an existing one).

The Code

Here is a compact and really efficient solution (see explanation after):

Try it on the Go Playground.

func Format(n int64) string {
    in := strconv.FormatInt(n, 10)
    out := make([]byte, len(in)+(len(in)-2+int(in[0]/'0'))/3)
    if in[0] == '-' {
        in, out[0] = in[1:], '-'
    }

    for i, j, k := len(in)-1, len(out)-1, 0; ; i, j = i-1, j-1 {
        out[j] = in[i]
        if i == 0 {
            return string(out)
        }
        if k++; k == 3 {
            j, k = j-1, 0
            out[j] = ','
        }
    }
}


Testing it:

for _, v := range []int64{0, 1, 12, 123, 1234, 123456789} {
    fmt.Printf(""%10d = %12s\n"", v, Format(v))
    fmt.Printf(""%10d = %12s\n"", -v, Format(-v))
}


Output:

         0 =            0
         0 =            0
         1 =            1
        -1 =           -1
        12 =           12
       -12 =          -12
       123 =          123
      -123 =         -123
      1234 =        1,234
     -1234 =       -1,234
 123456789 =  123,456,789
-123456789 = -123,456,789


Explanation:

Basically what the Format() function does is it formats the number without grouping, then creates a big enough other slice and copies the digits of the number inserting comma (',') grouping symbol when necessary (after groups of digits of 3 if there are more digits) meanwhile taking care of the negative sign to be preserved.

The length of the output:

It is basically the length of the input plus the number of grouping signs to be inserted. The number of grouping signs is:

numOfCommas = (numOfDigits - 1) / 3


Since the input string is a number which may only contain digits ('0..9') and optionally a negative sign ('-'), the characters are simply mapped to bytes in a 1-to-1 fashion in UTF-8 encoding (this is how Go stores strings in memory). So we can simply work with bytes instead of runes. So the number of digits is the input string length, optionally minus 1 for the sign digit '-'.

If there is a sign digit, it will be in in[0]. The numerical value of '-' is 45, while the numerical value of digit characters '0'..'9' are 48..57. So the sign character is less than the possible digits. So if we divide the first character (there is always at least 1 character) by '0', we get 0 if it is a negative sign and 1 if it is a digit (integer division).

So the number of digits in the input string is:

numOfDigits = len(in) - 1 + int(in[0]/'0')


And therefore the number of grouping signs:

numOfCommas = (len(in) - 2 + int(in[0]/'0')) / 3


Therefore the output slice will be:

out := make([]byte, len(in)+(len(in)-2+int(in[0]/'0'))/3)


Handling the negative sign character:

If the number is negative, we simply slice the input string to exclude it from processing and we manually copy the sign bit to the output:

if in[0] == '-' {
    in, out[0] = in[1:], '-'
}


And therefore the rest of the function does not need to know/care about the optional negative sign character.

The rest of the function is a for loop which just copies the bytes (digits) of the number from the input string to the output, inserting a grouping sign (',') after every group of 3 digits if there are more digits. The loop goes downward so it's easier to track the groups of 3 digits. Once done (no more digits), the output byte slice is returned as a string.

Variations

Handling negative with recursion

If you're less concerned with efficiency and more about readability, you might like this version:

func Format2(n int64) string {
    if n < 0 {
        return ""-"" + Format2(-n)
    }
    in := strconv.FormatInt(n, 10)
    out := make([]byte, len(in)+(len(in)-1)/3)

    for i, j, k := len(in)-1, len(out)-1, 0; ; i, j = i-1, j-1 {
        out[j] = in[i]
        if i == 0 {
            return string(out)
        }
        if k++; k == 3 {
            j, k = j-1, 0
            out[j] = ','
        }
    }
}


Basically this handles negative numbers with a recursive call: if the number is negative, calls itself (recursive) with the absolute (positive) value and prepends the result with a ""-"" string.

With append() slices

Here's another version using the builtin append() function and slice operations. Somewhat easier to understand but not so good performance-wise:

func Format3(n int64) string {
    if n < 0 {
        return ""-"" + Format3(-n)
    }
    in := []byte(strconv.FormatInt(n, 10))

    var out []byte
    if i := len(in) % 3; i != 0 {
        if out, in = append(out, in[:i]...), in[i:]; len(in) > 0 {
            out = append(out, ',')
        }
    }
    for len(in) > 0 {
        if out, in = append(out, in[:3]...), in[3:]; len(in) > 0 {
            out = append(out, ',')
        }
    }
    return string(out)
}


The first if statement takes care of the first optional, ""incomplete"" group which is less than 3 digits if exists, and the subsequent for loop handles the rest, copying 3 digits in each iteration and appending a comma (',') grouping sign if there are more digits.
",13020308
536,31103130,"I learning go language (and English :P), and in the tour of go is a exersie: Fibonacci closure

(https://tour.golang.org/moretypes/22)

The result is:
0
1
1
2
3
5
8
13
21
34

The main function is:

func main() {
    f := fibonacci()
    for i := 0; i < 10; i++ {
        fmt.Println(f())
    }
}


And my first solution was:

func fibonacci() func() int {
    antant := 0
    ant := 1
    i := 0
    return func() int {
        var result int
        if i == 0 || i == 1 {
            result = i
            i++
            return result
        }
        result = antant + ant
        antant = ant
        ant = result
        return result
    }
}


But I didn't want ask in heach call to f() if was the firsth or second call (if i == 0 || i == 1). The result was a function auto-override:

type doFibonacci func(*doFibonacci) int

func fibonacci() func() int {
    antant := 0
    ant := 1
    i := 0
    doFibo := doFibonacci(func(ptrDo *doFibonacci) int {
        var result int
        if i == 0 || i == 1 {
            result = i
            i++
            return result
        }
        *ptrDo = func(ptrDo *doFibonacci) int {
            var result int
            result = antant + ant
            antant = ant
            ant = result
            return result
        }
        return (*ptrDo)(ptrDo)
    })
    return func() int {
        return doFibo(&doFibo)
    }
}


I apologize for my English.
",30502933
537,31143133,"There is a package by this guy on GitHub that includes both an encoder and a decoder for WebP:
https://github.com/chai2010/webp

From the readme file:

package main

import (
    ""bytes""
    ""fmt""
    ""io/ioutil""
    ""log""

    ""github.com/chai2010/webp""
)

func main() {
    var buf bytes.Buffer
    var width, height int
    var data []byte
    var err error

    // Load file data
    if data, err = ioutil.ReadFile(""./testdata/1_webp_ll.webp""); err != nil {
        log.Println(err)
    }

    // GetInfo
    if width, height, _, err = webp.GetInfo(data); err != nil {
        log.Println(err)
    }
    fmt.Printf(""width = %d, height = %d\n"", width, height)

    // GetMetadata
    if metadata, err := webp.GetMetadata(data, ""ICCP""); err != nil {
        fmt.Printf(""Metadata: err = %v\n"", err)
    } else {
        fmt.Printf(""Metadata: %s\n"", string(metadata))
    }

    // Decode webp
    m, err := webp.Decode(bytes.NewReader(data))
    if err != nil {
        log.Println(err)
    }

    // Encode lossless webp
    if err = webp.Encode(&buf, m, &webp.Options{Lossless: true}); err != nil {
        log.Println(err)
    }
    if err = ioutil.WriteFile(""output.webp"", buf.Bytes(), 0666); err != nil {
        log.Println(err)
    }
}

",8340751
538,31287203,"you should not predict the goroutine schedule. by running the example you provided, I got this output.

direct : 0
direct : 1
direct : 2
goroutine : 0
goroutine : 1
goroutine : 2
going
done


if I add runtime.GOMAXPROCS(4) at the begin of main function, and run it on my i5 Qcore desktop ubuntu, it output

direct : 0
direct : 1
direct : 2
goroutine : 0
goroutine : 1
goroutine : 2
going

done


it not always produce same output I think. So we should assume goroutine may  parallel, add lock if you need control the sequence.
",31285215
539,31327554,"Here's a simple little solution.

days := 0
for {
     if (t.Equal(f)) {
         return days
     }
     if (t.Weekday() != 6 && t.Weekday() != 7) {
          days++
     }
     t.Add(time.Hour*24)
}


You probably don't want to use your original t variable but keeping the example simple. I loop until t equals f, if they're equal I return my days count. If they're not I check to make sure it's a weekday and increment my days count if it is. I unconditionally add one day to my starting time.
",31327124
540,31329658,"Here is a solution thank you evanmcdonnal and luc for answering

package main

  import (
""fmt""
""time""
)

func main() {
t := time.Date(2015, time.Now().Month(), time.Now().Day(), time.Now().Hour(), time.Now().Minute(), time.Now().Second(), time.Now().Nanosecond()*0, time.UTC)
fmt.Printf(""%s\n"",t)
f := time.Date(2015, time.August, 22, time.Now().Hour(), time.Now().Minute(), time.Now().Second(), time.Now().Nanosecond()*0, time.UTC)
fmt.Printf(""%s\n"",f)
days :=0


for{
    if(t.Equal(f)){

        break

    }

    if(t.Weekday()!=6 && t.Weekday()!=0){
        days++

    }
t=t.Add(time.Hour*24)


}




 fmt.Printf(""days  %d\n"", days)

}


output 32
",31327124
541,31411854,"There's 2 primary issues (and many unrelated).

First, you need to parenthesize named return parameters

func ping(curl_out string) (endtime int64) {


Second, you can't assign the return value of a goroutine. It's executed asynchronously in an entirely new context. Use a channel to communicate between goroutines

You could declare the ping function like:

func ping(curl_out string, endtime chan<- int64) {


And then pass in a channel on which to receive the value

ch := make(chan int64)
go ping(string(curl_out), ch)
endtime <- ch


(Though there is no point in this case to using a goroutine, since you want the value synchronously)
",31411555
542,31411861,"In line 9:

Add parenthesis 

func ping(curl_out string) (endtime int64) {


or remove return value name:

func ping(curl_out string) int64 {


And you're right about the use of go keyword to create a goroutine, you can't assign that to a return value, just remove the go keyword and assign the value directly.

Also (style)  go variables are in camelCase so you should change your variables from run_container  to either runContainer  or better just container or even better just c, same goes for run_curl it could be curl

Here's an slightly enhanced version of your code ( without really knowing what it does)

http://play.golang.org/p/3Y7TPip5kP
",31411555
543,31436063,"Use binary shift operators to load seven bits at a time into a bit buffer, and whenever the bit buffer has eight bits, output that.  At the end, if there are any bits leftover, output a final byte with what's in the buffer.

So something like (don't know Go, but this should be close):

bits = 0
bitbuf = 0
... some loop ...
    ...make your seven bits ...
    bitbuf |= sevenbits << bits
    bits += 7
    if bits >= 8 {
        output(bitbuf & 0xff)
        bitbuf >>= 8;
        bits -= 8;
    }
...
if bits > 0 {
    output(bitbuf)
}

",31434554
544,31474039,"There's no convention, as far as I am aware of. It's OK to create a slice type if you really need it. In fact, if you ever want to sort your data, this is pretty much the only way: create a type and define the sort.Interface methods on it.

Also, in your example there is no need to take the address of Trips since slice is already a ""fat pointer"" of a kind. So you can simplify your method to:

func (trips Trips) TotalLength() (tl int) {
    for _, l := range trips {
        tl += l.Length
    }
    return tl
}

",31473429
545,31474074,"If this is what your type is (a slice), it's just fine. It gives you an easy access to underlying elements (and allows for range iteration) while providing additional methods.

Of course you probably should only keep essential set of methods on this type and not bloating it with everything that would take []Trip as an argument. (For example I would suggest having DrawTripsOnTheGlobe(t Trips) rather than having it as a Trips' method.)

To calm your mind there are plenty of such slice-types in standard packages:

http://golang.org/pkg/net/#IP

http://golang.org/pkg/sort/#Float64Slice

http://golang.org/pkg/sort/#IntSlice

http://golang.org/pkg/encoding/json/#RawMessage
",31473429
546,31503648,"You should add a date field into the documents, over which you can query. That is the easiest option.

type Post struct {
    Id bson.ObjectId `bson:""_id""`
    date time.Time `bson:""date""`
}


Then you can write your queries over the date object.
",31502195
547,31541855,"Here's how you do it.


Assemble fromDate and toDate.
Create bson.ObjectId with bson.NewObjectIdWithTime()
Query for date range


Example: Query for posts created 2015

year := 2015
fromDate := time.Date(year, time.January, 1, 0, 0, 0, 0, time.UTC)
toDate := time.Date(year+1, time.January, 1, 0, 0, 0, 0, time.UTC)
fromId := bson.NewObjectIdWithTime(fromDate)
toId := bson.NewObjectIdWithTime(toDate)
posts := []*Post{}
if e := cPost.Find(bson.M{""_id"": bson.M{""$gte"": fromId, ""$lt"": toId}}).All(&posts); e != nil {
}


note: Because ObjectId isn't ISODate assemble ObjectId from ISODate
",31502195
548,31598706,"It is possible you are running an older version of the app, when I try to build the container locally I get the following error:

➜ docker build .
# Executing 3 build triggers
Trigger 0, COPY . /go/src/app
Step 0 : COPY . /go/src/app
Trigger 1, RUN go-wrapper download
Step 0 : RUN go-wrapper download
 ---> Running in c1854666d13c
+ exec go get -v -d
github.com/julienschmidt/httprouter (download)
github.com/rdegges/ipify-api (download)
github.com/rs/cors (download)
Trigger 2, RUN go-wrapper install
Step 0 : RUN go-wrapper install
 ---> Running in 0bbdec1b99d7
+ exec go install -v
github.com/julienschmidt/httprouter
github.com/rdegges/ipify-api/models
github.com/rs/cors
github.com/rdegges/ipify-api/api
app
# app
./main.go:27: cannot use api.NotFound (type func(http.ResponseWriter, *http.Request)) as type http.Handler in assignment:
    func(http.ResponseWriter, *http.Request) does not implement http.Handler (missing ServeHTTP method)
./main.go:28: cannot use api.MethodNotAllowed (type func(http.ResponseWriter, *http.Request)) as type http.Handler in assignment:
    func(http.ResponseWriter, *http.Request) does not implement http.Handler (missing ServeHTTP method)
The command '/bin/sh -c go-wrapper install' returned a non-zero code: 2


Are there any errors in your event stream after you deploy? ""eb events"" i believe.
",30428926
549,31626494,"I came across a similar problem - from a package path how do you get the package name. The best solution I found is to exec the ""go list"" command. Not ideal but I came up blank elsewhere. 

In my case I also had a problem that sometimes the package is an empty directory. With no source files, ""go list"" throws an error, so I added a function to create a sensible package name from the path. 

Here's the code:

func getPackageName(path string) string {
    output, err := exec.Command(""go"", ""list"", ""-f"", ""{{.Name}}"", path).CombinedOutput()
    if err != nil {
        return guessPackageName(path)
    }
    return strings.TrimSpace(string(output))
}

func guessPackageName(path string) string {
    preferred := path
    if strings.HasSuffix(preferred, ""/"") {
        // training slashes are usually tolerated, so we can get rid of one if it exists
        preferred = preferred[:len(preferred)-1]
    }
    if strings.Contains(preferred, ""/"") {
        // if the path contains a ""/"", use the last part
        preferred = preferred[strings.LastIndex(preferred, ""/"")+1:]
    }
    if strings.Contains(preferred, ""-"") {
        // the name usually follows a hyphen - e.g. github.com/foo/go-bar
        // if the package name contains a ""-"", use the last part
        preferred = preferred[strings.LastIndex(preferred, ""-"")+1:]
    }
    if strings.Contains(preferred, ""."") {
        // dot is commonly usually used as a version - e.g. github.com/foo/bar.v1
        // if the package name contains a ""."", use the first part
        preferred = preferred[:strings.LastIndex(preferred, ""."")]
    }
    return preferred
}

",31567734
550,31632586,"Building on the answer provided by @Mark

Although the OP asked how to print an integer, I often want to look at more then 64 bits worth of data, without my eyes boggling:

/* --- Credit to Dave C in the comments --- */
package main

import (
    ""bytes""
    ""fmt""
)

func main() {
    fmt.Printf(""\n"", fmtBits([]byte{0xDE, 0xAD, 0xBE, 0xEF, 0xF0, 0x0D, 0xDE, 0xAD, 0xBE, 0xEF, 0xF0, 0x0D}))

    // OUTPUT:
    // 
}

func fmtBits(data []byte) []byte {
    var buf bytes.Buffer
    for _, b := range data {
        fmt.Fprintf(&buf, ""%08b "", b)
    }
    buf.Truncate(buf.Len() - 1) // To remove extra space
    return buf.Bytes()
}


see this code in play.golang.org
",13870845
551,31688970,"The Go dev_appserver does not currently support local Google Cloud Storage emulation. What is recommended is that you create a real GCS bucket for testing purposes and then you can start your dev_appserver to talk to the ""test"" GCS bucket.

This tutorial: https://cloud.google.com/appengine/docs/go/googlecloudstorageclient/getstarted
gives detailed instructions on how you can set up your local app to use a real GCS bucket. (Make sure you carefully follow the linked instructions to enable the two Cloud Storage APIs and set up and download your private key.)

Also, just FYI, the google-appengine-go Google Group is a great place to ask questions like this and also search through the posts to find answers.  There are a lot of really helpful people on that list to help you get up and running quickly.
",31102871
552,31691333,"Even though A and B both have a status field they are not interchangeable to the type system. You must have separate cases for each of them.

case A:
    t.Status = status
case B:
    t.Status = status
} 


playground link

Alternatively, you could use an actual interface:

type HasStatus interface {
  SetStatus(int)
}

type A struct {
   Status int
}

func (a *A) SetStatus(s int) { a.Status = s }

func foo(v HasStatus, status int) {
    v.SetStatus(status)
}


full example

If you have multiple types that all have a common set of fields you may want to use an embedded struct:

type HasStatus interface {
    SetStatus(int)
}

type StatusHolder struct {
    Status int
}

func (sh *StatusHolder) SetStatus(s int) { sh.Status = s }

type A struct {
    StatusHolder
}

type B struct {
    id string
    StatusHolder
}


full example
",31691193
553,31714459,"Not vim-go but syntastic do this, just config 

let g:syntastic_go_checkers = []
",31689929
554,31778315,"The types you are converting is neither a numeric type or a string: []string and stringsLongestFirst are slice types.

So the conversion should incur no more overhead than copying the slice header (which is 12 or 24 bytes, depending on the word size), which would happen anyway when packing it as an interface{} variable in order to call Sort.  The backing array is not copied, which is why severalThousandStrings appears to be sorted after the call.
",31776584
555,31791886,"Assuming your data isn't inherently too big for the computer it's running on, the problem is likely the inefficient building of that string. Instead you should be using a bytes.buffer and then callings it's String() method. Here's an example;

var buffer bytes.Buffer

for _, record := range all_data {
    body, _ := json.Marshal(record)
    buffer.Write(body)
    buffer.WriteString(""\n"")
}

fmt.Println(buffer.String())

",31788886
556,31796112,"According to the golang website:


  Get downloads and installs the packages named by the import paths, along with their dependencies.


It sounds like the download isn't working, which is causing the folder to be empty. One alternative is to download the driver as a zip file and run go install on the folder.
",31794172
557,31967618,"Go is not Java; Go is even not C++. You should think of Go as ""C with interfaces"".

In particular, you cannot do as you want, as you cannot nest struct definitions in interface definitions. Note that you can nest structs inside structs, but you cannot instantiate a nested struct directly.

The closest you can do is to move each logical group of objects to its own package.
",31967057
558,31967977,"Here is a suggestion to organize your code in more ""idiomatic"" Go way:

package user

type Request struct {
    ...
}

type Response struct {
    ...
}

type Service interface {
   GetUser(r Request) Response
}


Outside of user package the code will look like:

s := user.NewService()
var req user.Request
var resp user.Response
resp = s.GetUser(req)


As you can see the code uses much shorter names and still remains very readable.

Package names like service shows that you organize the code in your app by layers instead of by features. I wouldn't recommend it. Here is interesting article about it: http://www.javapractices.com/topic/TopicAction.do?Id=205. It uses Java but the principle applies to any programming language.
",31967057
559,31987081,"Field names need to begin with upper case character to be exported identifiers.
",31987018
560,32034083,"I am not an authority, but I will make a few observations that might help even though I do not have a complete answer for you.

The first thing about your question that struck me is the use of the term ""inherit"" --  Go does not support inheritance.  It does support embedding.   I might have written the question subject as ""Reuse controller from module in Revel framework. 

Second, I wonder if you are trying to reuse a Revel module between two separate Revel applications or if you are trying to reuse code from a module in two separate parts of one Revel application that just happens to have a front end and a back end.   A quick read of the reveal framework makes me think modules were designed for the former, not the latter.

Third, I wonder if perhaps you are confusing files with packages.  It was not obvious to me when learning Go that one package can span multiple files.. if the same declaration of ""package controller"" exists in two files such as db.go and app.go, they are still in the same package.
",32033369
561,32067013,"package main

import ""fmt""
import ""strconv""
import ""time""

func main() {
    fmt.Println(""Hello, playground"")
    t := time.Now()
    time := t.Format(""20060102030405"")
    time = time[:6] + strconv.Itoa(int(t.Weekday())) + time[6:]
    fmt.Println(time)
}


Try it on the Go playground
",32066978
562,32142190,"This code works on big integers *big.Int :

x := big.NewInt(123)
s := fmt.Sprintf(""%b"", x)
// s == ""1111011""


because *big.Int implements the fmt.Formatter interface. 

Taken from https://stackoverflow.com/a/23317788/871134
",13870845
563,32143928,"Here is a bug on github. It turned out that go tool generated wrong names.
",32114128
564,32143987,"All of that approaches failed to me, noobie here. But i have found a better way http://play.golang.org/p/OcMsuUpv2g

I'm using sync package to solve that problem and wait for all goroutines to finish, without Sleep or Channel.

And don't forget to take a look at that awesome post http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/
",20993139
565,32180800,"Yes, the behaviour has changed in Go 1.5:


  If 'go install' (with no arguments, meaning the current directory) succeeds, remove the executable written by 'go build', if present. This avoids leaving a stale binary behind during a sequence like:

go build

go install

  
  Before this CL, the current directory still has the stale binary from 'go build'. If $PATH contains dot, running the name of the program will find this stale binary instead of the new, installed one.


I can't find anything mentioning that in the release notes though. Might be a documentation issue.

It seems like the solution is to use the binary that go install has produced.

EDIT: Here is the issue on the Go issue tracker if you want to follow on updates. Should be fixed by 1.5.1.
",32180434
566,32217055,"It turns out the method I needed was img.At(x, y).RGBA(), this returns those values respectively.
",32216985
567,32217287,"To build an archive callable from C, you will need to mark them as exported CGo symbols.
For example, if I create a file foo.go with the following contents:

package main

import (
    ""C""
    ""fmt""
)

//export PrintInt
func PrintInt(x int) {
    fmt.Println(x)
}

func main() {}


The important things to note are:


The package needs to be called main
You need to have a main function, although it can be empty.
You need to import the package C
You need special //export comments to mark the functions you want callable from C.


I can compile it as a C callable static library with the following command:

go build -buildmode=c-archive foo.go


The results will be an archive foo.a and a header foo.h.  In the header, we get the following (eliding irrelevant parts):

...
typedef long long GoInt64;
...
typedef GoInt64 GoInt;
...
extern void PrintInt(GoInt p0);
...


So that's enough to call the exported function.  We can write a simple C program that calls it like so:

#include ""foo.h""

int main(int argc, char **argv) {
    PrintInt(42);
    return 0;
}


We can compile it with a command like:

gcc -pthread foo.c foo.a -o foo


The -pthread option is needed because the Go runtime makes use of threads.  When I run the resulting executable it prints 42.
",32215509
568,32231151,"Adding this for future reference, but to access the underling color.YCbCr you just need to type assert the value, example:

for y := bounds.Min.Y; y < bounds.Max.Y; y++ {
    for x := bounds.Min.X; x < bounds.Max.X; x++ {
        if c, ok := img.At(x, y).(color.YCbCr); ok {
            fmt.Println(c.Y, c.Cb, c.Cr)
        } else {
            fmt.Println(reflect.TypeOf(img.At(x, y)))
        }
    }
}

",32216985
569,32250399,"You posted this:

kdata := make([]Klabel, 10)

kdata[0].label = ""test""


And it works. When printing the kdata slice, output is (Go Playground):

[{[] test} {[] } {[] } {[] } {[] } {[] } {[] } {[] } {[] } {[] }]


The output shows kdata has 10 elements, and the first has the label value: ""test"".

To be more clear, print it with:

fmt.Printf(""%+v"", kdata)


Output:

[{values:[] label:test} {values:[] label:} {values:[] label:} {values:[] label:} {values:[] label:} {values:[] label:} {values:[] label:} {values:[] label:} {values:[] label:} {values:[] label:}]




Slices (unlike maps) are addressable. You can change the fields of the elements (that are structs) by simply indexing the slice and assigning new values to the fields.

For example:

kdata[0].label = ""test""
kdata[0].values = []float64{1.1, 2.2}
kdata[0].values = append(kdata[0].values, 3.3)

fmt.Printf(""%+v"", kdata[0])


Output:

{values:[1.1 2.2 3.3] label:test}


If you want to append a slice of floats to the values field of an element:

vals := []float64{1.2, 2.3}

kdata[0].values = append(kdata[0].values, vals...) // Note the 3 dot ...

",32250277
570,32250480,"As an alternative to the other answer, you could also do this:

kdata := []Klabel{{label: ""test""}}


(See on Go Playground)

But note that the slice length will be 1 rather than 10, so it's not exactly equivalent.
",32250277
571,32253871,"Spec: Conversions:


  Specific rules apply to (non-constant) conversions between numeric types or to and from a string type. These conversions may change the representation of x and incur a run-time cost. All other conversions only change the type but not the representation of x.


So converting to and from the underlying type of your custom type does not make a copy if it.

When you pass a value to a function or method, a copy is made and passed. If you pass a string to a function, only the structure describing the string will be copied and passed, since strings are immutable.

Same is true if you pass a slice (slices are also descriptors). Passing a slice will make a copy of the slice descriptor but it will refer to the same underlying array.
",32253768
572,32273463,"Your program is exiting before all goroutines are done. You need to wait for both the foo and bar goroutines to finish before returning from main. 

The usual way of doing this is by using a sync.WaitGroup, but since main isn't the producer for the d channel, you will have to ensure that all sends on that channel are finished before closing that with a second WaitGroup (or equivalent).

var (
    fooWG sync.WaitGroup
    barWG sync.WaitGroup
)

func main() {
    d := make(chan uint)

    barWG.Add(1)
    go bar(d)

    c1 := make(chan uint)
    c2 := make(chan uint)
    c3 := make(chan uint)

    fooWG.Add(3)
    go foo(c1, d)
    go foo(c2, d)
    go foo(c3, d)

    c1 <- 1
    c2 <- 2
    c3 <- 3

    c1 <- 4
    c2 <- 5
    c3 <- 6

    c1 <- 7
    c2 <- 8
    c3 <- 9

    // close the channels so the foo goroutines can exit
    close(c1)
    close(c2)
    close(c3)
    fooWG.Wait()

    // all foo are done, so it's safe to close d and wait for bar
    close(d)
    barWG.Wait()
}

func foo(c chan uint, d chan uint) {
    defer fooWG.Done()
    fmt.Println(""foo start"")

    for stuff := range c {
        time.Sleep(1)
        d <- stuff * 2
    }

    fmt.Println(""foo end"")
}

func bar(d chan uint) {
    defer barWG.Done()
    fmt.Println(""bar start"")

    for stuff := range d {
        fmt.Printf(""bar received %d\n"", stuff)
    }

    fmt.Println(""bar end"")
}

",32273218
573,32280323,"JimB's answer definitely works, but it's adding more complexity than is actually needed in the code.  A simple complete channel would suffice to synchronize this code though completion.  

Also, with channel synchronization, the time.Sleep(1) command is no longer needed for functionality: 

package main

import (
    ""fmt""
    ""time""
)

func main() {
    d := make(chan uint)
    complete := make(chan bool)
    go bar(d, complete)

    c1 := make(chan uint)
    c2 := make(chan uint)
    c3 := make(chan uint)

    go foo(c1, d)
    go foo(c2, d)
    go foo(c3, d)

    c1 <- 1
    c2 <- 2
    c3 <- 3

    c1 <- 4
    c2 <- 5
    c3 <- 6

    c1 <- 7
    c2 <- 8
    c3 <- 9

    //If you know the number of inputs, count them to ensure completion
    for i:=0; i < 9; i++{
        <-complete
    }

    //Clean up after yourself, to keep away the memory leaks
    close(c1)
    close(c2)
    close(c3)
    close(d)

    //Verify bar is done and closed correctly
    <-complete
    close(complete)
}

func foo(c chan uint, d chan uint) {
    fmt.Println(""foo start"")

    for stuff := range c {
        time.Sleep(1)      //Not needed for the program to function
        d <- stuff * 2
    }

    fmt.Println(""foo end"")
}

func bar(d chan uint, cmp chan bool) {
    fmt.Println(""bar start"")

    for stuff := range d {
        fmt.Printf(""bar received %d\n"", stuff)
        cmp <- true
    }

    fmt.Println(""bar end"")

    //verify that cmp can be closed (all output is done, and d is closed)
    cmp <- true
}

",32273218
574,32322125,"Use interface{}:

func ParseJSON(file string, val interface{}) {
    configFile, err := ioutil.ReadFile(file)
    if err != nil {
        log.Fatal(err)
    }
    err = json.Unmarshal(configFile, val)
    if err != nil {
        log.Fatal(err)
    }
}


Calling the function is the same.
",32322013
575,32330783,"If you use the standard flag package to parse command-line flags, you can call the NFlag function to get the number of flags:

package main
import ""fmt""
import ""flag""

func main() {
        flag.Bool(""a"", true, ""A value"");
        flag.Bool(""b"", true, ""B value"");
        flag.Parse();

        fmt.Println(flag.NFlag())
}


Test:

$ go run test.go 
0
$ go run test.go -a
1
$ go run test.go -a -b
2

",32330631
576,32346093,"As the Go specification states:


  A function type denotes the set of all functions with the same parameter and result types


In your case, your result types differ (string vs interface{})

To be able to receive a function with any kind of result type, test would have to be defined as:

func text(x interface{}) { ... }


and then you will have to use reflect package to call the function stored in x.

Edit

Such a test function would look like this:

func test(x interface{}) {
    v := reflect.ValueOf(x)

    if v.Kind() != reflect.Func {
        panic(""Test requires a function"")
    }

    t := v.Type()

    if t.NumIn() != 0 && t.NumOut() != 1 {
        panic(""Function type must have no input parameters and a single return value"")
    }

    values := v.Call(nil)

    val := values[0].Interface()
    // some more code..
}


Playground: https://play.golang.org/p/trC2lOSLNE
",32345760
577,32346212,"You tripped over a very common misconception for Go newcomers: The empty interface interface{} does not mean ""any type"". Really, it does not. Go is statically typed. The empty interface interface {} is an actual (strongly typed type) like e.g. string or struct{Foo int} or interface{Explode() bool}.

That means if something has the type interface{} it has that type and not ""any type"".

Your function

func test(x func() interface{})


takes one parameter. This parameter is a (parameterless function) which returns a specific type, the type interface{}. You can pass any function to test which matches this signature: ""No parameters and return interface{}"". None of your functions a and b match this signature.

As said above: interface {} is not a magical abbreviation for ""whatever"",it is a distinct static type.

You have to change e.g. a to:

func a() interface{} {
    return ""hello""
}


Now this might look strange as you return a string which is not of type interface{}.  This works because any type is assignable to variables of type interface{} (as every type has at least no methods :-). 
",32345760
578,32423688,"It looks like you are editing the darwin64-local.env file , but actually using the system.env file (the one selected in the drop down on the top toolbar). make sure you are using the correct file. 
",32416778
579,32439080,"From Go 1.5 there's the ""vendor experiment"" that helps you manage dependencies. As of Go 1.6 this is no longer an experiment. Theres also some other options on the Go wiki..

Edit: as mentioned in this answer gopkg.in is a good option for pinning github-depdencies pre-1.5.
",24855081
580,32469214,"I have now successfully used the below approach for about a year in multiple projects. The idea is to return a function from the setup call. That resulting function contains the destruction logic. Here is an example:

package main

import (
    ""fmt""
    ""io""
    ""log""
    ""os""
)

func LogSetupAndDestruct() func() {
    logFile, err := os.OpenFile(""test.log"", os.O_CREATE|os.O_APPEND|os.O_RDWR, 0666)
    if err != nil {
        log.Panicln(err)
    }

    log.SetOutput(io.MultiWriter(os.Stderr, logFile))

    return func() {
        e := logFile.Close()
        if e != nil {
            fmt.Fprintf(os.Stderr, ""Problem closing the log file: %s\n"", e)
        }
    }
}

func main() {
    defer LogSetupAndDestruct()()

    log.Println(""Test message"")
}


It is using a closure around the cleanup logic being deferred.

A somewhat more elaborate public example of using this approach is in the Viper code: here is the return from a test initializer, and here it is used to encapsulate the cleanup logic and objects
",25342806
581,32486253,"The GOROOT is not set correctly in LiteIDE.  

In a terminal enter which go to know where gvm installed go.  Example:

/home/username/.gvm/gos/go1.6/bin/go


In LiteIDE, click on the grey box ""edit current environment"" right of the environment drop down menu.



Uncomment the GOROOT line in the system.env file and enter the correct path that you got from which go.  You omit ""/bin/go"".

GOROOT=/home/username/.gvm/gos/go1.6


Save the file.  If saving is greyed out, you might need to change the permission of LiteIDE's liteenv directory.  I installed mine to /opt/liteide/share/liteide/liteenv.

When the settings are configured correctly, this is what you should see in LiteIDE's Build Output window:

/home/username/.gvm/gos/go1.6/bin/go build -i [/home/username/go/src/project]
Success: process exited with code 0.
/home/username/go/src/bad/bad  [/home/username/go/src/project]
Hello World!
Success: process exited with code 0.


Instead of using the system environment config (the default in the drop down menu) I'm personally using the linux64-local.env file. My LiteIDE config file looks like this:

# native compiler linux amd64

GOROOT=/home/username/.gvm/gos/go1.6
#GOBIN=
GOARCH=amd64
GOOS=linux
CGO_ENABLED=1

PATH=$GOROOT/bin:$PATH

LITEIDE_GDB=gdb
LITEIDE_MAKE=make
LITEIDE_TERM=/usr/bin/gnome-terminal
LITEIDE_TERMARGS=
LITEIDE_EXEC=/usr/bin/xterm
LITEIDE_EXECOPT=-e

LITEIDE_SHELL=gnome-terminal;lxterminal;kconsole;xfce4-terminal;xterm

",32486252
582,32630589,"You can use git checkout to get an specific version and build your program using this version.

Example:

export GOPATH=~/
go get github.com/whateveruser/whateverrepo
cd ~/src/github.com/whateveruser/whateverrepo
git tag -l
# supose tag v0.0.2 is correct version
git checkout tags/v0.0.2
go run whateverpackage/main.go

",24855081
583,32716043,"There is a problem with you code missing some brackets etc. This seems to work : 

package main

import (
    ""bytes""
    ""fmt""
)

const data = `{""abc"":[{""b"":5,""bca"":14,""xyz"":0}]}{""abc"":[{""b"":7,""hjk"":14,""qwe"":0}]}`

func main() {

    buf := []byte(data)
    fmt.Printf(""buf = %s\n"", string(buf))

    if bytes.Contains(buf, []byte(""}{"")) {
        fmt.Printf(""I got you\n"")
    }

}


There may be an encoding problem receiving the data in your connected application, thats a tricky one to show and I have resorted to printing the hex vals of received data on occasion to really see what came across the wire.

EDIT : 

Try to print out the received data like this : 

for _, b := range buf {
    fmt.Printf(""%X "", b)
}


And then compare with the test data to see if there are differences, this is as you say the only place it could go wrong ?
",32715166
584,32717193,"Do you actually check err and Len after c.conn.Read(buf) finishes?

The chief flaw in your program (as presented) is that you're using buf to search for data while the read operation on your socket is free to return successfuuly after receiving any number of bytes between 1 and 1024, and return with an error after receiving any number of bytes between 0 and 1024.

So, you must do two things:


Check for error;
To access the actual data available at the beginning of the buffer after the read operation ends you have to use the actual length of data, Len.


To do the latter, you usually construct a new slice:

data := buf[:Len]


And then use the data variable:

if bytes.Contains(data, []byte(""}{"")) {
   ...
}


If you don't do this, you might easily access stale data in your buffer — that is, the data left there from the previous call to c.conn.Read(buf).

If you'll think of the situation a bit more, you'll see that nothing guarantees that the next call to Read() on your socket will bring the }{ sequence into the buffer, and you have to be prepared for accumulating your data: that is,


Each call to Read() should add its Len bytes to the number of bytes in the buffer to consider by your code.

This means that if the Nth read operation failed to provide the data you're looking for, the (N+1)th operation must put its bytes right after the last byte of the previous read operation; in Go, this typically means constructing another slice for that next read operation.
You should use the total current number of accumulated bytes to search for ""}{"".


Please consider starting with this book to grasp the basics of networking programming (with Go specifics).



As you can see, properly dealing with this task looks complicated.
So why not let Go do buffering itself?

You could restate your algorythm like this:


Read the input data until a } character is found.  Accumulate this data.
Once } is found, read the next character and if it's a {, we've found the spot we're interested in.

Otherwise return to step (1).


This is doable using bytes.Buffer and its methods:


ReadBytes(delim byte) — for reading up to a } byte.
ReadByte() — for reading a single byte to check if a { follows.
UnreadByte(c byte) — for putting the byte back into the buffer if it's not a { following }.




Now let's look at your problem from a more general perspective.
The data you've presented in your example looks like a series of JSON objects to me.  So why are you trying to apply some low-tech approach for finding boundaries between those objects instead of just using JSON decoder to decode your data right away or at least properly skip over objects in the stream?
",32715166
585,32731118,"Since entering this answer, I learned that OP is trolling us. Stop feeding the troll.

You can write multiple values to a stream. You can read multiple values from a stream.

This code writes two values to output stream w, an io.Writer:

e := gob.NewEncoder(w)
err := e.Encode(v1)
if err != nil {
   // handle error
}
err := e.Encode(v2)
if err != nil {
  // handle error
}


This code reads the values from stream r, an io.Reader. Each call to Decode reads a value that was written by a call to Decode.

d := gob.NewDecoder(r)
var v1 V
err := e.Decode(&v1)
if err != nil {
   // handle error
}
var v2 V
err := e.Decode(&v2)
if err != nil {
  // handle error
}


Writing multiple values to a stream gains efficiency because information about each encoded type is written once to the stream.  
",32730794
586,32833605,"Binding so not work. The fields of your form - name = ""fields [1]"" and
name = ""fields [0]"" are independent from each other, so for each of them your structure should contain its own field:

type FormInfo struct {
    Fields1   string
    Fields2   string
    Action    string
    PageTitle string
    Id        string
}


respectively, in the handler:

...
&f.Fields1: ""fields[0]"",
&f.Fields2: ""fields[1]"",
&f.Action:  ""action"",
...


As a result, the output will be:

(*main.FormInfo)(0xc08200aa50)({
 Fields1: (string) (len=7) ""value 1"",
 Fields2: (string) (len=7) ""value 2"",
 Action: (string) (len=4) ""save"",
 PageTitle: (string) """",
 Id: (string) """"
})


EDIT:

If you change the code in the form on the

...
<input type=""text"" name=""fields""...
<input type=""text"" name=""fields""...


you can get

info.Fields = [value 1 value 2]


without changing its original code.
",32815561
587,32932233,"Outside of a package only the exported identifiers can be reached / referred to, that is identifiers that start with an uppercase letter.

So the easiest fix is to export your math.add() function by changing its name to Add() in math.go:

func Add(x, y int) int {
    return x + y
}


And of course when you refer to it from the main.go:

x := math.Add(6 + 5)


And as a side note, note that when importing your hello_world/math package you don't have to specify a new name to refer to its exported identifiers: by default it will be the last part of its import path, so this is equivalent to your imports:

import (
    ""fmt""
    ""hello_world/math""
)

",32932199
588,32962550,"The main problem is that structs are not descriptor values like slices or maps, that is if you assign a struct value to a variable, it will be copied. If you assign a struct value to an element of a slice or array, the slice will be copied. They will not be linked!

So when you add your rootFile to stack, and then you pop an element from the stack (which will be equal to rootFile) and you modify the popped element, you will not observe the changes in your local variable rootFile.

Solution is simple: use pointers to structs.

You also have a mistake in your code:

child = (toFile(children[i], path+""/""+children[i].Name())) //turn it into a File object


It should be:

child = (toFile(children[i], file.Path+""/""+children[i].Name())) // ...


Tips to improve your code:

I would rather use path.Join() or filepath.Join() to join path elements:

child = toFile(children[i], filepath.Join(file.Path, children[i].Name()))


Your code might not even work if the initial path ends with a slash or backslash and you explicitly concatenate it with another slash. Join() will take care of these so you don't have to.

Don't declare all local variables ahead in the beginning of your function, only when you need them, and in the most inner block you need them. This will ensure you don't accidentally assign to the wrong variable, and you will know it is not modified outside of the innermost block (because outside of it it is not in scope) - this helps understanding your code much easier. You may also use short variable declaration.

Make use of the for ... range construct, much cleaner. For example:

for _, chld := range children {
    child := toFile(chld, filepath.Join(file.Path, chld.Name()))
    file.Children = append(file.Children, child)
    stack = append(stack, child)
}


Also make use of zero values, for example if a file is not a link, you don't need to set the IsLink and LinksTo fields as the zero values are false and """" which is what you would end up with.

And although it may not be important here, but always handle errors, print or log them as a minimum so you won't end up wasting time figuring out what is wrong if something is not what you expect (you will end up searching bugs in your code, and hours later you finally add print errors and see the bug wasn't in your code but somewhere else).

Working variant using pointers and tips mentioned above

type File struct {
    ModifiedTime time.Time `json:""ModifiedTime""`
    IsLink       bool      `json:""IsLink""`
    IsDir        bool      `json:""IsDir""`
    LinksTo      string    `json:""LinksTo""`
    Size         int64     `json:""Size""`
    Name         string    `json:""Name""`
    Path         string    `json:""Path""`
    Children     []*File   `json:""Children""`
}

func iterateJSON(path string) {
    rootOSFile, _ := os.Stat(path)
    rootFile := toFile(rootOSFile, path) //start with root file
    stack := []*File{rootFile}

    for len(stack) > 0 { //until stack is empty,
        file := stack[len(stack)-1] //pop entry from stack
        stack = stack[:len(stack)-1]
        children, _ := ioutil.ReadDir(file.Path) //get the children of entry
        for _, chld := range children {          //for each child
            child := toFile(chld, filepath.Join(file.Path, chld.Name())) //turn it into a File object
            file.Children = append(file.Children, child)                 //append it to the children of the current file popped
            stack = append(stack, child)                                 //append the child to the stack, so the same process can be run again
        }
    }

    output, _ := json.MarshalIndent(rootFile, """", ""     "")
    fmt.Println(string(output))
}

func toFile(file os.FileInfo, path string) *File {
    JSONFile := File{ModifiedTime: file.ModTime(),
        IsDir:    file.IsDir(),
        Size:     file.Size(),
        Name:     file.Name(),
        Path:     path,
        Children: []*File{},
    }
    if file.Mode()&os.ModeSymlink == os.ModeSymlink {
        JSONFile.IsLink = true
        JSONFile.LinksTo, _ = filepath.EvalSymlinks(filepath.Join(path, file.Name()))
    } // Else case is the zero values of the fields
    return &JSONFile
}

",32962128
589,33165892,"It might be simple, but matrix environement can not be done for a specific OS ...

Then just select with local environement variable:

language: go
go: 
  - 1.5.1
branches: 
  only: 
    - master
os:
  - osx
  - linux
install:
  - if [ ""$TRAVIS_OS_NAME"" == ""linux"" ]; then
        export GIMME_OS=windows;
        export GIMME_ARCH=amd64;
    fi
before_script:
  - go get -d -v ./...
script:
  - go build -v ./...
after_script:
  - go test -v ./...
before_deploy: 
  - ./before_deploy.sh


An other way:

language: go
go: 
  - 1.5.1
branches: 
  only: 
    - master
matrix:
  include:
    - os: linux
      env: GIMME_OS=windows; GIMME_ARCH=amd64;
    - os: osx
before_script:
  - go get -d -v ./...
script:
  - go build -v ./...
after_script:
  - go test -v ./...
before_deploy: 
  - ./before_deploy.sh


Note: the commande: - chmod +x ./before_deploy.sh can be directly done in your repository and commited on it ...

Note: The environament variable can be accessibe: http://docs.travis-ci.com/user/environment-variables/#Default-Environment-Variables or calling \printenv`
",33111375
590,33171739,"QueryRow returns a single *sql.Row

What you want is Query, which will give you *sql.Rows which has the methods you are trying to use.
",33171661
591,33180089,"For a function like json.Unamrshal, you don't need the map, you only need the correct type pointer, which you can make with reflect.New. The json package will allocate the map as needed.

m := reflect.New(reflect.MapOf(reflect.TypeOf(""""), reflect.TypeOf(typ)))


If you need to allocate the map, use the Set method to assign it to the pointer.

http://play.golang.org/p/hnOhh8242i

mapType := reflect.MapOf(reflect.TypeOf(""""), reflect.TypeOf(typ))

ptr := reflect.New(mapType)
ptr.Elem().Set(reflect.MakeMap(mapType))

",33179876
592,33237188,"Type this stuff into Google before you come here.


  you can do this by execing stty -echo to turn off echo and then 
  stty echo after reading in the password to turn it back on


OR


  Just saw a mail in #go-nuts maillist. There is someone who wrote quite
  a simple go package to be used. You can find it here:
  https://github.com/howeyc/gopass
  
  It something like that:

package main

import ""fmt"" import ""github.com/howeyc/gopass""

func main() {
    fmt.Printf(""Password: "")
    pass := gopass.GetPasswd()
    // Do something with pass }



Taken from another Stackoverflow post.
",33237126
593,33308935,"A few things:


Create an interface that will be implemented both by datastore.Storage and your mock store.
Use the above interface as the argument type in EventHandler (not a pointer to the interface).
Pass a pointer to your MockStore to EventHandler, as the Get method is defined for a pointer to the struct.


Your updated code should be something like the following:

type Store interface {
   Get() (interface{}, bool) // change as needed
   Set(interface{}) bool
}

type MockStore struct {
   mock.Mock
}

func (s *MockStore) Get() ... 

func EventHandler(w http.ResponseWriter, r *http.Request,bucket datastore.Storage){
   //Does HTTP stuff and stores things in a data store
   // Need to mock out the data store get/sets
}


// Later in my Tests
ms := &MockStore{}
EventHandler(w,r,ms)

",33308887
594,33314888,"Hope this will help:

package main

import (
    ""fmt""
    ""io/ioutil""
    ""log""
    ""net/http""
)

func Error(err error) {
    if err != nil {
        log.Fatal(err)
    }
}

func main() {
    response, err := http.Get(""http://www.oracle.com/"")
    Error(err)

    defer response.Body.Close()

    contents, err := ioutil.ReadAll(response.Body)
    Error(err)

    fmt.Printf(""%s\n"", contents)
}


For more details: https://golang.org/pkg/net/http/
",33314790
595,33317209,"An alternative approach is to make main() be a stub that merely calls into another function after arguments are processed by flag.Parse(), for example:

var flagvar int
func init() {
    flag.IntVar(&flagvar, ""flagname"", 1234, ""help for flagname"")
}

func main() {
    flag.Parse()
    submain(flag.Args)
}

func submain(args []string) {
   ...
}


Then in your tests, flag variables can be set and arguments established before calling submain(...) simulating the command line establishment of flags and arguments.  This approach can be used to maximize test coverage without actually using a command line.  For example, in main_test.go, you might write:

func TestSomething(t *testing.T) {
    flagvar = 23
    args := []string{""a"", ""b"", ""c""}
    submain(args)
    ...
}

",21350962
596,33338989,"I'm new to Go, please excuse this code for being ugly/malformed/just plain wrong.

I've been working my way though this and ran across the same problem on appengine. 

@Caleb's answer above was a big help. I've just added some detail to that to help someone who might come across a similar problem.

Here's what my import statement looks like:

Import {
    ""appengine""
    ""appengine/urlfetch""
    ""bytes""
    ""encoding/json""
    ""fmt""
    ""golang.org/x/oauth2""
    ""io/ioutil""
    ""net/http""
    ""net/url""
}


This is a function that receives and incoming authentication callback request, then replies with a request for an access token from the authentication server. In this case, fitbit, which needs an Authentication header set to ""Basic"" with some extra information. I couldn't figure out how to do this with the stock Oauth2 library, which doesn't seem to easily allow changing the request headers. 

As you can see we the context of the incoming request (r). From that context, we get the http.Client from urlfetch. 

Then we pack up and send a request back, with some authorization information. 

After we get a response we print the results to the browser. 

Hope this helps!

func authCallbackHandler(w http.ResponseWriter, r *http.Request) {

    data := url.Values{}
    data.Set(""client_id"", ""231343"")
    data.Add(""grant_type"", ""authorization_code"")
    data.Add(""redirect_uri"", ""http://localhost:8080/callmebacklaterok"")
    data.Add(""code"", ""authcode123132"")

    encodedData := data.Encode()

    c := appengine.NewContext(r)
    client := urlfetch.Client(c)

    urlStr := ""https://api.fitbit.com/oauth2/token""
    req, _ := http.NewRequest(""POST"", urlStr,bytes.NewBufferString(encodedData))
    req.Header.Add(""Authorization"", ""Basic RmFuY3kgbWVldGluZyB5b3UgaGVyZSEg"")
    resp, _ := client.Do(req)
    defer resp.Body.Close()

    fmt.Fprint(w, resp)

    body, err := ioutil.ReadAll(resp.Body)
    if err != nil {
       panic(err.Error())
    }

    var bodydata interface{} 
    err = json.Unmarshal(body, &bodydata)
    if err != nil {
        panic(err.Error())
    }
    fmt.Fprint(w, bodydata)

}

",29871954
597,33400582,"I can't reproduce this behavior. Are you sure it's not a simple error that you forgot to show here?

https://play.golang.org/p/-jtmll17Xj

package main

import ""fmt""

func Info(format string, args ...interface{}){
    msg := fmt.Sprintf(format, args...)
    fmt.Print(msg)
}

func main() {
    Info(""Hello %s"", ""World"")
}


Prints

Hello World


According to the fmt docs, %!(EXTRA string=WORLD) is added to the string when you pass extra parameters, unexpected by the format. Maybe you are using the format string ""Hello World"" instead of ""Hello %s"", or passing the argument twice?
",33400325
598,33401293,"The error was between the chair and keyboard. I mixed up the following interfaces:

func Print(v ...interface{})
func Printf(format string, v ...interface{})


Some of my code was calling the library without a format string.See here for a more detailed example: http://play.golang.org/p/Xx79qujaFp
",33400325
599,33513828,"This seems to be a known issue: https://github.com/golang/go/issues/6483.  The workaround is to call SerializePrivate first, even if you don't use the result.
",29929750
600,33524942,"in case where multiple ""teardown"" processes are needed, great solution to this is using google context package (https://blog.golang.org/context). advantage is that you can teardown all currently executing procedures with single context. smth like this:

package main

import (
    ""fmt""
    ""io""
    ""log""
    ""os""

    ""golang.org/x/net/context""
)

func LogSetup(ctx context.Context) error {
    logFile, err := os.OpenFile(""test.log"", os.O_CREATE|os.O_APPEND|os.O_RDWR, 0666)
    if err != nil {
        return err
    }

    log.SetOutput(io.MultiWriter(os.Stderr, logFile))
    // here we could f.ex. execute:
    // sendLogOutputToExternalService(ctx)
    // and it could have it's own teardown procedure
    // which would be called on main context's expiration
    go func() {
       for _ = range ctx.Done() {
         err := logFile.Close()
         if err = nil {
             fmt.Fprintf(os.Stderr, ""Problem closing the log file: %s\n"", e)
        }
    }()
    return nil
}


func main() {
    var stopAll func()
    mainContext, stopAll = context.WithCancel(context.Background())
    defer stopAll()

    err := LogSetup(mainContext)
    if err!=nil {
        log.Fatal(""error while initializing logging"") 
    }

    log.Println(""Test message"")
}

",25342806
601,33605439,"It turns out that line

glidenovendor = append(glidenovendor, strings.Split(out.String(), "" "")...)

for some reason added a new line character ""\n"" to the last string element of the glidenovendor slice. I still have no idea why. But removing it with the snippet below got the script running as expected:

// Remove trailing LF from strings in `glidenovendor`
for i, v := range glidenovendor {
    glidenovendor[i] = strings.Trim(v, ""\n"")
}

",33604928
602,33632446,"Your method of generating the random numbers is fine, however xs is empty, and Go doesn't automatically extend slices. You could use append, however since you know the size in advance, it's most efficient to replace

var xs []float64


with

xs := make([]float64, 10)


which will give it the right size initially.
",33632365
603,33633601,"@hobbs answered the part about your error, but still your solution will give you the same array every time you run it because you are not passing a random seed. I would do something like this:

package main 

import (
    ""fmt""
    ""math/rand""
    ""time""
)

func main() {
    s := rand.NewSource(time.Now().UnixNano())
    r := rand.New(s)

    xn := make([]float64, 10)

    for n := 0; n < 10; n++ {
        xn[n] = r.Float64()
    }

    fmt.Println(xn)
}

",33632365
604,33646531,"You can create one timer object with time.NewTicker this will provide with a channel that sends a message periodically. 
",33645459
605,33655049,"You want to create a single priority queue that holds all of the scheduled timeouts.  A single goroutine should be checking the head of the priority queue, sleeping until the next timeout, and either execute the associated code or discard it.

Of course, you will need to deal with synchronisation issues.  The Java way would be to protect the priority queue by a lock.  The more go-ish approach would be to put the timeout-handling goroutine in charge of enqueing timeouts, which it receives over a dedicated channel.

There is a priority queue implementation in package container/heap, but I haven't checked how good it is.
",33645459
606,33672201,"Your OAuth token has no write:public_key scope. Scopes
",33666158
607,33699213,"
  Is there a way to pre-compile my dependencies (get .a) files, so it is
  faster to compile when I run go install or go build


See https://golang.org/cmd/go/#hdr-Compile_packages_and_dependencies


  go build [-o output] [-i] [build flags] [packages]


[...]


  The -i flag installs the packages that are dependencies of the target.





  Also, how can I remove vendor/ from go's tools to lint and check the
  codebase for errors?


See https://github.com/golang/go/issues/11659#issuecomment-122139338:


  Instead of using ./... you can do:


go install $(go list ./... | grep -v /vendor/)
",33688705
608,33705844,"The GitHub API docs for creating a public key give an example with  a request body that contains lowercase keys:

{
  ""title"": ""octocat@octomac"",
  ""key"": ""ssh-rsa AAA...""
}


while the first character of your request keys is capitalized:

{
  ""Title"": ""octocat@octomac"",
  ""Key"": ""ssh-rsa AAA...""
}


I think the easiest way to fix this is by using json struct tags on your githubBody struct. For example:

type githubBody struct {
    Title string `json:""title""`
    Key string `json:""key""`
}

",33666158
609,33705989,"You are trying to access variables called 1back and 2back but your variables are actually called back1 and back2 
",33705973
610,33708340,"Refactoring issues aside, keep in mind that variables in go must begin with a letter, not a number. back1 and back2 are valid go variables, but 1back and 2back are not. See https://golang.org/ref/spec#Identifiers. 
",33705973
611,33722676,"I do not believe you're doing what you think you are.

curl -X POST -d ""Screen Shot 2015-11-15 at 6.09.58 pm.png"" http://localhost:8000/image/agent123/property --header ""Content-Type:image/png"" --header ""X-User-Agent:agent-php"" 


Will not send the file ""Screen Shot 2015-11-15 at 6.09.58 pm.png"", it's gonig to send the literal text as the body. You probably want ""-d @'Screen Shot 2015-11-15 at 6.09.58 pm.png'"".

Which then your ""good"" result is not exactly good, so you have to figure out what the bug is at the receiving end on the server. As the GUI client you're using is probably sending the file, whereas cURL is not. And your backend seems to accept text, not files. 
",33722090
612,33806519,"
  I am trying to use logrus to write the CSV as logs. But I see the log level (info) and the time getting added to the CSV content in logs.


It looks like you definitely shouldn't be using logrus, as the main reason it exists is creating structured logs, i.e. key-value style. Not sure why don't you simply do

fmt.Println(""100,Click,Android"")


or

fmt.Fprintln(os.Stderr, ""100,Click,Android"")


if you want it to be written into the standard error (default for loggers).

If for any reason you need a logger, you can pretty much do the same thing with the standard logger by disabling flags:

log.SetFlags(0)
log.Println(""100,Click,Android"")

// Output:
// 100,Click,Android


However, if you're creating a CSV output yourself (i.e. you have spearate fields rather than full CSV lines already), use csv package from the standard library:

w := csv.NewWriter(os.Stdout)
w.Write([]string{""100"", ""Click"", ""Android""})
w.Flush()

// Output:
// 100,Click,Android


Unless you just want to use logrus, then follow the concept of the package and stick with structured output:

logrus.WithFields(logrus.Fields{
    ""id"": ""100"",
    ""event"": ""Click"",
    ""os"": ""Android"",
}).Info(""Hooray, we have some users!"")

// Output:
// time=""2015-11-19T15:20:32+01:00"" level=info msg=""Hooray, we have some users!"" event=Click id=100 os=Android

",33781161
613,33836248,"Vehicle is embedded in Car and Bus so you got things going in the wrong direction... It's not like Vehicle is a parent class so you can't get the polymorphic behavior you're looking for out of this design. What you need is an interface.

To show you a working example I'm just going to use empty interface (it will allow you to store any type in the collection). For your actual program you might want to make something like an IVehicle interface and put whatever common method all the vehicles will have on it, maybe something like Start() or whatever...

https://play.golang.org/p/iPJbFYlo7o

To expand on that embedding thing a little bit... This isn't inheritance. You can accomplish the same things with it however the statement ""Car is a Vehicle"" is not true. This is actually more like composition, ""Car has a Vehicle"". It's just that Vehicle's fields and methods are 'hoisted' up to Car, meaning they can be accessed from an instance of Car without another layer of indirection like Car.Vehicle.FieldOnVehicle. That's not really what you're looking for. If you want to say ""Car is a Vehicle"" and it be true, then Vehicle needs to be an interface which Car implements.
",33835925
614,33848913,"What about anonymous fields? I'm not sure if that will constitute a ""nested struct"" but it's cleaner than having a nested struct declaration. What if you want to reuse the nested element elsewhere?

type NestedElement struct{
    someNumber int `json:""number""`
    someString string `json:""string""`
}

type BaseElement struct {
    NestedElement `json:""bar""`
}

",21268000
615,33873000,"
Yes it will; this is true of basically all binaries compiled for 64-bit Linux, not just those written in Go (except for shared libraries, which Go doesn't rely on)
You can set the GOOS and GOARCH environment variables before building: GOOS=windows GOARCH=386 go build (or go install or whatever), etc
By default a binary will be built for the system you're running, but this isn't necessary - see 2

",33872612
616,33902991,"It seems the documentation is incorrect. handlers.RecoveryHandler can not be used as a http handler middleware itself, it returns one. Looking at the signature

func RecoveryHandler(opts ...RecoveryOption) func(h http.Handler) http.Handler


we can see that it takes 0 or more handlers.RecoveryOptions and returns a func(http.Handler) http.Handler. That func that it returns is what we actually want to wrap around our router. We can write it as

recoveryHandler := handlers.RecoveryHandler()
http.ListenAndServe("":1123"", recoveryHandler(r))


Or you could do it all in one line

http.ListenAndServe("":1123"", handlers.RecoveryHandler()(r))

",33902212
617,33911866,"Fields in your structures starts with lower case so they are not marshalled to JSON. Make them start with upper case letter.

package main

import ""encoding/json""
import ""fmt""

type Sim struct {
    Yr, Ag, Av, Db, Wd, St []int
    Withdrawal             []string
}

func main() {
    // Creating simulation
    var s Sim

    // Converting to JSON, for transmission over web
    data, err := json.Marshal(s)
    if err != nil {
        fmt.Println(err)
        return
    }

    // Data is correct
    fmt.Println(s)

    // Prints: {}
    fmt.Println(string(data))
}


Playground

JSON serialization in GO
",33911712
618,33948752,"Really surprised nobody has mentioned gopkg.in.

gopkg.in is a service that provides a wrapper (redirect) that lets you express versions as repo urls, without actually creating repos. eg gopkg.in/yaml.v1 vs gopkg.in/yaml.v2, even though they both live at https://github.com/go-yaml/yaml


gopkg.in/yaml.v1 redirects to https://github.com/go-yaml/yaml/tree/v1
gopkg.in/yaml.v2 redirects to https://github.com/go-yaml/yaml/tree/v2


This isn't perfect if the author is not following proper versioning practices (by incrementing the version number when breaking backwards compatibility), but it does work with branches and tags.
",24855081
619,34101405,"Edit:

Taking a closer look at the Go repository, the releases are actually just tags and not Github releases, that's why it's returning an empty array. Try this:

// https://api.github.com/repos/jp9000/obs-studio/releases
releases, rsp, err := client.Repositories.ListReleases(""jp9000"", ""obs-studio"", opt)


This should correctly return all releases for jp9000's obs-studio repository.

Original Answer:

Looking at the docs, the code looks good but this might be an issue with Github's API though. For instance, if you go to https://api.github.com/repos/golang/go/releases you get an empty array, but if you search for the tags using https://api.github.com/repos/golang/go/tags it lists all tasks without any problem.

And if you go to https://api.github.com/repos/golang/go/releases/1 you get a 404. I took these addresses from the Github Developer's page: https://developer.github.com/v3/repos/releases/#list-releases-for-a-repository
",34100738
620,34191218,"By default, Angular adds the hashPrefix in front of urls. So when you navigate to http://localhost:8080/admin , You don't see index.html since you have not yet visited the url as defined in the angular's ui-router. You will have to navigate to http://localhost:8080/admin/#/ to actuall be in the / state of your application. 

It is the same reason that your app doesn't work without the .otherwise(), since then it automatically redirects you to the / state later. 

For a possible fix:

Inside your .config function:

// This is in your app module config.
$locationProvider.html5Mode(true);


And in your index.html:

// This is in your index.html head.


",34191096
621,34191224,"The problem is not with not having a declared otherwise.

The problem lays on your route. You're specifying the url to be '/', that means the state home is accessible only through http://localhost:8080/admin/ and NOT through http://localhost:8080/admin

What the otherwise does is. When you access the url http://localhost:8080/admin the router try to find a state that matches the url, but don't find it. So it redirects to http://localhost:8080/admin/ which matches with your home state.
",34191096
622,34230466,"I assume your main_package isn't the main package in Go. I think the child_packages shouldn't be under the main_package as our goal is to decouple each package from one another. 

This is the pattern that I'm currently using in my project to avoid dependency conflicts:

project/
├── main_package
│   └── main_package.go
├── brokers
│   └── brokers.go
├── child_package1
│   └── child_package1.go
├── child_package2
│   └── child_package2.go
└── child_package3
    └── child_package3.go


Essentially, each package should never have to deal with anything outside of itself (or at least do so with as little as possible). The broker will be the sole party who ""negotiates"" between any two packages. 

// main_package.go
package main_package

import (
    ""path/to/sql""
    ""path/to/mux""
    ""path/to/brokers""
)

// Never use selectors from packages directly
// but create a `Broker` object for each endpoint
var bk1 = brokers.New(""/api1"")
var bk2 = brokers.New(""/api2"")
var bk3 = brokers.New(""/api3"")

func Handlers(db *sql.DB, customeruploadFile string) *mux.Router {
    router := mux.NewRouter()

    // each broker has its own `MyHandler` function
    router.HandleFunc(""/api1"", bk1.MyHandler)
    router.HandleFunc(""/api2"", bk2.MyHandler)
    router.HandleFunc(""/api3"", bk3.MyHandler)

    fileHandler := http.FileServer(http.Dir(""./client/compiled""))
    router.PathPrefix(""/"").Handler(http.StripPrefix(""/"", fileHandler))
    return router
}


The brokers package is the central interface for the communication

// brokers.go
package brokers

import (
    ""path/to/child_package1""
    ""path/to/child_package2""
    ""path/to/child_package3""
    ""net/http""
)

type Broker interface {
    MyHandler(http.ResponseWriter, *http.Request) 
}

// Factory function to create a `Broker` instance
func New(uri string) Broker {
    if uri == ""/api1"" {
        return Broker( new(child_package1.Delegate) )
    } else if uri == ""/api2"" {
        return Broker( new(child_package2.Delegate) )
    } else if uri == ""/api3"" {
        return Broker( new(child_package3.Delegate) )
    }
    return nil
}


Now child_packageX is no long decoupled to any internal dependency, provided
it expose a ""representative"" or Delegate object to talk to the broker.

// child_package1.go
package child_package1

import ""net/http""

type Delegate struct {
   // Optional parameters can be carried by the Delegate
   // to be used in the created Broker anywhere
}

func (d *Delegate) MyHandler(w http.ResponseWriter, r *http.Request) {
  // Maybe return a JSON here
}


Each child can have its own MyHandler that does different things for different api calls, without having to know what endpoints they are serving.

// child_package2
package child_package2

import ""net/http""

type Delegate struct {}

func (d *Delegate) MyHandler(w http.ResponseWriter, r *http.Request) {
    // Maybe return an XML here
}


The main_package doesn't import all the child_packageX, but just the broker package. You can write a test that imports the broker package instead of the actual packages, or you can even write another broker for testing.

package test

import (
    ""testing""
    ""path/to/main_package""
)

func TestMain(*testing.T) {
    // test the routing in `main_package`
}


You're no longer testing a functionality of a handler function, but one of an endpoint exposed by a broker. This encourage you to write generic handler functions and focus on the higher level endpoints.

package test

import (
    ""testing""
    ""path/to/broker""

)

func TestGetJSONAlright(*testing.T) {
     bk1 := brokers.New(""/api1"")
     // test if I get JSON here
}

func TestGetXMLAlright(*testing.T) {
    bk1 := brokers.New(""/api2"")
    // test if I get XML here
}


This, in my opinion, is a powerful pattern since you can write more ""generic"" handlers and just plug them in to the routes you want.  
",34222841
623,34232264,"Order 'not specified' means that it's up to compiler to decide, and it is not guaranteed to be the same over different versions of a compiler/other compilers etc/other machine/other time of day etc.

It does not mean that it has to be different each time or crash (as you may be accustomed to from C, where 'undefined behaviour' usually meant something bad, for example like using a pointer after freeing memory)
",34232126
624,34259703,"If you for example just do a http.Get then just

User-Agent: Go-http-client/1.1
Accept-Encoding: gzip

",34259350
625,34295295,"I just had this exact issue, and the accepted solution did NOT solve it for me. That's because my $HTTP_PROXY environment variable was not set!

I was able to solve it by setting up my environment variables as per indicated here: http://www.bonusbits.com/wiki/HowTo:Setup_Charles_Proxy_on_Mac Then once the variable was set correctly, I didn't even need to apply a custom Transport to my client. It worked with the default transport.

Perhaps because I'm using a custom shell (zsh) this didn't happen automatically. However what's interesting is that python would correct appear in Charles Proxy in the same shell while Go would not. Updating my .zshrc (or whatever shell or profile you are using's config) to export the appropriate variables worked.
",18187136
626,34376163,"you can just cast your integer literal to uint64.

for i := uint64(1); i <= k; i++ {
    // do something
}


Alternatively you could initialize i outside of the for loop, but then it's scoped larger than the loop itself.

var i uint64
for i = 1; i <= k; i++ {
    // note the `=` instead of the `:=`
}
// i still exists and is now k+1

",34376141
627,34376170,"You have to explicitly declare your variables as that type. The int literal will be of type int https://play.golang.org/p/OgaZzmpLfB something like var i uint64 is required. In your example you'd have to change your assignment as well so something like this;

var i uint64
for i = 2; i <= k; i += 1 { // I want i to be a uint64
    ...
}

",34376141
628,34406759,"Function overloading is not supported in the language. From the official Golang site it says,

Method dispatch is simplified if it doesn't need to do type matching as well. Experience with other languages told us that having a variety of methods with the same name but different signatures was occasionally useful but that it could also be confusing and fragile in practice. Matching only by name and requiring consistency in the types was a major simplifying decision in Go's type system.

Regarding operator overloading, it seems more a convenience than an absolute requirement. Again, things are simpler without it.

https://golang.org/doc/faq#overloading

One potential solution would be to define a high level function that type checks and handles different types similarly to how you would overload multiple functions. See @evanmcdonnal's solution for a great example. 
",34406700
629,34406772,"The most common way to do this would be to define the method as func fatal(err interface{}) then do type assertions or use a type switch within it's body to handle each of the different types. If I were coding for your example it would look like this;

func fatal(err interface{}) {
     if v, ok := err.(string); ok {
         fmt.Println(v)
     }
     if v, ok := err.(error); ok {
          fmt.Println(v.Error())
     } else {
        // panic ?
     }
}


Also; here's a quick read about type switches and assertions that may be helpful; http://blog.denevell.org/golang-interface-type-assertions-switch.html
You can also check out effective-go as it has sections on both features.
",34406700
630,34406811,"Use log.Fatal() instead. https://golang.org/pkg/log/#Fatal

You can use interface{} but it is not recommended because you lose all the benefits of type checking when you do that. The Go authors get to use interface{} because they understand the appropriate level of additional testing and checks to do when using interface{}. It's much easier (even for intermediate and advanced gophers) to use builtin and standard library functions when something like this is required.

Go does not have algebraic or/sum types either. The standard workaround is to define an and/product type with pointers (e.g. struct{*string, *error}) and go to the effort of making sure you only ever make one of the fields non nil at any point in time.
",34406700
631,34464139,"No, they can't be lost.

While the language spec does not in any way impose any particular implementation on channels, you can think of them as critical sections or mutexes protecting either a single value (for the single message) or an array/list of them (for buffered channels).

The semantics are then enforced in such a way that as soon as a goroutine wants to send a message to a channel, it enters that critical section / locks the mutex, and then either succeds at sending—there's a free slot for its message—or blocks—when there isn't.  As soon as such a slot appears—someone has received an existing message—the sending succeeds and the sending goroutine gets unblocked.

This is a simplified explanation but I hope it gets you the correct idea. In other words, channels in Go is not like message queues which usually are happy with losing messages.

On a side note, I'm not really sure what happens if the receiver panics in some specific state when it's about to receive your message. IOW I'm not sure whether Go guarantees that the message is either sent or not in the presence of a receiver panicking in an unfortunate moment.

Oh, and there's that grey area of the main goroutine exiting (that one running the main.main() function): the spec states clear than the main goroutine does not wait for any other goroutines to complete when it exits. So unless you somehow arrange for the synchronized controlled shutdown of all your spawned goroutines, I beleive they may lose messages.  On the other hand, in this case the world is collapsing anyway…
",34463793
632,34465135,"If something has been successfully sent into the channel then no, it can't be lost in correctly working environment (I mean if you're tampering with your memory or you have bit flips due to cosmic rays then don't expect anything of course).

Message is successfully sent when ch  returns. Otherwise, if it panics, it's not really being sent and if you don't recover than you could claim it's lost (however, it would be lost due to application logic). Panic can happen if channel is closed or, say, you're out of memory.

Similarly if sender is putting into the channel in non-blocking mode (by using select), you should have a sufficient buffer in your channel, because messages can be ""lost"" (although somehow intentionally). For example signal.Notify is working this way:


  Package signal will not block sending to c: the caller must ensure that c has sufficient buffer space to keep up with the expected signal rate.

",34463793
633,34480141,"Message can not be lost. It can be not sent.Order of goroutines execution not defined. So your endless for loop can receive from only one worker all time, and even can sleep if it isn't in main thread. To be sure your queue works in regular fashion you better explicitly in 'main' receive messages for each worker.
",34463793
634,34494494,"Hi I Don't know about go but I know about oracle return query 

Same problem I had with PHP and I solve it using this query 

insert into table (field1,field2,field3)
values (val1,val2,val3) return primaryfield_id into :xx


It will automatically return value in your Go variable (I guess )
please try this 
",34285040
635,34584151,"The program sends two values to the channel out and reads one value from the channel out.  One of the values is not received.

If the channel is unbuffered (capacity 0), then one of the sending goroutines will block until the program exits.  This is a leak.

If the channel is created with a capacity of 1, then both goroutines can send to the channel and exit. The first value sent to the channel is received by main. The second value remains in the channel.

If the main function does not receive a value from the channel out, then a channel of capacity 2 is required to prevent the goroutines from blocking indefinitely.
",34583722
636,34645031,"I think you are assuming mgo is an ""ORM"". But it's just a simple way to store data in Mongo. There are 3 different ways to fix your problem:


Put different types into different collections. That way, every document is the same type.  (Collections are like ""tables"" in a relational database).
Tag each thing with it's type (i.e. store the object type in a field), then you can query on it.
If you are feeling dangerous, you can assume all Artists have Genres, and all Users have a Profile. Then use $exists to select only that type.


The first option is the usual way to do it. You should have specific reasons for doing #2 or #3, as they could be slower.
",34644754
637,34696916,"In order for your JSON to be picked up by the decoder, the fields in your struct must be exported.

This means you need you capitalize the field names. If you have custom naming on your fields -> json conversion, you can add json tags to your structs. 

This will fix your issue:

type SynonymResponse struct {
    Lists []SynonymList `json:""response""`
}

type SynonymList struct {
    Category string `json:""category""`
    Synonyms string `json:""synonyms""`
}

",34696852
638,34717018,"You should use strings.Join for this. Try,

fmt.Printf(""%s, Author of The Art of Computer Programming"", strings.Join(os.Args[1:], "", ""))


Join returns a string with "", "" inserted between each argument.
",34716700
639,34721983,"The reason it's outputting the brackets is because you're passing a slice into the print command.

What you want to do is take each command and put them into a string to be printed as needed.

firstname := os.Args[1]
lastname := os.Args[2]
fmt.Println(lastname + "", "" + firstname)


You should also take a look at the strings package as was pointed out by Chandru. There's a bunch of goodies in there to help with dealing with strings.

See: https://golang.org/pkg/strings/
",34716700
640,34726387,"It looks like the two libraries that you are using both correctly use runtime.LockOSThread to make main-thread-only API calls; unfortunately, to use more than one such library, you'll have to do something fancier than the example code that either provides.  You'll need to write your own main thread / main.Main-invoked message loop that handles calls to multiple MTO APIs.

runtime.LockOSThread is part of the solution to operating with APIs such as this; the golang wiki has a page about how to use it to interact with ""call from main thread only"" APIs.

An extremely short description of how your program should change:

You'll want to use runtime.LockOSThread in main.init to make sure that the main thread is running main.Main; main.Main should be refactored into two parts:


starts a goroutine or goroutines that run what previously was in main.Main;
enters a message loop receiving messages to take certain main-thread actions on one or more channels

",34724912
641,34826423,"Since there is not enough traction on this question I've decided to post my own solution I found while trying to workaround this issue. This won't be marked as answer yet since someone else may provide better solution.

I have moved one of the UI processes (namely part that uses systray) into another binary and call it using cmd := exec.Command(...) and cmd.Start() then I pipe stdin and stdout and communicate with this child process through those.

The example code can be found on Github. Warning there is an error in this gist where after child exits main process will start burning through CPU cycles. Feel free to fix it yourself.

The reason why I did not want to go through with RPC is because this will become slightly too complex to what I want to achieve and does not provide easy way to do two way communication.
",34724912
642,34829722,"One way could be to have an if statement controlling the print output, i.e. if the result is cleanly divisible by 1 (result%1 == 0) then print the result to no decimal places. Otherwise print to .2f as you've done above. Not sure if there is a shorter way of doing this, but I think this should work.
",34829606
643,34829815,"There's no direct solution with the fmt package.

But you can remove the dot and zeros at end with a regular expression:

r, _ := regexp.Compile(`\.?0*$`)
fmt.Printf(""%s%%\n"", r.ReplaceAllString(fmt.Sprintf(""%.2f"", 100*(value/total)),""""))


Bonus: the same regex works for any number of trailing zeros.

Side note: You'll display 50.0041 the same way than 50, which might be a little misleading.
",34829606
644,34830031,"There's no way to do that inside fmt with e.g. another flag or what have you. You'll have to write out the logic yourself. You could do something like:

var final string
doubledecimal := fmt.Sprintf(""%.2f"", 100*value/total)
if doubledecimal[len(doubledecimal)-2:] == ""00"" {
    final = doubledecimal[:len(doubledecimal)-3]
} else {
    final = doubledecimal
}
fmt.Printf(""%s%%\n, final)


You could similarly use strings.Split to split on the decimal point and work from there.

You could even adjust this to turn 50.10% into 50.1%.

doubledecimal := fmt.Sprintf(""%.2f"", 100*value/total)
// Strip trailing zeroes
for doubledecimal[len(doubledecimal)-1] == 0 {
    doubledecimal = doubledecimal[:len(doubledecimal)-1]
}
// Strip the decimal point if it's trailing.
if doubledecimal[len(doubledecimal)-1] == ""."" {
    doubledecimal = doubledecimal[:len(doubledecimal)-1]
}
fmt.Printf(""%s%%\n"", doubledecimal)

",34829606
645,34837911,"Since the empty string is the nil value of a string, you should compare against that. 

str == """"


Checking variables against their nil values to see if they are empty is the Go way of doing this. 

In terms of performance, there's no notable difference. Using len(str) is a function call, so it should in theory be slower.

EDIT: Some evidence:

I benchmarked this code:

func BenchmarkNil(b *testing.B) {
    str := ""asd""
    cnt := 0
    for i := 0; i < b.N; i++ {
        if str == """" {
            cnt++
        }
    }
}


with the three different checks in the if-statement: str == """", len(str) == 0 and len(str) .

BenchmarkLenEq-8        2000000000               0.77 ns/op
BenchmarkLenLess-8      2000000000               0.76 ns/op
BenchmarkNil-8          2000000000               0.50 ns/op


For checking against an empty string (str := """" instead of str := ""asd""), there is no measurable difference. Checking against a non-empty string takes more time, and there, the nil check is noticeably faster.

BenchmarkLenEq-8        2000000000               0.34 ns/op
BenchmarkLenLess-8      2000000000               0.33 ns/op
BenchmarkNil-8          2000000000               0.33 ns/op


EDIT2:
The only thing you can do these days to be somewhat sure of how fast something is is to benchmark it. Modern CPU's are superscalar, so one clock cycle per instruction is simply not true anymore. The benchmark code comparing against the empty string ran at 2.94GHz (2.94*10^9 op/s) on my 4GHz 6700k, which is less than two clock cycles per loop iteration. The nil check against the non-empty string ran at 2GHz (2*10^9 op/s) on the same CPU. 

This means 2 cpu cycles per loop iteration on the nil check, and 3 on the len check, or a single instruction per loop iteration on the check against the empty string. 
",34837805
646,34838015,"If you check X86 Assembly control flows, you see that there are jump on equality and jump on inequality instructions. So in theory and if you make some simple assumptions about Go compiler, != and  would perform the same (1 CPU clock). 

If you are really into it, you can see this answer and compare what assembly is produced for each of them.
",34837805
647,34879997,"You could dial to the socket before using it:

_, err = net.Dial(""tcp"", ""127.0.0.1:8021"")    //8021 is a closed socket
if err != nil {
    panic(""Error, socket not opened"")
}


EDIT:
Maybe this way is more clear:

isOpen := true
_, err = net.Dial(""tcp"", ""127.0.0.1:8021"")    //8021 is a closed socket
if err != nil {
    isOpen = false
}

if isOpen {
    //Your logic here
}

",34875888
648,34889113,"I enabled tcp keepalive and this problem got solved. I was running my VM in google compute engine and probably the firewall terminated idle connections.

TCP Keep alive

Configuring tcp keep alive in linux

Golang http server automatically picked this up, so no change was required in my golang code.

Regards,

Sathya
",34823724
649,34927433,"Something like this should work, however I'm not familiar with how GCD works so I could be way off.

func main() {
    q := NewQueue(10) // the size is mainly so it wouldn't block, you can play with that to your liking.
    var wg sync.WaitGroup
    for i := 0; i < 10; i++ {
        wg.Add(1)
        i := i
        q <- func() { log.Println(""i ="", i); wg.Done() }
    }
    wg.Wait()
    close(q)
}

func NewQueue(size int) (q chan func()) {
    q = make(chan func(), size)
    go func() {
        for fn := range q {
            fn()
        }
    }()
    return
}


playground
",34926930
650,34947853,"Check out https://godoc.org/code.google.com/p/go-uuid/uuid#NewRandom.

And you may want to consider storing this in a database with the email address and perhaps an expiry date / time so that the verification doesn't stay there forever. You may only want to allow people to verify within 24 hours, or 7 days and so on. Have another job that periodically cleans expired and non-verified emails.
",34947001
651,34947943,"Two points:


No, the method as presented won't guarantee them to be unique.
You don't need to have all your tokens to be unique.


To expand on these points…

You're dealing with a set of outstanding verification requests.
That is:


A request is made by the user;
You generate a unique verification token and store it into some presistent database.  This is needed in order for verification to work anyway.
The user receives your e-mail and clicks that link from it which contain your token.  At this point you remove the information about this pending verificaton request from your persistent storage.


As you can see, at any given time you only have several outstanding verification requests.  Hence this situation has two important properties:


You only need the tokens of these outstanding requests be different from one another.  It's OK to have a verification token to be the same as that of some past (or future) request.
Your tokens have to be hard-to-guess (obviously).  I'm sure you already understand that.


So, the approach to generating a new token is as follows:


Generate something hard-to-guess.
Compare it with the tokens bound to the outstanding/pending verification requests persisted in your storage.

If you find an outstanding request with the same token, you have a collision so go to step (1) and repeat.

Otherwise the token is OK so proceed with it and persist the data about this request.
Once the request passed verification, remove it from your storage.


Exact algorythm for generating tokens does not matter much.  I'd say an UUID or something looking like SHA-256/512 calculated over some random data is OK.
",34947001
652,34949307,"No need to be unique. You could look for more secure/complex solutions but what about simply putting a random number in hex such that    

strconv.FormatInt(rand.Int63(), 16)


https://play.golang.org/p/l9U2uUZNAV
",34947001
653,34995923,"The second current is in the if scope. Replace current :=  with current =  (no colon). When using := you define a new current variable in the nested scope.

if winning == current {
    fmt.Println(games_played)
    break
} else {
    current := <- ch
    games_played += 1
}


is equivalent of:

if winning == current {
    fmt.Println(games_played)
    break
} else {
    var current int[6] // you don't want this, as it shadows your
                       // current form the outher scope
    current = <- ch // you want only this guy
    games_played += 1
}

",34995808
654,35030421,"Your server receives a file (e.g. via a form post), and your server code is responsible to save it to a folder of the server's choice.

The client has no control over where the server will save it. The client may arbitrarily recommend a folder e.g. with another form field (or a subfolder relative to some agreed or arbitrary root), but the client is not in a position to enforce anything.

One thing you should be aware of that if you acquire the posted file name at server side, you should not use it as is, because the client may send a file name which contains folder separators (e.g. '/' and it may contain sequences to denote parent folders (e.g. ""../.."").

What you should do (most secure) is to generate a name at the server side. Or if you want to use the name recommended by the client, only use the last part of the sent file name (in case it contains folder names too). Also if you use the name sent by the client, you should check if file already exists to prevent independent clients to overwrite each other's files. Or best would be to use a folder name unique to the client, that way there is no chance to overwrite each other's files.

You may use the path package to check/manipulate file names and paths. For example path.Base() returns only the last part (the file name) of a path. And you may use path.Join() to concatenate folders and file name.

For example if a client uploads a file via a form post, you may handle it at server side like this:

func fileHandler(w http.ResponseWriter, r *http.Request) {
    f, fh, err := r.FormFile(""file"")
    if err != nil {
        // File not submitted? Handle error 
        http.Error(w, ""You must upload a file"", http.StatusBadRequest)
        return
    }

    // Save it:
    // Here I use username as a unique client identifier
    saveName := path.Join(""path/to/uploaded/files/"", username, path.Base(fh.Filename))
    savef, err := os.Create(saveName)
    if err != nil {
        // Failed to create file on server, handle err
        http.Error(w, ""Failed to save file"", http.StatusInternalServerError)
        return
    }
    defer savef.Close()

    io.Copy(savef, f)
    fmt.Fprintln(w, ""File saved successfully."")
}

",35029311
655,35042360,"Here is the code, that calculates current offset between local and specified timezones. I agree with Ainar-G's comment that offset makes sense only with relation to specified moment in time:

package main

import (
    ""fmt""
    ""time""
)

func main() {
    loc, err := time.LoadLocation(""MST"")
    if err != nil {
        fmt.Println(err)
    }

    now := time.Now()
    _, destOffset := now.In(loc).Zone()
    _, localOffset := now.Zone()

    fmt.Println(""Offset:"", destOffset-localOffset)
}

",35036951
656,35085405,"If only a single goroutine accesses the struct member, you don't need to have a mutex to control access. I would, probably, use one anyway (either re-use the existing mutex in the struct, or another one), on the basis that while there may only be one goroutine accessing that struct member today, there's nothing enforce that.
",35084268
657,35094402,"You do not need another mutex for it, also if you're just operating on int* types, you can ditch the mutex all together and use atomic.*

type shared struct {
    sharedCounter    int64 // member shared between multiple goroutines, protected by mutex
    exclusiveCounter int64 // member exclusive of one goroutine -- is mutex needed?
}

func (s *shared) readCounter() int64 {
    return atomic.LoadInt64(&s.sharedCounter)
}

func (s *shared) setCounter(i int64) {
    atomic.StoreInt64(&s.sharedCounter, i)
}


playground
",35084268
658,35141761,"Based on the compile error you're working with a uint64 pointer and not a uint64 value.  You may get what you want by referencing the value directly using the * operator. I've never worked with protobuf, so I could be off but that should get you moving.  Here's a nice reference that may help golang pointers
",35141669
659,35141771,"pb_obj.Score's type seems to be *uint64 (pointer to uint64), not uint64. You just need to access to the value the pointer is referencing:

score := int64(*pb_obj.Score)


(See the * prefix as the difference)
",35141669
660,35203695,"Like JimB pointed out, you are not handling http nor websocket connections yet.

You can do websocket handling with the package github.com/gorilla/websocket
This is how a simple setup could look like:

package main

import (    
    ""log""
    ""net/http""
    ""github.com/gorilla/websocket""
)

// wsHandler implements the Handler Interface
type wsHandler struct{}

func main() {
    router := http.NewServeMux()
    router.Handle(""/"", http.FileServer(http.Dir(""./webroot""))) //handles static html / css etc. under ./webroot
    router.Handle(""/ws"", wsHandler{}) //handels websocket connections

    //serving
    log.Fatal(http.ListenAndServe(""localhost:8080"", router))
}

func (wsh wsHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
    // upgrader is needed to upgrade the HTTP Connection to a websocket Connection
        upgrader := &websocket.Upgrader{
            ReadBufferSize:  1024,
            WriteBufferSize: 1024,
        }

        //Upgrading HTTP Connection to websocket connection
        wsConn, err := upgrader.Upgrade(w, r, nil)
        if err != nil {
            log.Printf(""error upgrading %s"", err)
            return
        }

        //handle your websockets with wsConn
}


In your Javascript you then need var sock = new WebSocket(""ws://localhost/ws:8080""); obviously.
",35202405
661,35216377,"Note that you can also manipulate what the name of the fields in the generated JSON are by doing the following:

type Name struct {
  First string `json:""firstname""`
  Middle string `json:""middlename""`
  Last string `json:""lastname""` 
}

",15452004
662,35253006,"The issue is that you are initializing the nested map of ""key"" in each called, so it always overrides the previous data.

So just changing your line

retMap[key] = make(map[string]string) // If not assign here then it gives runtime error ""panic: assignment to entry in nil map""


to the below should make your code work:

=_, ok := retMap[key]
if !ok {
    retMap[key] = make(map[string]string)
}


I'm just checking the existence of a value stored for ""key"", and initialize a new map if it doesn't exist.



Updated:

I also rewrote your code to use some built-in functions that Go provide with, as strings.Split or strings.Trim* functions. It could be helpful.

package main

import (
    ""fmt""
    ""strconv""
    ""strings""
)

const str = ""Hello @John martin #sosos &Hi @William ""

func main() {
    retMap := make(map[string]map[string]string)
    retMap[""group""] = make(map[string]string)
    retMap[""user""] = make(map[string]string)
    retMap[""hashTag""] = make(map[string]string)
    list := strings.Split(strings.TrimSpace(str), "" "")

    for _, value := range list {
        firstCharacter := string(value[0])
        if firstCharacter == ""@"" {
            retMap[""user""][strconv.Itoa(len(retMap[""user""])+1)] = strings.TrimLeft(value, ""@"")
        } else if firstCharacter == ""&"" {
            retMap[""group""][strconv.Itoa(len(retMap[""group""])+1)] = strings.TrimLeft(value, ""&"")
        } else if firstCharacter == ""#"" {
            retMap[""hashTag""][strconv.Itoa(len(retMap[""hashTag""])+1)] = strings.TrimLeft(value, ""#"")
        }
    }

    fmt.Println(""Final String "", retMap)
}

",35250981
663,35256530,"Importantly, you should check all of your errors - e.g.:

- hashedPassword, _ := bcrypt.GenerateFromPassword([]byte(r.Form[""passwordSignup""][0]), bcrypt.DefaultCost)
# Check our error, especially for something as important as password hashing
+ hashedPassword, err := bcrypt.GenerateFromPassword([]byte(r.Form[""passwordSignup""][0]), bcrypt.DefaultCost)
if err != nil {
    http.Error(w, http.StatusText(http.StatusBadRequest), http.StatusBadRequest)
    return
}




A lot of your relevant cookie code is missing, but here's what it should look like:

cookie := &http.Cookie{
        Name: ""my_app"",
        Value: val, // Some encoded value
        Path: ""/"", // Otherwise it defaults to the /login if you create this on /login (standard cookie behaviour)
        MaxAge: 86400, // One day
}

http.SetCookie(w, cookie)


Alternatively, if you use gorilla/sessions (which I recommend because it correctly authenticates cookies), you would do the following:

session, err := store.Get(r, ""session-name"")
if err != nil {
    http.Error(w, err.Error(), 500)
    return
}

session.Options.Path = ""/""
session.Values[""user""] = user

err := session.Save(r, w)
if err != nil {
    http.Error(w, err.Error(), 500)
    return
}

http.Redirect(w, r, ""/"", 301)

",35252253
664,35257894,"Ok, two things:


You haven't ""inherited"" io.Writer (you simply stated that your struct contains a writer). In go, interfaces are implicit. If your struct implements Write(p []byte) (n int, err, error), it is an io.Writer and can be used with any function accepting it. Period. No need to declare anything.
As for your problem: fmt.Printf(""%s\n"", string(p))

",35257784
665,35327747,"I think the best approach for this would be to keep a pool of worker goroutines, dispatch the work for them in channels, and then close the channel so they would exit. 

something like this:

// create a channel for work ""tasks""
ch := make(chan string)

wg := sync.WaitGroup{}

// start the workers
for t = 0; t < 100; t++{
    wg.Add(1)
    go saveToDB(ch, &wg)
}

// push the lines to the queue channel for processing
for _, line := range fileline {
    ch <- line
}

// this will cause the workers to stop and exit their receive loop
close(ch)

// make sure they all exit
wg.Wait()


and then the saveFunction looks like this:

func saveToDB(ch chan string, wg *sync.WaitGroup) {
    // cnosume a line
    for line := range ch {
        // do work
        actuallySaveToDB(line)
    }
    // we've exited the loop when the dispatcher closed the channel, 
    // so now we can just signal the workGroup we're done
    wg.Done()
}

",35327609
666,35348490,"@OneOfOne, it was close but not quite.

I ended up making a Serial Dispatch Queue implementation in Go available here.

It is basically a go routine that blocks on a channel of type func() and runs the functions that are passed in order. 

Implementation:

//Package serialqueue provides a serial queue for functions. 
//Queue items are processed in First In First Out (FIFO) order. 
package serialqueue

//New returns a new serial queue.
//Enqueue items like queueObj <- func() {doWork(data)}
func New() chan func() {
    //create channel of type function
    var queue = make(chan func())

    //spawn go routine to read and run functions in the channel
    go func() {
        for true {
            nextFunction := <-queue
            nextFunction()
        }
    }()

    return queue
}


Usage: (demonstrating writing to a string in the correct order)

//Package serialqueue provides provides tests for github.com/ansonl/serialqueue. 
package serialqueue_test

import (
    ""testing""
    ""fmt""
    ""sync""
    ""github.com/ansonl/serialqueue""
    )

func TestQueue(t *testing.T) {
    //Create new serial queue
    queue := serialqueue.New()

    //Number of times to loop
    var loops = 100

    //Queue output will be added here
    var queueOutput string

    //WaitGroup for determining when queue output is finished
    var wg sync.WaitGroup

    //Create function to place in queue
    var printTest = func(i int) {
        queueOutput = fmt.Sprintf(""%v%v"",queueOutput, i)
        wg.Done()
    }

    //Add functions to queue
    var i int;
    for i=0;i<loops;i++ {
        wg.Add(1)
        t:=i
        queue <- func() {printTest(t)}
    }

    //Generate correct output
    var correctOutput string
    for i=0;i<loops;i++ {
        correctOutput = fmt.Sprintf(""%v%v"", correctOutput, i)       
    }

    //Wait until all functions in queue are done
    wg.Wait()

    //Compare queue output with correct output
    if queueOutput != correctOutput {
        t.Errorf(""Serial Queue produced %v, want %v"", queueOutput, correctOutput);
    }
}


Hope this helps someone with the same issue! 
",34926930
667,35379919,"
  The Go Programming Language Specification
  
  Map types
  
  A new, empty map value is made using the built-in function make, which
  takes the map type and an optional capacity hint as arguments:

make(map[string]int)
make(map[string]int, 100)

  
  The initial capacity does not bound its size: maps grow to accommodate
  the number of items stored in them, with the exception of nil maps. A
  nil map is equivalent to an empty map except that no elements may be
  added.


You write:

var countedData map[string][]ChartElement


Instead, to initialize the map, write,

countedData := make(map[string][]ChartElement)

",35379378
668,35386184,"To paraphrase, there are lies, damn lies, and benchmarks.

Despite being asked, you still haven't posted the code necessary to reproduce your issue: How to create a Minimal, Complete, and Verifiable example.

Here's a reproducible benchmark, which uses a PRNG, that should drive your CPUs to close to 100%:

package main

import (
    ""math/rand""
    ""runtime""
    ""time""
)

func DoSomeCPU(done <-chan bool) {
    r := rand.New(rand.NewSource(time.Now().UnixNano()))
    k := 0
    for i := 0; i < 1000000; i++ {
        j := i*i + 2
        k += i * r.Intn(j)
    }
    _ = k
    <-done
}

func main() {
    numCPU := runtime.NumCPU()
    runtime.GOMAXPROCS(numCPU)
    done := make(chan bool, 2*numCPU)
    for {
        done <- true
        go DoSomeCPU(done)
    }
}


What results do you get when you run this code?
",35384033
669,35388675,"The main reason is, the global rand.* uses a mutex, so at any given point, you can only generate one random number at a time.

The reason @peterSO's answer works is because there's no mutex now and it's 1 generator per routine, however you can end up with duplicate state if 2 or more goroutines start at the exact nano second, although unlikely.

Look here to see how the global rand works under the hood.
",35384033
670,35436450,"Try to add your endpoint operatin id ('updateBar') as a parameter operation id. Something like:

// swagger:parameters updateBar
type BarParam struct {

    // aaaa
    // in: path
    bar string
}


And remove 'Parameters' from your endpoint swagger doc
",35432369
671,35487263,"Great question!

Looking at the source code of go/doc, we can see that it has to deal with this same case in readType function. There, it says:

324     func (r *reader) readType(decl *ast.GenDecl, spec *ast.TypeSpec) {
...
334     // compute documentation
335     doc := spec.Doc
336     spec.Doc = nil // doc consumed - remove from AST
337     if doc == nil {
338         // no doc associated with the spec, use the declaration doc, if any
339         doc = decl.Doc
340     }
...


Notice in particular how it needs to deal with the case where the AST does not have a doc attached to the TypeSpec. To do this, it falls back on the GenDecl. This gives us a clue as to how we might use the AST directly to parse doc comments for structs. Adapting the for loop in the question code to add a case for *ast.GenDecl:

for _, f := range d {
    ast.Inspect(f, func(n ast.Node) bool {
        switch x := n.(type) {
        case *ast.FuncDecl:
            fmt.Printf(""%s:\tFuncDecl %s\t%s\n"", fset.Position(n.Pos()), x.Name, x.Doc.Text())
        case *ast.TypeSpec:
            fmt.Printf(""%s:\tTypeSpec %s\t%s\n"", fset.Position(n.Pos()), x.Name, x.Doc.Text())
        case *ast.Field:
            fmt.Printf(""%s:\tField %s\t%s\n"", fset.Position(n.Pos()), x.Names, x.Doc.Text())
        case *ast.GenDecl:
            fmt.Printf(""%s:\tGenDecl %s\n"", fset.Position(n.Pos()), x.Doc.Text())
        }

        return true
    })
}


Running this gives us:

main.go:3:1:    GenDecl %!s(*ast.CommentGroup=)
main.go:11:1:   GenDecl &{[%!s(*ast.Comment=&{69 // FirstType docs})]}
main.go:11:6:   TypeSpec FirstType  %!s(*ast.CommentGroup=)
main.go:13:2:   Field [FirstMember] &{[%!s(*ast.Comment=&{112 // FirstMember docs})]}
main.go:17:1:   GenDecl &{[%!s(*ast.Comment=&{155 // SecondType docs})]}
main.go:17:6:   TypeSpec SecondType %!s(*ast.CommentGroup=)
main.go:19:2:   Field [SecondMember]    &{[%!s(*ast.Comment=&{200 // SecondMember docs})]}
main.go:23:1:   FuncDecl main   &{[%!s(*ast.Comment=&{245 // Main docs})]}
main.go:33:23:  Field [n]   %!s(*ast.CommentGroup=)
main.go:33:35:  Field []    %!s(*ast.CommentGroup=)


And, hey!

We've printed out the long-lost FirstType docs and SecondType docs! But this is unsatisfactory. Why is the doc not attached to the TypeSpec? The go/doc/reader.go file goes to extraordinary lengths to circumvent this issue, actually generating a fake GenDecl and passing it to the readType function mentioned earlier, if there is no documentation associated with the struct declaration! 

   503  fake := &ast.GenDecl{
   504   Doc: d.Doc,
   505   // don't use the existing TokPos because it
   506   // will lead to the wrong selection range for
   507   // the fake declaration if there are more
   508   // than one type in the group (this affects
   509   // src/cmd/godoc/godoc.go's posLink_urlFunc)
   510   TokPos: s.Pos(),
   511   Tok:    token.TYPE,
   512   Specs:  []ast.Spec{s},
   513  }


But why all this?

Imagine we changed the type definitions from code in the question slightly (defining structs like this is not common, but still valid Go):

// This documents FirstType and SecondType together
type (
    // FirstType docs
    FirstType struct {
        // FirstMember docs
        FirstMember string
    }

    // SecondType docs
    SecondType struct {
        // SecondMember docs
        SecondMember string
    }
)


Run the code (including the case for ast.GenDecl) and we get:

main.go:3:1:    GenDecl %!s(*ast.CommentGroup=)
main.go:11:1:   GenDecl &{[%!s(*ast.Comment=&{69 // This documents FirstType and SecondType together})]}
main.go:13:2:   TypeSpec FirstType  &{[%!s(*ast.Comment=&{129 // FirstType docs})]}
main.go:15:3:   Field [FirstMember] &{[%!s(*ast.Comment=&{169 // FirstMember docs})]}
main.go:19:2:   TypeSpec SecondType &{[%!s(*ast.Comment=&{215 // SecondType docs})]}
main.go:21:3:   Field [SecondMember]    &{[%!s(*ast.Comment=&{257 // SecondMember docs})]}
main.go:26:1:   FuncDecl main   &{[%!s(*ast.Comment=&{306 // Main docs})]}
main.go:36:23:  Field [n]   %!s(*ast.CommentGroup=)
main.go:36:35:  Field []    %!s(*ast.CommentGroup=)


That's right

Now the struct type definitions have their docs, and the GenDecl has its own documentation, too. In the first case, posted in the question, the doc was attached to GenDecl, since the AST sees the individual struct type definitions of ""contractions"" of the parenthesized-version of type definitions, and wants to handle all definitions the same, whether they are grouped or not. The same thing would happen with variable definitions, as in:

// some general docs
var (
    // v docs
    v int

    // v2 docs
    v2 string
)


So if you wish to parse comments with pure AST, you need to be aware that this is how it works. But the preferred method, as @mjibson suggested, is to use go/doc. Good luck!
",19580688
672,35513661,"You can do this by setting the CGO_CPPFLAGS and CGO_LDFLAGS environment variables.

For example, on my MacBook, Homebrew is installed in ~/.homebrew (instead of /usr/local), so when I try to go get packages with native bindings they can't find the headers and libs.

To fix that I added these two lines to my ~/.zshenv file:

export CGO_CPPFLAGS=""-I $BREW_HOME/include""
export CGO_LDFLAGS=""-L $BREW_HOME/lib""

",28710276
673,35556287,"As noted, the fmt package always uses \n as the newline ""sequence"" regardless of the OS (on Windows too). The log package uses fmt under the hood, so the same applies to log too. When functions that do not end with ...ln() are called (e.g. log.Printf()), a \n will be printed explicitly as documented at Logger.Output() (to which log.Printf() forwards to).

Just deal with \n as the newline. If you do need to print \r\n, you have to handle that manually by appending a \r character at the end of the format string, e.g.:

log.Printf(""This will be terminated by CR+LF\r"") // \n is appended automatically


You may create a wrapper function for it:

func winprintf(format string, a ...interface{}) {
    log.Printf(format+""\r"", a...)
}


Note that this however will only print \r\n at the end of the log entry; but if you use \n inside the format string or the arguments are strings (or will result in a string by calling their String() method) containing \n, those will not turn into \r\n automatically. You may use strings.Replace() to handle those too.
",35555692
674,35576591,"Don't link files across packages, that's bad practice. For one, the code will be duplicated. For another, identifiers will be duplicated meaning to denote the same entities (e.g. type or function), but they will be distinct. E.g. if linked and structs.go would contain a type Response definition, you would have 2 distinct types server.Response and routines.Response giving just more confusion.

One solution would be to put structs.go into its own package, e.g. model, and all other packages relying on it can import it (e.g. your main, server and routines).

In a theoretical example: if package A imports package B and structs.go would be needed in both, then it could also be added to package B. If there would be a package C needing only structs.go, then again it would be wiser to create its own package model (so package C doesn't need to import / know about package B, only the new model package).

Also if noone else will use your package and it is not too complex, it might not worth the hassle to organize it into multiple packages.
",35576337
675,35607787,"Go has a library for creating services in windows.
Please check this library github.com/kardianos/service. 

package main

import (
    ""log""

    ""github.com/kardianos/service""
)

var logger service.Logger

type program struct{}

func (p *program) Start(s service.Service) error {
    // Start should not block. Do the actual work async.
    go p.run()
    return nil
}
func (p *program) run() {
    // Do work here
}
func (p *program) Stop(s service.Service) error {
    // Stop should not block. Return with a few seconds.
    return nil
}

func main() {
    svcConfig := &service.Config{
        Name:        ""GoServiceExampleSimple"",
        DisplayName: ""Go Service Example"",
        Description: ""This is an example Go service."",
    }

    prg := &program{}
    s, err := service.New(prg, svcConfig)
    if err != nil {
        log.Fatal(err)
    }
    logger, err = s.Logger(nil)
    if err != nil {
        log.Fatal(err)
    }
    err = s.Run()
    if err != nil {
        logger.Error(err)
    }
}

",35605238
676,35636889,"@peterSO mentioned that errors should always be checked in Go, I should had done that.
",35632942
677,35644397,"Because c.Find(https://godoc.org/gopkg.in/mgo.v2#Collection.Find) only allow one param

You can try

query := bson.M{
    ""company_name"": ""bank"",
    ""process"": bson.M{
        ""$elemMatch"": bson.M{""process.process_name"":""Converted""}
    }
}
err := c.Find(query).Sort(""-id"").All(&results)

",35644058
678,35660410,"The Write method needs a pointer to a value, not a pointer to an interface containing the value. You can get it using reflection:

u := reflect.New(reflect.ValueOf(v).Type())
u.Elem().Set(reflect.ValueOf(v))
v := u.Interface()

",35658354
679,35791164,"Please check this out difference between godep update and godep save.
I usually just use godep save unless I am updating a specific package. This grabs all the updated packages for the project from GOPATH. 
BTW: I am also fairly new to Godeps.
",35790414
680,35791966,"Make sure you have git committed package you want to update, you can check the commit sha-1 checksum using git log and make sure it has different rev commit version in Godeps.json.
Then include package name in godep command godep update github.com/package/...
",35790414
681,35890152,"You need to explicitly ask your server to serve static files.  

See http.FileServer

In your case register another handler.

http.Handle(""/public/"", http.StripPrefix(""/public/"", http.FileServer(http.Dir(""public""))))

",35888817
682,35901368,"Like Aruna said, register a static file server handle

http.Handle(""/public/"", http.StripPrefix(""/public/"", http.FileServer(http.Dir(""public""))))


And to use the files in your HTML, simply



",35888817
683,35918852,"Programming languages are able to communicate with each other -- yes, you can write a server in Go and a client in Python and have them communicate with each other.

If you're trying to communicate using raw sockets, look at the documentation for your desired languages and make sure that the serialized data match in structure.

e.g. You could decide on a struct and implement your payload in Python or code and then match that structure in Go (there may be a better/stdlib way in Go; I'm not very experienced in this language).  The potential maintenance and implementation headache in worrying about these details is why people use higher-level protocols -- exactly a good use case for ZeroMQ.

If you're using a message queue as the backbone of your operation, simply use that as the shared protocol.  If your Python code can speak with ZeroMQ, then it's doing its job correctly -- there's no need for your Go code to know it's speaking to Python.

In this case, your new Go server would bind to ZeroMQ, your Python client would bind to ZeroMQ, and your two heterogenous languages need to know nothing about each other.
",35918588
684,35961173,"You do not need to call ParseFiles and Must, you can call one or the other

func RenderTemplate(w http.ResponseWriter, data interface{}, tmpl... string) {
    cwd, _ := os.Getwd()
    for _,file:=range tmpl{
        file=filepath.Join(cwd,""./view/""+file+"".html"")
    }
    t, err := template.ParseFiles(tmpl...)
    if err != nil {
        http.Error(w, err.Error(), http.StatusInternalServerError)
        return
    }

    err = t.Execute(w, data)
    if err != nil {
        http.Error(w, err.Error(), http.StatusInternalServerError)
    }
}


I believe the func above should do what you want...
",35904722
685,35962433,"template.Must() has this signature:

func Must(t *Template, err error) *Template 


the arguments to Must() are ""by coincidence"" the same as the return values to ParseFiles() and ParseGlob() so you can use those functions inside Must() and have the effect that it panics, if the error is non-nil. So you can say

t := template.Must(template.ParseFiles(....))


and don't care about the error checking. This is merely a convenience function, similar to all other Must() functions throughout the standard library, such as regexp.MustCompile().

The implementation of Must() is straightforward:

func Must(t *Template, err error) *Template {
    if err != nil {
            panic(err)
    }
    return t
}


See https://golang.org/src/text/template/helper.go?s=576:619#L11
",35904722
686,35985183,"It's the Base64 encoding of the signature which can have the last letter changed to certain targets without affecting the relevant bits.

Try popping both signatures into a base64->hex decoder and you'll get the same results. In fact at https://conv.darkbyte.ru/ both signatures get re-evaluated to base64 SxshVL42DUH9e7jXUblbBbTwKxhe4jo70DrvbQMlaQ==
",35950072
687,36029056,"As hinted, it's because you haven't set the content type. Quoting from http.ResponseWriter:

// Write writes the data to the connection as part of an HTTP reply.
// If WriteHeader has not yet been called, Write calls WriteHeader(http.StatusOK)
// before writing the data.  If the Header does not contain a
// Content-Type line, Write adds a Content-Type set to the result of passing
// the initial 512 bytes of written data to DetectContentType.
Write([]byte) (int, error)


If you don't set the content type yourself, first call to ResponseWriter.Write() will call http.DetectContentType() to guess what to set. If the content you send starts with """", it won't be detected as HTML, but ""text/plain; charset=utf-8"" will be set (which ""instructs"" the browser to display the content as text and not try to interpret it as HTML).

If the content would start with """" for example, content type ""text/html; charset=utf-8"" would be set automatically and it would work without further actions.

But don't rely on automatic detection if you know what you're sending, also it's much faster to set it yourself than to run a detection algorithm on it, so simply add this line before writing/sending any data:

w.Header().Set(""Content-Type"", ""text/html; charset=utf-8"")


And also make your post.html template a complete, valid HTML document.

Also another piece of advice: in your code you religiously omit checking returned errors. Don't do that. The least you could do is print them on the console. You will save a lot of time for yourself if you don't omit errors.
",36027099
688,36098929,"In C, that pointer you return is going to be stale.  You would need to allocate the table like double *result = calloc(sizeof(double), nrows) --- which would require also have a way to free the memory.
",36098875
689,36103121,"OK, so I figured out a simple way to achieve this.

We first use calloc to allocate memory for the array:

double* c_func(int n_rows) {
    double* result;
    result = calloc(n_rows, sizeof(double));
    for (int i = 0; i < n_rows; ++i) {
        result[i] = (double)i;
    }
    return result;
}


and after that, we simply convert the data into proper type in Go. The trick is to use C.free to free the memory allocated from C side.

// convert C double pointer to float64 slice ...
func doubleToFloats(in *C.double, size int) []float64 {
    defer C.free(unsafe.Pointer(in))
    out := (*[1 << 30]float64)(unsafe.Pointer(in))[:size:size]
    return out
}

",36098875
690,36153205,"Because there is no implicit identifier denoting the actual receiver value (like this in Java), and if you want to refer to the fields or methods of the receiver value (Rectangle value), you need an identifier that you can use.

Note that the spec does not require you to name the receiver value, e.g. the following using the blank identifier is a valid syntax:

func (_ Rectangle) Foo() string {
    return ""foo""
}


Or even this: omitting the receiver name (the parameter name):

func (Rectangle) Foo() string {
    return ""foo""
}


Relevant section from the spec: Method declarations:


MethodDecl   = ""func"" Receiver MethodName ( Function | Signature ) .
Receiver     = Parameters .



Where Parameters is:


Parameters     = ""("" [ ParameterList [ "","" ] ] "")"" .
ParameterList  = ParameterDecl { "","" ParameterDecl } .
ParameterDecl  = [ IdentifierList ] [ ""..."" ] Type .



As you can see in the last line, the IdentifierList is optional (but Type is required).
",36152939
691,36153664,"Struct methods are like Class methods. The variable 'r' is a reference to the struct/class instance/object that the method is being applied to. Without that reference, you will not be able to access whatever is contained within that struct/object. 

Lets say for example, I created smallRectangle using your struct:

var smallRectangle = Rectangle{5,3}


Now I want to calculate the area using the Rectangle method Area

area := smallRectangle.Area()


Lets look at what happens within the function. r from the method declaration becomes a copy of smallRectangle since that's the struct object calling it. 

func (smallRectangle Rectangle) Area() int {
    return smallRectangle.length * smallRectangle.width
}


As indicated by Icza, there is no implicit identifier like self or this, so the only way for the method to access the values of the struct is through the identifier r. 
",36152939
692,36153952,"The problem is that your first assigning i to 15 when your calling closure1() And then closure two you print it.. Your doing closure1() after assigning i to 20.. Thats the problem, this should fix your problem:

package main

import ""fmt""

func main() {
    i := 10

    closure1 := func() {
        fmt.Printf(""closure, i: %d\n"", i)
        i = 15
    }

    closure1()

    fmt.Printf(""in main, i: %d\n"", i)

    closure2 := func(x int) {
        fmt.Printf(""function call, pass parameter, i: %d\n"", x)
    }



    closure1()
    i = 20 // Now it assigns it back to 20.. So the result below will become 20...
    closure2(i)
}


You see your problem?
",36152294
693,36158275,"The last line of closure1 sets i to 15.  This i belongs to the main() context.

The next to last line of main calls closure1() again.  So the i from main is set to 15 again.
",36152294
694,36180479,"Perhaps you could put the setup code that you want to use from multiple unit test files into a separate package that only the unit tests use?

Or you could put the setup code into the normal package and just use it from the unit tests.

It's been asked before but the Go authors have chosen not to implicitly supply a test tag that could be used to selectively enable function compiles within the normal package files.
",36177614
695,36188366,"Test packages, not files! 

Since you're testing handlers/endpoints it would make sense to put all your _test files in either the handlers or the router package. (e.g. one file per endpoint/handler).

Also, don't use init() to setup your tests. The testing package specifies a function with the following signature:

func TestMain(m *testing.M) 



  The generated test will call TestMain(m) instead of running the tests
  directly. TestMain runs in the main goroutine and can do whatever
  setup and teardown is necessary around a call to m.Run. It should then
  call os.Exit with the result of m.Run


Inside the TestMain function you can do whatever setup you need in order to run your tests. If you have global variables, this is the place to declare and initialize them. You only need to do this once per package, so it makes sense to put the TestMain code in a seperate _test file. For example: 

package router

import (
    ""testing""
    ""net/http/httptest""
) 

var (
    testServer *httptest.Server
)

func TestMain(m *testing.M)  {
    // setup the test server
    router := ConfigureRouter()
    testServer = httptest.NewServer(router)

    // run tests
    os.Exit(m.Run())
}


Finally run the tests with go test my/package/router.
",36177614
696,36200934,"You have one workspace and projects share the packages.

It's there in the overview section: 


  Go programmers typically keep all their Go code in a single workspace.
  
  Note that this differs from other programming environments in which every project has a separate workspace and workspaces are closely tied to version control repositories.


Edit: If you use vendoring, you can effectively get a separate workspace for each project. This brings things closer to how other programming languages work.
",36200806
697,36204611,"So far, I use different workspaces either when I want to use a different version of Go or I want to separate my private work from the code the kids and I have fun with.  Also if I want to play with some open source code but want a simple way of cleaning it all up later.

Something like 

mk /tmp/tmpgo
cd /tmp/tmpgo
# Copy or edit a setenv file
. setenv  # I use bash


The setenv file looks something like this.

export GOROOT=$HOME/go16
export GOPATH=$PWD
export GOBIN=$GOPATH/bin
export PATH=$GOROOT/bin:$GOPATH/bin:$PATH
export PS1='\[\033[01;32m\]workspacenamehere\[\033[01;33m\] \W\[\033[00m\] '


This gives me a go workspace with its own bin, src, pkg subdirectories.  I can go get anything I want.  Later I can delete the whole temporary directory if I like.  Getting things from repositories like github.com has a tendency to get many packages from other contributors, but because it puts them all into a clean src subdirectory, it's easy to use find and see what has been pulled down.  And later it is even easier to remove everything from the hd again.
",36200806
698,36296251,"Check out https://github.com/sendgrid/go-gmime (disclaimer, I work with SendGrid, but did not put together anything in the lib)
",36295343
699,36299472,"You should generally never have to set $GOROOT unless you know why you're setting it.

This assumes a 'normal' installation of Go.  If you've moved the go binary around, or deleted pkg or src folders, your mileage may vary.

Also, make sure an older version of go is not found in your $PATH before the version you intend to use.

In this case @Bangash had to delete the old /usr/bin/go and add /usr/local/go/bin to his PATH environment variable.

Usually people use $GOROOT when switching between multiple versions of go.

Please read comments as well as chat for the solution.
",36299375
700,36300055,"Check and handle the error returned from json.Unmarshal([]byte(buff), &s).  You will find that there's an invalid character '{' after array element at offset 1685.

playground example
",36299902
701,36309240,"Given that the message is malformed, I would fix it through a separate piece of code that reformats the message:

func fixBrokenMime(r_ io.Reader, w io.WriteCloser) {
    r := bufio.NewScanner(bufio.NewReader(r_))
    for r.Scan() {
        line := r.Text()
        if len(line) > 0 && line[0] != ' ' && strings.IndexByte(line, ':') < 0 {
            line = "" "" + line
        }
        w.Write([]byte(line+""\n""))
    }
    w.Close()
}


Playground: http://play.golang.org/p/OZsXT7pmtN

Obviously, you may want a different heuristic. I assumed that a line that is not indented and doesn't contain "":"", must be indented.
",36295343
702,36322864,"The first server is double encoding the value. The result is a string. 

d, _ := json.Marshal(c) // d is []byte containing the JSON
...
encoder.Encode(d)  // encoder writes base64 encoding of []byte as JSON string


Change the code to:

conn, err := net.Dial(""tcp"", ""127.0.0.1:8081"")
if err != nil {
     // handle error
}
encoder := json.NewEncoder(conn)
if err := encoder.Encode(c); err != nil {
   // handle error
}

",36322527
703,36322866,"When you do encoder.Encode(d), you are encoding the marshaled result from previous step. So when you decode it back you don't get the go object, but a string.

Instead you can do, encoder.Encode(c). (Directly encode the object c).

This should help you understand: http://play.golang.org/p/qNxqOJcj_a
",36322527
704,36328644,"unsafe.Sizeof(&process) returns the size of the pointer — the address of the memory occupied by the variable process.

I suppose you want to use unsafe.Sizeof(process) for that.
",36326870
705,36329704,"

_, _, err = GetProcessMemoryInfo.Call(uintptr(current), uintptr(unsafe.Pointer(&process)), uintptr(process.cb))




use process.cb can't get use info.
",36326870
706,36342688,"First, what is the output of this:

$ echo $PATH


It should, at a minimal to run Go projects, have TWO directories in it for:


/path/to/go/installation/bin (e.g. /usr/local/go/bin)
/path/to/your/GOPATH/bin (e.g. /Users/denis/Programming/Golang/bin)


Your go's installation should be in your PATH already if you followed the Go installation setup.  

https://golang.org/doc/install

Since you posted /Users/denis/Programming/Golang, with the capital U, I am going to assume that you are on OS X going forward...

In OS X, and if you used the default install, you can test for Go in your PATH with a simple command:

$ echo $PATH | grep --color=auto ""/usr/local/go/bin""


It should print our your entire $PATH and highlight that you have things setup properly.  This is because the OS X GoLang installer in the URL above should have modified your PATH to include:


/usr/local/go/bin
or more specifically, it may be export PATH=""$PATH:/usr/local/go/bin"" 


If you have some custom .bashrc and/or .profile files, then most likely your PATH isn't being setup correctly.  You can test this by doing this:

$ PATH=""$PATH:/usr/local/go/bin""
$ PATH=""$PATH:/Users/denis/Programming/Golang/bin""
$ godep go build


If it works now, then your PATH isn't setup properly in your .bashrc/.profile files.  That's a different kind of question and can be setup a 1000 different ways and you may need to figure it out (or another SO question).  

If that resolves your issue, then you need to follow the godep directions to run godep from your project's root:

$ cd $GOPATH/src/backend/
$ godep save
$ git add Godeps/


godep creates a Godeps directory in the root of the Go project.  If you have multiple Go projects/multiple executables, then you need to run godep save on each root of the runtime.

IOW, for each executable you run go build for, you need to run godep save in each directory.

Also, once you move to godep, you want to use it for your build and testing as well:

$ godep go build
$ godep go test
...etc


If that's not the problem (you are running it as stated above), then please update your question with more specifics such as what godep command you are running, where, and what that directorys structure looks like for the root of that project (including the filename with package main and your func main() function).
",36341505
707,36344766,"That's not a compile error, you are getting panic: runtime error: index out of range

If the slice searchresponse.Hits.Hits has a length of 0, indexing the first element is going to be out of range and panic. You can check for the number of Hits first with searchresponse.Hits.Len().
",36344680
708,36347471,"

package main

import (
	""fmt""
	""syscall""
	""unsafe""
)

const (
	PROCESS_QUERY_INFORMATION = 1 << 10
	PROCESS_VM_READ           = 1 << 4
)

type PROCESS_MEMORY_COUNTERS struct {
	cb                         uint32
	PageFaultCount             uint32
	PeakWorkingSetSize         uint64
	WorkingSetSize             uint64
	QuotaPeakPagedPoolUsage    uint64
	QuotaPagedPoolUsage        uint64
	QuotaPeakNonPagedPoolUsage uint64
	QuotaNonPagedPoolUsage     uint64
	PagefileUsage              uint64
	PeakPagefileUsage          uint64
}

func main() {
	current, err := syscall.OpenProcess(PROCESS_QUERY_INFORMATION|PROCESS_VM_READ, false, 21984)
	defer syscall.CloseHandle(current)
	if err != nil {
		return
	}
	psapi := syscall.NewLazyDLL(""psapi.dll"")
	var process PROCESS_MEMORY_COUNTERS
	process.cb = uint32(unsafe.Sizeof((process)))
	GetProcessMemoryInfo := psapi.NewProc(""GetProcessMemoryInfo"")

	_, _, err = GetProcessMemoryInfo.Call(uintptr(current), uintptr(unsafe.Pointer(&process)), uintptr(process.cb))
	if err != nil {
		fmt.Println(err)
	}
	fmt.Println(""PageFaultCount: "", process.PageFaultCount)
	fmt.Println(""PeakWorkingSetSize: "", process.PeakWorkingSetSize)
	fmt.Println(""WorkingSetSize: "", process.WorkingSetSize)
	fmt.Println(""QuotaPeakPagedPoolUsage: "", process.QuotaPeakPagedPoolUsage)
}




The results of the code run and I see a lot of gaps in the resource manager.Who can tell me Why?
",36326870
709,36365437,"The code is correct. The server https://hide.me is not a proxy server.
",36356835
710,36403089,"Glide is a really elegant package management for Go especially if you come from Node's npm or Rust's cargo. 

It behaves closely to Godep's new vendor feature in 1.6 but is way more easier. Your dependencies and versions are ""locked"" inside your projectdir/vendor directory without relying on GOPATH. 

Install with brew (OS X)

$ brew install glide


Init the glide.yaml file (akin to package.json). This also grabs the existing imported packages in your project from GOPATH and copy then to the project's vendor/ directory. 

$ glide init


Get new packages

$ glide get vcs/namespace/package


Update and lock the packages' versions. This creates glide.lock file in your project directory to lock the versions. 

$ glide up


I tried glide and been happily using it for my current project. 
",24855081
711,36407524,"you need to define the app_history variable outside the if statement and then assign to it in each of the branches

like so

var app_history &models.AppsHistoryInsert{}

if x {
  app_history = &models.AppsHistoryInsert{
    AppId:          response.SetAppData[0].Id,
    LiveDate:       &theTime,
  }
}else {
  app_history = &models.AppsHistoryInsert{
    AppId:          response.SetAppData[0].Id,
  }
}

",36407297
712,36489594,"You are right currently it's impossible. But you can use sub-structures like

type PriceType struct {
    Price int    `xml:""Price,attr""`
    Type  string `xml:""Type,attr""`
}

type Book struct {
    XMLName    xml.Name  `xml:""DailyAct""`
    Symbol     string    `xml:""TradeInstrId,attr""`
    EntityId   string    `xml:""EntityId,attr""`
    AssetClass string    `xml:""AssetClass,attr""`
    Open       PriceType `xml:""Open""`
    High       PriceType `xml:""High""`
    Low        PriceType `xml:""Low""`
    Close      PriceType `xml:""Close""`
}


Example here http://play.golang.org/p/Ekd6Xf3miS
",36487467
713,36526059,"If their package takes an actual *log.Logger, there's nothing you can do to inject your own logger other than set the output of a log.Logger to a custom writer where you intercept their log statements and you then re-log them through yours.

But that will be sub-awesome as you'd basically be parsing all their log statements just so you can re-log.   Not sure if log.Logger writes a log message as one call to Write.  if it does, it's easy as all you do is re-log for every call to Write.

You might also want to consider finding another library or forking and changing that library as nothing should really depend on log.Logger like that.
",36525757
714,36566412,"Since you mention a time period of days, of the two given, you should probably go with the second option.  This way you can store state to a file (or database) and restart the process if necessary.  The first option makes storing the state more difficult, but still possible.
",36566288
715,36572467,"Nothing was leaked. The memory is still reachable and it's quite common to not free things on exit, it just takes unnecessary time and the OS will deal with it anyway.

This is memory allocated to thread local storage to a thread that's still running, so it would be incorrect to free it. A better question would be ""how do I stop this thread?"", to which an answer is: you don't, the Go runtime deals with it. It is quite common to not stop threads at exit, it just takes unnecessary time and the OS will deal with it anyway.

It has nothing to do with your code and your function call, it's something that Go runtime allocates for itself.

Go is a garbage collected language and using valgrind on it will not tell you much. It will neither detect real memory leaks nor will it understand which memory is still in use.
",36571917
716,36614587,"You didn't declare your function correctly.

full_name := func() string{ // add a return type
   return first_name
}


Even for an anonymous function, arguments and return values must be declared. Since you did not specify any return value, you cannot use return xx.

Also, be aware that fmt.Println(full_name) will return the address of the function, not execute the function. Try fmt.Println(full_name()) instead.
",36614509
717,36614590,"You need to change your function definition to the following:

  full_name := func() string {
    return first_name
  }


That's how you tell Go that you intend to return something from a function and what that something is (a string in this case).

Then later you should call your newly created function like this:

   fmt.Println(full_name())

",36614509
718,36659185,"And when calling Add in your main function, dont use this 

x := math.Add(6 + 5)


Instead use this 

x := math.Add(6, 5)

",32932199
719,36666114,"The testing package modifies the global environment when loaded: it registers a lot of command-line flags. So, we can check if these flags are registered:

func init() {
    if flag.Lookup(""test.v"") == nil {
        fmt.Println(""normal run"")
    } else {
        fmt.Println(""run under go test"")
    }
}

",14249217
720,36689864,"All your variables have a slice type. Slices have a backing array. In Go you can't access uninitialized variables. If you don't explicitly provide a value when you create a new variable, they will be initialized with the zero value of the variable's type.

This means when you create a slice with make([]int, 0, 5), it also creates a backing array, the backing array will be initialized with its zero value, and this zeroed array will be sliced. The zero value of an array type is an array having the zero value of element type for each of its elements.

So even though you didn't explicitly set every elements of the backing array to 0, they will be zeroed automatically. So when you do c := b[:2], it will slice the b slice, and c will have a length of 2, and those 2 elements will be 0.

And when you do d := c[2:5] that slices the c slice, its length will be 5-2 = 3, and its capacity will also be 5-2 = 3 because slicing a slice will result in a new slice which shares the same backing array, and the capacity will be the first element till the last of the backing array (unless you use a full slice expression which also controls the resulting slice's capacity).

Must-read blog posts for newcomers who want to understand slices and arrays:

The Go Blog: Go Slices: usage and internals

The Go Blog: Arrays, slices (and strings): The mechanics of 'append'
",36683911
721,36696853,"As a general guideline, functions aren't very mockable so its in our best interests to mock structs that implement a certain interface that may be passed into functions to test the different branches of code. See below for a basic example.

package a

type DoSomethingInterface interface {
    DoSomething() error
}


func DoSomething(a DoSomethingInterface) {
    if err := a.DoSomething(); err != nil {
        fmt.Println(""error occurred"")
        return
    }
    fmt.Println(""no error occurred"")
    return
}

package a_test

import (
    ""testing""
    ""/a""
)

type simpleMock struct {
    err error
}

func (m *simpleMock) DoSomething() error {
    return m.err
}

func TestDoSomething(t *testing.T) {
    errorMock := &simpleMock{errors.New(""some error"")}
    a.DoSomething(errorMock)
    // test that ""an error occurred"" is logged

    regularMock := &simpleMock{}
    a.DoSomething(regularMock)
    // test ""no error occurred"" is logged
}


In the above example, you would test the DoSomething function and the branches that happens eg. you would create an instance of the mock with an error for one test case and create another instance of the mock without the error to test the other case. The respective cases are to test a certain string has been logged to standard out; in this case it would be ""error occurred"" when simpleMock is instantiated with an error and ""no error occurred"" when there simpleMock is not instantiated with an error. 

This can of course be expanded to other cases eg. the DoSomething function actually returns some kind of value and you want to make an assertion on the value. 

Edit:

I updated the code with the concern that the interface lives in another package. Note that the new updated code has a package a that contains the interface and the function under test and a package a_test that is merely a template of how to approach testing a.DoSomething.
",36688872
722,36697143,"I'm not sure what you're trying to do here but I'll explain how testing should be done in Go. 

Lets say we have an application with the following directory hierarchy:

root/
  pack1/
    pack1.go
    pack1_test.go
  pack2/
    pack2.go
    pack2_test.go
  main.go
  main_test.go


We'll assume that pack2.go has the functions you want to test:

package pack2 

func f1() error {
  ... //some API call
}

func (s *SomeStruct) f2() error {
  return f1
}

func f3() error {
  return nil
}

func f4() error {
  ...
  err = obj.f2()
  ...
  err = f3()
  ...
}


Looks good so far. Now if you want to test the functions in pack2, you would create a file called pack2_test.go. All test files in go are named similarly (packagename_test.go). Now lets see the inside of a typical test for a package (pack2_test.go in this example):

package pack2

import (
  ""testing""
  ""fmt""
)

TestF1(*testing.T) {
  x := ""something for testing""
  f1() // This tests f1 from the package ""pact2.go""
}


TestF2(*testing.T) {
    y := new(somestruct) 
    y.f2() // tests f2 from package ""pact2.go""
}


TestF3(*testing.T) {
   /// some code
   f3() // tests f3
}


TestF4(*testing.T) {
    /// code
    f3() // you get the gist
}


Let me explain. Notice how in pack2_test.go, the first line says that the package is pack2. In a nutshell, this means that we're in the ""scope"" of the package pack2 and thus all the functions found in pack2 can be called as if you're within pack2. Thats why, within the Testf* functions, we could've called the functions from pack2. Another thing to note is the imported package ""testing"". This helps with two things:

First, it provides some functionality for running tests. I won't go into that.
Second, it helps identify the functions that go test should run. 

Now to the functions. Any function within a test package that has the prefix ""Test"" and the parameters ""t *testing.T"" (you can use ""*testing.T"" when you don't need to use the testing functionality) will be executed when you run  go test. You use the variable t to reference the testing functionality I mentioned. You can also declare functions without the prefix and call them within the prefixed functions.

So, if I go to my terminal and run go test, it will execute the functions you want to test, specified in pack2_test.go

You can learn more about testing here and here
",36688872
723,36729325,"The 3 letter month constant is Jan

date := ""APR 19, 3:15p ET""
d, err := time.Parse(""Jan 02, 3:04p ET"", date)


http://play.golang.org/p/LkeQOtc1Hd
",36729147
724,36771170,"You have to install mingw-get and after that you can run ""mingw-get install make"" to have the command make. Here is a link for what you want http://www.mingw.org/wiki/getting_started
",36770716
725,36800555,"I faced with the same problem. However i set everything as it was said in the tutorial  but forgot to restart cmd. So the steps were:


Download and install Go distribution(the GOROOT variable was set automatically)
Create new folder wherever you like for your workspace, create there 3 directories: bin, src and pkg
Then go to Control Panel -> All Control Panel Items -> System -> Advansed System Settings -> tab Advanced -> Environment Variables -> add new system variable by clicking New on System varaibles -> Variable name = GOPATH, Variable value = Your:\directory\that\you\created
When you're done, RESTART your cmd or Bash(that's important) and you have your GOPATH set. To be sure run go env and you will see your value.

",25499670
726,36917148,"In order to be able to get the elements out you have to have ""exported"" fields, meaning that app_id and app_name in the App struct should start with a capital letter. In addition, your app_name field is also missing a ,attr in its xml field tag. See below for a working example of your code. I've added comments on the lines that require some changes.

package main

import (
    ""fmt""
    ""encoding/xml""
)

func main() {
    data:=`
    
    
        
        
    
    `

    type App struct {
        App_id   string  `xml:""app_id,attr""`    // notice the capitalized field name here
        App_name string  `xml:""app_name,attr""`  // notice the capitalized field name here and the `xml:""app_name,attr""`
    }

    type AppList struct {
        XMLName xml.Name `xml:""applist""`
        Apps  []App      `xml:""app""`
    }

    var portfolio AppList
    err := xml.Unmarshal([]byte(data), &portfolio)
    if err != nil {
        fmt.Printf(""error: %v"", err)
        return
    }
    fmt.Printf(""application ID:: %q\n"", portfolio.Apps[0].App_id)       // the corresponding changes here for App
    fmt.Printf(""application name:: %q\n"", portfolio.Apps[0].App_name)   // the corresponding changes here for App
}

",36916504
727,36922225,"For anyone else looking for a way to validate any JSON string regardless of schema, try the following:

func IsJSON(str string) bool {
    var js json.RawMessage
    return json.Unmarshal([]byte(str), &js) == nil
}

",22128282
728,36932024,"The issue is that the src attribute isn't treated strictly as an attribute, but as a URL.  If you change it from a string to a template.URL it works just fine.

tplVars := map[string]interface{}{
    ""Dog"": template.URL(""cid:dog.png""),
    ""Cat"": ""cid:cat.png"",
}


https://play.golang.org/p/ZN27nGnUE9
",36931742
729,36939646,"The error message you are getting is a PostgreSQL error and not GORM. It is caused as you are opening the database connection more than once.

db, err := gorm.Open(""postgres"", ""user=gorm dbname=gorm"")


Should be initiated once and referred to after that.
",36935089
730,36960703,"Functions, variables , anything coming from  a different package have to start with a capital letter to make it visible for when importing into the main package.

example:

package main

import ""fmt""
import ""other/out""

func main(){

fmt.Println(out.X)

// hello

}




package other

var X string = ""hi""

",32932199
731,36973208,"Have the service have an internal field that takes a pointer to the db and use that.

type DBService struct {
    db *sql.DB
}

func (dbs *DBService) GetUserKey(id int64) (key string, err error)
    dbs.db.Query(""SOMETHING"")
    return
}

func NewService(db *sql.DB) *DBService { return &DBService{db: db} }

",36972513
732,37064603,"The way I ended up solving this, for lack of a better solution, was to use private global maps on the Go side (ref). These maps would associate instances of the Go objects with a random uint64 id, and the id would be returned to C++ as an ""opaque handle"". 

type frameSetMap struct {
    lock *sync.RWMutex
    m    map[FrameSetId]*frameSetRef
    rand idMaker
}
//...
func (m *frameSetMap) Add(fset fileseq.FrameSet) FrameSetId {
    // fmt.Printf(""frameset Add %v as %v\n"", fset.String(), id)
    m.lock.Lock()
    id := FrameSetId(m.rand.Uint64())
    m.m[id] = &frameSetRef{fset, 1}
    m.lock.Unlock()
    return id
}


Then I use reference counting to determine when C++ no longer needs the object, and remove it from the map:

// Go
func (m *frameSetMap) Incref(id FrameSetId) {
    m.lock.RLock()
    ref, ok := m.m[id]
    m.lock.RUnlock()

    if !ok {
        return
    }

    atomic.AddUint32(&ref.refs, 1)
    // fmt.Printf(""Incref %v to %d\n"", ref, refs)
}

func (m *frameSetMap) Decref(id FrameSetId) {
    m.lock.RLock()
    ref, ok := m.m[id]
    m.lock.RUnlock()

    if !ok {
        return
    }

    refs := atomic.AddUint32(&ref.refs, ^uint32(0))
    // fmt.Printf(""Decref %v to %d\n"", ref, refs)
    if refs != 0 {
        return
    }

    m.lock.Lock()
    if atomic.LoadUint32(&ref.refs) == 0 {
        // fmt.Printf(""Deleting %v\n"", ref)
        delete(m.m, id)
    }
    m.lock.Unlock()
}

//C++
FileSequence::~FileSequence() {
    if (m_valid) {
//        std::cout << ""FileSequence destroy "" << m_id << std::endl;
        m_valid = false;
        internal::FileSequence_Decref(m_id);
        m_id = 0;
        m_fsetId = 0;
    }
}


And all C++ interactions with the exported Go library communicate via the opaque handle:

// C++
size_t FileSequence::length() const {
    return internal::FileSequence_Len(m_id);
}


Unfortunately it does mean that in a multhreaded C++ environment, all threads would go through a mutex to the map. But it is only a write lock when objects are created and destroyed, and for all method calls on an object it is a read lock.
",36861569
733,37083273,"Okay guys, I figured out the problem. 

https://github.com/joefitzgerald/go-plus/issues/386 

here it has been discussed. I will just copy it from that 

Linux folks, particularly those running Ubuntu. I believe I have reproduced your issues and I think they have to do with where you are setting your GOPATH and PATH.


~/.profile: If you set them here, $GOPATH will be set in Atom when you launch Atom for the first time from the launcher in the toolbar
~/.bashrc If you set them here, $GOPATH will be set in Atom when you launch Atom for the first time from the terminal
Thus, to ensure GOPATH and PATH are set correctly regardless of how you launch Atom, you should put the following (or similar) in both ~/.profile and ~/.bashrc:



export GOPATH=$HOME/work

export PATH=$GOPATH/bin:/usr/local/go/bin:$PATH



Obviously the above doesn't apply exactly if bash isn't your default shell, but I trust that if you're a user of a different shell, you can grok what I am saying above and apply the same principles to your particular environment.
",37083167
734,37096297,"It stated on Golang http docs :


  For incoming requests, the Host header is promoted to the Request.Host
  field and removed from the Header map.


So you can get the host by access 


  http.Request.Host


Check here for details : https://golang.org/pkg/net/http/
",37096166
735,37114445,"
Replace ???? with []Item: Go Playground. It is just the same as how that variable report.Items is defined in struct Report.


Ok, yes that does change the question. The thing I thought of immediately was that you just needed to create an interface such as Itemer and have []Itemer in the function definition of doSmth:

type Itemer interface {
    Foo() bool
} 

func doSmth(items []Itemer) {
    ...
}


Unfortunately this does not seem to be possible. I then tried some other permutations including using interface{}, []interface{} as well as variadic functions and I couldn't get anything to work.

After doing some research it turns out that Go will not convert the type of slices. Even if each element of a slice is an instance of an interface such as Itemer or interface{} it still won't do it. I could not re-find the source but apparently This is due to the fact that a new slice would have to be created and each element would have to be type cast individually from the old slice to the new slice: https://stackoverflow.com/a/7975763/2325784.

To me this suggests that a function such as doSmth is not possible. 

The only thing I could suggest is to restructure the code. If you are willing to post more information about Foo and doSmth I can try to help with that.
",37114313
736,37114487,"You need to use variadic function for this scope:

func main(){
    //some funcs called to get the report object
    doSmth(report.Items)
}
func doSmth(items ...report.Items){
    for _, item := range items {
        item.Foo()
    }
}

",37114313
737,37115672,"EDIT: Nvm, this wont work. Forgot about the fact that go doesn't have inheritance.

You could convert the array into a slice, and make the function take a slice as a parameter instead. 

names := []string{""leto"", ""paul"", ""teg""}
process(names[:])

func process(names []string) {
  ...
}

",37114313
738,37141582,"I put together a sample Kubernetes client in Go that allows to query the API version and make a sample NGINX deployment. Maybe it's helpful to you: https://github.com/timoreimann/kubernetes-goclient-example

Note that it doesn't use replication controllers (which, by the way, have been replaced by replica sets by now) but uses the newer Deployments API. I also don't feed in YAML files; instead, I define everything programmatically. Reading YAML files and unmarshalling them into Kubernetes structs should be a fairly straight-forward thing to do though.
",37135933
739,37211133,"You have an unbuffered channel. According to the docs:


  If the channel is unbuffered, the sender blocks until the receiver has
  received the value. If the channel has a buffer, the sender blocks
  only until the value has been copied to the buffer


By changing the channel to being buffered, we can avoid deadlock.

c := make(chan int, 10) // holds 10 ints


I also suggest reading https://golang.org/doc/effective_go.html#channels, it's got some good stuff in there related to channels.
",37210109
740,37211325,"So, lets look at what's really going on in your source. You have two goroutines (there's more than two, but we're going to focus on the explicit ones), main and readFromChannel. 

Lets look at what readFromChannel does:

if channel `c` is not empty before `ti` has expired, print its contents and return, after signalling its completion to wait group.
if `ti` has expired before `c` is not empty, print ""TIMED OUT"" and return, after signalling its completion to wait group.


now Main:

adds to waitgroup 
make a channel `c`
start a goroutine `readFromChannel`
sleep for 5 seconds
send 10 to channel `c`
call wait for waitgroup


Now, lets go through the flow of execution for your code, concurrently (your code may/ may not execute in this order every time, keep that in mind)

1) wg.Add(1)
2) c := make(chan int)
3) go readFromChannel(c, time.After(time.Duration(2)*time.Second))
#timer ti starts#
4) time.Sleep(time.Duration(5) * time.Second)
#MAIN Goroutine begins sleep
#timer ti expires#
5) case <-ti:
6) fmt.Println(""TIMED OUT"")
7) wg.Done()
# readFromChannel Goroutine returns #
#MAIN Goroutine exits sleep#
8) c<-10
9) ......#DEADLOCK#


Now you can guess why you got a deadlock. In go, non buffered channels will block until something happens on the other end of the channel, regardless of whether you're sending or receiving. So c  will block until something reads from the other end of c, but the goroutine you had for that has dropped out of the picture 2 seconds ago. Therefore, c blocks forever, and since main is the last goroutine left, you get a Deadlock.

How to prevent it? When using channels, ensure that there's always a receive at the other end of the channel for every send. You can also use a buffered channel, but in your code above, it would not be the ""right"" solution. 

Here's my fix for the deadlock:

func main() {
    wg.Add(1)
    c := make(chan int)
    go readFromChannel(c, time.After(time.Duration(2)*time.Second))
    time.Sleep(time.Duration(5) * time.Second)
    c <- 10
    wg.Wait()
}

func readFromChannel(c chan int, ti <-chan time.Time) {
        // the forloop will run forever
    loop: // **
    for {
        select {
            case x := <-c:
                    fmt.Println(""Read"", x)
                    break loop // breaks out of the for loop and the select **
            case <-ti:
                    fmt.Println(""TIMED OUT"")
            }
    }
    wg.Done()
} 


** see this answer for details
",37210109
741,37211409,"Your problem is that you are using select statement but you are not using inside a goroutine.

go func() {
    for {
        select {
        case x := <-c:
            fmt.Println(""Read"", x)
        case <-ti:
            fmt.Println(""TIMED OUT"")
        }
    }
}()


Getting the values out of different concurrently executing goroutines can be accomplished with the select keyword, which closely resembles the switch control statement and is sometimes called the communications switch.

Using a send operation in a select statement with a default case guarantees that the send will be non-blocking! If there are no cases, the select blocks execution forever.

https://play.golang.org/p/Ai1ggveb4s
",37210109
742,37214476,"Thank you Will Charzuck for the answer, however, it did not work for me unless I used a pointer method receiver, and set the value of the pointer in the function body.

type ConvertibleBoolean bool

func (bit *ConvertibleBoolean) UnmarshalJSON(data []byte) error {
    asString := string(data)
    if asString == ""1"" || asString == ""true"" {
        *bit = true
    } else if asString == ""0"" || asString == ""false"" {
        *bit = false
    } else {
        return errors.New(fmt.Sprintf(""Boolean unmarshal error: invalid input %s"", asString))
    }
    return nil
}

",30856454
743,37255140,"The problem is that WrapperFunc() expects a value of function type:

func(int, int, RequestBody) int


And you try to pass add to it which has a function type:

func(int, int, LoginRequest) int


2 function types are equal if both have the same parameter and result types. This does not hold in the above mentioned 2 function types: RequestBody and LoginRequest are different types, and so function types having these as (or among) parameters are different types.

You may only pass add to WrapperFunc() if you change its parameters to match the required type:

func add(a, b int, lr RequestBody) int {
    fmt.Println(lr.GetDescription())
    return a + b
}


Now add() has the same function type as fn in the parameters of WrapperFunc(), so your code will compile and run.

Output (try it on the Go Playground)

cool function
7


Notes:

Now lr parameter in add() is of type RequestBody and not LoginRequest. You may use it like a RequestBody, which is you may call its GetDescription() method. In WrapperFunc() you don't have to change anything, as LoginRequest implements RequestBody, so it is allowed to call fn() with a value of LoginRequest, and an interface value of type RequestBody will automatically, implicitly be created and passed to fn (which is add() in your case).

Note that in add() since parameter is now a RequestBody, you can't refer to fields of LoginRequest. You may if the value implementing the interface is indeed a value of type LoginRequest, in which case you may use type assertion to obtain the wrapped LoginRequest value should you need it.
",37253717
744,37279729,"The ExpectContinueTimeout field was added in Go 1.6. Upgrade your version of Go.
",37268031
745,37280167,"You need to specify struct tags in your struct definition:

type Retailers struct {
  Id int `json:""id""`
  Name string `json:""name""`
  Products []Product `json:""products""`
}

type Product struct {
  Id int `json:""id""`
  Description string `json:""description""`
  Url string `json:""url""`
}

",37280034
746,37292523,"Some background

First let's clear some things related to types. Quoting from Spec: Types:


  A type determines the set of values and operations specific to values of that type. Types may be named or unnamed. Named types are specified by a (possibly qualified) type name; unnamed types are specified using a type literal, which composes a new type from existing types.


So there are (predeclared) named types such as string, int etc, and you may also create new named types using type declarations (which involves the type keyword) such as type MyInt int. And there are unnamed types which are the result of a type literal (applied to / including named or unnamed types) such as []int, struct{i int}, *int etc. 

You can get the name of a named type using the Type.Name() method, which ""returns an empty string for unnamed types"":

var i int = 2
fmt.Printf(""%q\n"", reflect.TypeOf(""abc"").Name())              // Named: ""string""
fmt.Printf(""%q\n"", reflect.TypeOf(int(2)).Name())             // Named: ""int""
fmt.Printf(""%q\n"", reflect.TypeOf([]int{}).Name())            // Unnamed: """"
fmt.Printf(""%q\n"", reflect.TypeOf(struct{ i int }{}).Name())  // Unnamed: """"
fmt.Printf(""%q\n"", reflect.TypeOf(&struct{ i int }{}).Name()) // Unnamed: """"
fmt.Printf(""%q\n"", reflect.TypeOf(&i).Name())                 // Unnamed: """"


There are types which are predeclared and are ready for you to use them (either as-is, or in type literals):


  Named instances of the boolean, numeric, and string types are predeclared. Composite types—array, struct, pointer, function, interface, slice, map, and channel types—may be constructed using type literals.


Predeclared types are:

bool byte complex64 complex128 error float32 float64
int int8 int16 int32 int64 rune string
uint uint8 uint16 uint32 uint64 uintptr


You may use Type.PkgPath() to get a named type's package path, which ""if the type was predeclared (string, error) or unnamed (*T, struct{}, []int), the package path will be the empty string"":

fmt.Printf(""%q\n"", reflect.TypeOf(""abc"").PkgPath())    // Predeclared: """"
fmt.Printf(""%q\n"", reflect.TypeOf(A{}).PkgPath())      // Named: ""main""
fmt.Printf(""%q\n"", reflect.TypeOf([]byte{}).PkgPath()) // Unnamed: """"


So you have 2 tools available to you: Type.Name() to tell if the type is a named type, and Type.PkgPath() to tell if the type is not predeclared and is a named type.

But care must be taken. If you use your own, named type in a type literal to construct a new type (e.g. []A), that will be an unnamed type (if you don't use the type keyword to construct a new, named type):

type ASlice []A

fmt.Printf(""%q\n"", reflect.TypeOf([]A{}).PkgPath())    // Also unnamed: """"
fmt.Printf(""%q\n"", reflect.TypeOf(ASlice{}).PkgPath()) // Named: ""main""


What can you do in such cases? You may use Type.Elem() to get the type's element type, if type's Kind is Array, Chan, Map, Ptr, or Slice (else Type.Elem() panics):

fmt.Printf(""%q\n"", reflect.TypeOf([]A{}).Elem().Name())    // Element type: ""A""
fmt.Printf(""%q\n"", reflect.TypeOf([]A{}).Elem().PkgPath()) // Which is named, so: ""main""


Summary

Type.PkgPath() can be used to ""filter out"" predeclared and unnamed types. If PkgPath() returns a non-empty string, you can be sure it's a ""custom"" type. If it returns an empty string, it still may be an unnamed type (in which case Type.Name() returns """") constructed from a ""custom"" type; for that you may use Type.Elem() to see if it is constructed from a ""custom"" type, which may have to be applied recursively:

// [][]A -> Elem() -> []A which is still unnamed: """"
fmt.Printf(""%q\n"", reflect.TypeOf([][]A{}).Elem().PkgPath())

// [][]A -> Elem() -> []A -> Elem() -> A which is named: ""main""
fmt.Printf(""%q\n"", reflect.TypeOf([][]A{}).Elem().Elem().PkgPath())


Try all the examples on the Go Playground.

Special case #1: Anonymous struct types

There is also the case of an anonymous struct type which is unnamed, but it may have a field of a ""custom"" type. This case can be handled by iterating over the fields of the struct type and performing the same check on each field, and if any of them is found to be a ""custom"" type, we can claim the whole struct type to be ""custom"".

Special case #2: Map types

In case of maps we may consider an unnamed map type ""custom"" if any of its key or value type is ""custom"".

The value type of a map can be queried with the above mentioned Type.Elem() method, and the key type of a map can be queried with the Type.Key() method - we also have to check this in case of maps.

Example implementation

func isCustom(t reflect.Type) bool {
    if t.PkgPath() != """" {
        return true
    }

    if k := t.Kind(); k == reflect.Array || k == reflect.Chan || k == reflect.Map ||
        k == reflect.Ptr || k == reflect.Slice {
        return isCustom(t.Elem()) || k == reflect.Map && isCustom(t.Key())
    } else if k == reflect.Struct {
        for i := t.NumField() - 1; i >= 0; i-- {
            if isCustom(t.Field(i).Type) {
                return true
            }
        }
    }

    return false
}


Testing it (try it on the Go Playground):

type K int
var i int = 2
fmt.Println(isCustom(reflect.TypeOf("""")))                // false
fmt.Println(isCustom(reflect.TypeOf(int(2))))            // false
fmt.Println(isCustom(reflect.TypeOf([]int{})))           // false
fmt.Println(isCustom(reflect.TypeOf(struct{ i int }{}))) // false
fmt.Println(isCustom(reflect.TypeOf(&i)))                // false
fmt.Println(isCustom(reflect.TypeOf(map[string]int{})))  // false
fmt.Println(isCustom(reflect.TypeOf(A{})))               // true
fmt.Println(isCustom(reflect.TypeOf(&A{})))              // true
fmt.Println(isCustom(reflect.TypeOf([]A{})))             // true
fmt.Println(isCustom(reflect.TypeOf([][]A{})))           // true
fmt.Println(isCustom(reflect.TypeOf(struct{ a A }{})))   // true
fmt.Println(isCustom(reflect.TypeOf(map[K]int{})))       // true
fmt.Println(isCustom(reflect.TypeOf(map[string]K{})))    // true

",36310538
747,37366707,"This serve all files inside the folder flag, as well as serving index.html at the root. 

Usage

   //port default values is 8500
   //folder defaults to the current directory
   go run main.go 

   //your case, dont forget the last slash
   go run main.go -folder static/

   //dont
   go run main.go -folder ./


Code

    package main

import (
    ""flag""
    ""fmt""
    ""net/http""
    ""os""
    ""strconv""
    ""strings""

    ""github.com/gorilla/handlers""
    ""github.com/gorilla/mux""
    ""github.com/kr/fs""
)

func main() {
    mux := mux.NewRouter()

    var port int
    var folder string
    flag.IntVar(&port, ""port"", 8500, ""help message for port"")
    flag.StringVar(&folder, ""folder"", """", ""help message for folder"")

    flag.Parse()

    walker := fs.Walk(""./"" + folder)
    for walker.Step() {
        var www string

        if err := walker.Err(); err != nil {
            fmt.Fprintln(os.Stderr, ""eroooooo"")
            continue
        }
        www = walker.Path()
        if info, err := os.Stat(www); err == nil && !info.IsDir() {
            mux.HandleFunc(""/""+strings.Replace(www, folder, """", -1), func(w http.ResponseWriter, r *http.Request) {
                http.ServeFile(w, r, www)
            })
        }
    }
    mux.HandleFunc(""/"", func(w http.ResponseWriter, r *http.Request) {
        http.ServeFile(w, r, folder+""index.html"")
    })
    http.ListenAndServe("":""+strconv.Itoa(port), handlers.LoggingHandler(os.Stdout, mux))
}

",15834278
748,37368727,"You can compare the two strings (the one that won't work, and where you type the ""same"" string in manually) and you can see there's a difference. The string that doesn't work uses A0 (hex) non-breaking space, while the one that works uses the regular space 20 (hex).

You can see it in the playground: https://play.golang.org/p/6UIEKg9hs0
",37368442
749,37405003,"Remove the space in the middle of tags.

Use bson:""firstName"" instead of bson: ""firstName""

type Person struct {
    FirstName string `bson:""firstName"" json:""firstName""`
    LastName string `bson:""lastName json:""lastName""`
}


From documentation at https://golang.org/pkg/reflect/#StructTag,


  By convention, tag strings are a concatenation of optionally
  space-separated key:""value"" pairs.


So there should be no space between key and value. Different pairs of a key and a value could be separated by a space.
",37404523
750,37409084,"To get information about a struct at runtime, you have to use the package reflect. First, get the type of the struct, and then you can iterate through it. However, with your example, be aware that the type main.Student doesn't have any methods associated, but the type *main.Student has.

Here is an example of how you can fetch those information:

func main() {
    s := Student{1, ""Jack"", 22}
    t := reflect.TypeOf(s)
    ptr_t := reflect.TypeOf(&s)

    methods := make([]string, 0)
    for i := 0; i < ptr_t.NumMethod(); i++ {
        methods = append(methods, ptr_t.Method(i).Name)
    }

    fields := make([]string, 0)
    for i := 0; i < t.NumField(); i++ {
        fields = append(fields, t.Field(i).Name)
    }

    fmt.Println(methods)
    # [getAge getId getName setAge setId setName]
    fmt.Println(fields)
    # [id name age]

}


A point about your code: look at how the export of fields and methods between package is done. Because all the fields and methods starting by a lowercase letter are not accessible outside of the package. You have to start them with an uppercase letter.

Another point: there are usually no getters and setters in Go code. If you want to read and write a struct field, simply start it with an uppercase letter.
",37406075
751,37459588,"There is json.RawMessage for this purpose.

package main

import (
    ""encoding/json""
    ""fmt""
)

type Container struct {
    Type   string
    Object json.RawMessage
}

type Selling struct {
    Surname   string
    Firstname string
    Price     int
}

type Buying struct {
    ID        int
    Surname   string
    Firstname string
}

func main() {
    rawJson1 := []byte(`{""Type"":""Selling"",""Object"":{""Surname"":""X"",""Firstname"":""Mister"",""Price"":10}}`)
    rawJson2 := []byte(`{""Type"":""Buying"",""Object"":{""ID"":1,""Surname"":""X"",""Firstname"":""Mister""}}`)

    processMessage(rawJson1)
    processMessage(rawJson2)
}

func processMessage(data []byte) {
    var c Container
    json.Unmarshal(data, &c)

    switch {
    case c.Type == ""Buying"":
        processBuying(c)
    case c.Type == ""Selling"":
        processSelling(c)
    default:
        fmt.Println(""bad entry"")
    }
}

func processBuying(c Container) {
    var bu Buying
    json.Unmarshal(c.Object, &bu)
    fmt.Println(bu.Firstname, bu.Surname, ""wants to buy the following product:"", bu.ID)
}

func processSelling(c Container) {
    var se Selling
    json.Unmarshal(c.Object, &se)
    fmt.Println(se.Firstname, se.Surname, ""wants to sell something for:"", se.Price)
}

",37458556
752,37459613,"I might be wrong, but I don't think you can do it in one step.

First idea: Unmarshal in map[string]interface{}

Don't use type with unmarshal, instead use a map[string]interface{}, and then construct Selling/Buying from this map (or use directly the map) 

type Container struct {
    Type string
    Object map[string]interface{}
}


Second idea: Two steps / clueless container

First: Unmarshall in a clueless Container that doesn't know the type

type CluelessContainer struct {
    Type string 
    Object interface{} `json:""-""` // or just remove this line ?
}


Then unmarshall in the type aware container. You could use a factory pattern to come with the right struct.
",37458556
753,37503340,"I think the question is about Different Forms of For Loop:
simple loop variants working sample:

package main

import ""fmt""

func main() {
    //0 1 2 3 4 5 6 7 8 9
    for i := 0; i < 10; i++ {
        fmt.Print(i, "" "")
    }
    fmt.Println()

    i := 0
    for ; i < 10; i++ {
        fmt.Print(i, "" "")
    }
    fmt.Println()

    for i := 0; i < 10; {
        fmt.Print(i, "" "")
        i++
    }
    fmt.Println()

    //2 4 6 8 10 12 14 16 18 20
    for i := 1; ; i++ {
        if i&1 == 1 {
            continue
        }
        if i == 22 {
            break
        }
        fmt.Print(i, "" "")
    }
    fmt.Println()

    i = 0
    for {
        fmt.Print(i, "" "")
        i++
        if i == 10 {
            break
        }

    }
    fmt.Println()

    for i, j := 0, 0; i < 5 && j < 10; i, j = i+1, j+2 {
        fmt.Println(i, j)
    }
}


for array, slice,string, map, channel using range keyword:

package main

import ""fmt""

func main() {
    ary := [5]int{0, 1, 2, 3, 4}
    for index, value := range ary {
        fmt.Print(""ary["", index, ""] ="", value, "" "")
    }
    fmt.Println()
    for index := range ary {
        fmt.Print(""ary["", index, ""] ="", ary[index], "" "")
    }
    fmt.Println()
    for _, value := range ary {
        fmt.Print(value, "" "")
    }
    fmt.Println()

    slice := []int{20, 21, 22, 23, 24, 25, 26, 27, 28, 29}
    for index, value := range slice {
        fmt.Println(""slice["", index, ""] ="", value)
    }
    fmt.Println()

    str := ""Hello""
    for index, value := range str {
        fmt.Println(""str["", index, ""] ="", value)
    }
    fmt.Println()

    mp := map[string]int{""One"": 1, ""Two"": 2, ""Three"": 3}
    for key, value := range mp {
        fmt.Println(""map["", key, ""] ="", value)
    }
    fmt.Println()

    ch := make(chan int, 10)
    for i := 0; i < 10; i++ {
        ch <- i
    }
    close(ch)

    for i := range ch {
        fmt.Print(i, "" "")
    }
    fmt.Println()
}


and Label for break Label and continue Label:

package main

import ""fmt""

func main() {
    a, b := 1, 1
Loop1:
    for {
        b++
    Loop2:
        for {
            a++
            switch {
            case a == 2:
                fallthrough
            case a == 3:
                fmt.Println(3)
            case a == 4, a == 5:
                continue
            case a == 7:
                continue Loop1
            case a == 9:
                break Loop2
            case a == 10:
                break Loop1
            case a == 8:
                break
            default:
                fmt.Println(a, b)
            }
        }
    }
}


also see: Different Forms of For Loop
",37484049
754,37557884,"You have a type mismatch here. If you look at the documentation, you'll see that the field Transport of the Client struct returns an interface RoundTripper:

type Client struct {
    // Transport specifies the mechanism by which individual
    // HTTP requests are made.
    // If nil, DefaultTransport is used.
    Transport RoundTripper

    // ...
}


So, the type of tmp1 is http.RoundTripper, though the underlying type is *http2.Transport which implements the RoundTripper interface.

As for tmp2 and tmp3, they are seen as pointers to a RoundTripper and not as **http2.Transport.

In order to retrieve the DialTLS field, you have to use type assertions to convert a RoundTripper back into a Transport:

dialTLS := client.Transport.(*http2.Transport).DialTLS

",37557763
755,37596328,"You don't appear to be parsing your file correctly.  You should first split on \n, THEN split on \t.  Also, verify your text file actually has \t and not spaces.

You should probably iterate through your parsed values with fmt.Println to verify your parsed results are as expected.

It should look something like this.
",37595002
756,37614097,"Well, if you really want to hide the page by redirecting the user to another page, then you obviously cannot use this method, because anyone can turn javascript off and see the page, thus this can be a security risk. However, if you just simply want to redirect for some reason, this is fine.

As for you crawler, what you can do is search the source code with regex for redirections like that, but it can be very challenging to cover all cases.
",37613823
757,37657970,"This is an example of how to unmarshall JSON responses from the Safebrowsing v4 API sbserver proxy server:  https://play.golang.org/p/4rGB5da0Lt

// this example shows how to unmarshall JSON requests from the Safebrowsing v4 sbserver
package main

import (
    ""fmt""
    ""log""
    ""encoding/json""
)

// response from sbserver POST request
type Results struct {
    Matches []Match     
}

// nested within sbserver response
type Match struct {
    ThreatType string 
    PlatformType string 
    ThreatEntryType string 
    Threat struct {
        URL string
    }
}

func main() {
    fmt.Println(""Hello, playground"")

    // sample POST request
    //   curl -X POST -H 'Content-Type: application/json' 
    // -d '{""threatInfo"": {""threatEntries"": [{""url"": ""http://testsafebrowsing.appspot.com/apiv4/ANY_PLATFORM/MALWARE/URL/""}]}}' 
    // http://127.0.0.1:8080/v4/threatMatches:find

    // sample JSON response
    jsonResponse := `{""matches"":[{""threatType"":""MALWARE"",""platformType"":""ANY_PLATFORM"",""threatEntryType"":""URL"",""threat"":{""url"":""http://testsafebrowsing.appspot.com/apiv4/ANY_PLATFORM/MALWARE/URL/""}}]}`

    res := &Results{}
    err := json.Unmarshal([]byte(jsonResponse), res)
        if(err!=nil) {
            log.Fatal(err)
        }

    fmt.Printf(""%v\n"",res)
    fmt.Printf(""\tThreat Type: %s\n"",res.Matches[0].ThreatType)
    fmt.Printf(""\tPlatform Type: %s\n"",res.Matches[0].PlatformType)
    fmt.Printf(""\tThreat Entry Type: %s\n"",res.Matches[0].ThreatEntryType)
    fmt.Printf(""\tURL: %s\n"",res.Matches[0].Threat.URL)
}

",21268000
758,37658851,"You can use %s to printf:

for _, hit := range serachResult.Hits.Hits {
   fmt.Printf(""%s\n"", hit.Source)
}

",37658719
759,37734617,"Use the encoding/binary package:

import (
    ""encoding/binary""
)

data := []byte{0xB0, 0x1B}
val := binary.BigEndian.Uint16(data)


https://play.golang.org/p/wHW8KDgls9
",37734556
760,37740198,"According to Go FAQ, you cannot change the type of slice directly.

So it seems that your solution is the preferred way.
",37739896
761,37742126,"Is getSomeValue() your function? If so, I would change the return type to be map[string][]string rather than map[string][]interface.

If that is not the case, I would create some helpers to go through and check to make sure the types are set to your needs. I have an example in the playground

https://play.golang.org/p/9OPgXGXADY
",37739896
762,37759643,"This isn't a Golang specific question or answer but the best solution would be to compress the folder into an archive and have your users download that.
",37759462
763,37759782,"I am not really sure what are you trying to achive, but may be it help.

bodyBytes, err := ioutil.ReadAll(resp.Body)
reader := bytes.NewReader(bodyBytes)
http.Post(""https://httpbin.org/post"", ""application/json; charset=utf-8"", reader)

//or you can do it directly
//http.Post(""https://httpbin.org/post"", ""application/json; charset=utf-8"", resp.Body)

",37759697
764,37832151,"Here is a thread that may interest you: Add runtime.Free() for GOGC=off

Interesting part:


  The Go GC does not have the ability to manually deallocate blocks 
  anymore. And besides, runtime. Free is unsafe (people might free still
  in use pointers or double free) and then all sorts of C memory problem
  that Go tries hard to get rid of will come back. The other reason is
  that runtime sometimes allocates behind your back and there is no way
  for the program to explicitly free memory.
  
  If you really want to manually manage memory with Go, implement your
  own memory allocator based on syscall.Mmap or cgo malloc/free.
  
  Disabling GC for extended period of time is generally a bad solution
  for a concurrent language like Go. And Go's GC will only be better
  down the road.


TL;DR: Yes, but don't do it
",37831477
765,37881018,"This library will works perfectly with firebase, if you do several things:


Change xmppHost from https://gcm-http.googleapis.com/gcm/send to https://fcm.googleapis.com/fcm/send
Add new const xmppDomain = ""gcm.googleapis.com""
Change function xmppUser, it should be like


func xmppUser(senderId string) string {
    return senderId + ""@"" + xmppDomain
}



",37478857
766,37900615,"Handing io.EOF is part of the contract of using an io.Reader, and it indicates that there's nothing more to read. If you have read what you expected to read, there is no error. If you look at functions like ioutil.ReadAll, you'll see that it handles the EOF, and returns no error at the end of the stream. 

You may also consider not checking for ContentLength, as it precludes you from handing chunked responses. 
",37899240
767,37903293,"I was able to reproduce this error if and only if I had a semi-colon in the To header within the message body. E.g.:

msg := []byte(""To: email1@example.com;email2@example.com\r\nSubject: foo\r\n\r\nbody\r\n"")


Double-check the To header you're sending and make sure it uses commas instead of semi-colons to separate multiple recipients.
",37885698
768,37922991,"The documentation states:


  Multiple goroutines may invoke methods on a Conn simultaneously.


There is no mention of whether each individual write is atomic. While the current implementation may ensure that each call to Write happens completely before the next call can begin, there is no guarantee in the language specification. 
",37922775
769,37986398,"No, accessing stack[1] does not work reliably. It doesn’t contain any result as soon as the stack needs to grow beyond 16, its initial size. (See #16163.)

The if statement after the yystack label then creates a new stack and totally forgets about the one saved in yyParserImpl.



I did the following.

Add a result field to the lexer type:

type ShellLexer struct {
    /* … */
    result *ShellProgram
}


Extend the grammar by the following rule at the very beginning:

start : program {
    shyylex.(*ShellLexer).result = $$
}


(This depends on the parameter name of the Parse method (which can have a custom prefix), but I think that’s ok.)
",36822702
770,38010631,"The second solution handles the leak by using the quit channel. When the quit channel is closed (in Same() function), the case 2 of select statement succeeds(case 
",29190333
771,38017286,"In your code, since you didn't tell, I guess the variable 'd' is passed to the template. 'd' is of type Daten and thus contain a field named TableData. This field is a slice of *Tasks. This is why in your template you can loop on it using range.

The range keyword returns two values, the first one, '$key' in your code, is the index of the slice, and the second one, '$values' in your code is the value pointed by TableData[$key]. Because TableData is a slice of type *Tasks, that means $values is of type *Tasks. So not an array nor a slice.

That means, you can't loop on $values because it's not a slice. But, you can access all the exported fields of Tasks. So depending on what you want to display in your template, you can do the following:

// Inside the firts range
{{ $key }}: 
name: $values.Name
open: $values.Open


Note the uppercase on the field's name, in order to access a field it shall be exported, and thus starts with an upper case in the type declaration.
",38001650
772,38079468,"I can see you have a lot of redundancy in your code. Few months back I had a same problem and have great answer. Take a look at here: How to return dynamic type struct in Golang?.

Basically you will have same three functions(add/edit/delete/count) like this (i do not know what db are you using I use NoSql Rethinkdb, but the principle is same):

func (c Main) Get(modelname string) interface{} {

   //your query here for getting stuff from model name and return interface

   rows, err := rethink.Table(modelname).OrderBy(rethink.Asc(""sortNo"")).Run(c.DB)
   if err != nil {
       log.Println(err)
       return nil
   }

   if (modelType == ""brand"") {

       var brands  []*models.Brand
       rows.All(&brands)

       return brands

   }
   //rest of your models here or use some switch
})


I usually put all my functions that are doing stuff with database in some helper (this is mostly because of tests). 

I think this is good directions because like this you code is easy to maintain and you will be changing only helper functions instead of going to million fictions that are doing add/delete/update for every model.  
",38079036
773,38081337,"I implemented this idea in the code. It turned out great.

Refactoring code

//------------------------------------------------------------------------
//  REFACTORING
//-----------------------------------------------------------------------
func (d *Database)Create(model string, params interface{}) *Answer {
    //variables
    answer := d.initCall(""Create"")
    tableType := d.Mapper[model]
    var (
        errorExists interface{}
        flag bool
    )

    //logic switch types
    switch tableType.(type) {
    case User:
        params := params.(UserUpdate)
        if errorExists = d.DB.Find(&User{}, &User{Email:params.Email}).Error; errorExists == nil {
            flag = false
        } else {
            flag = true
            //variables
            user := new(User)
            userinfo := UserInfo{Data:time.Now()}
            session := Session{Data:time.Now()}
            cook := Cook{}

            //make support  tables object
            //userinfo object
            userinfo.Password = params.Password
            userinfo.Username = params.Username
            //cook object
            cook.SessionID = session.ID
            cook.Cookie = d.cookgeneratenew(""somesaltforcooksgenerate"")
            cook.Status = true
            cook.Lastconnect = time.Now()
            cook.CountConnect += 1

            //user object
            user.Email = params.Email
            user.Session = session
            user.UserInfo = userinfo
            user.Cook = cook
            user.Role = int64(params.Role)

            //assign ready model for create
            tableType = user
        }

    case Category:
        params := params.(CategoryUpdate)
        if errorExists = d.DB.Find(&Category{}, &Category{Name:params.Name}).Error; errorExists == nil {
            //set logic switcher
            flag = false
        } else {
            //set logic switcher
            flag = true

            //speciffic functional
            cat := new(Category)
            cat.Name = params.Name

            //assign ready model for create
            tableType = cat
    }
    default:
        fmt.Printf(""Wrong type table\n"")
    }

    //call function create model
    if flag {
        if err := d.DB.Create(tableType).Error; err != nil {
            answer.AnswerJSON.ErrorAnswer.Message = err.Error()
            answer.AnswerJSON.Status = false
        } else {
            answer.AnswerJSON.Result = tableType
            answer.AnswerJSON.Status = true
        }
    } else {
        answer.AnswerJSON.ErrorAnswer.Message = ""object already exist""
        answer.AnswerJSON.Result = nil
        answer.AnswerJSON.Status = false
    }
    //make answer
    d.serilize(answer)
    return answer
}

",38079036
774,38163481,"There's a certain edge case you are probably missing in your code. See https://getsatisfaction.com/codeeval/topics/bubble-sort-iterations-are-too-high-causing-solution-to-be-aborted-in-java
",38088721
775,38234154,"You need to write one yourself, but the building blocks are already in the standard library:

func swapCase(s string) string {
    return strings.Map(func(r rune) rune {
        switch {
        case unicode.IsLower(r):
            return unicode.ToUpper(r)
        case unicode.IsUpper(r):
            return unicode.ToLower(r)
        }
        return r
    }, s)
}

",38234029
776,38234237,"
  but in case I would like to get the output in realtime


One way to do that is to attach os.Stdout to cmd.Stdout

oCmd := exec.Command(bin, cmdArgs...)
oCmd.Stdout = os.Stdout
oCmd.Stderr = os.Stderr

err := oCmd.Run()


Then you can use a File instead with f,_ := os.Create(""file"").

If you want to write it to both a file and to the terminal at same time, i suspect (I have not done that yet), that you need to use io.Mutiwriters

f, _ := os.Create(""file"")
cmd.Stdout = io.MultiWriter(os.Stdout, f)

",38229584
777,38253645,"You can do this, at the cost of creating a new array (which may or may not be a deal breaker for you)

for _, i := range append([]int{1, 2, 3}, []int{4, 5, 6, 7}...) {
    fmt.Printf(""%v\n"", i)
}


Note it works with different length arrays.  See https://play.golang.org/p/DRCI_CwSjA for a playground example.
",28047311
778,38290806,"I do not know PHP, but as far as I understand from the PHP code the Go equivalent should be:

func compare(keyword string, filters map[string]struct{}) (string, error) {
    // value, ok := myMap[key]
    // this is Go syntax for checking the existance of a key in a map - check the ok variable.
    _, filterMatched := filters[keyword]
    if filterMatched {
        return ``, fmt.Errorf(""keyword %s got filtered"", keyword)
    }

    return keyword, nil
}


In other words you could just use the map type, but having a helper function that clears our intention is good.
",38262155
779,38295195,"Maybe someone found this useful:

const regKey = `SOFTWARE\Microsoft\Windows NT\CurrentVersion`

func getSettingsFromRegistry() (settings map[string]string) {
    settings = make(map[string]string)

    k, err := registry.OpenKey(registry.LOCAL_MACHINE, regKey, registry.QUERY_VALUE)
    if err != nil {
        self.Log.Println(""Can't open registry key "" + regKey , err)
        return
    }
    defer k.Close()

    params, err := k.ReadValueNames(0)
    if err != nil {
        self.Log.Printf(""Can't ReadSubKeyNames %s %#v"", psaConfRegistry32, err)
        return
    }

    for _, param := range params {
        val, err := getRegistryValueAsString(k, param)
        if err != nil {
            self.Log.Println(err)
            return
        }
        settings[param] = val
    }

    self.Log.Printf(""%#v\n"", settings)
    return
}

func getRegistryValueAsString(key registry.Key, subKey string) (string, error) {
    valString, _, err := key.GetStringValue(subKey)
    if err == nil {
        return valString, nil
    }
    valStrings, _, err := key.GetStringsValue(subKey)
    if err == nil {
        return strings.Join(valStrings, ""\n""), nil
    }
    valBinary, _, err := key.GetBinaryValue(subKey)
    if err == nil {
        return string(valBinary), nil
    }
    valInteger, _, err := key.GetIntegerValue(subKey)
    if err == nil {
        return strconv.FormatUint(valInteger, 10), nil
    }

    return """", errors.New(""Can't get type for sub key "" + subKey)
}


REG_BINARY values will looks like ""\x01\x00\x00...""
",18425465
780,38321944,"The problem is, that not every data could be marshaled to json (or unmarshaled). http.HandlerFunc is not a function (https://golang.org/pkg/net/http/#HandlerFunc). You cannot put it directly - but you can change handler to string and on the place when you trying to call it obtain HandlerFunc from reflect (a quite complicated) or from prepared map[string]HandlerFunc.
",38321621
781,38322054,"The simplest solution is to have a string instead of the http.HandlerFunc as type, and define a map with the functions.

var functions = map[string]interface{}{
    ""func1"": func1,
}


then after unmarshalling your json you can assign the handler using the handlername of each route
",38321621
782,38382115,"For MAC this worked well for me. 

sudo nano /etc/bashrc


and add the below at the end of the file

export PATH=$PATH:/usr/local/opt/go/libexec/bin
export GOPATH=/usr/local/opt/go/bin


This should fix the problem. Try opening a new terminal and echo $GOPATH you should see the correct value. 
",20628918
783,38387285,"So you need Interval Timer to run one function at noon  everyday, you may use:
time.AfterFunc()  or time.Tick() or time.Sleep() or time.Ticker

first when program starts calculate time interval for start up time till first next noon and use some wait (e.g. time.Sleep or ...) then use   24 * time.Hour interval for the next interval.  

sample code using time.Sleep:  

package main

import ""fmt""
import ""time""

func noonTask() {
    fmt.Println(time.Now())
    fmt.Println(""do some job."")
}
func initNoon() {
    t := time.Now()
    n := time.Date(t.Year(), t.Month(), t.Day(), 12, 0, 0, 0, t.Location())
    d := n.Sub(t)
    if d < 0 {
        n = n.Add(24 * time.Hour)
        d = n.Sub(t)
    }
    for {
        time.Sleep(d)
        d = 24 * time.Hour
        noonTask()
    }
}
func main() {
    initNoon()
}


and you may change main to this (or any thing you need):  

func main() {
    go initNoon()

    // do normal task here:
    for {
        fmt.Println(""do normal task here"")
        time.Sleep(1 * time.Minute)
    }
}


using time.AfterFunc:  

package main

import (
    ""fmt""
    ""sync""
    ""time""
)

func noonTask() {
    fmt.Println(time.Now())
    fmt.Println(""do some job."")
    time.AfterFunc(duration(), noonTask)
}
func main() {
    time.AfterFunc(duration(), noonTask)
    wg.Add(1)
    // do normal task here
    wg.Wait()
}

func duration() time.Duration {
    t := time.Now()
    n := time.Date(t.Year(), t.Month(), t.Day(), 12, 0, 0, 0, t.Location())
    if t.After(n) {
        n = n.Add(24 * time.Hour)
    }
    d := n.Sub(t)
    return d
}

var wg sync.WaitGroup


using time.Ticker:  

package main

import (
    ""fmt""
    ""sync""
    ""time""
)

var ticker *time.Ticker = nil

func noonTask() {
    if ticker == nil {
        ticker = time.NewTicker(24 * time.Hour)
    }
    for {
        fmt.Println(time.Now())
        fmt.Println(""do some job."")
        <-ticker.C
    }
}
func main() {
    time.AfterFunc(duration(), noonTask)
    wg.Add(1)
    // do normal task here
    wg.Wait()
}

func duration() time.Duration {
    t := time.Now()
    n := time.Date(t.Year(), t.Month(), t.Day(), 12, 0, 0, 0, t.Location())
    if t.After(n) {
        n = n.Add(24 * time.Hour)
    }
    d := n.Sub(t)
    return d
}

var wg sync.WaitGroup  


and see:
https://github.com/jasonlvhit/gocron
Golang - How to execute function at specific times
Golang: Implementing a cron / executing tasks at a specific time
",38386762
784,38420129,"It is because you are only declaring and assigning values to number. You are never actually using it anywhere (i.e. referring to the value it holds in any way). In you code, you can safely remove number declaration and number = x[0] and it won't change the program behavior.

The correct implementation however would return the smallest number from the function:

package main
import(
    ""fmt""
)

func main() {
    n := samlestNumber()
    fmt.Println(""Smallest Number ="", n)
}

func samlestNumber() int { // add a return type
    x := []int{
        48,96,86,68,
        57,82,63,70,
        37,34,83,27,
        19,97, 9,17,
    }

    //x = append(x,6,7)
    var number int = x[0]
    for _,element := range x {

        // always compare to smallest number. Even if you don't return
        // number anymore, you are still accessing the value held by
        // the number variable. So even making this change alone will
        // make the compiler error go away 
        if element < number {
            number = element
        }

        fmt.Println("" :::: "",element)
    }
    return number // return number
}

",38420069
785,38422879,"You need to close the channel after wg.Wait(). Otherwise your range for loop gets stuck.

Other than that your code looks fine.
",38422600
786,38423953,"As @creker wrote, you have to close the channel, othervise the loop which reads from it will be infinite loop. However, I do not agree that just adding close(ch) after the wg.Wait() is right way to go - this would mean that the loop which reads the values from the channel wouldn't start until all ports are scanned (all connect() calls return). I'd say you want to start proccessing the results as soon as they are available. For that you have to restructure your code so that the producer and consumer are different goroutines, something like following

var results []*portscan.ScanResult
ch := make(chan *portscan.ScanResult)

// launch the producer goroutine    
go func() {
   var wg sync.WaitGroup
   wg.Add(len(splitPorts))
   for _, port := range splitPorts {
       go func(port int32) {
          defer wg.Done()
          ch <- connect(ip, port, req.Timeout)
       }(port)
   }
   wg.Wait()
   close(ch)
}()

// consume results
for elem := range ch {
    results = append(results, elem)
}

func connect(ip string, port, timeout int32) *portscan.ScanResult {
    res := &portscan.ScanResult{
            Port:   port,
            IsOpen: false,
    }
    conn, err := net.DialTimeout(""tcp"", fmt.Sprintf(""%s:%d"", ip, port), time.Duration(timeout)*time.Millisecond)

    if err == nil {
        conn.Close()
        res.IsOpen = true
    }
    return res
}


Note that now the channel is unbuffered and the connect function doesn't know about the waitgroup or channel, so it is more reusable. You could use buffered channel too, if it turns out that the producers generate data more rapidly than the consumer reads it, but you probaly wouldn't need the buffer to be len(splitPorts) but something smaller.

Another optimisation could be to preallocate the results array as you seem to know the numer of results beforehand (len(splitPorts)) so you do not need to use append.
",38422600
787,38465911,"I was able to get the information by executing a Linux command. Here's the piece of code:

    iwlistCmd := exec.Command(""iwlist"", iface, ""scan"")
    iwlistCmdOut, err := iwlistCmd.Output()
    if err != nil {
        fmt.Println(err, ""Error when getting the interface information."")
    } else {
        fmt.Println(string(iwlistCmdOut))
    }


The output is a huge list of information and works in Linux only. As a next stel I have to find a way to extract the info I need which is the ESSID probably with strings.split package/function.
",38427250
788,38499181,"
  Struct values encode as JSON objects. Each exported struct field
  becomes a member of the object unless


- the field's tag is ""-"", or
- the field is empty and its tag specifies the ""omitempty"" option.



  The empty values are false, 0, any nil pointer or interface value, and
  any array, slice, map, or string of length zero. The object's default
  key string is the struct field name but can be specified in the struct
  field's tag value. The ""json"" key in the struct field's tag value is
  the key name, followed by an optional comma and options. Examples:


// Field is ignored by this package.
Field int `json:""-""`

// Field appears in JSON as key ""myName"".
Field int `json:""myName""`

// Field appears in JSON as key ""myName"" and
// the field is omitted from the object if its value is     empty,
// as defined above.
Field int `json:""myName,omitempty""`

// Field appears in JSON as key ""Field"" (the default), but
// the field is skipped if empty.
// Note the leading comma.
Field int `json:"",omitempty""`


So your code should be:

package main

import ""fmt""
import ""encoding/json""

type A struct {
    Name     string `json:""name""`
    Password string `json:""password""`
}

type B struct {
    A
    Password string `json:""password,omitempty""`
    Locale   string `json:""locale""`
}

func main() {

    a := A{""Jim"", ""some_secret_password""}
    b := B{A: a, Locale: ""en""}

    data, _ := json.Marshal(&b)
    fmt.Printf(""%v"", string(data))
}


https://play.golang.org/p/HdwIssr-oC
",38494274
789,38543982,"The capacity growth is not under user control:  


append(s S, x ...T) S  // T is the element type of S 

  
  If the capacity of s is not large enough to fit the additional values,
  append allocates a new, sufficiently large underlying array that fits
  both the existing slice elements and the additional values. Otherwise,
  append re-uses the underlying array.


ref: https://golang.org/ref/spec#Appending_and_copying_slices
and see:  https://golang.org/doc/effective_go.html#append  

it is not increased by 2 (it is performance optimized):
test sample code with initial capacity 5 bytes then it is 16 instead of 10 (see commented output):  

package main

import ""fmt""

func main() {
    s := []byte{1, 2, 3, 4, 5}
    fmt.Println(cap(s)) // 5
    s = append(s, s...)
    fmt.Println(cap(s)) // 16
}


test sample code (with commented output):  

package main

import (
    ""fmt""
)

func main() {
    s := []int{0}
    fmt.Println(cap(s)) // 1
    s = append(s, s...)
    fmt.Println(cap(s)) // 2
}


test sample code (with commented output):  

package main

import (
    ""fmt""
)

func main() {
    s := []int{}
    fmt.Println(cap(s)) // 0
    s = append(s, 1)
    fmt.Println(cap(s)) // 1
}


test sample code with nil slice (with commented output):  

package main

import (
    ""fmt""
)

func main() {
    var s []int
    fmt.Println(cap(s)) // 0
    s = append(s, 1)
    fmt.Println(cap(s)) // 1
}


your sample code (with commented output):  

package main

import ""fmt""

func main() {
    var s1 []int
    s2 := append(s1, 1)
    fmt.Println(cap(s1)) // 0
    fmt.Println(cap(s2)) // 1
}


test sample code with 5 ints (with commented output):  

package main

import ""fmt""

func main() {
    s := []int{1, 2, 3, 4, 5}
    fmt.Println(cap(s)) // 5
    s = append(s, s...)
    fmt.Println(cap(s)) // 10
}


you can not access uninitialized indexes of slice like s2[1]:
panic: runtime error: slice bounds out of range:
test sample code (with commented output):  

package main

import ""fmt""

func main() {
    var s1 []int
    s2 := append(s1, 1)

    fmt.Println(cap(s1)) // 0
    fmt.Println(cap(s2)) // 1
    fmt.Println(s1)      // []
    fmt.Println(s2)      // [1]

    //fmt.Println(s2[0:2]) //panic: runtime error: slice bounds out of range
    //fmt.Println(s2[1])   //panic: runtime error: slice bounds out of range

}



  Bounds Checking Elimination (or BCE) is a general term for removing
  redundant bound checking. Normally a go program will panic when a
  slice or a string is accessed outside of its bounds. There are two
  types of bound checking: for indexing (a[i]) and for slicing (a[i:j]).
  The go compiler inserts these bounds checks at every access, but in
  most cases they are not needed and are redundant based on the context.
  
  Bound checking is important because it provides a defense against
  buffer overflow attacks and catches a common programming error early.
  BCE is important because: it speeds up the code, makes the binary
  smaller. If binaries are slowed down by bound checks then developers
  will have an incentive to disable bound checking (using -gcflags=-B).  


ref 
",38543825
790,38544172,"Go is free to provide you more capacity than you request. This improves performance by reducing the number of allocations (and possibly copying) that are required. Capacity is just the amount of space reserved before another allocation would be required.

If you append 5 elements to this slice, at least in my experiments, the capacity is 8. This shouldn't be surprising, but also shouldn't be relied on. On different platforms, or different versions of the compiler, the actual result may be different, as long as the capacity is ""sufficiently large"" (equal to or greater than length).

The upper index bound of a slice is defined as its capacity:


  For arrays or strings, the indices are in range if 0 


This is why reading past the length is not causing a panic. Even so, you shouldn't think of those zeros as part of the slice. They are indexable by the slice, but fmt.Printf(s2) would correctly not show them because they are not part of the slice. Don't subscript this way.

In general, you want to be looking at length, not capacity. Capacity mostly is readable to assist in performance optimization.
",38543825
791,38544227,"Slice zero value

Zero value for slices is nil. But it doesn't mean you can't do anything with it. In Go types can actually be used when the value is nil. For example, struct methods can be called even if the pointer receiver is nil. Here's an example:

package main

import ""fmt""

type foo struct {
}

func (f *foo) bar() {
    fmt.Println(1)
}

func main() {
    var f *foo
    fmt.Println(f)
    f.bar()
}


playground

The same applies to slices. len, cap, append all work even if you pass a nil slice. In case of append it basically creates a new slice for you that points to an array holding the value.

Slice capacity growth

When you add an element and you need to allocate more space for it, you don't allocate space for just one element. That's very ineficient. Instead you allocate more than actually needed.

Exactly how much more is allocated depends on the implementation and is not defined in the language spec. Usually capacity is doubled but in case of Go, at least as of v1.5, it rounded up to allocated memory block. You can find link to the source code here.

Slicing past length

Slicing past length is actually supported. You can slice beyond the length of a slice but you can't slice beyond the capacity:


  Earlier we sliced s to a length shorter than its capacity. We can grow
  s to its capacity by slicing it again:
  
  A slice cannot be grown beyond its capacity. Attempting to do so will
  cause a runtime panic, just as when indexing outside the bounds of a
  slice or array. Similarly, slices cannot be re-sliced below zero to
  access earlier elements in the array.


https://blog.golang.org/go-slices-usage-and-internals

In your case underlying array has capacity of 2. You only appended one element so the other one is equal to it's zero value. When you reslice past length Go can recognize that slice already has the needed capacity. So it returns a new slice that points to the same array but with length value set to 2. Here's an example of how it works:

package main

import ""fmt""

func main() {
    var s []int
    s = append(s, 1, 2)
    fmt.Println(s, cap(s))

    s = s[:1]
    fmt.Println(s, cap(s))

    s = s[:2]
    fmt.Println(s, cap(s))
}


playground

It will print


  [1 2] 2
  [1] 2
  [1 2] 2  


You can see that even though I resliced to smaller length, second element is still preserved.
",38543825
792,38547676,"Problem is Python is interpreted, GO isn't so there's no real way to bench test speeds. Interpreted languages usually (not always have a vm component) that's where the problem lies, any test you run is being run in interpreted bounds not actual runtime bounds. Go is slightly slower than C in terms of speed and that is mostly due to it using garbage collection instead of manual memory management. That said GO compared to Python is fast because its a compiled language, the only thing lacking in GO is bug testing I stand corrected if I'm wrong.
",12574909
793,38548703,"There's a bit of confusion here about capacity and length, I think. What you are looking at when you print the slice and see zero or one elements in the slice is its length, that is, the number of values the slice actually contains. The capacity of the underlying array is generally hidden from you unless you look it up with the cap() builtin.

Under the hood, slices are actually fixed length arrays. When you run out of space in the slice, Go has to make it bigger by creating a new (longer) array, and copying all the values over from the old one. If you're adding lots of values to a slice, it would be very slow to allocate memory for the new value (and copy all the old ones over) every time, so sometimes Go assumes that you're going to append more elements and goes ahead and allocates more memory than it needs so that you don't have to copy things as often. This extra memory can be used the next time you call append, and the number of values which can be stored in the slice before it has to be expanded is called its capacity. In other words, the capacity of the slice is the length of the slices backing array, and the length of a slice is independent from the capacity.

When you append a single value to your slice Go sees that it has to allocate space for this value, so it allocates twice the amount of space that it actually needs, increasing the length by 1 and the capacity by 2.

The slice you mention is because slicing acts on the underlying array: Go lets you slice beyond the length of a slice, you just can't go beyond its capacity (the length of the underlying array). For example, lets try a few things on a simple nil slice:

var s []int
fmt.Println(len(s), cap(s)) // Prints `0 0` because this is a nil slice
s = append(s, 1)
fmt.Println(len(s), cap(s)) // Prints `1 2`
fmt.Println(s[0:2])         // Prints `[1 0]` (only the first value is part of the slice, the second position in the underlying array is a zero value that is waiting to be used when the slices length grows)
fmt.Println(s[0:3])         // panic: slice bounds out of range (because we've exceeded the slices capacity)

",38543825
794,38556663,"I reworked the code to get the results I wanted.

// Get the karma value for nick from the database.
func getKarma(nick string, db *sql.DB) string {
    var karma int
    rows, err := db.Query(""SELECT SUM(delta) FROM karma WHERE nick = $1"", nick)
    if err != nil {
        log.Fatal(err)
    }
    defer rows.Close()
    karmaStr := fmt.Sprintf(""%s has no karma."", nick)
    if rows.Next() {
        rows.Scan(&karma)
        karmaStr = fmt.Sprintf(""Karma for %s is %d."", nick, karma)
    }
    return karmaStr
}


Tempted to submit a documentation patch of some sort to the database/sql package.
",38555568
795,38558922,"I believe your issue is that you're getting a NULL value back from the database, which go translates into nil. However, you're scanning into an integer, which has no concept of nil. One thing you can do is scan into a type that implements the sql.Scanner interface (and can handle NULL values), e.g., sql.NullInt64.

In the example code in the documentation, I'd assume they have a NOT NULL constraint on the username column. I think the reason for this is because they didn't want to lead people to believe that you have to use NULL-able types across the board.
",38555568
796,38613473,"You need to serialise the rsa.PublicKey to a []byte.  There are multiple ways of doing this, but I'd probably go with JSON.

The struct looks like this, and everthing within it is a) Public and b) Serializable with JSON.

type PublicKey struct {
    N *big.Int // modulus
    E int      // public exponent
}

",38612279
797,38616355,"If you are sending data from a Go program to another Go one (as you show in your examples), you can use the package encoding/gob https://golang.org/pkg/encoding/gob/ to serialize (Encode) an object into a slice of bytes and deserialize (Decode) the received bytes back into the Go object.  Here's an example (also https://play.golang.org/p/3bxbqGtqQY):

package main

import (
    ""bytes""
    ""crypto/rand""
    ""crypto/rsa""
    ""encoding/gob""
    ""fmt""
    ""log""
)

func main() {
    priv, _ := rsa.GenerateKey(rand.Reader, 512) // skipped error checking for brevity
    pub := priv.PublicKey
    // adapted from https://golang.org/pkg/encoding/gob/#example__basic:
    // Initialize the encoder and decoder.  Normally enc and dec would be
    // bound to network connections and the encoder and decoder would
    // run in different processes.
    var network bytes.Buffer        // Stand-in for a network connection
    enc := gob.NewEncoder(&network) // Will write to network.
    dec := gob.NewDecoder(&network) // Will read from network.
    enc.Encode(&pub)
    var pub2 = rsa.PublicKey{}
    dec.Decode(&pub2)
    if pub.N.Cmp(pub2.N) != 0 || pub.E != pub2.E {
        log.Fatal(""Public Keys at source and destination not equal"")
    }
    fmt.Printf(""OK - %#v\n"", pub2)
}


Output similar to:

OK -rsa.PublicKey{N:10881677056019504919833663670523712169444878787643568603135265932739968735275981472697621424678110007129031867528249518560683510901399549383480944574041391, E:65537}

Sending gob blobs can be faster and more efficient then doing JSON encoding especially if you are doing a lot of it, but you need to decide whether it is a significant factor for you and whether you prefer text (JSON) or binary format (gob or protobufs) for data transport.
",38612279
798,38645289,"Every array could be a slice but not every slice could be an array. If you have a fixed collection size you can get a minor performance improvement from using an array. At the very least you'll save the space occupied by the slice header.
",38645175
799,38645343,"Arrays are more efficient in saving space.  If you never update the size of the slice (i.e. start with a predefined size and never go past it) there really is not much of a performance difference.  But there is extra overhead in space, as a slice is simply a wrapper containing the array at its core. Contextually, it also improves clarity as it makes the intended use of the variable more apparent.
",38645175
800,38645895,"There is more to arrays than just the fixed length:  they are comparable, and they are values (not reference or pointer types).

There are countless advantages of arrays over slices in certain situations, all which together more than justify the existence of arrays (along with slices). Let's see them. (I'm not even counting arrays being the building blocks of slices.)



1. Being comparable means you can use arrays as keys in maps, but not slices. Yes, you could say now that why not make slices comparable then, so that this alone wouldn't justify the existence of both. Equality is not well defined on slices. FAQ: Why don't maps allow slices as keys?


  They don't implement equality because equality is not well defined on such types; there are multiple considerations involving shallow vs. deep comparison, pointer vs. value comparison, how to deal with recursive types, and so on.


2. Arrays can also give you higher compile-time safety, as the index bounds can be checked at compile time (array length must evaluate to a non-negative constant representable by a value of type int):

s := make([]int, 3)
s[3] = 3 // ""Only"" a runtime panic: runtime error: index out of range

a := [3]int{}
a[3] = 3 // Compile-time error: invalid array index 3 (out of bounds for 3-element array)


3. Also passing around or assigning array values will implicitly make a copy of the entire array, so it will be ""detached"" from the original value. If you pass a slice, it will still make a copy but just of the slice header, but the slice value (the header) will point to the same backing array. This may or may not be what you want. If you want to ""detach"" a slice from the ""original"" one, you have to explicitly copy the content e.g. with the builtin copy() function to a new slice.

a := [2]int{1, 2}
b := a
b[0] = 10 // This only affects b, a will remain {1, 2}

sa := []int{1, 2}
sb := sa
sb[0] = 10 // Affects both sb and sa


4. Also since the array length is part of the array type, arrays with different length are distinct types. On one hand this may be a ""pain in the ass"" (e.g. you write a function which takes a parameter of type [4]int, you can't use that function to take and process an array of type [5]int), but this may also be an advantage: this may be used to explicitly specify the length of the array that is expected. E.g. you want to write a function which takes an IPv4 address, it can be modeled with the type [4]byte. Now you have a compile-time guarantee that the value passed to your function will have exactly 4 bytes, no more and no less (which would be an invalid IPv4 address anyway).

5. Related to the previous, the array length may also serve a documentation purpose. A type [4]byte properly documents that IPv4 has 4 bytes. An rgb variable of type [3]byte tells there are 1 byte for each color components. In some cases it is even taken out and is available, documented separately; for example in the crypto/md5 package: md5.Sum() returns a value of type [Size]byte where md5.Size is a constant being 16: the length of an MD5 checksum.

6. They are also very useful when planning memory layout of struct types, see JimB's answer here, and this answer in greater detail and real-life example.

7. Also since slices are headers and they are (almost) always passed around as-is (without pointers), the language spec is more restrictive regarding pointers to slices than pointers to arrays. For example the spec provides multiple shorthands for operating with pointers to arrays, while the same gives compile-time error in case of slices (because it's rare to use pointers to slices, if you still want / have to do it, you have to be explicit about handling it; read more in this answer).

Such examples are:


Slicing a p pointer to array: p[low:high] is a shorthand for (*p)[low:high]. If p is a pointer to slice, this is compile-time error (spec: Slice expressions).
Indexing a p pointer to array: p[i] is a shorthand for (*p)[i]. If p is pointer to a slice, this is a compile time error (spec: Index expressions).


Example:

pa := &[2]int{1, 2}
fmt.Println(pa[1:1]) // OK
fmt.Println(pa[1])   // OK

ps := &[]int{3, 4}
println(ps[1:1]) // Error: cannot slice ps (type *[]int)
println(ps[1])   // Error: invalid operation: ps[1] (type *[]int does not support indexing)


8. Accessing (single) array elements is more efficient than accessing slice elements; as in case of slices the runtime has to go through an implicit pointer dereference. Also ""the expressions len(s) and cap(s) are constants if the type of s is an array or pointer to an array"".

May be suprising, but you can even write:

type IP [4]byte

const x = len(IP{}) // x will be 4


It's valid, and is evaluated and compile-time even though IP{} is not a constant expression so e.g. const i = IP{} would be a compile-time error! After this, it's not even surprising that the following also works:

const x2 = len((*IP)(nil)) // x2 will also be 4


Note: When ranging over a complete array vs a complete slice, there may be no performance difference at all as obviously it may be optimized so that the pointer in the slice header is only dereferenced once. For details / example, see Array vs Slice: accessing speed.



See related questions where an array can be used / makes more sense than a slice:

Why use arrays instead of slices?

Why can't Go slice be used as keys in Go maps pretty much the same way arrays can be used as keys?

Hash with key as an array type

Golang: How do I check the equality of three values elegantly?

Slicing a slice pointer passed as argument

And this is just for curiosity: a slice can contain itself while an array can't. (Actually this property makes comparison easier as you don't have to deal with recursive data structures).

Must-read blogs:

Go Slices: usage and internals

Arrays, slices (and strings): The mechanics of 'append'
",38645175
801,38645964,"Arrays are values, and it is often useful to have a value instead of a pointer.

Values can be compared, hence you can use arrays as map keys.

Values are always initialized, so there's you don't need to initialize, or make them like you do with a slice.

Arrays give you better control of memory layout, where as you can't allocate space directly in a struct with a slice, you can with an array:

type Foo struct {
    buf [64]byte
}


Here, a Foo value will contains a 64 byte value, rather than a slice header which needs to be separately initialized. Arrays are also used to pad structs to match alignment when interoperating with C code and to prevent false sharing for better cache performance.

Another aspect for improved performance is that you can better define memory layout than with slices, because data locality can have a very big impact on memory intensive calculations. Dereferencing a pointer can take considerable time compared to the operations being performed on the data, and copying values smaller than a cache line incurs very little cost, so performance critical code often uses arrays for that reason alone.
",38645175
802,38672052,"This is the concept which should work.

Inside the package you should declare a variable, which is exported. This variable has to be a pointer.

var myVar = 3
var MyPointer = &myVar


https://play.golang.org/p/EQDwGF7pjv

From your main package you can set the pointer to your ""global"" db or session adress.

mypackage.MyPointer = dbPointer


Then the pointer inside your package points to your dbPointer. I think this is a good way to pass a pointer into other packages.
",38669971
803,38709178,"You can ""pack"" the static files (text, images etc.) by including it into a .go file (usually automatically generated) and then compiling it into the stand-alone binary.  You can do it by using https://github.com/golang/tools/blob/master/godoc/static/makestatic.go or with https://github.com/jteeuwen/go-bindata. See http://blog.ralch.com/tutorial/golang-embedded-resources/ for more information and examples.
",38705615
804,38714480,"The latest version of goimports support -local flag. Quoting this commit message:

For example, running goimports -local example.com/ might produce

import (
    ""database/sql""
    ""io""
    ""strconv""

    ""golang.org/x/net/context""

    ""example.com/foo/bar""
    ""example.com/foo/baz""
)

",38704769
805,38810688,"The arguments to the go install command are packages, not .go files. Use these commands to specify the package by relative path.  

For the package containing the file ./src/tutorial/helloworld/hello.go:

go install ./src/tutorial/helloworld


For the package containing the file ./path/to/.go/file/hello.go:

go install ./path/to/.go/file

",38810507
806,38811255,"If you just want the content as string, then the simple solution is to use the ReadFile function from the io/ioutil package. This function returns a slice of bytes which you can easily convert to a string.

package main

import (
    ""fmt""
    ""io/ioutil""
)

func main() {
    b, err := ioutil.ReadFile(""file.txt"") // just pass the file name
    if err != nil {
        fmt.Print(err)
    }

    fmt.Println(b) // print the content as 'bytes'

    str := string(b) // convert content to a 'string'

    fmt.Println(str) // print the content as a 'string'
}

",13514184
807,38830027,"To be able to find an entity in the result of a query/filter by a property that property must have had indexing enabled (in the model definition) at the time when the entity was created and the datastore's background indexing task(s) must be completed for it.

If you enable indexing for that property after the entity was created you need to re-write the property so that the indexing tasks are triggered for it, see: https://stackoverflow.com/a/34583510/4495081.

The ""Saving search indexes"" message is a generic one printed before the operation takes place, it doesn't mean the result of the operation will be non-empty.

You don't need to worry that your index.yaml file is empty. Not all indexes need to be present in the index.yaml file, only the more complex/composite ones need to. Your filter can be matched using the built-in indexes (after the above-mentioned indexing requirements are met). From Indexes:


  There are two types of indexes:
  
  
  Built-in indexes
  
  By default, Cloud Datastore automatically predefines an index for each property of each entity kind. These single property indexes are
  suitable for simple types of queries.
  Composite indexes
  
  Composite indexes index multiple property values per indexed entity. Composite indexes support complex queries and are defined in
  an index configuration file (index.yaml).
  

",38829469
808,38839236,"Wrap your handlers with a redirector:

func wwwRedirect(h http.Handler) http.Handler {
  return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
    if host := strings.TrimPrefix(r.Host, ""www.""); host != r.Host {
        // Request host has www. prefix. Redirect to host with www. trimmed.
        u := *r.URL
        u.Host = host
        u.Scheme = ""https""
        http.Redirect(w, r, u.String(), http.StatusFound)
        return
    }
    h.ServeHTTP(w, r)
  })
}


Use the redirector like this:

log.Fatal(http.ListenAndServeTLS(addr, certFile, keyFile, wwwRedirect(handler))

",38839094
809,38842871,"The property name in the datastore is ""Email"" with capital E, not ""email"".

It's case-sensitive, must be queried with capital E:

query = datastore.NewQuery(""UserAccount"").Filter(""Email ="", ""test@example.com"")


If you would want it to be saved / retrieved with small e, you could use tags to do the mapping, e.g.:

type UserAccount struct {
    Email string `datastore:""email""`
    // other fields...
}

",38829469
810,38870609,"There are some problems:


The pipe is being closed before reading all data.  
Always check for errors
Start cmd.Start() after c  and use unbuffered channel c := make(chan struct{})




Two working sample codes:

1: Wait using channel then close the pipe after EOF using defer func() { c , like this working sample code:  

package main

import (
    ""bufio""
    ""fmt""
    ""os/exec""
)

func main() {
    cmd := exec.Command(""Streamer"")
    c := make(chan struct{})

    go run(cmd, c)

    c <- struct{}{}
    cmd.Start()

    <-c
    if err := cmd.Wait(); err != nil {
        fmt.Println(err)
    }
    fmt.Println(""done."")
}

func run(cmd *exec.Cmd, c chan struct{}) {
    defer func() { c <- struct{}{} }()
    stdout, err := cmd.StdoutPipe()
    if err != nil {
        panic(err)
    }
    <-c
    scanner := bufio.NewScanner(stdout)
    for scanner.Scan() {
        m := scanner.Text()
        fmt.Println(m)
    }
    fmt.Println(""EOF"")
}




2: Also you may Wait using sync.WaitGroup, like this working sample code:  

package main

import (
    ""bufio""
    ""fmt""
    ""os/exec""
    ""sync""
)

var wg sync.WaitGroup

func main() {
    cmd := exec.Command(""Streamer"")
    c := make(chan struct{})
    wg.Add(1)
    go func(cmd *exec.Cmd, c chan struct{}) {
        defer wg.Done()
        stdout, err := cmd.StdoutPipe()
        if err != nil {
            panic(err)
        }
        <-c
        scanner := bufio.NewScanner(stdout)
        for scanner.Scan() {
            m := scanner.Text()
            fmt.Println(m)
        }
    }(cmd, c)

    c <- struct{}{}
    cmd.Start()

    wg.Wait()
    fmt.Println(""done."")
}




And Streamer sample code (just for testing):

package main

import ""fmt""
import ""time""

func main() {
    for i := 0; i < 10; i++ {
        time.Sleep(1 * time.Second)
        fmt.Println(i, "":"", time.Now().UTC())
    }
}




And see func (c *Cmd) StdoutPipe() (io.ReadCloser, error)  Docs:  


  StdoutPipe returns a pipe that will be connected to the command's
  standard output when the command starts.
  
  Wait will close the pipe after seeing the command exit, so most
  callers need not close the pipe themselves; however, an implication is
  that it is incorrect to call Wait before all reads from the pipe have
  completed. For the same reason, it is incorrect to call Run when using
  StdoutPipe. See the example for idiomatic usage.

",38866952
811,38871065,"From godocs:


  StdoutPipe returns a pipe that will be connected to the command's
  standard output when the command starts.
  
  Wait will close the pipe after seeing the command exit, so most
  callers need not close the pipe themselves; however, an implication is
  that it is incorrect to call Wait before all reads from the pipe have
  completed.


You are calling Wait() immediately after starting the command. So the pipe gets closed as soon as the command completes, before making sure you have read all the data from the pipe. Try moving Wait() to your go routine after the scan loop.

go func(cmd *exec.Cmd, c chan int) {
    stdout, _ := cmd.StdoutPipe()

    <-c

    scanner := bufio.NewScanner(stdout)
    for scanner.Scan() {
        m := scanner.Text()
        fmt.Println(m)
    }

    cmd.Wait()
    c <- 1
}(cmd, c)

cmd.Start()
c <- 1

// This is here so we don't exit the program early,
<-c


There's also a simpler way to do things, which is to just assign os.stdout as the cmd's stdout, causing the command to directly write to the os.stdout:

cmd := exec.Command(""some"", ""command"")
cmd.Stdout = os.Stdout
cmd.Run()

",38866952
812,38877591,"Try this simplification:

var t time.Time
if fi, err2 := os.Stat(finalFilePath); err2 == nil {
    t := fi.ModTime()
}


and later:

params := &s3.GetObjectInput{Bucket: aws.String(bucket),
    Key:    aws.String(filename),
    IfModifiedSince: aws.Time(t)}


...as suggested in the example code here: https://github.com/aws/aws-sdk-go/blob/f1e26250235022af782521266389e4b2ae2945e4/service/s3/examples_test.go#L975

At first I thought it was an erasure issue, but after testing, I find that the time.Time value that t was pointing to escapes the block (which honestly surprised me). Maybe there's some other bug happening in between the two, but I would assume that since their tests are passing, this should work.
",38809347
813,38885186,"Capitalize the function within your package that you want other functions to read:

func Add(x, y int) int {
      return x + y
}


then call it in hello.go like this:

x := math.Add(6 + 5)


Keeping them lower case does have its purpose, particularly if you want to protect it from inadvertent use outside the package.
",32932199
814,38898596,"Use this:

""$center"": []interface{}{j.Location.Coordinates, 5000}


This line is probably an error:

 time.Now().Unix() * 1000


Did you want + 1000?
",38892436
815,38923623,"The goroutines are only working on copies of the slice headers, the underlying arrays are the same. To make a copy of a slice, you need to use copy (or append to a different slice).

buf_Seq = append(buf_Seq, line)
bufCopy := make([]string, len(buf_Seq))
copy(bufCopy, buf_Seq)


You can then safely pass bufCopy to the goroutines, or simply use it directly in the closure.
",38923237
816,38923640,"The data race exists because slices are reference types in Go. They are generally passed by value, but being reference types, any changes made to the one value is reflected in another. Consider:

func f(xs []string) {
    xs[0] = ""changed_in_f""
}

func main() {
    xs := []string{""set_in_ main"", ""asd""}
    fmt.Println(""Before call:"", xs)
    f(xs)
    fmt.Println(""After call:"", xs)

    var ys []string
    ys = xs
    ys[0] = ""changed_through_ys""
    fmt.Println(""After ys:"", xs)

}


This prints:

Before call: [set_in_main asd]
After call: [changed_in_f asd]
After ys: [changed_through_ys asd]


This happens because all three slices share the same underlying array in memory. More details here.

This is what might be happening when you pass buf_Seq to search_gene2. A new slice value is passed to each call, however, each slice value may be referring to the same underlying array, causing potential race condition (call to append may change the underlying array of a slice).

To solve the problem, try this in your main:

bufCopy := make([]string, len(buf_Seq))
// make a copy of buf_Seq in an entirely separate slice
copy(buffCopy, buf_Seq)
go func(genes, buf_Seq []string) {
        defer wg.Done()
        queue <- search_gene2( genes, bufCopy)
    }(genes, buf_Seq)
}

",38923237
817,38923846,"The slices are indeed copies, but slices themselves are reference types.  A slice, fundamentally, is a 3-word structure.  It contains a pointer to the start of an underlying array, an integer denoting the current number of elements in the slice, and another integer denoting the capacity of the underlying array.  When you pass a slice into a function, a copy is made of this slice ""header"" structure, but the header still refers to the same underlying array as the header that was passed in.

This means any changes you make to the slice header itself, like sub-slicing it, appending to it enough to trigger a resize (and thus a reallocation to a new location, with a new start pointer), etc will only be reflected in the slice header inside that function.  Any changes to the underlying data itself, however, will be reflected even in the slice outside the function (unless you triggered a reallocation due by growing the slice past capacity).

Example: https://play.golang.org/p/a2y5eGulXW
",38923237
818,38927101,"I think this is the idiomatic Go (for this job):
A code is worth a thousand comments:

genes = readGenes(""lists/genes.csv"") // read the gene list
n := runtime.NumCPU()                // the number of goroutines
wg.Add(n + 1)
go scan() // read the ""fasta/sequences.tsv""
for i := 0; i < n; i++ {
    go search()
}
go WaitClose()
slice := []string{}
for t := range queue {
    slice = append(slice, t)
}
fmt.Println(slice)


scan() reads the ""fasta/sequences.tsv"" to this channel: var ch = make(chan string, 100) concurrently and  search() is CPU intensive goroutine so for performance reason the number of goroutines limited to NumCPU.

Try this working sample code (simulated and tested):

package main

import (
    ""bufio""
    ""fmt""
    //""os""
    ""runtime""
    ""strings""
    ""sync""
    //""github.com/mathpl/golang-pkg-pcre/src/pkg/pcre""
)

func main() {
    genes = readGenes(""lists/genes.csv"") // read the gene list
    n := runtime.NumCPU()                // the number of goroutines
    wg.Add(n + 1)
    go scan() // read the ""fasta/sequences.tsv""
    for i := 0; i < n; i++ {
        go search()
    }
    go WaitClose()
    slice := []string{}
    for t := range queue {
        slice = append(slice, t)
    }
    fmt.Println(slice)
}

var wg sync.WaitGroup
var genes []string
var ch = make(chan string, 100)
var queue = make(chan string, 100)

func scan() {
    defer wg.Done()
    defer close(ch)
    scanner := bufio.NewScanner(strings.NewReader(strings.Join([]string{""A2"", ""B2"", ""C2"", ""D2"", ""E2"", ""F2"", ""G2"", ""H2"", ""I2""}, ""\n"")))
    /*f, err := os.Open(""fasta/sequences.tsv"")
    if err != nil {
        panic(err)
    }
    defer f.Close()
     scanner := bufio.NewScanner(f)*/
    for scanner.Scan() {
        ch <- scanner.Text()
    }
}

func match(pattern, seq string) bool {
    //return pcre.MustCompile(pattern, 0).MatcherString(seq, 0).Matches()
    return pattern[0] == seq[0]
}

func search() {
    defer wg.Done()
    for seq := range ch {
        for _, gene := range genes {
            if match(gene, seq) {
                queue <- seq
                break
            }
        }
    }
}

func WaitClose() {
    wg.Wait()
    close(queue)
}

// function read a list of genes and return a slice of gene names.
func readGenes(filename string) []string {
    return []string{""A1"", ""B1"", ""C1"", ""D1"", ""E1"", ""F1"", ""G1"", ""H1"", ""I1""}
    /*var genes []string // slice of genes names
    f, err := os.Open(filename)
    if err != nil {
        panic(err)
    }
    defer f.Close()
    scanner := bufio.NewScanner(f)
    for scanner.Scan() {
        line := scanner.Text()
        genes = append(genes, line)
    }
    return genes*/
}


Output:  

[A2 B2 C2 D2 E2 F2 G2 H2 I2]


I hope this could help for your real case (comments switched in that code, not tested):

package main

import (
    ""bufio""
    ""fmt""
    ""os""
    ""runtime""
    //""strings""
    ""sync""

    ""github.com/mathpl/golang-pkg-pcre/src/pkg/pcre""
    //pcre ""regexp""
)

func main() {
    genes = readGenes(""lists/genes.csv"") // read the gene list
    n := runtime.NumCPU()                // the number of goroutines
    wg.Add(n + 1)
    go scan() // read the ""fasta/sequences.tsv""
    for i := 0; i < n; i++ {
        go search()
    }
    go WaitClose()
    slice := []string{}
    for t := range queue {
        slice = append(slice, t)
    }
    fmt.Println(slice)
}

var wg sync.WaitGroup
var genes []string
var ch = make(chan string, 100)
var queue = make(chan string, 100)

func scan() {
    defer wg.Done()
    defer close(ch)
    //scanner := bufio.NewScanner(strings.NewReader(strings.Join([]string{""A2"", ""B2"", ""C2"", ""D2"", ""E2"", ""F2"", ""G2"", ""H2"", ""I2""}, ""\n"")))
    f, err := os.Open(""fasta/sequences.tsv"")
    if err != nil {
        panic(err)
    }
    defer f.Close()
    scanner := bufio.NewScanner(f)
    for scanner.Scan() {
        ch <- scanner.Text()
    }
}

func match(pattern, seq string) bool {
    return pcre.MustCompile(pattern, 0).MatcherString(seq, 0).Matches()
    //return pattern[0] == seq[0]
    //return pcre.MustCompile(pattern).Match([]byte(seq))
}

func search() {
    defer wg.Done()
    for seq := range ch {
        for _, gene := range genes {
            if match(gene, seq) {
                queue <- seq
                break
            }
        }
    }
}

func WaitClose() {
    wg.Wait()
    close(queue)
}

// function read a list of genes and return a slice of gene names.
func readGenes(filename string) []string {
    //return []string{""A1"", ""B1"", ""C1"", ""D1"", ""E1"", ""F1"", ""G1"", ""H1"", ""I1""}
    var genes []string // slice of genes names
    f, err := os.Open(filename)
    if err != nil {
        panic(err)
    }
    defer f.Close()
    scanner := bufio.NewScanner(f)
    for scanner.Scan() {
        line := scanner.Text()
        genes = append(genes, line)
    }
    return genes
}




problems of your code:
1- in read_genes(filename string) []string you should check for errors:  

f, err := os.Open(filename)
if err!=nil{
    panic(err)
}


2- in read_genes(filename string) []string Close Opened file:

defer f.Close()


3- Afterfilename := ""fasta/sequences.tsv"" you should check for errors:  

f, err := os.Open(filename)
if err!=nil{
    panic(err)
}


4-  Afterfilename := ""fasta/sequences.tsv"" Close Opened file:

defer f.Close()


5- Inside for scanner.Scan() { if this file fasta/sequences.tsv does not contain multiples of 100 lines if n == read_buff { will not succeeds for last slice and you will miss it.

6- How many CPU cores do you have? You should limit the number of goroutines.
7- your main question:
I made a Minimal, Complete, and Verifiable example (still problem 5 exists):

package main

import (
    ""bufio""
    ""fmt""
    ""strings""
    ""sync""
)

func match(pattern, str string) bool {
    return pattern[0] == str[0]
}
func search_gene2(genes, seqs []string) (res []string) {
    for _, r := range seqs {
        for _, i := range genes {
            if match(i, r) {
                res = append(res, r) // is the gene matches the gene name is append to res
                break
            }
        }
    }
    return
}

func main() {
    read_buff := 2 // the number of sequences analysed by one goroutine
    var wg sync.WaitGroup
    queue := make(chan []string, read_buff)
    genes := []string{""A1"", ""B1"", ""C1"", ""D1"", ""E1"", ""F1"", ""G1"", ""H1"", ""I1""}
    sequences := strings.Join([]string{""A2"", ""B2"", ""C2"", ""D2"", ""E2"", ""F2"", ""G2"", ""H2"", ""I2""}, ""\n"")
    scanner := bufio.NewScanner(strings.NewReader(sequences))
    buf_Seq := make([]string, 0, read_buff)
    for n := 1; scanner.Scan(); n++ {
        line := scanner.Text()
        buf_Seq = append(buf_Seq, line) // store the sequences into buf_Seq
        if n == read_buff {             // when the read buffer contains 100 sequences one goroutine analyses them
            wg.Add(1)
            temp := make([]string, n)
            copy(temp, buf_Seq)
            buf_Seq = buf_Seq[:0] // reset buf_Seq
            n = 0                 // reset the sequences counter
            go func(genes, Seq []string) {
                defer wg.Done()
                fmt.Println(Seq)
                queue <- search_gene2(genes, Seq)
            }(genes, temp)
        }
    }
    go func() {
        wg.Wait()
        close(queue)
    }()
    slice := []string{}
    for t := range queue {
        slice = append(slice, t...)
    }
    fmt.Println(slice)
}


output (5: I2 ?):

[A2 B2]
[C2 D2]
[E2 F2]
[G2 H2]
[A2 B2 C2 D2 E2 F2 G2 H2]


here is the solution to your main question (make a new slice and copy all data ):

temp := make([]string, n)
copy(temp, buf_Seq)
buf_Seq = buf_Seq[:0] // reset buf_Seq
n = 0                 // reset the sequences counter
go func(genes, Seq []string) {
    defer wg.Done()
    fmt.Println(Seq)
    queue <- search_gene2(genes, Seq)
}(genes, temp)


cause of this:
    Found 1 data race(s)
    exit status 66

    line 71 is : copy(bufCopy, buf_Seq)
    line 63 is : buf_Seq = append(buf_Seq, line)
    line 73 is :}(genes, buf_Seq)


As other answers said: you shared same underlying array of slice with all goroutines.

I hope this helps.
",38923237
819,38940489,"Yes, You do need to have all dependencies into your repository. 

In fact when you run godep save ./... and you are using go 1.5 or greater, Godep will automatically put dependencies in a directory named vendor (inside root directory of your repo). You need to commit both Godep and vendor directory to your repository.

On side note while adding vendor directory use -f flag to add all files in it. It is needed as some files/directory might not be committed depending on your gitignore file and that will cause build failure in heroku. As a standard practice you can exeute following command to after adding dependencies using godep.


  git add -f vendor/ Godep/
  
  git commit -a -m ""Vendorizing dependencies""

",38933957
820,38958767,"I do not know which proto generation package you are using, but with github.com/golang/protobuf/proto you also get the reverse mapping of enums.

Example xyz.pb.go generated file:

type TimeInterval int32

const (
    TimeInterval_TI_UNKNOWN TimeInterval = 0
    TimeInterval_TI_HOUR    TimeInterval = 1
    TimeInterval_TI_DAY     TimeInterval = 2
    TimeInterval_TI_WEEK    TimeInterval = 3
    TimeInterval_TI_MONTH   TimeInterval = 4
    TimeInterval_TI_QUARTER TimeInterval = 5
    TimeInterval_TI_YEAR    TimeInterval = 6
)

var TimeInterval_name = map[int32]string{
    0: ""TI_UNKNOWN"",
    1: ""TI_HOUR"",
    2: ""TI_DAY"",
    3: ""TI_WEEK"",
    4: ""TI_MONTH"",
    5: ""TI_QUARTER"",
    6: ""TI_YEAR"",
}
var TimeInterval_value = map[string]int32{
    ""TI_UNKNOWN"": 0,
    ""TI_HOUR"":    1,
    ""TI_DAY"":     2,
    ""TI_WEEK"":    3,
    ""TI_MONTH"":   4,
    ""TI_QUARTER"": 5,
    ""TI_YEAR"":    6,
}

func (x TimeInterval) String() string {
    return proto.EnumName(TimeInterval_name, int32(x))
}
func (TimeInterval) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }


So with this you could test for existence in the following manner:

if _, found := TimeInterval_name[testinputint]; found{
    //all ok
} else {
   //not a value for this enum
}

",38957169
821,38966338,"Please see this oracle blog post. Appengine runs JDK7 and it supports TLSv1.2 but the default protocol is TLSV1

So it first tries to make connection in v1 and if it doesnt support try the other protocols v1.1 and then v1.2 

As far as I know you cannot pass {-Dhttps.protocols=TLSv1.2} to GAE but you may be able to set it through code
{System.setProperty(""https.protocols"", ""TLSv1.2"");}
",38942171
822,39028462,"Change the nested line of your main function from:

fmt.Errorf(""Error: %v"", err)


To:

fmt.Printf(""Error: %v"", err)


Notice that the ""Errorf"" function doesn't print anything to stdout. It creates an error by formatting the text and arguments you provide and simply returns that error. What you really want is ""fmt.Printf"".
",39027998
823,39059763,"From Go net/http documentation:


  For control over proxies, TLS configuration, keep-alives, compression, and other settings, create a Transport:


tr := &http.Transport{
    TLSClientConfig:    &tls.Config{...},
    DisableCompression: true,
}
client := &http.Client{Transport: tr}


From the appengine documentation it appears you can use the net/http package as usual with a few tweaks.
",38942171
824,39130940,"You have some options:
1-  Using runtime type switch: 

package main

import (
    ""fmt""
)

func main() {
    fmt.Println(Less(1, 2))       // true
    fmt.Println(Less(""AB"", ""AC"")) // true
}

func Less(a, b interface{}) bool {
    switch v := a.(type) {
    case int:
        w := b.(int)
        return v < w
    case string:
        w := b.(string)
        return v < w

    }
    return false
}


then replace } else if cur.data  with 
} else if Less(cur.data , data) {



2- Using Comparer interface:

package main

import (
    ""fmt""
)

type Comparer interface {
    // Less reports whether the element  is less than b
    Less(b interface{}) bool
}

func main() {
    a, b := Int(1), Int(2)
    fmt.Println(a.Less(b)) // true

    c, d := St(""A""), St(""B"")
    fmt.Println(c.Less(d)) // true
}

type Int int

func (t Int) Less(b interface{}) bool {
    if v, ok := b.(Int); ok {
        return int(t) < int(v)
    }
    return false
}

type St string

func (t St) Less(b interface{}) bool {
    if v, ok := b.(St); ok {
        return string(t) < string(v)
    }
    return false
}




3- Using reflect
",39130593
825,39132056,"You may use one func Save(d interface{}) like this:

package main

import (
    ""encoding/json""
    ""fmt""
)

type User struct {
    ID   int
    Name string
}

type Admin struct {
    User
    Level int
}

func main() {
    Save(User{})
    Save(Admin{})
}

func Save(d interface{}) {
    body, err := json.Marshal(d)
    if err != nil {
        panic(err)
    }
    st := string(body)
    fmt.Println(st)
}


output:

{""ID"":0,""Name"":""""}
{""ID"":0,""Name"":"""",""Level"":0}




for your case, use this one function for all types:

func Save(i interface{}, id int) {
    data, err := json.Marshal(i)
    check(err)
    if id == 0 {
        _, err = app.DB.Exec(`INSERT INTO users(data) VALUES ($1) `, string(data))
    } else {
        _, err = app.DB.Exec(`UPDATE users SET data = $1 WHERE id=$2`, string(data), id)
    }
    check(err)
}


And call it like this:

u := User{}
a := Admin{}

Save(u, u.ID)
Save(a, a.ID)




And Yes, this is even simplifies call to Save to one parameter:

package main

import (
    ""encoding/json""
    ""fmt""
)

type Model interface {
    ID() int
    setID(int)
}

type User struct {
    Id   int
    Name string
}

func (t User) ID() int      { return t.Id }
func (t User) setID(id int) { t.Id = id }

type Admin struct {
    User
    Level int
}

func main() {
    Save(User{})
    Save(Admin{})
}

func Save(d Model) {
    body, err := json.Marshal(d)
    if err != nil {
        panic(err)
    }
    st := string(body)
    fmt.Println(st)

    fmt.Println(""ID is "", d.ID())
}


output:

{""Id"":0,""Name"":""""}
ID is  0
{""Id"":0,""Name"":"""",""Level"":0}
ID is  0




Now You may use this one function for all types:

func Save(i Model) {
    data, err := json.Marshal(i)
    check(err)
    id := i.ID()
    if id == 0 {
        _, err = app.DB.Exec(`INSERT INTO users(data) VALUES ($1) `, string(data))
    } else {
        _, err = app.DB.Exec(`UPDATE users SET data = $1 WHERE id=$2`, string(data), id)
    }
    check(err)
}


And call it like this:

u := User{}
a := Admin{}

Save(u)
Save(a)




Effective Go:


  Getters
  
  Go doesn't provide automatic support for getters and setters. There's
  nothing wrong with providing getters and setters yourself, and it's
  often appropriate to do so, but it's neither idiomatic nor necessary
  to put Get into the getter's name. If you have a field called owner
  (lower case, unexported), the getter method should be called Owner
  (upper case, exported), not GetOwner. The use of upper-case names for
  export provides the hook to discriminate the field from the method. A
  setter function, if needed, will likely be called SetOwner. Both names
  read well in practice:

owner := obj.Owner()
if owner != user {
    obj.SetOwner(user)
}


",39131886
826,39136399,"I've done this using the runtime.Stack function. Its output is equivalent to what you get from a panic(), but without halting the program. You can set up a signal handler to dump the stack to a file/stdout, or start a goroutine to dump the stack at regular intervals, if you prefer.

You could also check out the runtime/debug package.
",39132629
827,39143263,"Avoid using unsafe whenever possible. The above task can be done using reflection (reflect package):

var v interface{} = Big{Small{1}, 2}

rf := reflect.ValueOf(v)
s := rf.FieldByName(""Small"").Interface()

fmt.Printf(""%#v\n"", s)
fmt.Printf(""%#v\n"", s.(Small).val)


Output (try it on the Go Playground):

main.Small{val:1}
1


Notes:

This works for any field, not just the first one (at ""offset 0""). This also works for named fields too, not just for embedded fields. This doesn't work for unexported fields though.
",39143091
828,39143331,"type Small struct {
    val int
}

type Big struct {
    Small
    bigval int
}

func main() {
    var v = Big{Small{10},200}
    print(v.val)
}

",39143091
829,39143823,"While answer with reflection is working but it has performance penalties and is not idiomatic to Go.

I believe you should use interface. Like this 

https://play.golang.org/p/OG1MPHjDlQ

package main

import (
    ""fmt""
)

type MySmall interface {
    SmallVal() int
}

type Small struct {
    val int
}

func (v Small) SmallVal() int {
    return v.val
}

type Big struct {
    Small
    bigval int
}

func main() {
    var v interface{} = Big{Small{val: 3}, 4}
    fmt.Printf(""Small val: %v"", v.(MySmall).SmallVal())
}


Output:

Small val: 3

",39143091
830,39149407,"With help from this question: How to parse http headers in Go the following attempt with http.ReadRequest() works...

if tcpLayer := packet.Layer(layers.LayerTypeTCP); tcpLayer != nil {
   tcp, _ := tcpLayer.(*layers.TCP)
   if len(tcp.Payload) != 0 {
      reader := bufio.NewReader(bytes.NewReader(tcp.Payload))
      httpReq, err := http.ReadRequest(reader)
      .
      ..
      ...
  }
}

",39082404
831,39151726,"Because echo appends a \n character. Try doing echo -n:

echo -n ""sha1 this string"" | gsha256sum
fceab3bb749b11a43b89f21ccd28e3f5d8b38d5b23eeea960fc169ab482ee2cd  -

",39151674
832,39154131,"I use the first approach. Here its a gulp task the build go code. If the production flag is set, it runs GOOS=linux CGO_ENABLED=0 go build instead  go build. So the binary will work inside a docker container

gulp.task('server:build', function () {
    var build;

    let options = {
        env: {
            'PATH': process.env.PATH,
            'GOPATH': process.env.GOPATH
        }
    }

    if (argv.prod) {
        options.env['GOOS'] = 'linux'
        options.env['CGO_ENABLED'] = '0'
        console.log(""Compiling go binarie to run inside Docker container"")
    }

    var output = argv.prod ? conf.paths.build + '/prod/bin' : conf.paths.build + '/dev/bin';
    build = child.spawnSync('go', ['build', '-o', output, ""src/backend/main.go""], options);
    if (build.stderr.length) {
        var lines = build.stderr.toString()
            .split('\n').filter(function(line) {
                return line.length
            });
        for (var l in lines)
            util.log(util.colors.red(
                'Error (go install): ' + lines[l]
            ));
        notifier.notify({
            title: 'Error (go install)',
            message: lines
        });
    }
    return build;
});

",35997995
833,39161250,"You can't because in Go types do not have constructors.

Instead, have either an explicit initializer function (or method on the pointer receiver) or a constructor/factory function (these are conventionally called New so yours would be NewFileData) which would return an initialized value of your type.

All-in-all, I have a feeling this looks like an XY problem. From your question, it appears you want to have a default value on one of your fields if nothing was unmarshaled.
If so, just post-process the values of this type unmarshaled from JSON and if nothing was unmarshaled to Encodning set it to whatever default you want.

Alternatively you might consider this approach:


Have a custom type for your field.

Something like type EncodingMethod string should do.
Have a custom JSON unmarshaling method for this type which would do whatever handling it wants.

",39160807
834,39161269,"Since your FileData isn't too complex, you can easily make use of json.Unmarshaler interface. Declare Encoding as a separate type and set the default value in the unmarshal method:

type FileData struct {
    UID string `json:""uid""`                 
    Size int `json:""size""`
    Content string `json:content`
    Encoding Encoding `json:encoding` // declared as a custom type
    User string `json:""user""`
}

type Encoding string

// implement the Unmarshaler interface on Encoding
func (e *Encoding) UnmarshalJSON(b []byte) error {
    var s string
    if err := json.Unmarshal(b, &s); err != nil {
        return err
    }
    if s == """" {
        *e = Encoding(""base64"")
    } else {
        *e = Encoding(s)
    }
    return nil
}


Now when you encode a json with empty Encoding value, it'll be set to base64:

var data1 = []byte(`{""uid"": ""UID"", ""size"": 10, ""content"": ""CONTENT"", ""encoding"": ""ASCII"", ""user"": ""qwe""}`)
var data2 = []byte(`{""uid"": ""UID"", ""size"": 10, ""content"": ""CONTENT"", ""encoding"": """", ""user"": ""qwe""}`)

func main() {
    fmt.Println(""Hello, playground"")
    f := FileData{}
    if e := json.Unmarshal(data1, &f); e != nil {
        fmt.Println(""Error:"", e)
    }
    fmt.Println(f, f.Encoding)
    if e := json.Unmarshal(data2, &f); e != nil {
        fmt.Println(""Error:"", e)
    }
    fmt.Println(f, f.Encoding)
}


Output:

{UID 10 CONTENT ASCII qwe} ASCII
{UID 10 CONTENT base64 qwe} base64


Working code: https://play.golang.org/p/y5_wBgHGJk
",39160807
835,39161308,"You can set default value when you init your 'FileData'
See my example: https://play.golang.org/p/QXwDG7_mul
Page int has default value 33


package main

import (
    ""encoding/json""
    ""fmt""
)

type Response2 struct {
    Page   int      `json:""page""`
    Fruits []string `json:""fruits""`
}

func main() {
    str := `{""fruits"": [""apple"", ""peach""]}`
    res := Response2{Page: 33 /*Default value*/}
    json.Unmarshal([]byte(str), &res)
    fmt.Println(res)
}

",39160807
836,39166548,"Goroutine deadlock analysis is handled well using the trace command.

First, you need to get data to run a trace against, which you want at any point. You can get this by using the pprof package or the trace package.

https://golang.org/pkg/net/http/pprof/
https://golang.org/pkg/runtime/trace/

The pprof package will add its HTTP handlers to a web server and let you collect trace data while the app is running, while the trace package lets you write out a trace to a stream (e.g. a file), but I haven't tried that myself.

Once you've collected trace data, you can run the trace command against the data you've collected to produce a web view of the state:

https://golang.org/cmd/trace/

There's an example output here:

https://talks.golang.org/2015/dynamic-tools.slide#30
",39132629
837,39185719,"Here's a simple function using regex:

import (
    ""strconv""
    ""regexp""
)

func formatCommas(num int) string {
    str := strconv.Itoa(num)
    re := regexp.MustCompile(""(\\d+)(\\d{3})"")
    for i := 0; i < (len(str) - 1) / 3; i++ {
        str = re.ReplaceAllString(str, ""$1,$2"")
    }
    return str
}


Example:

fmt.Println(formatCommas(1000))
fmt.Println(formatCommas(-1000000000))


Output:

1,000
-1,000,000,000


https://play.golang.org/p/0v6wOzxJ1H
",13020308
838,39192294,"You can have one file called for example MainController where you can make functions for accessing database, sessions, config files and so on. All  you have to do really from there is to say something like this for example (inherit stuff from some other controller):

//MyController.go
type App struct {
    MainController
}

func (c Application) MyControllerFunc() returnTypeHere(http.Response for example) {

    //c.getDatabaseName is function from MainController that reads information from some plain text file or json file or similar
    someInfoFromConfigFile = c.getDatabaseName()
    var str []string
    str = append(str,  someInfoFromConfigFile)

    //RenderJson is function that render http response as json (Content type plain/json)
    return c.RenderJson(str)
}


But if you need mvc I suggest that you use some framework (Revel for example). I am using it all the time. It gives you that basic mvc functionality if you like and all other stuff is really up to you.
You keep you business logic in some helpers, models in models file etc.

You can check Revel main controller structure here:
https://github.com/revel/revel/blob/master/controller.go
",39189731
839,39229876,"Old question, but I figured this could help somebody down the road. I'm on Windows (yes I know this was for Linux) and was running Hugo outside the created directory where hugo.exe lives.

Note that the hugo.exe doesn't have to live in c:\hugo\bin as per the example below


Download Hugo (64 or 32-bit) from https://github.com/spf13/hugo/releases 
Create a folder on your C:\ called Hugo. 
Create another folder inside of C:\Hugo called bin
Unzip the file downloaded from the HUGO URL into the bin folder
Open cmd.exe to add the path to HUGO to the windows PATH environment variables. Type set PATH=%PATH%;C:\Hugo\bin


To verify that hugo is installed globally, under any directory in command prompt type where hugo and it'll tell you where it is (in our case, c:\hugo\bin\hugo.exe)

From there you should be able to run your Hugo sites from any repository on your HD.
",25595011
840,39240034,"The snippet of code defines one variable v with type *account.CreateAccountRequest.   The second type assertion attempts to assign a *account.PostAccountRequest to the variable v.  This is an error.

The code will compile if you create a second variable v:

v, ok := req.(*account.CreateAccountRequest)                                                         
if ok {
    if v, ok := req.(*account.PostAccountRequest); ok { // note "":""
      panic(ok)
  }
}


... but does not make sense because v can only be one of the struct types.

Perhaps you are looking for something like this:

var name, token string
switch v := v.(type) {
case *account.CreateAccountRequest:
 // v is a *account.CreateAccountRequest in this branch of the switch
 name = v.Name
 token = v.Token
case *account.PostAccountRequest:
 // v is a *account.PostAccountRequest in this branch of the switch
 name = v.Name
 token = v.Token
default:
 // panic?
}

",39239977
841,39260680,"Go's reference layout uses -7 hours as the timezone offset, but you used +7 hours:

package main

import (
    ""fmt""
    ""time""
)

func main() {
    date := ""2016-07-08T08:34:24+00:00""
    d, err := time.Parse(""2006-01-02T15:04:05-07:00"", date)
    if err == nil {
        fmt.Println(d)
    } else {
        fmt.Println(err)
    }
}


https://play.golang.org/p/FNzx57R2jy
",39260647
842,39345982,"Wow I just have the wrong type in this line:

parsed := TimeWithoutZone{}


must be

parsed := TimeTestObj{}


...
",39345921
843,39350291,"That's not how you do regex with mgo. You must use bson.RegEx. Try this:

bson.M{""$match"": bson.M{""wordname"": bson.M{""$in"": []bson.RegEx{{""^how$"", ""i""}}}}}
",39349612
844,39383654,"you can do something like this

    majorCat := body[""categorySlug""]
    category := body[""category""]
    subCategory := body[""subCategory""]
    brandId, err := strconv.Atoi(body[""brandId""])
    if err != nil {
        log.Println(err)
    }
    result := database.GetMappedFields(""Brands"", bson.M{""brandId"": brandId}, bson.M{""category"": 1, ""_id"": 0})
    internalObj := result[0][""category""].(map[string]interface{})
    finalValue := internalObj[""television_warrantyPeriod""]
    if category != """" {
        for _, v := range internalObj[majorCat].([]interface{}) {
            subObj := v.(map[string]interface{})
            if subObj[""cat""] == category {
                finalValue = subObj[""warrantyPeriod""]
                if subCategory != """" {
                    minorObj := subObj[""subCategory""].([]interface{})
                    for _, iter := range minorObj {
                        kevVal := iter.(map[string]interface{})
                        if kevVal[""subCat""] == subCategory {
                            finalValue = kevVal[""warrantyPeriod""]
                        }
                    }
                }
            }
        }
    }


Hopefully this will do dynamically or you can create a struct so that it can directly be decoded into that cheers
",39364133
845,39442001,"
You describe how http protocol works, means request-response. If that all you need you may feel good with just keep-alive connections. Websocket is async in nature, messages aren't assume responses. Use-case is server-send-events for example.
In Go server uses fire-and-forget strategy. It accepts connection, spawns goroutine to handle it, forgets it and listens for a new. Spawned goroutine upgrades connection to websocket and then serves client itself without any intermediary.

",39438422
846,39527767,"With slice value type

map is a good choice if you need fast lookup, but since you want to store multiple values for the same key, that warrants for a slice as the value type:

m := map[int][]interface{}{}
m[1] = append(m[1], ""one"")
m[2] = append(m[2], ""two"")
m[1] = append(m[1], ""three"")
fmt.Println(m[1])


Output (try it on the Go Playground):

[one three]


Note that using this map is a little less convenient, as when you want to add a new value you don't (can't) just assign it but you have to append to the existing slice associated with the key, and you have to assign back the (potentially) new slice.

To ease this ""pain"", you may create your own type and provide helper methods to support different operations on the map. This is also true for the subsequent alternatives, so being a little more verbose does not necessarily mean you have to struggle with it.

With pointer to slice value type

Note that you could avoid having to reassign the new slice if you would store pointers in the map, for example:

m := map[int]*[]interface{}{}
m[1] = &[]interface{}{}
m[2] = &[]interface{}{}

s := m[1]
*s = append(*s, ""one"")
s = m[2]
*s = append(*s, ""two"")
s = m[1]
*s = append(*s, ""three"")
fmt.Println(m[1])


Output (try it on the Go Playground):

&[one three]


You still have to assign back the slice returned by append(), but not to a map key but to the pointed value (acquired from / stored in the map).

But as you can see, handling it is more hassle, but may be more efficient if you add new elements frequently. Also note that since zero value for any pointer type is nil, before you could add an element for a key, you first have to initialize it with a pointer to an existing, non-nil slice (but if you create your own type, you can hide this check and initialization).

With map as value type

Previous solutions (with slices in keys) are good, but if you also have to support frequent removal operation, they lag behind, as whenever you have to remove an element, you index the map to get the slice, and you have to search this slice and remove the element from it (and removing from a slice includes slice header update and copying subsequent elements to 1-less indices). If this slice is not sorted, this is a linear search and so it has O(n) complexity (where n is the number of elements associated with the same key, not the number of keys in the map). May not be acceptable depending on your case.

To support fast element removal, you may keep the value slices sorted, and so finding the removable element in them is O(log(n)) complexity – acceptable in most cases.

An even faster solution may use another map (as a set, see example #1 and example #2) as the value type, which will be O(1) complexity for removals too. Cool. It could look like this:

m := map[int]map[interface{}]bool{}
m[1] = map[interface{}]bool{}
m[2] = map[interface{}]bool{}

m[1][""one""] = true
m[2][""two""] = true
m[1][""three""] = true
fmt.Println(m[1])


Output (try it on the Go Playground):

map[one:true three:true]


Just as with the pointer-to-slice value type, you first have to initialize a value for a key with a non-nil map before you can actually ""add"" values to it. Hide this by creating your own type and adding methods.
",39527700
847,39537990,"If you are modifying state of m, you'll need a mutex lock and careful locking patterns.

Other than that, this will increase context switching across your thread boundries under most circumstances.

This is why we have the Go idiom:


  Do not communicate by sharing memory; 
  instead, share memory by communicating.


https://blog.golang.org/share-memory-by-communicating
",39537728
848,39538506,"I'd seen the link @eduncan911 posted but never tried to apply it. Hopefully this example helps:

package main

import (
    ""fmt""
    ""time""
)

type dummyStruct struct {
    a int
}

func (m *dummyStruct) doSomethingElse() {
    fmt.Println(m.a)
}

func doSomething(c chan int) {
    for i := 0; i < 5; i++ {
        go func() {
            x := time.Now().Unix()
            c <- int(x)
        }()
        time.Sleep(time.Second)
    }
}

func main() {
    outputs := make(chan int)
    m := &dummyStruct{}
    doSomething(outputs)
    for {
        //block until we can read from channel:
        x := <-outputs
        m.a = x
        m.doSomethingElse()
    }
}

//Output:
go run main.go
1474052448
1474052449
1474052450
1474052451
1474052452
fatal error: all goroutines are asleep - deadlock!

",39537728
849,39543478,"Go executes these commands a way that you can't use shell things, because it creates a new process.
So you should create a new shell process, for example:

package main

import (
    ""os""
    ""os/exec""
)

func main() {
    cmd := exec.Command(""sh"", ""-c"", ""value=`ls`; echo $value"")
    cmd.Stdout = os.Stdout
    err := cmd.Run()
    if err != nil {
        panic(err)
    }

}


Let me know if it's not what you want!
",39543356
850,39568490,"I think the problem is with the synchronization. Using a sleep may solve the problem. When you send a value on a channel, it should be received on the other end or else it will show deadlock error.
package main

import ""sync""
import ""time""
import ""fmt""

var wg sync.WaitGroup

func main() {
    sC := make(chan string)
    wg.Add(1)
    go getS(sC)

    cC := make(chan string)
    wg.Add(1)
    go getC(sC, cC)

    time.Sleep(1 * time.Millisecond)
    select {
    case s := <-sC:
        print(s)

    case c := <-cC:
        print(c)
    }

    wg.Wait()
}
func getS(sC chan string) {
    defer wg.Done()
    s := "" simple completed ""
    fmt.Println(s)
    sC <- s
}

func getC(sC chan string, cC chan string) {
    defer wg.Done()
    fmt.Println(""complex is not complicated\n"")
    s := <-sC
    c := s + "" more ""
    cC <- c //send complex value
}

",22882934
851,39569070,"I think Pointer is not the right way to share data with respect to goroutines, as it will decrease the performance. The best option is channels.
",39537728
852,39571341,"You can use PAM Authentication for both linux and OS X.
The main function being pam_authenticate, though you'll need to start the pam service first and end it when you're finished.

Here's an example of its basic usage.
",39560479
853,39590815,"This isn't ""part"" of any convention, but the standard library also uses MustXX() functions, so it's a good pattern to follow, if you really need this.

Examples:

Exported:


func MustCompile(str string) *Regexp
func Must(t *Template, err error) *Template
src/syscall/dll_windows.go: (on Windows)


func MustLoadDLL(name string) *DLL
func (d *DLL) MustFindProc(name string) *Proc



Unexported:


src/cmd/go/go_test.go:


func (tg *testgoData) must(err error)
func (tg *testgoData) mustExist(path string)
func (tg *testgoData) mustNotExist(path string)

src/encoding/xml/xml.go:


func (d *Decoder) mustgetc() (b byte, ok bool)

src/fmt/scan.go:


func (s *ss) mustReadRune() (r rune)

src/reflect/value.go:


func (f flag) mustBe(expected Kind)
func (f flag) mustBeExported()
func (f flag) mustBeAssignable()

src/syscall/dll_windows.go:


func (d *LazyDLL) mustLoad()
func (p *LazyProc) mustFind()


",39590458
854,39593997,"You should create and setup new transport that has TLS configuration and uses the AppEngine service. It can be done by replacing default dial function with one that is defined by AppEngine SDK (with context).

// NewClient sets up an HTTP/2 client for a certificate and context
func NewClient(ctx context.Context) (*http.Client, error) {
    config := &tls.Config{}
    transport := &http.Transport{
        TLSClientConfig: config,
        Dial: func(network, addr string) (net.Conn, error) {
            // this uses the appengine service to create the actual client
            return socket.Dial(ctx, network, addr)
        },
    }
    return &http.Client{Transport: transport}, nil
}

",38942171
855,39603015,"In case someone else comes across a similar issue, I was able to get this working by adding the JSON header to my CORS function(instead of the WriteJSON function) like this:

func CORS(h http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        w.Header().Set(""Content-Type"", ""application/json; charset=UTF-8"")
        w.Header().Set(""Access-Control-Allow-Origin"", r.Header.Get(""Origin""))
        w.Header().Set(""Access-Control-Allow-Methods"", ""POST, GET, OPTIONS, PUT, DELETE"")
        w.Header().Set(
            ""Access-Control-Allow-Headers"",
            ""Accept, Content-Type, Content-Length, Accept-Encoding, X-CSRF-Token, Authorization"",
        )
        w.Header().Set(""Access-Control-Allow-Credentials"", ""true"")

        if r.Method == ""OPTIONS"" {
            return
        }
        h.ServeHTTP(w, r)
    })
}


After I added that, the request was still not working with fetch. So, I switched tried it with axios again and it worked. Here is what the new request code looks like with axios.

export function putVisit(visit) {
  return function(dispatch) {
    return axios.put(`http://localhost:8080/api/v1/visits/${visit.visit_id}/`, visit)
      .then(response =>
        dispatch(updateVisit(response.data))
      )
      .catch(err =>
        console.log(err)
      )
  }
}

",39597109
856,39619149,"CreatorId (which, by the way should be called CreatorID) is a part of Сommon, so the only way to initialize it in struct literal is:

post1 := &Post{
    Common: Common{CreatorID: 1},
    // ...
}


Alternatively,

post1 := &Post{
    // ...
}
post1.CreatorID = 1

",39618959
857,39626592,"I wrote https://github.com/alokmenghrajani/gpgeez for exactly this purpose. It's a Go library which makes things like key creating or exporting a key as an armored string easier.

Here is the gist of it, without any error checking:

func CreateKey() *openpgp.Entity {
  key, _ := openpgp.NewEntity(name, comment, email, nil)

  for _, id := range key.Identities {
    id.SelfSignature.PreferredSymmetric = []uint8{...}    
    id.SelfSignature.PreferredHash = []uint8{...}    
    id.SelfSignature.PreferredCompression = []uint8{...}

    id.SelfSignature.SignUserId(id.UserId.Id, key.PrimaryKey, key.PrivateKey, nil)
  }

  // Self-sign the Subkeys
  for _, subkey := range key.Subkeys {
    subkey.Sig.SignKey(subkey.PublicKey, key.PrivateKey, nil)
  }

  return r
}

",29929750
858,39641551,"The Hub function creates a new client map on every call. Change the function to:

func Hub() *hubSingleton {
  if instance == nil {
    fmt.Println(""New instance created"")
    instance = &hubSingleton{}
    instance.Clients = make(map[string][]*websocket.Conn, 6)
  }
  return instance
}


If the first call to Hub is from a request handler, then there's a data race on instance.  Use a lock to fix the race:

var (
  instance *hubSingleton
  mu sync.Mutex
)

func Hub() *hubSingleton {
  mu.Lock()
  defer mu.Unlock()
  if instance == nil {
    fmt.Println(""New instance created"")
    instance = &hubSingleton{}
    instance.Clients = make(map[string][]*websocket.Conn, 6)
  }
  return instance
}


A simpler approach is to initialize the instance once before use:

var instance *hubSingleton

func newHub() *hubSingleton {
   return &hubSingleton{Clients:  make(map[string][]*websocket.Conn, 6)}
}

func main() {
   instance = newHub()
   ...
}


If Publish and Subscribe are called concurrently by handlers, then there are data races on Clients in Publish and Subscribe.
",39640284
859,39642839,"You may use sync.WaitGroup to stop the program from exiting until all the work is done.
Try it on The Go Playground:

package main

import (
    ""fmt""
    ""sync""
    ""time""
)

var (
    wg sync.WaitGroup
)

func main() {
    wg.Add(1)
    go func() {
        defer wg.Done()
        time.Sleep(2 * time.Second)
    }()

    fmt.Println(""Wait..."")
    wg.Wait()
    fmt.Println(""Done."")
}

",39642189
860,39654604,"Method expressions:


  If M is in the method set of type T, T.M is a function that is
  callable as a regular function with the same arguments as M prefixed
  by an additional argument that is the receiver of the method.

MethodExpr    = ReceiverType ""."" MethodName .
ReceiverType  = TypeName | ""("" ""*"" TypeName "")"" | ""("" ReceiverType "")"" .

  
  Consider a struct type T with two methods, Mv, whose receiver is of
  type T, and Mp, whose receiver is of type *T.

type T struct {
  a int
}
func (tv  T) Mv(a int) int         { return 0 }  // value receiver
func (tp *T) Mp(f float32) float32 { return 1 }  // pointer receiver

var t T

  
  The expression

T.Mv

  
  yields a function equivalent to Mv but with an explicit receiver as
  its first argument; it has signature

func(tv T, a int) int

  
  That function may be called normally with an explicit receiver, so
  these five invocations are equivalent:

t.Mv(7)
T.Mv(t, 7)
(T).Mv(t, 7)
f1 := T.Mv; f1(t, 7)
f2 := (T).Mv; f2(t, 7)

  
  Similarly, the expression

(*T).Mp 

  
  yields a function value representing Mp with signature

func(tp *T, f float32) float32

  
  For a method with a value receiver, one can derive a function with an
  explicit pointer receiver, so

(*T).Mv

  
  yields a function value representing Mv with signature

func(tv *T, a int) int

  
  Such a function indirects through the receiver to create a value to
  pass as the receiver to the underlying method; the method does not
  overwrite the value whose address is passed in the function call.
  
  The final case, a value-receiver function for a pointer-receiver
  method, is illegal because pointer-receiver methods are not in the
  method set of the value type.
  
  Function values derived from methods are called with function call
  syntax; the receiver is provided as the first argument to the call.
  That is, given f := T.Mv, f is invoked as f(t, 7) not t.f(7). To
  construct a function that binds the receiver, use a function literal
  or method value.
  
  It is legal to derive a function value from a method of an interface
  type. The resulting function takes an explicit receiver of that
  interface type.




And see:
Go - difference between parameter and receiver
Is there a performance penalty for passing ""this"" by value in Go methods?
differences between pointer and value slice in for-range loop   
",39654312
861,39659996,"Declare field Data in struct Sample as interface{}:

type Sample struct {
    Temppath string
    Data     interface{}
}


The type Sample then can also be used in other controllers as placeholder of any data which is going to be passed to template.
",39655389
862,39685362,"Using golang package reflect in this particular case will be the best.

reflect will get you the fields of the struct and you can iterate
over them comparing the values with the corresponding filter value.

The example is specific to the struct that you provided, but you can easily modify it to apply to all structs, again using reflection.  

Example: Go Playground

package main

import (
        ""fmt""
        ""reflect""
)

type cnts []cnt

type cnt struct {
        ID    int    `json:""Id""`
        Area  string `json:""Area""`
        State string `json:""State""`
        City  string `json:""City""`
}
// Filtering function
func filterItem(val *cnt, filter map[string]string) bool {
        item := reflect.ValueOf(val).Elem()
        itemType := item.Type()
        isValid := true
        // Iterate over the struct fileds
        for i := 0; i < item.NumField(); i++ {
                field := item.Field(i)
                filterValue, ok := filter[itemType.Field(i).Name]
                if ok {
                        // filter out  
                        if filterValue != field.Interface() {
                                isValid = false
                                break
                        }
                } 

        }

        return isValid
}

func main() {
        mycnts := cnts{
                cnt{124, ""Here"", ""South"", ""Home""},
                cnt{125, ""Here"", ""West"", ""Home""},
                cnt{126, """", ""South"", ""Home""},
                cnt{127, ""Here"", ""West"", ""NY""}}

        // my maps with filter
        mapFilter := map[string]string{""Area"": ""Here"", ""City"": ""Home""}
        fmt.Println(mapFilter)

        mycntsFilter := make(cnts, 0)
        for _, val := range mycnts {
               if filterItem(&val, mapFilter) {
                      mycntsFilter = append(mycntsFilter, val)
               }
        }
        fmt.Println(mycntsFilter)
}

",39681086
863,39689964,"Thanks to @putu comment, I was available to cross-compile using GOARM=6

env GOOS=freebsd GOARCH=arm GOARM=6 go build

",39678131
864,39759625,"Rather than redirecting it's output to the terminal read it and then you can log/print do whatever you want with it.

    stdout, err := cmd.StdoutPipe()
    b, _ := ioutil.ReadAll(stdout)
    fmt.Println(string(b))


Something like the code above would work though there are many options. I think you'll want to remove all that code you have to redirect to the terminal. 
",39758689
865,39760283,"you could store the output in a temporary buffer and write it to several places

outBuf := bytes.Buffer{}
cmd := exec.Command(cmd1, slice...)

cmd.Stdout = &outBuf

cmd.Run()

if outBuf.Len() > 0 {
    log.Printf(""%s"", outBuf.String())
    fmt.Fprintf(os.Stdout, ""%s"", outBuf.String())
}

",39758689
866,39813836,"This worked for me. I run go in 8081 and made a request from port 8080.

fmt.Printf(""r: %+v\n"", r) // Print all fields that you get in request


Output:


  r: &{Method:POST URL:/email Proto:HTTP/1.1 ProtoMajor:1 ProtoMinor:1 Header:map[User-Agent:[Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_1) AppleWebKit/602.2.11 (KHTML, like Gecko) Version/10.0.1 Safari/602.2.11] Accept-Language:[en-us] Accept-Encoding:[gzip, deflate] Connection:[keep-alive] Accept:[/] Referer:[http://127.0.0.1:8080/] Content-Length:[9] Content-Type:[application/x-www-form-urlencoded; charset=UTF-8] Origin:[http://127.0.0.1:8080]] Body:0xc420012800 ContentLength:9 TransferEncoding:[] Close:false Host:127.0.0.1:8081 Form:map[] PostForm:map[] MultipartForm: Trailer:map[] RemoteAddr:127.0.0.1:62232 RequestURI:/email TLS: Cancel: Response: ctx:0xc420017860}


The Referer and Origin have my client IP.

ip := r.Referer() // Get Referer value
fmt.Println(ip) // print ip


Output:


  http://127.0.0.1:8080/  

",17222021
867,39824758,"try this way put the html files to html folder  add html and js files to it.

func webServer() {
http.Handle(
    ""/"",
    http.StripPrefix(
        ""/"",
        http.FileServer(http.Dir(""html"")),
    ),
)
http.ListenAndServe("":9000"", nil)


}

AND BROWSE IT UNDER http://localhost:9000/
",39824698
868,39876956,"Try the following 

t := strconv.Itoa(123)

",39876914
869,39877077,"While that is perfectly fine for what you're trying to do, the encoding/binary package has much more functionality for reading and writing binary values.

You can use 

i := uint16(0x474F)

b := make([]byte, 2)
binary.BigEndian.PutUint16(b, i)
fmt.Println(string(b))
// GO


https://play.golang.org/p/IdDnnOtS2V
",39876914
870,39936881,"Here is the working code with some optimizations, try it on the The Go Playground:

package main

import (
    ""fmt""
    ""strings""
)

func main() {
    filters := []string{""aaa"", ""bbb"", ""ccc""}
    fmt.Println(compareKeywords(""a"", filters)) // """"
    fmt.Println(compareKeywords(""d"", filters)) // ""d""
}
func compareKeywords(keyword string, filters []string) string {
    for _, filter := range filters {
        if strings.Index(filter, keyword) >= 0 {
            return """"
        }
    }
    return keyword
}


output:

d




And see strings.Index Docs:

func Index(s, sep string) int



  Index returns the index of the first instance of sep in s, or -1 if sep is not present in s.

",38262155
871,39948718,"There is a new line because you're adding a new line after colons (:)

This works https://play.golang.org/p/k4lazGhE-r
Note I just start the first if right after the first colons
",39948383
872,39953936,"In your first template, you have a newline after the static text ""Let's say:"", and the 2nd line contains only the {{if}} action, and it also contains a newline, and its body ""Hello, StackOverflow!"" starts in the 3rd line. If this is rendered, there will be 2 newlines between the 2 static texts, so you'll see an empty line (as you posted).

You may use {{- if... to get rid of the first newline, so when rendered, only 1 newline gets to the output, resulting in 2 different lines but no newlines between them:

Let's say:
{{- if eq .Foo ""foo"" }}
Hello, StackOverflow!
{{- else if eq .Foo ""bar"" }}
Hello, World!
{{- end }}


Output when Foo is ""foo"":

Let's say:
Hello, StackOverflow!


Output when Foo is ""bar"":

Let's say:
Hello, World!


Try it on the Go Playground.

Note that this was added in Go 1.6: Template, and is documented at text/template: Text and Spaces.

If you use the - sign at the closing of the actions -}}, you can even remove all the newlines:

Let's say:
{{- if eq .Foo ""foo"" -}}
Hello, StackOverflow!
{{- else if eq .Foo ""bar"" -}}
Hello, World!
{{- end -}}


Output when Foo is ""foo"" and Foo is ""bar"":

Let's say:Hello, StackOverflow!
Let's say:Hello, World!


Try this one on the Go Playground.
",39948383
873,40000860,"You could create a Docker container from the distinct OS you need for your executable, and map a volume to your src directory. Run the container and make the executable from within the container.  You end up with a binary that you can run on the distinct OS.
",35997995
874,40049793,"You can manually run garbage collection:
https://golang.org/pkg/runtime/#GC

I think that would free up the memory, but as others have said, that memory will get freed eventually when the runtime's scheduled garbage collector runs.
",36571917
875,40093374,"This is an older question, but i'm diving deep into learning channels myself and found this here.

I think you just need to close the channel after your done sending on it?

Code:

func main() {
    wg.Add(1)
    c := make(chan int)
    go readFromChannel(c, time.After(time.Duration(2)*time.Second))
    time.Sleep(time.Duration(5) * time.Second)
    c <- 10
    close(c) // <- CLOSE IT HERE
    wg.Wait()
}

",37210109
876,40120128,"I had the same issue on OSX. Weird in my case was that process.env showed I am using normal bash. This was strange, because I am using zsh. The environment variables overall were wrong and did not match the environment in my terminal at all. 



Turned out I needed to set zsh as default shell. This added zsh to the list of known shells and made it the default for my user. Note that xh3b4sd is my username.

command -v zsh | sudo tee -a /etc/shells
chsh -s $(which zsh) xh3b4sd


After restarting my mac the environment in the output of process.env was correct and go-plus worked as expected.


",37083167
877,40132097,"There are quite a few errors in your code.

As a ""pre-first"", always check returned errors!

First, os.Open() opens the file in read-only mode. To be able to replace the file content on the disk,  you must open it in read-write mode instead:

file, err := os.OpenFile(fileName, os.O_RDWR, 0)


Next, when you open something that is an io.Closer (*os.File is an io.Closer), make sure you close it with the Close() method, best done as a deferred statement.

Next, *os.File is an io.Reader, but that is not the same thing as a byte slice []byte. An io.Reader may be used to read bytes into a byte slice. Use io.Copy() to copy the content from the file to the gzip stream (which will end up in the buffer).

In certain situation (where you don't close the gzip.Writer), you must call gzip.Writer.Flush() to ensure everything is flushed into its writer (which is the buffer in this case). Note that gzip.Writer.Close() also flushes, so this may seem like an unnecessary step, but must be done for example if the Close() of the gzip.Writer is also called as a deferred statemement, because then it may not be executed before we use the content of the buffer. Since in our examle we close the gzip writer after io.Copy(), that will take care of necessary flushes.

Next, to replace the content of the original file, you must seek back to the beginning of the file to replace. For that, you may use File.Seek().

Next, you may again use io.Copy() to copy the contents of the buffer (the gzipped data) to the file.

And last, since the gzipped content will most likely be shorter than the original file size, you must truncate the file at the size of the gzipped content (else uncompressed content of the original file may be left there).

Here's the complete code:

file, err := os.OpenFile(fileName, os.O_RDWR, 0)
if err != nil {
    log.Fatalf(""Error opening %q: %v"", fileName, err)
}
defer file.Close()

// Check if gzip should be applied
if *metaGzip {
    var b = &bytes.Buffer{}
    w := gzip.NewWriter(b)
    if _, err := io.Copy(w, file); err != nil {
        panic(err)
    }
    if err := w.Close(); err != nil { // This also flushes
        panic(err)
    }
    if _, err := file.Seek(0, 0); err != nil {
        panic(err)
    }
    if _, err := io.Copy(file, b); err != nil {
        panic(err)
    }
    if err := file.Truncate(int64(b.Len())); err != nil {
        panic(err)
    }
}


Note: The above code will replace the file content on your disk. If you don't want this and you just need the compressed data, you may do it like this. Note that I used a new input variable of type io.Reader, as a value of bytes.Buffer (or *bytes.Buffer) cannot be assigned to a variable of type *os.File, and we will most likely only need the result as a value of io.Reader (and this is implemented by both):

var input io.Reader

file, err := os.Open(fileName)
if err != nil {
    log.Fatalf(""Error opening %q: %v"", fileName, err)
}
defer file.Close()

// Check if gzip should be applied
if *metaGzip {
    var b = &bytes.Buffer{}
    w := gzip.NewWriter(b)
    if _, err := io.Copy(w, file); err != nil {
        panic(err)
    }
    if err := w.Close(); err != nil { // This also flushes
        panic(err)
    }
    input = b
} else {
    input = file
}

// Use input here


Note #2: If you don't want to ""work"" with the compressed data but you just want to send it e.g. as the web response, you don't even need the bytes.Buffer, you can just ""stream"" the compressed data to the http.ResponseWriter.

It could look like this:

func myHandler(w http.ResponseWriter, r *http.Request) {
    file, err := os.Open(fileName)
    if err != nil {
        http.NotFound(w, r)
    }
    defer file.Close()

    gz := gzip.NewWriter(w)
    defer gz.Close()

    if _, err := io.Copy(gz, file); err != nil {
        // handle error
    }
}


Proper content type will be detected and set automatically.
",40130541
878,40171150,"i suggest to use a manifest based approach with version constraint.

Project A == Manifest
             |- Repo A@~1.0.1
             |- Repo B@~1.0.1

Repo A == Manifest
             |- Repo C@~1.0.1

Repo B == Manifest
             |- Repo C@~1.0.5

Repo C == Manifest empty


Which will resolve into

Project A == Resolved Manifest
             |- Repo A@1.0.1
             |- Repo B@1.0.1
             |- Repo C@1.0.5


where ~1.0.1 means >=1.0.1 .

As you see B and A dependency to C are independent, yet within project they are resolved correctly.

In the event A and B would define incompatible dependency to C, an error should occur as the project should not be build-able.

You may prefer to use caret ^ rather than tilde ~, ^1.0.1 -> >=1.0.1 .

Note that you are not forced to use those 'helpers' such tilde and caret, you may define explicit version range.

You shall decide which constraint to apply given the level of confidence you give to the remote author to correctly upgrade its version number.

Finally,you can use glide to solve that for you.

Starting with Repo C, assuming you already tagged the repos, run glide init, git commit -am 'glide init', git push

Repo A, glide init, glide get git@repo.com/repoc, git commit -am 'glide init', git push

Repo B, glide init, glide get git@repo.com/repoc, git commit -am 'glide init', git push

Finally, Project A, glide init, glide get git@repo.com/repoa, glide get git@repo.com/repob, git commit -am 'glide init', git push

To re install the project, glide install, go build. 

Nothing prevent you to tarball ProjectA with its vendor folder, in order to skip the glide install command when you execute the remote installation.

But you normally don t want to commit the vendor folder for a development environment. You d usually add vendor/ to your .gitignore file and run glide install or glide update.

Expect some difficulties in the begin, passed that step, things will work.

Once you jumped to that workflow, note that you ll have to bump every changes on your repos.

That is bloatware when you work both project A and repo B to reach a viable change, so in that case, rather than vendoring repoB into project A (you can leave the manifest definition, but get ride of the repoB folder into vendor/), install repoB as a go module with the go get command. 
Doing so the changes are taken in effect immediately on re-build. Once the change set is completed, browse into each repos and bump them appropriately.

Finally you may want to use a version bumper to help you to get it done quick and fast, it happens i did one for my personal usage.

hope this helps.
",40168086
879,40189899,"You need to have all imported libraries in your $GOPATH (external libs) or $GOROOT (std lib)

The go get command can fetch libraries from remote and put them in your $GOPATH

So if you go get github.com/labstack/echo it fetches the library from the URL and places it in $GOPATH/github.com/labstack/echo locally.

This is not possible for the library go-todo/models to be fetched remotely like that, so you need to make sure in your CI that it is copied and made available locally at $GOPATH/go-todo/models.

Or you can try vendoring. 
",40188257
880,40216486,"Go has garbage collection. This means the Go runtime checks in the background if an object or any other variable is not used anymore and if this is the case, frees the memory.

Also see the Go FAQ: Why is the syntax so different from C? - Why do garbage collection? Won't it be too expensive?
",40216428
881,40216490,"As you see here:


  Go is fully garbage-collected and provides fundamental support for concurrent execution and communication.


So you don't have to care about memory allocation.
",40216428
882,40216513,"In Go, unlike in C and C++, but like in Java, memory is managed automatically by a garbage collector.

There is no delete to call.

Off-topic:


  in C++ when new is used on an object you can delete the object once there is no longer any need for the object to be stored.


You must delete, otherwise you have memory leak.
",40216428
883,40229629,"From overall conceptual standpoint there is nothing wrong in your implementation.

On a detailed view there are inconsistencies that raise questions.

In all cases below there is a potential concurrency issue due to data shared across various Delete calls.

Case A

If models.User{} does all the work, then why can't we just

userModel := &models.User{}
userModel.Delete(userId)


Case B

If User is our public interface:

user      := User{model: userModel}
user.Delete(1)


then taking userId to delete is redundant and shall be done as:

user.Delete()


userId is taken from user context.

Case C

Otherwise, we might want to make userModel to be set for all User instances:

package User;
// private package level variable
var model = userModel
func Delete(userId int) {
    model.Delete(userId)
}
...
User.Delete(userId)


Conclusion

Each case above solves the same problem with a slightly different emphasis.  Case A is straightforward.  Case B and C rely on underlying shared code that could be used with event notifications.  Case B and C are different in User scope.  In Case B User is a structure.  In Case C user is a package name.  I think Case C is used less often than Case B.  So, if use insist on having an underlying model, then Case B is probably the most intuitive solution from user code point of view.
",40207528
884,40263029,"Go checks for bounds in arrays and slices so it is not vulnerable as long as you are not playing around with unsafe package.
",40262971
885,40263134,"After a quick search I found this link: http://0xdabbad00.com/2015/04/12/looking_for_security_trouble_spots_in_go_code/

It states that golang is safe from most ""known"" attacks (""known"" as in used in C). For instance, the fact that there is no pointer arithmetics, no manual memory management make it less prone to errors that would lead to ""exploitable"" code.

I'm no expert of golang but it seems like a well thought language with a good environment (std lib, compiler, etc...)
",40262971
886,40267397,"The types in the AST represent the syntax used to declare the type and not the actual type. For example:

type t struct { }

var a int          // TypeSpec.Type is *ast.Ident
var b struct { }   // TypeSpec.Type is *ast.StructType
var c t            // TypeSpec.Type is *ast.Ident, but c variable is a struct type


I find it's helpful to print example ASTs when trying to understand how different syntax is represented. Run this program to see an example.

This code will check for ints in most cases, but does not do so reliably:

if id, ok := ts.Type.(*ast.Ident); ok {
    if id.Name == ""int"" {
        // it might be an int
    }
}


The code is not correct for the following cases:

type myint int
var a myint          // the underlying type of a is int, but it's not declared as int

type int anotherType 
var b int            // b is anotherType, not the predeclared int type


To reliably find the actual types in the source, use the go/types package.  A tutorial on the package is available.
",40266003
887,40288438,"The field origin is an embedded field. The application can set the field using the following code:

 func (dest *destination) LaunchTheDevice(theOrigin origin) {
    dest.origin = theOrigin
 }


The name of an embedded field is the same as the type name.
",40288351
888,40370060,"The example you have is equivalent to:

type Cache struct {
    sync.Mutex
    mapping map[string]string
}

cache := Cache{
    mapping: make(map[string]string),
}


Except in your example you do not declare a type of Cache and instead have an anonymous struct.  In your example, as oppose to my Cache type, the type is the entire

struct {
    sync.Mutex
    mapping map[string]string
}


So think of the second pair of braces as the

cache := Cache{
    mapping: make(map[string]string),
}


part.

make is a built in function that works similarly to C's calloc() which both initialize a data structure filled with 0'd values, in Go's case, certain data structures need to be initialized this way, other's (for the most part structs) are initialized with 0'd values automatically.  The field there is needed so that the compiler now's cache.mapping is a empty map[string]string.

The comma there is part of Go's formatting, you can do Cache{mapping: make(map[string]string)} all on one line, but the moment the field's assignment is on a different line than the opening and closing braces, it requires a comma.
",40370006
889,40382754,"This is called a ""struct literal"" or an ""anonymous struct"" and is, in fact, how you always create structs in Go, it just may not be immediately obvious since you might be used to creating new types for struct types to make declaring them a bit less verbose.

An entire struct definition is actually a type in Go, just like int or []byte or string. Just as you can do:

type NewType int
var a NewType = 5 // a is a NewType (which is based on an int)


or:

a := 5 // a is an int


and both are distinct types that look like ints, you can also do the same thing with structs:

// a is type NewType (which is a struct{}).
type NewType struct{
  A string
}
a := NewType{
  A: ""test string"",
}

// a is type struct{A string}
a := struct{
  A string
}{
  A: ""test string"",
}


the type name (NewType) has just been replaced with the type of the struct itself, struct{A string}. Note that they are not the same type (an alias) for the purpose of comparison or assignment, but they do share the same semantics.
",40370006
890,40392962,"As JimB commented, that method won't work due to the operation of io.MultiReader. What you need to do is read from each from each response individually and combine the output. Since you're dealing with logs, it would make sense to break up the reads on newlines. bufio.Scanner does this for a single io.Reader. So one option would be to create a new type that scans multiple readers concurrently.

You could use it like this:

scanner := NewConcurrentScanner(readers...)
for scanner.Scan() {
    fmt.Println(scanner.Text())
}
if err := scanner.Err(); err != nil {
    log.Fatalln(err)
}


Example implementation of a concurrent scanner:

// ConcurrentScanner works like io.Scanner, but with multiple io.Readers
type ConcurrentScanner struct {
    scans  chan []byte   // Scanned data from readers
    errors chan error    // Errors from readers
    done   chan struct{} // Signal that all readers have completed
    cancel func()        // Cancel all readers (stop on first error)

    data []byte // Last scanned value
    err  error
}

// NewConcurrentScanner starts scanning each reader in a separate goroutine
// and returns a *ConcurrentScanner.
func NewConcurrentScanner(readers ...io.Reader) *ConcurrentScanner {
    ctx, cancel := context.WithCancel(context.Background())
    s := &ConcurrentScanner{
        scans:  make(chan []byte),
        errors: make(chan error),
        done:   make(chan struct{}),
        cancel: cancel,
    }

    var wg sync.WaitGroup
    wg.Add(len(readers))

    for _, reader := range readers {
        // Start a scanner for each reader in it's own goroutine.
        go func(reader io.Reader) {
            defer wg.Done()
            scanner := bufio.NewScanner(reader)

            for scanner.Scan() {
                select {
                case s.scans <- scanner.Bytes():
                    // While there is data, send it to s.scans,
                    // this will block until Scan() is called.
                case <-ctx.Done():
                    // This fires when context is cancelled,
                    // indicating that we should exit now.
                    return
                }
            }
            if err := scanner.Err(); err != nil {
                select {
                case s.errors <- err:
                    // Reprort we got an error
                case <-ctx.Done():
                    // Exit now if context was cancelled, otherwise sending
                    // the error and this goroutine will never exit.
                    return
                }
            }
        }(reader)
    }

    go func() {
        // Signal that all scanners have completed
        wg.Wait()
        close(s.done)
    }()

    return s
}

func (s *ConcurrentScanner) Scan() bool {
    select {
    case s.data = <-s.scans:
        // Got data from a scanner
        return true
    case <-s.done:
        // All scanners are done, nothing to do.
    case s.err = <-s.errors:
        // One of the scanners error'd, were done.
    }
    s.cancel() // Cancel context regardless of how we exited.
    return false
}

func (s *ConcurrentScanner) Bytes() []byte {
    return s.data
}

func (s *ConcurrentScanner) Text() string {
    return string(s.data)
}

func (s *ConcurrentScanner) Err() error {
    return s.err
}


Here's an example of it working in the Go Playground: https://play.golang.org/p/EUB0K2V7iT

You can see that the concurrent scanner output is interleaved. Rather than reading all of one reader, then moving on to the next, as is seen with io.MultiReader.
",40389137
891,40398093,"If a deferred function has any return values, they are discarded when the function completes (for more details check Spec: Defer statements).

So the only way to check the return value is to store it, and it is only possible if not the function itself is deferred, but another function that calls it.

One way to do it is using an anonymous function as you did, which may be slightly simplified:

defer func() {
    if err := r.Body.Close(); err != nil {
        fmt.Println(""Error when closing:"", err)
    }
}()


Or you may create a helper function for it:

func Check(f func() error) {
    if err := f(); err != nil {
        fmt.Println(""Received error:"", err)
    }
}


And using it:

defer Check(r.Body.Close)


The helper function of course can be used multiple times, e.g.:

defer Check(r.Body.Close)
defer Check(SomeOtherFunc)


For which you may also create a modified helper function, which may accept multiple functions:

func Checks(fs ...func() error) {
    for i := len(fs) - 1; i >= 0; i-- {
        if err := fs[i](); err != nil {
            fmt.Println(""Received error:"", err)
        }
    }
}


And using it:

defer Checks(r.Body.Close, SomeOtherFunc)


Note that I intentionally used a downward loop in Checks() to mimic the first-in-last-out nature of the execution of deferred functions, because the last defer will be executed first, and so using a downward loop the last function value passed to Checks() will be executed first.
",40397781
892,40413105,"That is not the url path for Beego. You also have a typo after your go get command.

You need to run this from your command line:

go get github.com/astaxie/beego

Installation directions from Beego
",40411832
893,40423745,"You're blocking the iteration over the channel in your handle function with the send on the done channel, because nothing is receiving on the other side.

Those extra channels aren't really doing anything, and you could just add a WaitGroup to synchronize the handler's exit, then you can remove the done channel which will allow the handler to continue. 

func handle(queue chan *Request, i int, wg *sync.WaitGroup) {
    defer wg.Done()

    for r := range queue {
        fmt.Println(i, ""---"", r)
    }
}

func Serve(clientRequests chan *Request, wg *sync.WaitGroup) {
    // Start handlers
    for i := 0; i < MaxOutstanding; i++ {
        wg.Add(1)
        go handle(clientRequests, i, wg)

    }
}

func main() {
    clientRequests := make(chan *Request)
    var wg sync.WaitGroup

    go Serve(clientRequests, &wg)

    for i := int32(0); i < 50; i++ {
        clientRequests <- &Request{i}
    }

    close(clientRequests)
    wg.Wait()
}


https://play.golang.org/p/oUFjZONjhk (note that in the playground, this example seems to currently favor a single goroutine being the receiver. Normally the blocked goroutines will receive randomly, and you can see that behavior if you compile and run normally)
",40423461
894,40423754,"Inside the for loop you are handling the channel operation only to the 5th element, however in the main function you are trying to send over the value to the channel, which is closed.

To overcome this situation you can send the request value inside a for loop:

for i := 0; i < MaxOutstanding; i++ {
        clientRequests <- &Request{int32(i)}
}


Here is the working code:

package main

import (
    ""fmt""
)

type Request struct {
    int32
}

var MaxOutstanding = 10

func handle(queue chan *Request, i int, done chan bool) {
    for r := range queue {
        fmt.Println(i, ""---"", r)
        done <- true
    }
}

func Serve(clientRequests chan *Request, quit, done chan bool) {
    // Start handlers
    for i := 0; i < MaxOutstanding; i++ {
        go handle(clientRequests, i, done)
    }
    <-quit // Wait to be told to exit.
}

func main() {
    clientRequests := make(chan *Request)
    quit := make(chan bool)
    done := make(chan bool)

    go Serve(clientRequests, quit, done)
    for i := 0; i < MaxOutstanding; i++ {
        clientRequests <- &Request{int32(i)}
    }

    fmt.Println(""...........>"", <-done)
    close(clientRequests)
    close(done)
}


https://play.golang.org/p/L5Y2YoFNvz
",40423461
895,40468644,"If clearing the terminal is truly part of your program's responsibility then check out the answers in this question How can I clear the terminal screen in Go?

However if you're just wanting to clear the screen as part of your development process then I would keep it simple and do something like this

clear && go run *.go

",40468404
896,40502582,"You need to write your own implimentation of logrus.Formatter.

type Formatter interface {
    Format(*Entry) ([]byte, error)
}


Source
",40502309
897,40502637,"Time zone setting is not supported directly, but you may use a custom log.Formatter in which you may ""switch"" to the time zone of your choice, UTC included.

A simple usage that uses the local time zone (not UTC) may look like this:

import (
    log ""github.com/Sirupsen/logrus""
)

func main() {
    log.SetFormatter(&log.JSONFormatter{})
    log.Info(""Testing"")
}


Output (time is formatted using my +01 local timezone):

{""level"":""info"",""msg"":""Testing"",""time"":""2016-11-09T09:28:02+01:00""}


Now let's create a custom log.Formatter which switches to UTC:

type UTCFormatter struct {
    log.Formatter
}

func (u UTCFormatter) Format(e *log.Entry) ([]byte, error) {
    e.Time = e.Time.UTC()
    return u.Formatter.Format(e)
}

func main() {
    log.SetFormatter(UTCFormatter{&log.JSONFormatter{}})
    log.Info(""Testing"")
}


Output (time is formatted in UTC timezone):

{""level"":""info"",""msg"":""Testing"",""time"":""2016-11-09T08:28:09Z""}

",40502309
898,40505694,"You JSON is not valid with superfluous comma after the second ]
Once you correct the JSON, you can use the excellent https://mholt.github.io/json-to-go/ to build the following Go struct

type AutoGenerated struct {
    Message struct {
        Server1ExampleCom []struct {
            Application string `json:""application""`
            Host struct {
                Name string `json:""name""`
            } `json:""host""`
            Owner string `json:""owner""`
            Project string `json:""project""`
            Subowner string `json:""subowner""`
        } `json:""Server1.example.com""`
        Server2ExampleCom []struct {
            Application string `json:""application""`
            Host struct {
                Name string `json:""name""`
            } `json:""host""`
            Owner string `json:""owner""`
            Project string `json:""project""`
            Subowner string `json:""subowner""`
        } `json:""Server2.example.com""`
    } `json:""message""`
    ResponseMs int `json:""response_ms""`
    Success bool `json:""success""`
}

",40505410
899,40509559,"You could include a map[string]ServerStruct to fullfill your requirements.

your struct could look like this:

type YourStruct struct {
    Success bool
    ResponseMS int
    Servers map[string]*ServerStruct
}

type ServerStruct struct {
    Application string
    Owner string
    [...]
}


With some additional json tags, you will be able to parse your json.
",40505410
900,40540527,"Try this:

 type ConfigItem struct {
    Name string
    Value interface{}
    SomethingElse bool
 }

mapOfResults = ThingDoer([]ConfigItem{
  {""One"",    -1,    true},
  {""Flying"", """",    true},
  {""Banana"", false, true},
})


The ThingDoer can use a type switch to determine the value types:

func ThingDoer(config []ConfigItem) map[foo]bar {
    for _, item := range config {
      switch v := item.Value.(type) {
      case int:
        // v is int
      case bool:
        // v is bool
      case string:
        // v is string
      }
    }
 }


playground example
",40540490
901,40575079,"This is normal behaviour that is defined by the spec (emphasis mine):


  The TypeSwitchGuard may include a short variable declaration. When that form is used, the variable is declared at the beginning of the implicit block in each clause. In clauses with a case listing exactly one type, the variable has that type; otherwise, the variable has the type of the expression in the TypeSwitchGuard.


So, in fact, the type switch does take effect, but the variable a keeps the type interface{}.

One way you could get around this is to assert that foo has the method test(), which would look something like this:

package main

import (
    ""fmt""
)

type A struct {
    a int
}

func (this *A) test() {
    fmt.Println(this)
}

type B struct {
    A
}

type tester interface {
    test()
}

func main() {
    var foo interface{}
    foo = &B{}
    if a, ok := foo.(tester); ok {
        fmt.Println(""foo has test() method"")
        a.test()
    }
}

",40575033
902,40586380,"Try this:

\((.*?)\)


Explanation

Code Sample:

package main

import (
    ""regexp""
    ""fmt""
)

func main() {
    var re = regexp.MustCompile(`\((.*?)\)`)
    var str = `foo(bar)foo(baz)golang`

    mt:= re.FindAllStringSubmatch(str, -1)

    for _, i := range mt {
        fmt.Println(i[1])
    }
}


Run the go code here
",40586313
903,40586418,"go's regexp package does not support zero width lookarounds. You can leverage captured grouping with the regexp.FindAllStringSubmatch() function:

package main

import (
    ""regexp""
    ""fmt""
)

func main() {
    str := ""foo(bar)foo(baz)golang""
    rex := regexp.MustCompile(`\(([^)]+)\)`)
    out := rex.FindAllStringSubmatch(str, -1)

    for _, i := range out {
        fmt.Println(i[1])
    }
}


outputs:

bar
baz




The Regex \(([^)]+)\):


\( matches literal (
([^)]+) matches substring upto next ) and put the match in a captured group, here you can use non-greeedy match .*?\) too
\) matches literal )




Go playground demo
",40586313
904,40589592,"AddDate takes (and adds) year, month, day as parameters, not hour, minute, second.

From https://golang.org/pkg/time/#Time.AddDate:

func (t Time) AddDate(years int, months int, days int) Time

",40589353
905,40589596,"I guess what you are looking for is

timein := time.Now().Local().Add(time.Hour * time.Duration(Hours) +
                                 time.Minute * time.Duration(Mins) +
                                 time.Second * time.Duration(Sec))

",40589353
906,40595743,"A binary search requires a greater than or less than comparison, otherwise it would just be a linear search over the slice. Any comparison greater than the value at the requested index needs to be true, in order for the search method to scan backwards looking for the smallest index.

See the default implementation of the string search function from the sort package:

https://golang.org/src/sort/search.go?s=3673:3717#L91

func SearchStrings(a []string, x string) int {
    return Search(len(a), func(i int) bool { return a[i] >= x })
}

",40595563
907,40658382,"Use the full option names of --start-group and --end-group rather than the shorthand version.
",40646106
908,40661736,"along with with separate packages as above, if you set the GOBIN=$GOPATH/bin then it will create client and server in the bin dir and it will not collide with dir names 
",24292133
909,40663575,"Here is a possible solution, which is based on @Andy's comment.

A new responseRecorder will be passed to the nextHandler, and the recorded response will be copied back to the client:

func timeoutHandler(w http.ResponseWriter, r *http.Request) error {
    const seconds = 1
    ctx, cancel := context.WithTimeout(r.Context(),
        time.Duration(seconds)*time.Second)
    defer cancel()

    r = r.WithContext(ctx)

    errCh := make(chan error, 1)
    w2 := newResponseRecorder()
    go func() {
        errCh <- nextHandler(w2, r)
    }()

    select {
    case err := <-errCh:
        if err != nil {
            return err
        }

        w2.cloneHeader(w.Header())
        w.WriteHeader(w2.status)
        w.Write(w2.buf.Bytes())
        return nil
    case <-ctx.Done():
        http.Error(w, ""Request timeout"", 408)
        return nil
    }
}


And here is the responseRecorder:

type responseRecorder struct {
    http.ResponseWriter
    header http.Header
    buf    *bytes.Buffer
    status int
}

func newResponseRecorder() *responseRecorder {
    return &responseRecorder{
        header: http.Header{},
        buf:    &bytes.Buffer{},
    }
}

func (w *responseRecorder) Header() http.Header {
    return w.header
}

func (w *responseRecorder) cloneHeader(dst http.Header) {
    for k, v := range w.header {
        tmp := make([]string, len(v))
        copy(tmp, v)
        dst[k] = tmp
    }
}

func (w *responseRecorder) Write(data []byte) (int, error) {
    if w.status == 0 {
        w.WriteHeader(http.StatusOK)
    }
    return w.buf.Write(data)
}

func (w *responseRecorder) WriteHeader(status int) {
    w.status = status
}

",40643379
910,40669025,"First check errors returned by json.Unmarshal().

Next your json tag uses small ""a"" as the JSON key, however the encoding/json package will recognize the capital ""A"" too.

And last passing such arguments in the command line may be OS (shell) specific. The backtick and quotes usually have special meaning, try passing it like this:

go run trial.go {\""a\"":\""1\""}


Also you should check the length of os.Args before indexing it, if the user does not provide any arguments, os.Args[1] will panic.

As you mentioned, you should find another way to test input JSON documents, this becomes unfeasible if the JSON text is larger, and also this is OS (shell) specific. A better way would be to read from the standard input or read from a file.
",40668910
911,40676494,"import (""fmt""; ""strings"")

func commas(s string) string {
    if len(s) <= 3 {
        return s
    } else {
        return commas(s[0:len(s)-3]) + "","" + s[len(s)-3:]
    }
}

func toString(f float64) string {
    parts := strings.Split(fmt.Sprintf(""%.2f"", f), ""."")
    if parts[0][0] == '-' {
        return ""-"" + commas(parts[0][1:]) + ""."" + parts[1]
    }
    return commas(parts[0]) + ""."" + parts[1]
}

",13020308
912,40688635,"Thanks to a comment from Ismail Badawi, the answer is to write a function in C that returns None. This is required because Py_None is a macro, which Go can't see.

none.c

#define Py_LIMITED_API
#include 

PyObject *IncrNone() {
        Py_RETURN_NONE;
}


mymodule.go

/*
#cgo pkg-config: python3
#define Py_LIMITED_API
#include 

PyObject *IncrNone();
*/
import ""C""

//export Nothing
func Nothing(self, args *C.PyObject) (status *C.PyObject) {
        return C.IncrNone()
}

",40688567
913,40713267,"You must use (with ""http://"" in this case)

resp, _ := http.Get(""http://localhost:80/static"")


and check the errors before use the response, just in case the request fails 

resp, err := http.Get(""http://localhost:80/static"")
if err != nil {
    // do something
} else {
    ans, _ := ioutil.ReadAll(resp.Body)
    fmt.Printf(""response: %s"", ans)
}


Also, if you want to get any response from your handler, you have to write a response in it.

func myHandler(rw http.ResponseWriter, req *http.Request) {
    fmt.Printf(req.URL.Path)
    rw.Write([]byte(""Hello World!""))
}

",40708750
914,40741632,"Yes, you can use an internal directory. 


  Code in or below a directory named ""internal"" is importable only by code in the directory tree rooted at the parent of ""internal"". 

",40741357
915,40802483,"You can try os.NewFile:

f := os.NewFile(4, ""my_fd_4"")

",40800343
916,40828492,"Yes. With gjson all you have to do now is:

bar := gjson.Get(json, ""foo.bar"")

bar could be a struct property if you like. Also, no maps.
",21268000
917,40833102,"The format is described here: Convert snmp octet string to human readable date format

If you just need to create a date/time string in the format you mentioned, this will do it:

func snmpTimeString(c []byte) string {
    year := (int(c[0]) << 8) | int(c[1])
    return fmt.Sprintf(""%d-%d-%d,%02d:%02d:%02d.%d,%c%d:%d"", year, c[2], c[3], c[4], c[5], c[6], c[7], c[8], c[9], c[10])
}

func main() {
    c := []byte{0x7, 0xe0, 0x1, 0x1c, 0x14, 0x4, 0x2a, 0x0, 0x2b, 0x0, 0x0}
    fmt.Println(snmpTimeString(c))
}


See https://play.golang.org/p/7WwQbPuESC.
",40832472
918,40842586,"Similar to bjarneh's response. If you want to do this via interfaces, best to avoid reflect. Reflect is not good for comparing values, because you cannot know what type the values are.

My suggestion is to implement something similar to go's sort interface which allows you to use the function sort on any type.

Implementing it this way would then allow you to get max value for structs or strings, as long as you implemented the functions for them.

On go playgorund

package main

import (
    ""fmt""
)

type Comparable interface {
    Less(i, j int) bool
    Len() int
    Val(i int) interface{}
}

func maxer(s Comparable) (interface{}) {
    if s.Len() == 0 {
        return nil
    }
    maxI := 0
    for i := 1; i < s.Len(); i++ {
        if s.Less(maxI, i) {
            maxI = i
        }
    }
    return s.Val(maxI)
}

type MaxerInt []int
func (m MaxerInt) Len() int {return len(m)}
func (m MaxerInt) Val(i int) interface{} {return m[i]}
func (m MaxerInt) Less(i, j int) bool {return m[i] < m[j]}

type MaxerFloat []float64
func (m MaxerFloat) Len() int {return len(m)}
func (m MaxerFloat) Val(i int) interface{} {return m[i]}
func (m MaxerFloat) Less(i, j int) bool {return m[i] < m[j]}

func main() {
    fmt.Println(maxer(MaxerInt{1, 2, 3, 4}))
    fmt.Println(maxer(MaxerFloat{1.1, 2.1, 3.14, 0.1, 2.4}))
}

",20930447
919,40843976,"Refactor your code, move the limit outside of your function which tests can change:

var limit = 1 << 32

var ErrTooLarge = errors.New(""String is too large!"")

func Process(s string) error {
    if len(s) > limit {
        return ErrTooLarge
    }
    // All OK
    return nil
}


Testing it:

func TestProcess(t *testing.T) {
    // Save limit and restore it at the end:
    old := limit
    defer func() { limit = old }()

    // Test success
    if err := Process(""123""); err != nil {
        t.Errorf(""Expected success, got: %v"", err)
    }

    // Test failure (too large string)
    limit = 5
    if err := Process(""123456""); err != ErrTooLarge {
        t.Errorf(""Expected ErrTooLarge, got: %v"", err)
    }
}


Running go test -cover:

PASS
coverage: 100.0% of statements
ok      play    0.001s

",40843808
920,40865028,"You use the StructTag type to get the tags. The documentation I linked has examples, look them up, but your code could be something like

func (b example) PrintFields() {
    val := reflect.ValueOf(b)
    for i := 0; i < val.Type().NumField(); i++ {
        fmt.Println(val.Type().Field(i).Tag.Get(""json""))
    }
}

",40864840
921,40865043,"Use:

func (b example) PrintFields() {
    val := reflect.ValueOf(b)
    t := val.Type()
    for i := 0; i < t.NumField(); i++ {
        fmt.Println(t.Field(i).Tag.Get(""json""))
    }
}


See it in playground.
",40864840
922,40865100,"Instead of using StructField's Name, you can use Tag to get a StructTag object.
See: https://golang.org/pkg/reflect/#StructTag

Then you can use StructTag's Get or Lookup methods to get the json tag:

Using Get:

func (b example) PrintFields() {
    val := reflect.ValueOf(b)
    for i := 0; i < val.Type().NumField(); i++ {
        // prints empty line if there is no json tag for the field
        fmt.Println(val.Type().Field(i).Tag.Get(""json""))
    }
}


Using Lookup:

func (b example) PrintFields() {
    val := reflect.ValueOf(b)
    for i := 0; i < val.Type().NumField(); i++ {
        // skips fields without json tag
        if tag, ok := val.Type().Field(i).Tag.Lookup(""json""); ok {
            fmt.Println(tag)
        }
    }
}

",40864840
923,40865110,"Not the Name you are looking for. What you looking is the Tag

func (b example) PrintFields() {
    val := reflect.ValueOf(b)
    for i := 0; i < val.Type().NumField(); i++ {
        fmt.Println(val.Type().Field(i).Tag.Get(""json""))
    }
}

",40864840
924,40876262,"You should be able to adapt this easily to a for loop if you range over a list of the functions that are your steps:

package main

import (
    ""fmt""
    ""time""
)

func a() { fmt.Printf(""a"") }
func b() { fmt.Printf(""b"") }
func c() { fmt.Printf(""c"") }
func d() { fmt.Printf(""d"") }
func e() { fmt.Printf(""e"") }

func f(quit <-chan struct{}) {
    for i := 0; i < 10000; i++ {
        for _, fn := range []func(){a, b, c, d, e} {
            select {
            case _, _ = <-quit:
                fmt.Println(""quit f"")
                return
            default:
                fn()
                time.Sleep(1 * time.Millisecond)
            }
        }
    }
}

func main() {
    quit := make(chan struct{})
    fmt.Println(""go f"")
    go f(quit)
    fmt.Println(""sleep"")
    time.Sleep(100 * time.Millisecond)
    fmt.Println(""\nquit"")
    close(quit)
    time.Sleep(10 * time.Millisecond)
    fmt.Println(""exit"")
}


Try it on the playground.

The outer loop is just there to repeat the steps for long enough that we can witness the quit command happening.
",39632932
925,40928592,"I had a slightly different problem, but the solution that I have found can help with this problem too. I foun solution here https://github.com/astaxie/beego/issues/1258

You need to call qs.RelatedSel() without parameters (or with int parameter, that responds about deep of relation selection) and manually call LoadRelated for each record

func GetAllCustomerSaldo(query map[string]string, fields []string, sortby []string, order []string,
    offset int64, limit int64) (ml []interface{}, err error, totals int64) {
    o := orm.NewOrm()
    qs := o.QueryTable(new(CustomerSaldo))
    qs.RelatedSel().All(&CustomerSaldo{})
    ...
}

o := orm.NewOrm()
for _, el := range arr {
   o.LoadRelated(el, ""CustomerId"")
}


RelatedSel is like LeftOuterJoin
",27397306
926,40939364,"Golang handle all date formatting in a unique way - it uses the reference time Mon Jan 2 15:04:05 MST 2006 (01/02 03:04:05PM '06 -0700) to show the pattern with which to format/parse a given time/string.

So, to read the format ""Wed Nov 23 23:26:10 2016"" you would put the reference date into that format:  ""Mon Jan 2 15:04:05 2006"", and then do:

t, _ := time.Parse(""Mon Jan 2 15:04:05 2006"", ""Wed Nov 23 23:26:10 2016"")


Then, to output it in the given format, if you wanted the format DD-MM-YYYY hh:mm:ss, you would put the reference time into that format: 02-01-2006 15:04:05, and then do:

t.Format(""02-01-2006 15:04:05"")


https://play.golang.org/p/VO5413Z7-z

So basically, the main change is

// Format mask for output
layout := ""DD-MM-YYYY hh:mm:ss""


should be

// Format mask for output
layout := ""02-01-2006 15:04:05""


and

time.Parse(date, layout)


should be

time.Parse(layout, date)

",40939261
927,40945424,"From go.vim Vim syntax file:


""   There are some options for customizing the highlighting; the recommended
""   settings are the default values, but you can write:
""     let OPTION_NAME = 0
""   in your ~/.vimrc file to disable particular options.



Put in your .vimrc

let g:go_highlight_trailing_whitespace_error=0


There are these other options:


""   - g:go_highlight_array_whitespace_error
""     Highlights white space after ""[]"".
""   - g:go_highlight_chan_whitespace_error
""     Highlights white space around the communications operator that don't
""     follow the standard style.
""   - g:go_highlight_extra_types
""     Highlights commonly used library types (io.Reader, etc.).
""   - g:go_highlight_space_tab_error
""     Highlights instances of tabs following spaces.



If you still like the highlighting of trailing whitespaces but not during the typing, you can try

au InsertEnter *.go match goSpaceError /\s\+\%#\@<!$/
au InsertLeave *.go match goSpaceError /\s\+$/


Read more in Highlight unwanted spaces from wikia.
",40945136
928,40949505,"You just put it in any of the test files and that's all. Test files using the same package clause belong to the same test package and can refer to each other's exported and unexported identifiers without any import statements.

Also note that you're not required to create a separate _test.go file for each of the .go files; and you can have an xx_test.go file without having a ""matching"" xx.go file in the package.

For example if you're writing package a, having the following files:

a/
    a.go
    b.go
    a_test.go
    b_test.go


For black-box testing you'd use the package a_test package clause in a_test.go and b_test.go. Having a func util() in file a_test.go, you can use it in b_test.go too.

If you're writing white-box testing, you'd use package a in the test files, and again, you can refer any identifiers declared in a_test.go from b_test.go (and vice versa) without any imports.

Note that however if the package clauses in a_test.go and b_test.go do not match (e.g. a_test.go uses package a and b_test.go uses package a_test), then they will belong to different test packages and then you can't use identifiers declared in one another.
",40949178
929,41009815,"The godoc.org/golang.org/x/tools/go/gcimporter15 tells that the package gcimporter is deprecated and this package will be deleted in October 2017. And this new code should be used: golang.org/x/tools/go/gcexportdata instead of gcimporter .

So, what you have to do is:

$ go get godoc.org/golang.org/x/tools/go/gcexportdata


PS: Tested within Ubuntu 16.04 64bit and go version go1.6.2 linux/amd64 without any issues.

Test:

package main
import (
    ""fmt""
    gcexportdata ""golang.org/x/tools/go/gcexportdata""
)
func main() {
    filename, path := gcexportdata.Find(""fmt"", """")
    fmt.Println(filename, path)
}


Output:

/usr/lib/go-1.6/pkg/linux_amd64/fmt.a fmt

",41009376
930,41034423,"Converting VonC's comment into an answer.

You can bind the host by setting host:port in your http.Server.Addr or http.ListenAndServe.

They use net.Listen internally.

From net.Listen :


  For TCP and UDP, the syntax of laddr is ""host:port"", like
  ""127.0.0.1:8080"". If host is omitted, as in "":8080"", Listen listens on
  all available interfaces instead of just the interface with the given
  host address.

",41028709
931,41108447,"While there's probably no generic package to implement this custom struct packing, you can easily create your own method extracting just the bits required for each field.

func (m *Message) UnmarshalBinary(data []byte) error {
    m.Length = binary.BigEndian.Uint32(data[:4])

    if int(m.Length) > len(data) {
        return fmt.Errorf(""not enough bytes"")
    }

    m.Type = MessageType(data[4])

    m.Version = data[5] >> 4
    m.Subversion = data[5] >> 2 & 0x03
    m.Optional = data[5] >> 1 & 0x01

    // move the index for ANumber back if there's an optional string
    idx := 6
    if m.Optional == 0 {
        // remove the last two bytes for ANumber
        end := int(m.Length) - 2
        m.NodeName = string(data[6:end])
        idx = end
    }

    m.ANumber = uint16(data[idx]&0xc0)>6)
    return nil


}

You can of course add more bound checks to return errors rather than letting this panic when indexing out of bounds.

I modified your inStream slice slightly to match your definition, and you can see the example output here: https://play.golang.org/p/FoNoazluOF
",41104049
932,41132011,"Mixing of google api go libs, was causing the problem.

Long Answer

Short Answer

Google Cloud API libs come in two different flavors, issues was caused by mixing of lib features from libs below.

google-cloud-go Recommanded

google-api-go-client
",41061803
933,41158012,"The user may be able to pass in any value, but your code can deal with invalid input by passing an error back to them. If you know the desired format of the incoming data you can directly unmarshal it and handle any invalid input separately. This removes the need to have the intermediate interface{} that's hard to deal with:

https://play.golang.org/p/VNCflbk3GL

package main

import (
    ""encoding/json""
    ""fmt""
)

type session struct {
    Value Person
    Flash map[string]string
}

type Person struct {
    Name string
    Age  int
}

func Get(marshaled string) (Person, error) {
    var sess session
    err := json.Unmarshal([]byte(marshaled), &sess)
    if err != nil {
        return Person{}, err
    }
    fmt.Println(sess) // {{bob 3} map[]}
    return sess.Value, nil
}

func main() {
    person, err := Get(`{""Value"":{""Name"":""bob"",""Age"":3},""Flash"":null}`)
    if err != nil {
        fmt.Println(""Got err:"", err)
    }
    fmt.Printf(""%#v"", person) // main.Person{Name:""bob"", Age:3}
}


If it's valid for Value to be multiple types, then you will have to do a type assertion somewhere. In Go it's not all that painful though:

https://newfivefour.com/golang-interface-type-assertions-switch.html

switch v := anything.(type) {
case string:
    fmt.Println(v)
case int32, int64:
    fmt.Println(v)
case SomeCustomType:
    fmt.Println(v)
default:
    fmt.Println(""unknown"")
}

",41157259
934,41158379,"You problem is that your incoming data type of Value is map[string]interface{}, and there's no direct/native way in Go to convert map into your type (while there's definitely code out there).

OK. If we assume that we totally have no control over incoming data in the Value field, but still, we can identify data type by a combination of its attributes, right? Because by definition, you should know possible options. We can create a universal incoming object instead of interface{}. AWS is using similar approach in their Go SDK, at least for DynamoDB service, setting optional attributes via pointers: https://github.com/aws/aws-sdk-go/blob/master/service/dynamodb/examples_test.go#L32

So, the approach is: your UnknownObj struct will have optional attributes that may be filled (and may be not) on json.Unmarshal. Knowing what fields were delivered via the switch, you can guess the data sent. 

package main

import (
    ""encoding/json""
    ""fmt""
)

type session struct {
    Value UnknownObj
    Flash map[string]string
}

type UnknownObj struct {
    Name           *string
    Age            *float64
    SomeOtherField *map[string]string
}

func Get() UnknownObj {
    marshalledString := `{""Value"":{""Name"":""bob"",""Age"":3},""Flash"":null}`

    var sess session
    json.Unmarshal([]byte(marshalledString), &sess)
    return sess.Value
}

func main() {

    v := Get()

    switch {
    case v.Name != nil && v.Age != nil:
        fmt.Println(""This is a Person"")
    default:
        fmt.Println(""Unknown data type"")

    }

}


However, if you have control over the root/Values field and you can request to send you specific fields for each of the types instead of pushing all under Values, then you could have:

type session struct {
    Person   *Person
    Car      *Car
    Building *Buidling
    Etc      *Etc

    ...
}


This way, your solution will be even easier -> you'll just need to check what property is not nil.

Hope this helps.

Cheers.

Update Dec 15, 2016
To reply on your comment regarding the framework: what you are describing is a process of binding of user's request to an arbitrary data-type.
OK. Unfortunately, its too much code to post here, but here's a link as a starting point:
https://github.com/go-playground/validator/blob/v8.18.1/validator.go#L498

This is a package and approach Gin framework is using for binding here: https://github.com/gin-gonic/gin/blob/master/binding/json.go

Good luck!
",41157259
935,41164738,"OK, I think I know what you're wanting to do. I found this answer Converting map to struct and made some tweaks to get it working for your particular use case. Note: this hasn't been tested thoroughly and may be a little shaky, use at your own risk:

package main

import (
    ""bytes""
    ""encoding/json""
    ""errors""
    ""fmt""
    ""log""
    ""reflect""
)

type session struct {
    Value interface{}
    Flash map[string]string
}

type Person struct {
    Name string
    Age  int
}

func Get(pointer interface{}) {
    marshalledString := `{""Value"":{""Name"":""bob"",""Age"":3},""Flash"":null}`

    var sess session

    d := json.NewDecoder(bytes.NewBuffer([]byte(marshalledString)))
    d.UseNumber()
    if err := d.Decode(&sess); err != nil {
        panic(err)
    }

    fmt.Printf(""%#v"", sess)

    switch sess.Value.(type) {
    case map[string]interface{}:
        err := FillStruct(sess.Value.(map[string]interface{}), pointer)
        if err != nil {
            log.Fatal(err)
        }
    default:
        return // You may want to return an error here...
    }
}

func main() {
    var personObj Person

    Get(&personObj)

    // Wanting to see personObj here have Name ""bob"" and Age 3
    fmt.Printf(""%#v"", personObj)
}

func SetField(obj interface{}, name string, value interface{}) error {
    structValue := reflect.ValueOf(obj).Elem()
    structFieldValue := structValue.FieldByName(name)

    if !structFieldValue.IsValid() {
        return fmt.Errorf(""No such field: %s in obj"", name)
    }

    if !structFieldValue.CanSet() {
        return fmt.Errorf(""Cannot set %s field value"", name)
    }

    structFieldType := structFieldValue.Type()
    val := reflect.ValueOf(value)

    if _, ok := value.(json.Number); ok {
        if f, err := value.(json.Number).Int64(); err == nil {
            structFieldValue.SetInt(f)
            return nil
        }
        if f, err := value.(json.Number).Float64(); err == nil {
            structFieldValue.SetFloat(f)
            return nil
        }
    }

    if structFieldType != val.Type() {
        return errors.New(fmt.Sprintf(""Provided value type [%s] didn't match obj field type [%s]"", val.Type().String(), structFieldType.String()))
    }

    structFieldValue.Set(val)
    return nil
}

func FillStruct(m map[string]interface{}, s interface{}) error {
    for k, v := range m {
        err := SetField(s, k, v)
        if err != nil {
            return err
        }
    }
    return nil
}

",41157259
936,41230015,"Had the same issue. Here is what I found from going through the graphql-go source. 

The Fields of an InputObject have to be of type InputObjectConfigFieldMap or InputObjectConfigFieldMapThunk for the pkg to work.

So an InputObject would look like this :

var inputType = graphql.NewInputObject(
    graphql.InputObjectConfig{
        Name: ""MyInputType"",
        Fields: graphql.InputObjectConfigFieldMap{
            ""key"": &graphql.InputObjectFieldConfig{
                Type: graphql.String,
            },
        },
    },
) 




Modified the Hello World example to take an Input Object :

package main

import (
    ""encoding/json""
    ""fmt""
    ""log""

    ""github.com/graphql-go/graphql""
)

func main() {
    // Schema

    var inputType = graphql.NewInputObject(
        graphql.InputObjectConfig{
            Name: ""MyInputType"",
            Fields: graphql.InputObjectConfigFieldMap{
                ""key"": &graphql.InputObjectFieldConfig{
                    Type: graphql.String,
                },
            },
        },
    )

    args := graphql.FieldConfigArgument{
        ""foo"": &graphql.ArgumentConfig{
            Type: inputType,
        },
    }

    fields := graphql.Fields{
        ""hello"": &graphql.Field{
            Type: graphql.String,
            Args: args,
            Resolve: func(p graphql.ResolveParams) (interface{}, error) {
                fmt.Println(p.Args)
                return ""world"", nil
            },
        },
    }
    rootQuery := graphql.ObjectConfig{
        Name:   ""RootQuery"",
        Fields: fields,
    }

    schemaConfig := graphql.SchemaConfig{Query: graphql.NewObject(rootQuery)}
    schema, err := graphql.NewSchema(schemaConfig)
    if err != nil {
        log.Fatalf(""failed to create new schema, error: %v"", err)
    }

    // Query
    query := `
        {
            hello(foo:{key:""blah""})
        }
    `
    params := graphql.Params{Schema: schema, RequestString: query}
    r := graphql.Do(params)
    if len(r.Errors) > 0 {
        log.Fatalf(""failed to execute graphql operation, errors: %+v"", r.Errors)
    }
    rJSON, _ := json.Marshal(r)
    fmt.Printf(""%s \n"", rJSON) // {“data”:{“hello”:”world”}}
}

",40360936
937,41239174,"Know that Reader.ReadString() returns you a string value with the delimieter. So r.ReadString('\n') will return you a string with the trailing newline character.

And when you split the string at the commas, the last part will contain the newline character, and attempting to parse the number from it will fail, as shown in this example:

line := ""0,1,2\n""
for _, ele := range strings.Split(line, "","") {
    fmt.Println(strconv.ParseInt(ele, 10, 64))
}


Output (try it on the Go Playground):

0 
1 
0 strconv.ParseInt: parsing ""2\n"": invalid syntax


You religiously omit error checks, don't do that! As you can see in the above example, checking and printing the error returned by strconv.ParseInt() immediately revealed the error and what's going wrong.

What you may do is cut the trailing newline character before attempting to parse any number from it, e.g.:

strconv.ParseInt(strings.TrimSpace(ele), 10, 64)


Or use the bufio.Scanner which can scan lines and it cuts trailing newlines automatically.
",41238879
938,41250437,"From the io.Writer documentation:


  Write must not modify the slice data, even temporarily. Implementations must not retain p


You can't store or reuse the slice being passed to your Write method. If you want to use that data elsewhere, you need to make a copy of it

func (self *WriterToHash) Write(p []byte) (n int, err error) {
    b := make([]byte, len(p))
    copy(b, p)
    fmt.println(""WriterToHash  len=%d, buff=%v"", len(p), b)
    self.BodyChannel <- b
    return len(p), nil
}

",41250130
939,41267045,"You could do something like this: 

func main() {
    var hello SmartString = ""hello""

    p := &hello
    p.Print()
    p = nil
    p.Print()

}

type SmartString string

func (p *SmartString) Print() {
    if p == nil {
        fmt.Println(p)
    } else {
        fmt.Println(*p)
    }
}


Whether it's a good idea or not is up to you.

You can even use the String interface to make it work with fmt.Println

func main() {
    var hello SmartString = ""hello""

    p := &hello
    fmt.Println(p)
    p = nil
    fmt.Println(p)

}

type SmartString string

func (p *SmartString) String() string {
    if p == nil {
        return """"
    }
    return string(*p)
}

",41266630
940,41302818,"You did the right thing by filing a bug, so hopefully that will be resolved soon. The most recent version of the cloud APIs adds support for query parameters but based on the error that you are seeing, one of the libraries was not updated properly.
",41297410
941,41318404,"You don't have to convert bson.M to struct, instead, you directly pass a struct pointer to the One function

var struct2 Struct2
err := c.Find(bson.M{nil}).One(&struct2)


In case of you still want to convert bson.M to struct, use Marshal and Unmarshal

var m bson.M
var s Struct1

// convert m to s
bsonBytes, _ := bson.Marshal(m)
bson.Unmarshal(bsonBytes, &s)

",36362457
942,41335088,"Ideally, whatever is constructing the Parent struct should initialize it so it's in a usable state. But since you have no control over it, the next best thing is to have a piece of code that lets you set the WithContext pointer in Parent, by providing a member function on Parent or just a piece of code in your application to set it, since WithContext field is exported.
",41332454
943,41354918,"Its bad but seems there is a mismatch between the gcimporter15 and go-1.5. I faced the same problem and looked at go-1.5 code in file src/go/constant/value.go and there is no ToFloat() function in the constant package. 

As @nexus66 says, the gcimporter is deprecated. So, I don't expect them to fix this. If you are using this package directly, its better to move on to the recommended gcexportdata package. If you are using a third party library which is in turn using gcimporter, may be you should upgrade to go-1.7. That's what I did and things worked fine. 
",41009376
944,41366470,"You are not checking the error returned by loadPage() in viewHandler() so if loadPage() can't load the file and returns nil with an error, viewHandler() tries to use that nil to obtain the page title and body and that's what causing the panic.

It works fine if loadPage() can read the file, though.
",41366347
945,41408909,"This is a little bit late but I found this post while I am trying to find a golang-to-python 0mq implementation.

In my golang code, I have just changed zmq to zmq4 and everything worked for me:

import (
    zmq4 ""github.com/pebbe/zmq4""
)

func main() {

    ctx, _ := zmq4.NewContext()
    sock, _ := ctx.NewSocket(zmq4.REQ)

    sock.Connect(""tcp://localhost:57000"")
    sock.Send(""simple message"", 0)
}

",35918588
946,41422312,"Instead of importing the entire C source code, you can link it with compiled object files and header files. Refer to https://golang.org/cmd/cgo/ which covers how to use the LDFLAGS argument for cgo.

There are other documents online which cover how to compile C code into object files (.a and .o files) such as this one. You should also refer to documentation in the library you're using, or its Makefile as it will likely already have instructions to compile it into object files that can be linked.

If the library that has import ""C"", and its source isn't being modified, you can also go get it, (or perhaps go install it) which will store its compiled object files in your $GOPATH/pkg, making compilation of other Go programs that import it faster.
",41422187
947,41424677,"The code referenced by the comment is memory efficient as written. Any allocations are in strings.Join which is written to minimize memory allocations.

I suspect that the comment was accidentally copied and pasted from this code in the net/http package:

        // TODO: could do better allocation-wise here, but trailers are rare,
        // so being lazy for now.
        if _, err := io.WriteString(w, ""Trailer: ""+strings.Join(keys, "","")+""\r\n""); err != nil {
            return err
        }


This snippet has the following possible allocations:


[]byte created in strings.Join for constructing the result
string conversion result returned by strings.Join
string result for expression ""Trailer: ""+strings.Join(keys, "","")+""\r\n""
The []byte conversion result used in io.WriteString


A more memory efficient approach is to allocate a single []byte for the data to be written. 

n := len(""Trailer: "") + len(""\r\n"")
for _, s := range keys {
    n += len(s) + 1
}
p := make([]byte, 0, n-1) // subtract 1 for len(keys) - 1 commas
p = append(p, ""Trailer: ""...)
for i, s := range keys {
    if i > 0 {
        p = append(p, ',')
    }
    p = append(p, s...)
}
p = append(p, ""\r\n""...)
w.Write(p)

",41423272
948,41439441,"There is a little trick in Go template parseFiles.

func parseFiles(t *Template, filenames ...string) (*Template, error) {
    if len(filenames) == 0 {
        // Not really a problem, but be consistent.
        return nil, fmt.Errorf(""template: no files named in call to ParseFiles"")
    }
    for _, filename := range filenames {
        b, err := ioutil.ReadFile(filename)
        if err != nil {
            return nil, err
        }
        s := string(b)
        name := filepath.Base(filename)
        // First template becomes return value if not already defined,
        // and we use that one for subsequent New calls to associate
        // all the templates together. Also, if this file has the same name
        // as t, this file becomes the contents of t, so
        //  t, err := New(name).Funcs(xxx).ParseFiles(name)
        // works. Otherwise we create a new template associated with t.
        var tmpl *Template
        if t == nil {
            t = New(name)
        }
        if name == t.Name() {
            tmpl = t
        } else {
            tmpl = t.New(name)
        }
        _, err = tmpl.Parse(s)
        if err != nil {
            return nil, err
        }
    }
    return t, nil
}


Only the template with same name will be reuse, otherwise create new one.
as your sample:

tmpl, err := template.New(""test"").ParseFiles(""file.txt"")


tmpl is the template named ""test"", and associated another template named ""file.txt"", you call Execute on ""test"" template, this template is a empty template, so raise the error ""test is an incomplete or empty template"".

It worked when you change the template name to file.txt

tmpl, err := template.New(""file.txt"").ParseFiles(""file.txt"")

",11805356
949,41466328,"Ok, I spent a whole day and found a viable solution.

We need to have the extension's main source file start with:

package main  // make sure to use main package

/*
#cgo CFLAGS: -I/path/to/postgres/include/server
#cgo LDFLAGS: -Wl,-unresolved-symbols=ignore-all


Use go build -o myext.so -buildmode=c-shared myext.go to generate myext.so.

If some Go method is needed from the C side, we should add //export methodname above the method declaration. This will generate symbols without package name prefix. Then we can extern these symbols on the C side. Make sure the exported Go methods reside in packages other than main.

package test :

//export Merge
func Merge(cint C.int) C.int ...


package main :

extern int Merge(int);

import ""./test""
var _ = test.Somevar  // dumb placeholder to fake use package test.

",41456777
950,41499772,"Since 'rows.Next()' is sequential, you would need to split your query into multiple statements, and then work concurrently on them.

func main() {

    queries := []string{
        ""SELECT * FROM abc where a < 10000"",
        ""SELECT * FROM abc where a >= 10000 && a <= 30000"",
        ""SELECT * FROM abc where a > 30000"",
    }

    for _, query := range queries {
        go dbCall(query)
    }
}

func dbCall(query string) {

    rows, _ := db.Query(query)
    for rows.Next() {
        var a, b, c int
        _ = rows.Scan(&a, &b, &c)
        // Process row
    }
}


Use channels, locks, etc when necessary, based on your use case.
",41492793
951,41522547,"You're forgetting to remove the IV. This means the IV gets ""decrypted"" as well, resulting in nonsense.

The nonsense seems to be interpreted as UTF-8, where a character may have a multi-byte encoding, so the size of the IV you print out may differ somewhat.

So remove the IV, and try printing out hexadecimals when debugging binary values.
",41521671
952,41592747,"AD HOC polymophism

Ad hoc polymorphism is a general way of polymorphism implementation for statically typed languages. Polymorphism in Go is ad hoc polymorphism which is very close to Bjarne's Stroustrup definition:


  Polymorphism – providing a single interface to entities of different types.


Interfaces

Go interface is really powerful tool designed specially for polymorphism implementation. Interface is a type abstraction (sets of methods) which provides a way to specify the behavior of an object: if something can do this, then it can be used here. Back to Straustrup's polymorphism definition: it is possible to use objects of different types as a type of a common interface if they implement the interface.

Playground with an example.

Parametric polyumorphism

Wiki:


  A function or a data type can be written generically so that it can handle values identically without depending on their type.


This kind of polymorphism is more regular for dynamically typed languages like Python or Ruby but Go implements it too! Go uses type empty interface interface{} for this purpose.

Type interface{}

From Tour Of Go:


  The interface type that specifies zero methods is known as the empty interface:
  
  interface{}
  An empty interface may hold values of any type. Every type implements at least zero methods.
  
  Empty interfaces are used by code that handles values of unknown type. For example, fmt.Print takes any number of arguments of type interface{}.


And it is possible to get particular type of an object with type assertion. 

And again Tour Of Go:


  A type assertion provides access to an interface value's underlying concrete value.


t := i.(T)


  This statement asserts that the interface value i holds the concrete type T and assigns the underlying T value to the variable t.


There we have parametric polymorphism with static duck typing.
",23211648
953,41613108,"Change the signature of your function to make it generic, and pass the slice as argument. The following should work:

func getDriversOrPilots(file string, slice interface{}) {
    raw, err := ioutil.ReadFile(file)
    if err != nil {
        fmt.Println(err.Error())
        os.Exit(1)
    }

    json.Unmarshal(raw, slice)
}

func getDrivers() []Driver {
    var d []Driver
    getDriversOrPilots(""/home/ubuntu/drivers.json"", &d)
    return d
}

func getPilots() []Pilot {
    var p []Pilot
    getDriversOrPilots(""/home/ubuntu/pilots.json"", &p)
    return p
}

",41612944
954,41647898,"
  You can write a helper view function like this


func replace(input, from,to string) string {
    return strings.Replace(input,from,to, -1)
}

funcMap = template.FuncMap{
        ""replace"":  replace,
}
template := template.New("""").Funcs(internalFuncMap)


and use the template to render the view.


  code ref links



https://github.com/sairam/kinli/blob/master/template_funcs.go#L57-L59
https://github.com/sairam/kinli/blob/master/templates.go#L48

",41647788
955,41665303,"This does what you want:

pwr := bson.Binary(msg[""pwr""].(bson.Binary)).Data


But assumes msg[""pwr""] can't be anything other than a bson.Binary... if that's not an invariant you should do the type assertion first (handle the possible type mismatch case when it happens) and then cast to get the Data field.
",41616043
956,41721291,"I have been working on some patch for restruct.io to be able to work with bitfields .... Still not fully tested but seems to work ... 

Will try to send a pull request once tested ... 

func (e *encoder) writeBits(f field, inBuf []byte) {

    var inputLength uint8 = uint8(len(inBuf))

    if f.BitSize == 0 {
        // Having problems with complex64 type ... so we asume we want to read all
        //f.BitSize = uint8(f.Type.Bits())
        f.BitSize = 8 * inputLength
    }

    // destPos: Destination position ( in the result ) of the first bit in the first byte
    var destPos uint8 = 8 - e.bitCounter

    // originPos: Original position of the first bit in the first byte
    var originPos uint8 = f.BitSize % 8
    if originPos == 0 {
        originPos = 8
    }

    // numBytes: number of complete bytes to hold the result
    var numBytes uint8 = f.BitSize / 8

    // numBits: number of remaining bits in the first non-complete byte of the result
    var numBits uint8 = f.BitSize % 8

    // number of positions we have to shift the bytes to get the result
    var shift uint8
    if originPos > destPos {
        shift = originPos - destPos
    } else {
        shift = destPos - originPos
    }
    shift = shift % 8

    var inputInitialIdx uint8 = inputLength - numBytes
    if numBits > 0 {
        inputInitialIdx = inputInitialIdx - 1
    }

    if originPos < destPos {
        // shift left
        carry := func(idx uint8) uint8 {
            if (idx + 1) < inputLength {
                return (inBuf[idx+1] >> (8 - shift))
            }
            return 0x00

        }
        mask := func(idx uint8) uint8 {
            if idx == 0 {
                return (0x01 << destPos) - 1
            }
            return 0xFF
        }
        var idx uint8 = 0
        for inIdx := inputInitialIdx; inIdx < inputLength; inIdx++ {
            e.buf[idx] |= ((inBuf[inIdx] << shift) | carry(inIdx)) & mask(idx)
            idx++
        }

    } else {
        // originPos >= destPos => shift right
        var idx uint8 = 0
        // carry : is a little bit tricky in this case because of the first case
        // when idx == 0 and there is no carry at all
        carry := func(idx uint8) uint8 {
            if idx == 0 {
                return 0x00
            }
            return (inBuf[idx-1] << (8 - shift))
        }
        mask := func(idx uint8) uint8 {
            if idx == 0 {
                return (0x01 << destPos) - 1
            }
            return 0xFF
        }
        inIdx := inputInitialIdx
        for ; inIdx < inputLength; inIdx++ {
            //note: Should the mask be done BEFORE the OR with carry?
            e.buf[idx] |= ((inBuf[inIdx] >> shift) | carry(inIdx)) & mask(idx)

            idx++
        }
        if ((e.bitCounter + f.BitSize) % 8) > 0 {
            e.buf[idx] |= carry(inIdx)
        }
    }

    //now we should update buffer and bitCounter
    e.bitCounter = (e.bitCounter + f.BitSize) % 8

    // move the head to the next non-complete byte used
    headerUpdate := func() uint8 {
        if (e.bitCounter == 0) && ((f.BitSize % 8) != 0) {
            return (numBytes + 1)
        }
        return numBytes
    }

    e.buf = e.buf[headerUpdate():]

    return
}

",41104049
957,41725497,"The Insert function should periodically rebalance the tree, as an imbalanced tree may lead to very uneven traversal times.  As a result, Insert should generally be slower that Contains.

If your Insert function does not rebalance the tree, then the time required for any given function become O(n) worst case instead of O(log n) and fairly unpredictable.

In addition, when talking about O(...) time complexity, we're generally talking about worst case behavior.  If you time single calls, then any given call may take (much) less time than the worst case -- for example, Contains looking for the node that happens to be the root will return immediately regardless of the size.
",41725118
958,41731291,"You can use struct sockaddr*:

void printPointer(struct sockaddr_any *pp) {
    struct sockaddr *p = pp->addr;
    printf("":: %p :: "", p); 
}


since sockaddr_any is defined as:

struct sockaddr_any {
   struct sockaddr addr;
   char pad[sizeof(union sockaddr_all) - sizeof(struct sockaddr)];
};

",41728874
959,41731636,"Using Laszlo answer, there is a simple solution for my problem. It isn't because the definition of the structure sockaddr_any isn't accessible in my context (there's no simple way to access the addr field) that we can't cast the pointer. So, I can simply do: 

// #include 
// void printPointer(struct sockaddr_any *p){
//     struct sockaddr *usable_pointer = (struct sockaddr *) p; 
// }
import ""C""


Then, I can use usable_pointer as any other sockaddr variable. 

Thank you very much
",41728874
960,41735501,"This could be happening because of your mac doesn't have a c compiler that can cross compiler to the target OS. I tried it on a Linux OS and it compiles without any issues. there was an issue on git about it last year and it's still open till today. I would suggest compiling it directly on the target OS. If you look throught the code in 

github.com/go-gl/gl/v2.1/gl/conversions.go


you will notice that it import ""c"" meaing it will require a C compiler that is compartible with the target OS.
",41733469
961,41784931,"func (t Time) Add(d Duration) Time


https://golang.org/pkg/time/#Time.Add
",41784825
962,41785015,"You are asigning a string to t (the result of calling Format) instead of a Time (the result of calling Now). Here's an working example:

package main

import (
    ""fmt""
    ""time""
)

func main() {
    t := time.Now()
    fmt.Println(t.Format(time.RFC3339))

    t = t.Add(time.Second)
    fmt.Println(t.Format(time.RFC3339))
}

// prints
// 2017-01-21T16:51:31-05:00
// 2017-01-21T16:51:32-05:00

",41784825
963,41790923,"So I found how to add back-reference.
I created two files in the same package containing the models, and added  Associations with the same join-table for the many2many.

tag.go :

type Tag struct {
    ID      uint    `gorm:""primary_key"" json:""id,omitempty""`
    Name    string  `gorm:""not null;unique"" json:""name,omitempty""`
    Gifs    []Gif `gorm:""many2many:gif_tags;"" json:""gifs,omitempty""`
}


and gif.go :

type Gif struct {
    ID      uint    `gorm:""primary_key"" json:""id,omitempty""`
    Url     string `gorm:""not null;unique"" json:""url,omitempty""`
    Tags    []Tag `gorm:""many2many:gif_tags;"" json:""tags,omitempty""`
}


They need to be in separate files.

Now I can access easily all the gifs matching a Tag and vice-versa.
",41789498
964,41837749,"In searching for an answer to this question, I found https://github.com/asaskevich/govalidator, which was tied to this blog post which describes creating an input validator: https://husobee.github.io/golang/validation/2016/01/08/input-validation.html. Just in case someone is looking for a quick library on doing this, I thought it would be useful to put that tool in an easy-to-find place.

This package uses the same method for isJSON that William King suggests, as follows:

// IsJSON check if the string is valid JSON (note: uses json.Unmarshal).
func IsJSON(str string) bool {
    var js json.RawMessage
    return json.Unmarshal([]byte(str), &js) == nil
}


This package gave me some greater insight into JSON in go, so it seemed useful to put here.
",22128282
965,41839169,"(for MAC)

I tried all these answers and, for some still unknown reason, none of them worked.

I had to ""force feed"" the GOPATH by setting the environment variable per every command that required it. For example:

sudo env GOPATH=$HOME/goWorkDirectory go build ...


Even glide was giving me the GOPATH not set error. Resolved it, again, by ""force feeding"":
    I tried all these answers and, for some still unknown reason, none of them worked.

I had to ""force feed"" the GOPATH by setting the environment variable per every command that required it.

sudo env GOPATH=$HOME/goWorkDirectory glide install


Hope this helps someone.
",20628918
966,41858792,"You do not check for any error when calling the api. Thus the error when trying to close a response that never arrived.

This code does not panic:

package main

import (
    ""fmt""
    ""net/http""
)

func main() {
    requests := 10000
    ch := make(chan string, requests)
    for i := 1; i <= requests; i++ {
        go func(iter int) {
            fmt.Println(iter)
            resp, err := http.Get(""http://localhost:8080/api/project"")
            if (err == nil) {
              resp.Body.Close()
            }
            ch <- fmt.Sprint(iter)
        }(i)
    }
    for i := 1; i <= requests; i++ {
        fmt.Println(<-ch)
    }
}

",41858635
967,41887654,"When iterating over a map with a range loop, the iteration order is not specified and is not guaranteed to be the same from one iteration to the next.

You can't surely print by newest without storing key somewhere else.

Read this: doc

You can store key and maintain order. See this

Again, if you want to print in reverse order. Iterate array in reverse order.
",41887596
968,41908127,"I'm sorry guys but I'm not convinced that this code in Go is really working as expected. I'm not an expert, so please correct me if I'm wrong. First of all it prints z which it seems is a current value of it in global scope (usually k*1000) https://play.golang.org/p/a4TJyjKBQh

// test.go
package main
import (
  ""fmt""
  ""time""
)

func main() {

  for z:=0; z<1000; z++ {
    go func(x int) { // I'm passing z to the function with current value now
      fmt.Println(x) 
    }(z)
  }

  time.Sleep(1 * time.Nanosecond)

}


And also if I comment out Sleep the program will exit before even starting any goroutines (at least it doesn't print out the results). I would be happy to know if I'm doing something wrong, but from this simple example it seems the problem is not with Elixir, but Go code provided. Some Go gurus out there?

I've also run some test on my local machine:

go run test.go 500 | wc -l
72442 # expected 500000
go run test.go 5000 | wc -l
76274 # expected 5000000

",41894046
969,41914615,"Instead of calling r.FormFile(), you could instead try:

mpr, _ := r.MultipartReader()
filePart, _ := r.NextPart()
fileName := filePart.FileName()


However, I would check the errors :)
",41908120
970,41950775,"When you find yourself trying to iterate over an array inside a ReQL query, it is often easier or necessary to use built-in ReQL operations such as Map or ConcatMap.

In this case, Contains seems to be the operation you want. Try something like:

(...).Filter(func(post r.Term) interface{}{
    r.Expr(listOriginID).Contains(post.Field(""OriginID""))
})

",41943744
971,42048039,"The receiver node is passed by value just like other parameters, so any changes you make in the function are not seen by the caller. If you want a function to modify something that exists outside the function, the function needs to be dealing with a pointer to that object. In your case, node is a pointer, but what you really want is a pointer to something that represents the list itself. For example:

package main

import (
    ""fmt""
)

type LinkedListNode struct {
    data int
    next *LinkedListNode
}

type LinkedList struct {
    head *LinkedListNode
}

// InsertList will insert a item into the list
func (list *LinkedList) InsertList(data int) {
    newHead := &LinkedListNode{data, list.head}
    list.head = newHead
}

func main() {
    var list LinkedList
    list.InsertList(4)
    fmt.Printf(""node = %+v\n"", list.head)
    list.InsertList(7)
    fmt.Printf(""node = %+v\n"", list.head)
}

",42047889
972,42048111,"Think of it like this: every variable must be stored at some location in memory, and you can use a pointer to store that location rather than just the variable itself.

To get or set the value at that location using the pointer, you need to use the ""indirection"" operator. For example, *node will get the LinkedList at the location that node points to, and *node = newHead will set the LinkedList at the location that node points to.

You can also point the pointer to a new memory location, but that change will only be visible in the current scope. In your case, that means node = &newHead only affects the node pointer in InsertList, not the node pointer in main.

Here's a simpler example using normal functions, though the same rules apply for methods:

// Changes the value `x` points to
func modifyValue(x *int) {
    fmt.Printf(""  modifyValue: x=%3d @ %p\n"", *x, x)
    *x = 1
    fmt.Printf(""  modifyValue: x=%3d @ %p\n"", *x, x)
}

// Changes the pointer `x` itself
func modifyPointer(x *int) {
    fmt.Printf(""modifyPointer: x=%3d @ %p\n"", *x, x)
    n := 1
    x = &n
    fmt.Printf(""modifyPointer: x=%3d @ %p\n"", *x, x)
}

func main() {
    x := 200
    fmt.Printf(""         main: x=%3d @ %p\n\n"", x, &x)
    modifyPointer(&x)
    fmt.Printf(""         main: x=%3d @ %p\n\n"", x, &x)
    modifyValue(&x)
    fmt.Printf(""         main: x=%3d @ %p\n\n"", x, &x)
}


Output:

         main: x=200 @ 0x1040e0f8

modifyPointer: x=200 @ 0x1040e0f8
modifyPointer: x=  1 @ 0x1040e134
         main: x=200 @ 0x1040e0f8

  modifyValue: x=200 @ 0x1040e0f8
  modifyValue: x=  1 @ 0x1040e0f8
         main: x=  1 @ 0x1040e0f8


Playground link
",42047889
973,42051365,"Just change the value reference argument point to

func (node *LinkedList) InsertList(data int) {
    newHead := LinkedList{data, node}
    *node = newHead   //<- dereference here 
}

",42047889
974,42069690,"You pass an anonymous function value to once.Do() (which is Once.Do()), and the return statements are inside that. Which means those return statements want to return from the anonymous function, but it doesn't have any return values:

func Config() (*ConfigMap, error) {
    once.Do(func() {
        // You can't return any values here, only this works:
        return
    })

    // And you do need to return something here:
    return &ConfigMap{}, nil
}


What you may do is create global variables matching the return values of Config(), and the anonymous function should store the values in them. And in Config() you may return the values of these global variables.

var cm *ConfigMap
var cmErr error

func Config() (*ConfigMap, error) {
    once.Do(func() {
        // load config, and store, e.g.
        cm, cmErr = &ConfigMap{}, nil
    })

    return cm, cmErr
}


Do we really need global variables? Since the values returned by Config() are produced by the anonymous function passed to once.Do() which is guaranteed to run only once, yes, you need to store them somewhere to be able to return them multiple times, even when the anonymous function is not called / run anymore (on subsequent calls to Config()).

Question: May there be a data race here?

If Config() is called from multiple goroutines, at least one will write the global variables cm and cmErr, and all will read them. So it's rightful to ask this question.

But the answer is no, the above code is safe. The global variables cm and cmErr are only written once, and this happens before they could be read. Because once.Do() blocks until the anonymous function returns. If Config() (and thus once.Do()) is called simultaneously from multiple goroutines, all will block until the anonymous function completes (once only), and reading the variables can happen only after the first write. And since the anonymous function will not run anymore, no more writes will happen.
",42069615
975,42069743,"You're calling return nil, err and similar from the nested func() inside your once.Do. Conversely, you're not returning from the actual function.

Instead, you can structure your code like this:

func newConfig() (*Config, error) {
    configFilePath, err := filepath.Abs(""../build/app.conf"")
    if err != nil {
        return nil, err
    }

    // Load app.conf
    cfg, err := ini.Load(configFilePath)
    if err != nil {
        return nil, err
    }

    // Get app mode
    mode, err := AppMode()
    if err != nil {
        return nil, err
    }

    c := &ConfigMap{}
    err = cfg.Section(mode).MapTo(c)
    if err != nil {
        return nil, err
    }

    return c, err
}

// Cached config and any error.
var (
   cachedConfig *Config
   cachedConfigErr error
)

func Config() (*Config, error) {
  once.Do(func() {
    cachedConfig, cachedConfigErr = newConfig()
  })
  return cachedConfig, cachedConfigErr
}

",42069615
976,42170463,"Alternative solution: use sed to insert additional field into the generated parser. Then, in your grammar action, assign the value.

go tool yacc -o parser.go -p Filter parser.y
sed -i '/type FilterParserImpl struct/a tree *treeNode' parser.go


The generated parser:

type FilterParserImpl struct {
tree *treeNode
    lval  FilterSymType
    stack [FilterInitialStackSize]FilterSymType
    char  int
}


Grammar action:

filter { Filterrcvr.tree = $1 }

",36822702
977,42197509,"From https://golang.org/pkg/regexp/:


  Find(All)?(String)?(Submatch)?(Index)?
  
  If 'All' is present, the routine matches successive non-overlapping
  matches of the entire expression. Empty matches abutting a preceding
  match are ignored. The return value is a slice containing the
  successive return values of the corresponding non-'All' routine. These
  routines take an extra integer argument, n; if n >= 0, the function
  returns at most n matches/submatches.

",42197468
978,42324497,"I see 3 choices:

0) Inconsistent Snapshot This is what you have: Your map is changing as you generate keys, so you get what you get. I'm not entirely sure your locking is correct. It looks really suspicious to me.  Test it extensively with the race detector, of course.

1) ""Stop The World"" - You can block write access to your map while you generate all the keys. Generating keys is much quicker than processing the items, and will give you a perfect consistent snapshot of the items to process. Unfortunately, when you send the keys to co-routines, those keys may not exist by the time you get around to processing it.  It sounds like you are OK with that.  It does require storing a copy of all the keys, so hopefully this is OK.

2) Roll your own MVCC (Multi-Version Concurrency Control) - Instead of using 1 map, use 2. Let's call them A and B. The idea is to only write to the first map while you process the second map, then flip roles.


Next to your RW Lock, add a boolean to protect your maps.
Take out your RW lock as normal, but then consult BOTH maps.
When the boolean is true, Read/Write from A, but allow reads to ""fall back"" to B if not found in A.
when the boolean is false, Read/Write from B, but allow reads to ""fall back"" to A if not found in B.


When it's time to start your background jobs, just take out a RW lock, while you flip the boolean.  Now you can iterate over the keys of the ""fall back"" map, calling a gouroutine for each one. The key is guaranteed to exist, since nobody is writing to that map.

You can delete from B in the goroutine (requires using locking when reading and again while deleting).

But it might be better/simpler to just process all the entries with NO locking (since everything is just reading), then wait for all the goroutines to be done, then wipe out B by doing ""B = make()"" to get an empty map. This will free up all your memory at once, and save some accounting that needs to be done after ever delete.

Once you wipe the map (or have deleted all the entries), you can take the RW lock while you flip the boolean the other way, then start processing the other map.

The downside is that you will end up with 2 copies of the map if you update items frequently.  If this is the case: 1) have WRITES check the fallback map. If it's there, update it, otherwise update the main map. 2) Delete the item from the map BEFORE background processing. (You can't use the bulk delete trick.)
",38000646
979,42365070,"At this point the documentation is a little bit hard to order. I am going to link the important topics to the hugo documentation so that you are able to read more details. After looking to your Content Organisation there are two Sections:


blog-folder-1
blog-folder-2


So inside your theme you are able to define one template for each section. If there is no template provided hugo uses the default.

So inside your layouts folder there is that logic: /layouts/SECTION/LAYOUT.html

For your case you can define a default layout. When for example blog-folder-2 needs another template your structure would look like this:

layouts/
  ▾ _default/
      single.html
  ▾ blog-folder-2/
      single.html


If you want to filter out one section inside a list, you need to use the page variables. 

At that points where you are ranging over the sites you can add a where clause:

 {{ range $i, $p := (.Paginate (where .Data.Pages ""Section"" ""!="" ""blog-folder-2"")).Pages }}

",42357204
980,42377440,"To recurse down a hierarchy, use a named template that executes itself.  In the following example, the template ""replies"" executes ""replies"" to display sub-replies: 

{{define ""main""}}
                                              
  {{.Title}}  
  {{.Body}}
  {{template ""replies"" .Replies}}

{{end}}

{{define ""replies""}}
   {{if .}}
      
      {{range . }}                                  
                                                  
                                             
             {{.Title}}   
           
           {{.Body}}
           {{template ""replies"" .Replies}}
         
      {{end}}
      
   {{end}}
{{end}}


Playground Example
",42375121
981,42377447,"You just have defined a recursive data type. You can render it by defining a recursive template:

{{define ""replies""}}
  
    {{ range $key, $value := . }}
      
        
          {{ $value.ID }}
        
        {{ $value.PostNum }}
      

      {{template ""replies"" .Replies}}
    {{end}}
  
{{end}}


  {{ .Title  }}
  {{ .Body  }}

  {{ template ""replies"" .Replies }}


",42375121
982,42396801,"Ok, after digging around a bit I got the whole thing working as follows

manifest.yml

---
applications:
- name: prometheus
  instances: 1
  buildpack: https://github.com/cloudfoundry/go-buildpack.git
  command: prometheus
  env:
    GOPACKAGENAME: github.com/prometheus/prometheus
    GO_INSTALL_PACKAGE_SPEC: github.com/prometheus/prometheus/cmd/prometheus
  memory: 1000M


BUT in order to listen on the right port, the only solution I could find is adding the following to the cmd/prometheus/config.go file to the beginning of the init() function

port := "":9090""
if s := os.Getenv(""PORT""); s != """" {
    port = "":""+s
}


and then changing the following part (also in the init() function)

cfg.fs.StringVar(
    &cfg.web.ListenAddress, ""web.listen-address"", "":9090"",
    ""Address to listen on for the web interface, API, and telemetry."",
)


to

cfg.fs.StringVar(
    &cfg.web.ListenAddress, ""web.listen-address"", port,
    ""Address to listen on for the web interface, API, and telemetry."",
)


After that you can simply deploy the application with cf push and everything should work as a charm
",42377057
983,42408164,"You could try through ssh, if your public ssh key is registered on coding.net.

See ""go get for private repos in docker"" as an example:

FROM golang:1.6

RUN echo ""[url \""git@github.com:\""]\n\tinsteadOf = https://github.com/"" >> /root/.gitconfig
RUN mkdir /root/.ssh && echo ""StrictHostKeyChecking no "" > /root/.ssh/config
ADD .  /go/src/github.com/company/foo
CMD cd /go/src/github.com/company/foo && go get github.com/company/bar && go build -o /foo


with the build step:

docker build -t foo-build .
docker run --name=foo-build -v ~/.ssh/id_rsa:/root/.ssh/id_rsa foo-build
docker cp foo-build:/foo foo
docker rm -f foo-build
docker rmi -f foo-build 

",42406445
984,42412985,"The element type of the slice is interface{}, so a composite literal needs an additional pair of braces: []interface{}{}.

In case of slice of slices:

toReturn := [][]interface{}{}


Or when using make(), you specify a type (and not a composite literal):

toReturn := make([][]interface{}, 0, len(map_))

",42412935
985,42412988,"You're creating an instance, not defining a type, so you need an extra pair of curly braces to initialize the variable:

toReturn := [][]interface{}{}

",42412935
986,42416871,"Prometheus is a TSDB. And it is intended to consume gigabytes and gigabytes of data.

On a Cloud Foundry platform, you are limited by available resources. 
So, why deploy Prometheus to Cloud Foundry?

Why not spin up a standalone bosh director and deploy Prometheus through the director as a Bosh deployment, and a standalone. Then inject it as a CUPS into Cloud Foundry?

I am just curious and trying to understand the use case.
",42377057
987,42473964,"No, there is not. The Go language specification specifies this clearly:


  Exported identifiers
  
  An identifier may be exported to permit access to it from another package. An identifier is exported if both:
  
  
  the first character of the identifier's name is a Unicode upper case letter (Unicode class ""Lu""); and
  the identifier is declared in the package block or it is a field name or method name.
  
  
  All other identifiers are not exported.

",42473897
988,42516860,"When you close the run channel, case  will always trigger: listening on a closed channel returns a zero value immediately.

if you want to stop the goroutine, you should return after you get the  signal.

As a side note, your default: clause makes the for loop actively work, you should get rid of it (you will still be listening on both channels)
",42516717
989,42517082,"Here's an isolated commented runable version of how such a signaling system might be implemented.

package main

import (
    ""time""
    ""log""
)

func main() {
    statusChannel := make(chan bool)
    go applicationLoop(statusChannel)

    // reasonably random outcome for testing
    if time.Now().Unix() % 2 == 0 {
        statusChannel<-true
    } else {
        statusChannel<-false
    }

    for {
        // busy loop for testing
        time.Sleep(1000)
    }
}

func applicationLoop(statusChannel chan bool) {
    defer close(statusChannel)
    for {
        log.Printf(""waiting for signal...\n"")
        shouldContinue := <-statusChannel
        if !shouldContinue {
            log.Print(""received false, breaking...\n"")
            break
        }
        // run your code here
        // you should use a second channel to return results, as the channel is not buffered
        log.Print(""working...\n"")
    }
}


Do note that sending a value to statusChannel while is is not listening for a value will make the example blow up in your face. Either use a buffered channel or a channel that signals back to main when the goroutine is back to listening for a signal.
",42516717
990,42518866,"This problem has two parts. 

First we need to stop child goroutines somehow in a way that even if a parent goroutines stops, all it's children should get notified and stop - a hierarchy of stop signals that goes down but not up.

On the other hand the parent needs to wait for it's children until they are done. Otherwise we would return from a goroutine or even exit from the app before some goroutines are finished properly.

For simplicity we ignore implementing error handling, timeouts and the like.

For handling the first problem we use context.Context which gives us a nice hierarchy of execution context handling tools and for solving the second problem we use sync.WaitGroup which allows us to wait for a group of goroutines to complete their tasks. A simple demonstration would be:

func main() {
    all := &sync.WaitGroup{}
    rootCtx, rootCancel := context.WithCancel(context.Background())

    all.Add(1)
    go level1(rootCtx, all)

    // just to simulate stop, we could use an os signal instead
    // app ends after 3 seconds
    go func() {
        time.Sleep(time.Second * 3)
        rootCancel()
    }()

    all.Wait()
}

func level1(parent context.Context, all *sync.WaitGroup) {
    defer all.Done()
    l1Ctx, l1Cancel := context.WithCancel(parent)
    defer l1Cancel()

    for i := 0; i < 3; i++ {
        all.Add(1)
        go level2(l1Ctx, all)
    }

    for {
        select {
        case <-parent.Done():
            return
        // other cases if any,
        // this is a sample
        case <-time.After(time.Second):
            log.Println(`level1`)
        }
    }
}

func level2(parent context.Context, all *sync.WaitGroup) {
    defer all.Done()
    for {
        select {
        case <-parent.Done():
            return
        case <-time.After(time.Second):
            log.Println(`level2`)
        }
    }
}


Which gives us some output like:

[  info ] level2
[  info ] level2
[  info ] level2
[  info ] level1
[  info ] level2
[  info ] level1
[  info ] level2
[  info ] level2


Currently there is no official package that provide a functionality which combines context.Context and sync.WaitGroup. The nearest thing is an errgroup which can resemble this functionality with some hacks.
",42516717
991,42529742,"As for just about any resource (and a connection is no different), a user should call the functions to return resources to the system after use. Most users understand this across languages and architectures, so I don't see why your package users should have any concern. Go addresses this problem very elegantly by including the defer statement which makes it very easy to provide for releasing a resource.
",42526950
992,42566899,"Simple answer: no.  Elements placed on a Go channel can only be read once, regardless of how many goroutines are trying to read off the channel at the same time, and that applies regardless of whether the channel is buffered or not.  There's no possibility that an element will be read by two different goroutines unless that element was sent to the channel more than once.  The only thing that buffering does, with regards to channel semantics, is remove the necessity for the read and write to occur synchronously.
",42566116
993,42580794,"
  In other words, could different go routine grab the same elem in the channel, or while one go routine is reading the buffer, the other go routines already read and processed some of the elements? 


Nope...

I believe a misunderstanding is in difference between non-blocking and thread safe concepts.

Non blocking (buffered) channels


  Sends to a buffered channel block only when the buffer is full.


Buffered channels just like it said have buffers to store some amount of items. It allows reading goroutine to read without await for writing goroutine put an item to a channel on condition something already written to a channel. If a channel unbuffered it can contain just single item therefore it requires to block channel for writing before a written item be withdrawn. ""Blocking/non-blocking"" concept doesn't related to ""thread safe"" concept and non-blocking doesn't mean not thread safe.

Thread safety of Go channels

Go channels are thread safe in all available ways of use. Channel is a reference type so once allocated with make channel could be passed by value because it has implicit pointer to a single memory slot. Obviously contained in a channel item never be copied and couldn't be read twice. 
",42566116
994,42633344,"Have a look at the present tool, it does a similar thing using flat files and might even be useful for you.

https://godoc.org/golang.org/x/tools/present
",42631255
995,42706064,"with 2 channels, this work:

package main

import (
    ""fmt""
    ""time""
)

var ch chan int = make(chan int)
var ch2 chan int = make(chan int)
var counter int

func main() {
    go sub()

    for i:=0; i < 10000; i++ { //change to 10000
        go con()
    }

    time.Sleep(1000 * time.Millisecond)

    ch2 <- 0
    fmt.Println(<- ch2)
    //fmt.Println(counter) //uncomment this
}

func sub() {
    for ;; {
        select {
        case <- ch:
            counter++
        case <- ch2:
            ch2 <- counter
        }
    }
}

func con() {
    for i := 0; i < 10000; i++ {
        ch <- 1
    }
}

",42705505
996,42726688,"(Not something) OR (not something else mutually exclusive) is always going to be true isn't it?

If it is method post, it will not be delete and vice versa , you might want && ?
",42726635
997,42728004,"Better to use AddDate for time calculations greater than 24 hours:

package main

import (
    ""fmt""
    ""time""
)

func AddWorkDays(t time.Time, workdays int) time.Time {
    curDate := t
    for curWorkdays := 0; curWorkdays <= workdays; {
        curDate = curDate.AddDate(0, 0, 1)
        if curDate.Weekday() != 6 && t.Weekday() != 7 {
            curWorkdays++
        }
    }
    return curDate
}

func main() {
    now := time.Now()
    workdays := 3
    t := AddWorkDays(now, workdays)
    fmt.Printf(""  now %-9v %v\n"", now.Weekday(), now)
    fmt.Printf(""later %-9v %v\n"", t.Weekday(), t)
}


Output on day I'm answering:

  now Friday    2017-03-10 21:33:28.395198671 +0000 UTC
later Wednesday 2017-03-15 21:33:28.395198671 +0000 UTC

",31327124
998,42732778,"Like Kenny Grant said, you might want to ponder about the logic. Perhaps this is what you meant:

// only allow POST or DELETE
if req.Method != http.MethodPost && req.Method != http.MethodDelete {
    http.Error(res, http.StatusText(http.StatusMethodNotAllowed), http.StatusMethodNotAllowed)
    return
}

",42726635
999,42745121,"In principle, yes it is bad, however you would need to decide whether the risks outweigh the cost in your specific case as the work required can be quite extensive.

No matter the language used employing the model 'Never trust the client' tends to provide the best security. In this model you assume all requests are malicious therefore should be validated and sanitized. This allows you to gain confidence in the data you are storing, and in principle protects against changing requirements. For example; if you are presenting this stored data back to the users then you can have some trust that nothing malicious is stored, however this should not mean output encoding is not also used.

The final point to consider is how you are accessing the DB and creating the inserts. Assuming this is a SQL DB then ensure your query uses named parameters rather than string concatenation.
",42730854
1000,42758241,"multipart.File implements io.Reader interface so you could copy its content into a bytes.Buffer like this:

file, header, err := ctx.Request.FormFile(""file"")    
defer file.Close()
if err != nil {
    return nil, err
}

buf := bytes.NewBuffer(nil)
if _, err := io.Copy(buf, file); err != nil {
    return nil, err
}


and then add to your app

app.SetFile(buf.Bytes())

",42758054
1001,42758492,"You need to pass a context to bulkRequest.Do().

From the olivere/elastic Github page (abbreviated);

// Create a context
     ctx := context.Background()
     bulkRequest.Do(ctx)

",42758392
1002,42761887,"Stable HEAD philosophy

It is not possible with pure go get. 


  Go takes the most minimal and pragmatic approach of any package manager. There is no such thing as multiple versions of a Go package.


But this is not as bad as it seems at the first view because there exists a philosophy behind this behavior.


  As a package author, you must adhere to the stable HEAD philosophy. Your default branch must always be the stable, released version of your package. You must do work in feature branches and only merge when ready to release.


This approach is forced by go get limitations and it should be treated like Python indentations - it is kind of philosophy forced by language design.

Development approaches

If you want to fork something or try new features you can clone repo then switch to a desired branch and do go build. This way shouldn't go to production.

git clone 
cd 
git checkout 
go build


Also you can use third party package management tools. But most of them support tags and revisions, not branches (since it is implied that you don't need to install feature branch).

gpm:


  You can specify packages with the   format, where version can be a revision number (a git/bazaar/mercurial/svn revision hash) or a tag.

",42761820
1003,42766877,"you can use gopkg.in, it will redirect to github.

There are two URL patterns supported:

gopkg.in/pkg.v3      → github.com/go-pkg/pkg (branch/tag v3, v3.N, or v3.N.M)
gopkg.in/user/pkg.v3 → github.com/user/pkg   (branch/tag v3, v3.N, or v3.N.M)


go get gopkg.in/pkg.v3 means go get github.com/go-pkg/pkg, but is branch or tag v3.*. 

for more details, see here
",42761820
1004,42770327,"If err implements the Error interface, then the Error() method will be invoked implicitly when using a valid format verb such as %s. The documentation for fmt has more on this.
",42770022
1005,42770341,"Both versions are completely fine.

The fmt package has special support for the error interface (scroll down a couple screens from this link):


  
  If an operand implements the error interface, the Error method will be invoked to convert the object to a string, which will then be formatted as required by the verb (if any).
  


Your second version will probably run faster as it can avoid most of the special assertions the fmt package does, but the difference shouldn't be noticeable in most cases.

In general you should probably prefer the first version, which is more readable, especially with more arguments.
",42770022
1006,42780150,"Another option would be to use Google's gopacket package which provides packets decoding for Go. In particular, the layers sub-package provides logic for decoding protocol packets, among which what is necessary to decode DNS packets.
",20845256
1007,42798467,"You just use net/http in most instances:


  Starting with Go 1.6, the http package has transparent support for the HTTP/2 protocol when using HTTPS.
  
  The http package's Transport and Server both automatically enable HTTP/2 support for simple configurations. To enable HTTP/2 for more complex configurations, to use lower-level HTTP/2 features, or to use a newer version of Go's http2 package, import ""golang.org/x/net/http2"" directly and use its ConfigureTransport and/or ConfigureServer functions. Manually configuring HTTP/2 via the golang.org/x/net/http2 package takes precedence over the net/http package's built-in HTTP/2 support.

",42798419
1008,42842803,"After some testing I manage to get it, I was sending the wrong parameter to the function I change it to this

var paramVar comments
handleReadAll(""/getsome"",paramVar)

func handleReadAll(getPath string,structToDecodeArray interface{}){
      var someVar = reflect.ValueOf(structToDecodeArray).Interface()
}


That would be the equivalent variable as type Interface of the parameter passed to the function just like having 

var someVar comments 

",42841854
1009,42881490,"The docs for the fmt package have this to say:


  Except when printed using the verbs %T and %p, special formatting
  considerations apply for operands that implement certain interfaces.
  In order of application:
  
  ...
  
  If the format (which is implicitly %v for Println etc.) is valid for a
  string (%s %q %v %x %X), the following two rules apply:
  
  
  If an operand implements the error interface, the Error method will be invoked to convert the object to a string, which will then be
  formatted as required by the verb (if any).
  If an operand implements method String() string, that method will be invoked to convert the object to a string, which will then be
  formatted as required by the verb (if any).
  


In other words, fmt.Println will attempt to print the string representation of the interface. Since the error interface is satisfied by binFunc, it invokes the Error method of binFunc.
",42881328
1010,43040753,"There are several things to be aware of when using depends_on:


depends_on will not wait for db and redis to be “ready” before starting web - only until they have been started. If you need to wait for a service to be ready, see Controlling startup order for more on this problem and strategies for solving it.


Version 3 no longer supports the condition form of depends_on.

The depends_on option is ignored when deploying a stack in swarm mode with a version 3 Compose file.

",43039501
1011,43042558,"This is stupid I wrote the depends_on not in order I fix the issue writing the order like this : 

depends_on:
  - redis
  - db


Before this I wrote it dbfirst. and do not forget to change the host to appropriate name just like in the docker-compose.yml file. In this case is redis = redis and mongodb = db.

I forget that in app.go I call redis first then mongodb.
",43039501
1012,43080367,"Disclaimer: Unrelated to map[string]int but related to testing the equivalence of maps in Go, which is the title of the question

If you have a map of a pointer type (like map[*string]int), then you do not want to use reflect.DeepEqual because it will return false.

Finally, if the key is a type that contains an unexported pointer, like time.Time, then reflect.DeepEqual on such a map can also return false.
",18208394
1013,43107783,"I have solved this problem, because different postfix may have different fdm, though I have set fdm=syntax in .vimrc
",43086360
1014,43188798,"I found easier to do it like this:

export GOROOT=$HOME/go
export GOPATH=$GOROOT/bin
export PATH=$PATH:$GOPATH

",20628918
1015,43289614,"I think it might be the way you are defining your structs. Given the json you provided {Source: {ID:string, subId:string, Campaigns:[]{CampaignID:string, Status:string}}} your struct should look like something close to whats below.

type object struct {
    Source struct {
        ID        string     `db:""id""`
        SubId     string     `db:""sub_id""`
        Campaigns []compaign `db:""compaigns""`
    } `json:""source""`
}

type compaign struct {
    CampaignID string `db:""compaign_id""`
    Status     string `db:""status""`
}


Given the comments below.  Try obj := make(map[string]interaface{}) instead of the defining a struct.

Also taking a look at https://github.com/jmoiron/sqlx the struct should be using the db flag instead of json, so I changed it. You shouldn't have to marshal the data

example db.Select(&people, ""SELECT * FROM person ORDER BY first_name ASC"") Where &people is a reference to a struct. E.g var people PeopleStruct

Now I'm not famailar with your driver, but it should be the same, in that you pass a reference to a struct or interface with your query and it looks the data into that reference.  You don't normally have to unmarshall in the struct after the query.
",43284894
1016,43398959,"I found out the legacy system I'm working with was using an ASP.Net library called ServiceStack to serialize/deserialize my sphinx db, and it was using it's own custom JSV format, which the author of ServiceStack say as an optimized mix of JSON and CSV, but hasn't been adopted anywhere else as far as I can tell.  

So it looks like I'm going to either rewrite that library in Go, or more likely change the indexing algorithm to use JSON.
",43284894
1017,43408894,"Abstract function type

You can do it with dependency injection not using interfaces:

import (
    ""fmt""
    ""math""
)

type a func(float64) float64

func A(arg float64) float64 {
    return math.Pow(arg, 2)
}

func mock(arg float64) float64 {
    return math.Sqrt(arg)
}

func b(function a, arg float64) float64 {
    return function(arg)
}

func main() {
    fmt.Println(b(A, 2))
    fmt.Println(b(mock, 2))
}


Function is first class citizen in Go


  In programming language design, a first-class citizen (also type, object, entity, or value) in a given programming language is an entity which supports all the operations generally available to other entities. 


It means you can pass function as argument among other possibilities. And of course you can declare an abstract type based on function with concrete interface (Don't confuse with interface type)

Interface approach

You can make compositions using your functions

import (
    ""fmt""
    ""math""
)

// Declare an interface type with dependencies
type HGer interface {
    H(float64) float64
    G(float64) float64
}

// Declare a dependent type with embedded interface
type Dependent struct {
    HGer
}

func (d *Dependent) B(arg float64) float64 {
    return d.H(arg) * d.G(arg)
}

// Implement the interface for an actual program
type ImplHGer struct{}

func (i *ImplHGer) H(arg float64) float64 {
    return math.Pow(arg, 2)
}

func (i *ImplHGer) G(arg float64) float64 {
    return math.Sqrt(arg)
}

// Implement the interface for mock of dependencies
type MockHGer struct{}

func (i *MockHGer) H(arg float64) float64 {
    return float64(0)
}

func (i *MockHGer) G(arg float64) float64 {
    return float64(0)
}

func main() {
    // Use real implementation
    a := Dependent{new(ImplHGer)}
    // Use the mock
    b := Dependent{new(MockHGer)}
    fmt.Println(a.B(8)) // 181.01933598375618
    fmt.Println(b.B(8)) // 0
}


Embedding


  Including an anonymous field in a struct is known as embedding. In this case the Discount type is embedded in the PremiumDiscount type. All the methods of Discount are instantly available on the PremiumDiscount type. Furthermore those same methods can be hidden


It is possible to embed interface to struct to extend it's behavior or to be more specific - declare abstract dependency.
",43408646
1018,43425461,"You may use port 0 to indicate you're not specifying an exact port but you want a free, available port selected by the system:

http.ListenAndServe("":0"", nil)


The problem with this is that you won't be able to find out what port was assigned. So you need to create the net.Listener yourself (using the net.Listen() function), and manually pass it to http.Serve():

listener, err := net.Listen(""tcp"", "":0"")
if err != nil {
    panic(err)
}

fmt.Println(""Using port:"", listener.Addr().(*net.TCPAddr).Port)

panic(http.Serve(listener, nil))


Example output:

Using port: 42039


As you can see, you can access the assigned port from the net.Listener, from its net.Addr address (acquired by its Addr() method). net.Addr does not directly give access to the port, but since we created the net.Listener using tcp network stream, the net.Addr will be of dynamic type *net.TCPAddr (which we can acquire with a type assertion), which is a struct and has a field Port int.

Note that if you don't need the port in your application (e.g. you just want to display it for yourself), you don't need the type assertion, you can just print listener.Addr() (which will contain the port at the end):

fmt.Println(""Address:"", listener.Addr())


Example output:

Address: [::]:42039


Also don't forget to handle returned errors (http.ListenAndServe() in this case). In my example I simply passed it to panic() because http.LitenAndServe() and http.Serve() block if everything goes well (so they only return if there's an error, which I pass to panic()).
",43424787
1019,43425767,"To serve files via http, define a FileServer for a directory and route it to, for example, ""/assets/"" using http.Handle. Following setup should work for you:

directory structure:

├── assets/
│   ├── js
│   └── css
├── templates/
└── main.go


main.go

func main() {
    http.HandleFunc(""/"", rootHandler)
    http.Handle(""/assets/"", http.StripPrefix(""/assets/"", http.FileServer(http.Dir(""assets""))))
    http.ListenAndServe("":8080"", nil)
}

func rootHandler(w http.ResponseWriter, r *http.Request) {
    http.ServeFile(w, r, ""templates/index.html"")
}


in your template file:



",43425594
1020,43430711,"
rune is an alias for the type int32. It is intended to make programs clear about the cases when an integer value represents a code point.
Because the sequence of bytes 0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x2c, 0x20, 0xe4, 0xb8, 0x96, 0xe7, 0x95, 0x8c (which is a representation of the utf-8 string Hello, 世界) is a valid UTF-8 sequence.
While utf8.Valid accepts only array of bytes (there is no overloading in Go, so the ""only"" part is actually irrelevant), there are a few similar functions to check for validness: utf8.ValidRune and utf8.ValidString


I recommend reading an awesome article on the Go blog: Strings, bytes, runes and characters in Go, I believe after reading it and experimenting a bit you'll get answers to most of your utf8-related questions about Go.
",43430410
1021,43437945,"Why not use the built-in gob package to store your struct values?  

I use it to store different structures, one per line, in files.  During decoding, you can test the type conversion or provide a hint in a wrapper - whichever is faster for your given use case.

You'd treat each line as a buffer when Encoding and Decoding when reading back the line. You can even gzip/zlib/compress, encrypt/decrypt, etc the stream in real-time. 

No point in re-inventing the wheel when you have a polished and armorall'd wheel already at your disposal.
",43437729
1022,43438265,"Instead of using the Bytes method on reflect.Value which does not work as you initially intended, you can use either the strconv package or the fmt to format you fields.

Here's an example using fmt:

var s string
switch fi.Kind() {
case reflect.String:
    s = fmt.Sprintf(""%q"", fi.String())
case reflect.Int:
    s = fmt.Sprintf(""%d"", fi.Int())
case reflect.Slice:
    if fi.Type().Elem().Kind() != reflect.String {
        continue
    }

    s = ""[""
    for j := 0; j < fi.Len(); j++ {
        s = fmt.Sprintf(""%s%q, "", s, fi.Index(i).String()) 
    }
    s = strings.TrimRight(s, "", "") + ""]""
default:
    continue
}

sf := rv.Type().Field(i)
if _, err := fmt.Fprintf(file, ""%s=%s\n"", sf.Name, s); err!= nil {
    panic(err)
}


Playground: https://play.golang.org/p/KQF3CicVzA
",43437729
1023,43449991,"This is how I did it:

package main

import (
  ""fmt""
  ""os""
   ""bytes""
)
fun main() {
   filerc, err := os.Open(""filename"")
   if err != nil{
     log.Fatal(err)
   }
   defer filerc.Close()

   buf := new(bytes.Buffer)
   buf.ReadFrom(filerc)
   contents := buf.String()


  fmt.Print(contents) 

}    

",13514184
1024,43459325,"Fork the repo in GitHub, then add your fork as a remote in your working copy under a name other than origin, e.g. git remote add myfork git@github.org.... You can push your changes to your fork (git push myfork), then open a PR from your fork to the original.

Explicitly, the commands would something like this after you fork the original to your own account:

git remote add myfork https://github.com//.git
git push myfork


After which, you can submit the PR to the original. If your PR is accepted, you can then run these commands:

git remote remove myfork
git rebase master
git pull origin master


You can then delete your fork from your GitHub account. After which, go get -u will function as normal.

Any time you need to make new changes to the package, you can repeat this process.
",43459290
1025,43459894,"In the code given, you're only synchronizing your writes, not your reads; that means you still might read from the map while you're writing to it, which would be a race condition.

To make it thread-safe, you need to wrap both reads and writes in a concurrency structure - either using channels or a mutex - in order to ensure that only one thread is accessing it at any given time if it is a write operation. Multiple threads can safely read at the same time, as long as no thread is writing to it. RWMutex provides this functionality explicitly.
",43458792
1026,43485517,"You use os.TempDir() for that.
",43485414
1027,43549158,"Go won't interpret $HOME. Use an explicit path such as /home/username/Documents/TEST/Login/.
",43549116
1028,43602060,"func invokeHello(p *Person) {
    p.Hello()
}


p is type *Person,  *Joker implement interface Person, revert invokeHello to: 

func invokeHello(p Person) {
    p.Hello()
}


this will fix the second program.

I think you have misleading about golang interface type


  An interface type specifies a method set called its interface. A variable of interface type can store a value of any type with a method set that is any superset of the interface. Such a type is said to implement the interface.

",43601858
1029,43605883,"Fix

You can't use pointers to interface type.
That is the problem:    

func invokeHello(p *Person) {
    p.Hello()
}


Should be:

func invokeHello(p Person) {
    p.Hello()
}


Interface implementation

Types implement interfaces. If type has methods appropriate to a methods declared in an interface than the interface is implemented by the type. 


  Interfaces in Go provide a way to specify the behavior of an object: if something can do this, then it can be used here.


Types vs pointers to a types

Type and *Type are different types. For example *Type could implement an interface but Type can not implement it. But *InterfaceType really has no sence to use.

If you want to receive pointer to a type in a function which expects an interface type, implement the interface with pointer receiver, like you did in a second example. 

Example:

type Person interface {
    Hello()
}

type Joker struct {
    Name string
}

/*
A Hello method declared with a pointer receiver which means that a pointer to
the Joker type (*Joker) not Joker type itself implements Person interface.
*/
func (j *Joker) Hello() {
    fmt.Println(j.Name, ""says, \""Hello!\"""")
}

/*
invokeHello receives ANY type which statisfies Person interface.
In this case this is pointer to Joker type.
*/
func invokeHello(p Person) {
    p.Hello()
}

func main() {
    i := Joker{""Peter""}
    j := &i
    // Note difference between types
    fmt.Printf(
        ""Joker type: %s\nPointer to Joker type: %s\n"",
        reflect.TypeOf(i), reflect.TypeOf(j))
    invokeHello(j)
}


Otherwise if you want to receive a value of a type, implement the interface with value receiver, like you did in a first example.
",43601858
1030,43607941,"Don't use pointer to interface, only a slice of interfaces:

content []DocumentItem


If the dynamic value wrapped in the interface value is a pointer, you lose nothing, you will be able to modify the pointed object.

This was the only thing that had to be changed. To verify, I added printing at the end:

fmt.Printf(""%+v"", p)


Output (try it on the Go Playground):

&{text:lalala}

",43607857
1031,43681742,"I found solution, it's because my field en began by a lower case. If i change en by En and translatedName by TranslatedName, it's work.
Here a more details answer
",43677530
1032,43696135,"r.HandleFunc(""/todo/{id}"", redisHandler.api.GetTodoHandler).Methods(""GET"")


Your redisHandler, as defined in main, has no api field, so this naturally doesn't compile.

If you re-defined your RedisInstance type in the api package, and you defined the handler methods on that type in the method-specific files, then you can initialize your redisHandler using that api.RedisInstance type and you can delete the main.RedisInstance type definition:

package main

import (
    ""github.com/gorilla/mux""
    ""github.com/go-redis/redis""
    ""net/http""
    ""fmt""
    ""log""
    ""encoding/json""
    ""io/ioutil""
    ""../redismanager""
    ""../api""
)

func main() {

    //Initialize Redis Client
    client := redismanager.InitRedisClient()
    //Get current redis instance to get passed to different Gorilla-Mux Handlers
    redisHandler := &api.RedisInstance{RInstance:&client}

    //Initialize Router Handlers
    r := mux.NewRouter()
    r.HandleFunc(""/todo"", redisHandler.AddTodoHandler).Methods(""POST"")
    r.HandleFunc(""/todo/{id}"", redisHandler.GetTodoHandler).Methods(""GET"")

    fmt.Println(""Listening on port :8000 . . ."")

    // Bind to a port and pass our router in
    log.Fatal(http.ListenAndServe("":8000"", r))

}

",43695832
1033,43696494,"Write a function that converts a function with the Redis instance argument to an HTTP handler:

func redisHandler(c *RedisInstance,
    f func(c *RedisInstance, w http.ResponseWriter, r *http.Request)) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) { f(c, w, r) })
}


Write your API handlers like this:

func AddTodoHandler(c *RedisInstance, w http.ResponseWriter, r *http.Request) {
    ...
}


Add to the mux like this:

r.Handler(""/todo"", redisHandler(client, api.AddTodoHandler)).Methods(""POST"")


where client is the Redis instance.
",43695832
1034,43779544,"
Go to ezwinports, https://sourceforge.net/projects/ezwinports/files/
Download make-4.2.1-without-guile-w32-bin.zip (get the version
without guile) 
Extract zip 
Copy the contents to C:\ProgramFiles\Git\mingw64\ merging the folders, but do NOT overwrite/replace any exisiting files.

",36770716
1035,43852617,"In Go, a string is a fixed-length struct containing a length and a pointer to a byte array.

So var a [2]string allocates an array with space for two such structs.

a[0] = ""Hello"" allocates another array to store ""Hello"", and puts a pointer to this, and a length into a[0].
",43852529
1036,43852653,"Strings are like read-only slices of bytes. So the reason this code works is because the array need only allocate space for a pointer and some metadata (the length of the string).

See the section on Strings here (at the bottom):

https://blog.golang.org/slices
",43852529
1037,43854626,"The default value for a bool is false. If you notice that you are overwriting the options value to true every time you run the code. 

The default values of a strings variable is """". So if check the string with len(opts.StringOption) == 0 or opts.StringOption == """" that would work as well.

https://play.golang.org/p/jifZZvoBVZ
",43854117
1038,43856941,"For detecting uninitialized struct fields, as a rule certain types have zero values, they are otherwise nil (maps and channels need to be maked):

var i int     // i = 0
var f float64 // f = 0
var b bool    // b = false
var s string  // s = """"
var m chan int// c = nil


There is a tour slide which is useful.

I think you're problem involves creating a default boolean value of true



For your sake, however, if you are passing an Option struct into that function, and the user did not specify the options, then yes they will be false and """" by default. 

One solution is to create a(nother) constructor: func NewOptions(b bool, s string) Options

This constructor would make the bool default true.

You could also try an enum to simulate a boolean; the zero value will be 0. So instead of type bool for the Options struct value BoolOption, you could use int:

const (
        TRUE
        FALSE
)


You could also have a UNINITIALIZED as zero, but I think you just want to switch the default value, rather than detecting that it is uninitialized.

So when checking a value of Options, you could write:

if opt.BoolOption == FALSE {
    // Do something with the option
} else {
    // The default option
}




A bit simpler would be to make the BoolOption into notBoolOption, and have the default be false.



Or, as Olivia Ruth points out, if you have the field as a pointer to a boolean, it will be remain nil until ""initialized"".
",43854117
1039,43936698,"If you look carefully at your json. you have an array in an array...

...
    ""values"": [
                    [...


If this is intended then the type of values is:

[][]Value


to represent the two arrays, else remove the array nesting and it becomes:

[]Value


Runnable Example: https://play.golang.org/p/UUqQR1KSwB
",43936400
1040,43936709,"    type Basic struct {
        ID string `json:""id""`
    }

    type Inner struct {
        ID string `json:""id""`
        Keys []Basic `json:""keys""`
    }

    type Middle struct {
        ID int `json:""id""`
        Values []Inner `json:""values""`
    }

    type Final struct {
        Data []Middle `json:""data""`
    }

",43936400
1041,43991706,"you can use interface with method
 In service (connect db)

// UserServiceInterface include method list
type UserServiceInterface interface {
    GetAll(helpers.ParamsGetAll) (models.PublicUsers, error)
    Get(int64) (models.User, error)
    Delete(int64) (bool, error)
    Create(models.User) (int64, error)
    Update(models.User) (models.User, error)
    CheckExistUsername(string) (bool, error)
    CheckExistEmail(string) (bool, error)
    CreateEmailActive(string, string, int64) error
    CheckExistUser(int64) (bool, error)
}

// UserService struct
type userService struct{}

// NewUserService to constructor
func NewUserService() userService {
    return userService{}
}

func (userService )GetAll (p helpers.ParamGetAll)(models.PublicUser, error) {
    code here....
}


In user controller

// UserController controller
type UserController struct {
    Service services.UserServiceInterface
}
    func (controller UserController) GetAll(c *gin.Context) {
    users, errGetAll := controller.Service.GetAll(params)
}

",40207528
1042,44073435,"Find It. I do

c, err := cdp.New(ctxt, cdp.WithRunnerOptions(
   runner.Flag(""headless"", true),
   runner.Flag(""disable-gpu"", true)))
if err != nil {
    log.Fatal(err)
}

",44067030
1043,44078268,"Unfortunately not. http.ListenAndServe generates a local http.Server instance, which you cannot gain access to, which is what you would need to be able to stop it. You'll need to create your own http.Server instance, and register your handlers with that instead of using http.HandleFunc. Then you can shut down the server using Close() to shut down immediately, or Shutdown() to do a graceful stop (letting requests in flight complete before shutting down).

var server *http.Server
//...
func PleaseStart() {
    http.HandleFunc(""/"", handlerfunc)
    server = &http.Server{
        Addr:    "":80"",
        Handler: http.DefaultServeMux,
    }
    log.Fatal(server.ListenAndServe())
}

func kill_server() {
    server.Close()
}

",44078189
1044,44103397,"If you're using Cgo, you must use something like this:

/*
#cgo CFLAGS: -I/usr/local/ssl/include
#cgo LDFLAGS: -lcrypto -L/usr/local/ssl/lib
*/
import ""C""


In this case I'm using it to compile against the latest OpenSSL.  Edit to suit your needs.
",44102971
1045,44136086,"Yes as @RickyA mentions using a range is nice as it verifies for all the possible underlying const values.

Additionally you could check the length of the enum, although that would only be possible when the underlying enum values do not have any 'gaps' and have a consequitive range of numbers.

Verbose explanation via code:

typelength := int32(len(TimeInterval_name))
if testinputint = typelength {
    // not a value for this enum, return err
}


A bit less verbose, and just using int instead of int32

if testinputint = len(TimeInterval_name) {
    // not a value for this enum, return err 
}


But as said, this will only be valid for enums that adhere to a proper iota. That might not be the case when you have changed your enum to read something like this:

var TimeInterval_name = map[int32]string{
    0: ""TI_UNKNOWN"",
    1: ""TI_HOUR"",
    2: ""TI_DAY"",
    3: ""TI_WEEK"",
    // we do not use month anymore 4: ""TI_MONTH"",
    5: ""TI_QUARTER"",
    6: ""TI_YEAR"",
}


as the length of the generated map will be clearly less than six :)

In other words use the found method of @Ricky_A above to keep on the safe side.
",38957169
1046,44178318,"It is automatically added by the IDE and its there to separate the parameter sent to delve from the parameters sent to the application. In case you don't have any parameters then, as you say, it's redundant but it's not harmful / shouldn't bother you. Is there any problem that you currently have with the IDE? 

Edit: This was fixed in the newer EAPs starting from EAP 8.
",44177972
1047,44201166,"The following code prettily statisfies your requirement, you can get this code at https://gist.github.com/hygull/645c3dc39c69b6b69c06f5ea9deee41f. The table data has been also provided.

/**
    {
        ""created_on"": ""26 may 2017"",
        ""todos"": [
            ""go get github.com/go-sql-driver/mysql""     
        ],
        ""aim"": ""Reading fname column into []string(slice of strings)""
    }
*/


/* 
mysql> select * from users;
+----+-----------+----------+----------+-------------------------------+--------------+
| id | fname     | lname    | uname    | email                         | contact      |
+----+-----------+----------+----------+-------------------------------+--------------+
|  1 | Rishikesh | Agrawani | hygull   | rishikesh0014051992@gmail.com | 917353787704 |
|  2 | Sandeep   | E        | sandeep  | sandeepeswar8@gmail.com       | 919739040038 |
|  3 | Darshan   | Sidar    | darshan  | sidardarshan@gmail.com        | 917996917565 |
|  4 | Surendra  | Prajapat | surendra | surendrakgadwal@gmail.com     | 918385894407 |
|  5 | Mukesh    | Jakhar   | mukesh   | mjakhar.kjahhar@gmail.com     | 919772254140 |
+----+-----------+----------+----------+-------------------------------+--------------+
5 rows in set (0.00 sec)

mysql> 
*/

package main
import ""fmt""
import ""log""
import (
    _""github.com/go-sql-driver/mysql""   
    ""database/sql""
)

func main() {
    // db, err := sql.Open(""mysql"", "":@tcp(127.0.0.1:)/?charset=utf8"" )
    db, err := sql.Open(""mysql"", ""hygull:admin@67@tcp(127.0.0.1:3306)/practice_db?charset=utf8"")

    if err != nil {
        log.Fatal(err)
    }

    rows, err := db.Query(""select fname from users"")

    if err != nil {
        log.Fatal(err)
    }

    firstnames:=[]string{}
    for rows.Next() {
        var fname string
        rows.Scan(&fname)
        firstnames = append(firstnames, fname)
    }

    fmt.Println(firstnames)
    db.Close()
}

/* 
[Rishikesh Sandeep Darshan Surendra Mukesh]
*/

",14477941
1048,44207768,"This error happens because by default go get doesn't use terminal input. This behaviour can be changed by modifying environment variable GIT_TERMINAL_PROMPT, which was introduced in git 2.3. That's why the go get command behaves differently in CentOS 7 (git 1.8) and Alpine 3.5 (git 2.11).

You can work your way around the issue in git >= 2.3 by running go get as follows:

$ GIT_TERMINAL_PROMPT=1 go get github.com/foo/bar
Username for 'https://github.com':


If you have multiple go get calls then you can export that environment variable before running the commands:

$ export GIT_TERMINAL_PROMPT=1
$ go get github.com/foo/bar
Username for 'https://github.com':
$ go get github.com/foo/baz
Username for 'https://github.com':

",42406445
1049,44250438,"this is ASCII. You need to convert your HEX output. 
I don't have any knowledge of GO.
https://en.wikipedia.org/wiki/ASCII
",44240806
1050,44302889,"The most effective way would be to remove this step: db := bytes.Split(data, []uint8(""\n"")) and instead iterate over data like that:

func main() {
    data, _ := ioutil.ReadFile(""test.txt"")

    s := make([]string, 0)
    start := 0
    for i := range data {
        if data[i] == '\n' {
            elem := string(data[start : i-1])
            s = append(s, elem)
            start = i
        }
    }
    fmt.Printf(""%v"", s)
}


Or if you want to convert [][]byte to []string:

func convert(data [][]byte) []string {
    s := make([]string, len(data))
    for row := range data {
        s[row] = string(data[row])
    }

    return s
}

",44301262
1051,44326496,"If you actually want to convert a file content to a []string, you can use bufio.Scanner which is cleaner (IMO) and more efficient than the code you posted:

func readFile(filename string) ([]string, error) {
    file, err := os.Open(filename)
    if err != nil {
        return nil, err
    }   
    defer file.Close()

    scanner := bufio.NewScanner(file)

    var data []string

    for scanner.Scan() {
        line := scanner.Text()
        data = append(data, line)
    }   
    if err = scanner.Err(); err != nil {
        return nil, err
    }   

    return data, nil 
}


Here's a benchmark* comparing the original function (readFile1) and my function (readFile2):

BenchmarkReadFile1-8         300       4632189 ns/op     3035552 B/op      10570 allocs/op
BenchmarkReadFile2-8        1000       1695820 ns/op     2169655 B/op      10587 allocs/op


*the benchmark read a sample file of 1.2 MiB and ~10K lines

The new code runs in 36% of the time and 71% of the memory used by the original function.
",44301262
1052,44372739,"I don't think it is particularly messy but I might be tempted to make some sort of addDupe helper function that takes a dupCount by value, makes whatever changes are required to add the line and returns the dupCount by value

func addDupe(dupes dupCount, filename string) dupCount {
    if dupes.count == 0 {
        dupes.fileCount = make(map[string]int)
    }
    dupes.fileCount[filename]++
    dupes.count++
    return dupes
}


This is similar to the way the standard append function for slices works. Then countLines can be written as:

func countLines(r io.Reader, counts map[string]dupCount, filename string) {
    input := bufio.NewScanner(r)
    for input.Scan() {
        line := input.Text()
        counts[line] = addDupe(counts[line], filename)
    }
}


But all I have done is replace your tmp with a function parameter.
",42633651
1053,44376544,"Why not use the windows registry?

https://godoc.org/golang.org/x/sys/windows/registry

How to return a default value from windows/registry with golang

package main

import (
    ""golang.org/x/sys/windows/registry""
    ""log""
    ""fmt""
)

func main() {

    k, err := registry.OpenKey(registry.LOCAL_MACHINE, `SOFTWARE\Microsoft\Windows NT\CurrentVersion`, registry.QUERY_VALUE)
    if err != nil {
        log.Fatal(err)
    }
    defer k.Close()

    cv, _, err := k.GetStringValue(""CurrentVersion"")
    if err != nil {
        log.Fatal(err)
    }
    fmt.Printf(""CurrentVersion: %s\n"", cv)

    pn , _, err := k.GetStringValue(""ProductName"")
    if err != nil {
        log.Fatal(err)
    }
    fmt.Printf(""ProductName: %s\n"", pn)

    maj, _, err := k.GetIntegerValue(""CurrentMajorVersionNumber"")
    if err != nil {
        log.Fatal(err)
    }
    fmt.Printf(""CurrentMajorVersionNumber: %d\n"", maj)

    min, _, err := k.GetIntegerValue(""CurrentMinorVersionNumber"")
    if err != nil {
        log.Fatal(err)
    }
    fmt.Printf(""CurrentMinorVersionNumber: %d\n"", min)

    cb, _, err := k.GetStringValue(""CurrentBuild"")
    if err != nil {
        log.Fatal(err)
    }
    fmt.Printf(""CurrentVersion: %s\n"", cb)    
}


This returns:

PS C:\Users\Adamar\Desktop> .\WindowsVersion.exe
CurrentVersion: 6.3
ProductName: Windows Server 2016 Standard Evaluation
CurrentMajorVersionNumber: 10
CurrentMinorVersionNumber: 0
CurrentVersion: 14393


Although in the newest version of windows you have to read the following keys to get the version: CurrentMajorVersionNumber & CurrentMinorVersionNumber
",44363911
1054,44378550,"Go Downloads

PowerPC architecture: ppc64le (64-bit PowerPC little-endian). For example, for Go 1.8.3,

go1.8.3.linux-ppc64le.tar.gz: https://storage.googleapis.com/golang/go1.8.3.linux-ppc64le.tar.gz
",44377492
1055,44426276,"Have you explored solutions such as ory/hydra, which will handle everything OAuth2/OpenID related and let you handle user authentication?

Implementing your own OAuth2 provider is dangerous territory. It only takes one misread RFC and BOOM! Security vulnerability. It's typically better to entrust that responsibility to established security experts or lasting projects as opposed to home-grown remedies.

Of course, this isn't to say that everybody needs to jump onto the hype train and use this cool new software. In fact, I would urge the opposite: if you are a competent security analyst and feel comfortable writing an OAuth2/OpenID Connect implementation, go right ahead! But us normal people who don't want our hair to gray before we are thirty will use existing technologies to our advantage.


",44398216
1056,44447716,"The compiler command is incomplete. You can use gomobile build -x to see how to invoke the compiler correctly, remember you might need to quote the parameters correctly in your shell.

An example of a correct command:

GOMOBILE=/home/janus/go/pkg/gomobile GOPATH=$HOME/go ANDROID_HOME=/home/janus/Desktop/android-sdk-linux GOOS=android GOARCH=arm CC=$ANDROID_HOME/ndk-bundle/toolchains/llvm/prebuilt/linux-x86_64/bin/clang CXX=$ANDROID_HOME/ndk-bundle/toolchains/llvm/prebuilt/linux-x86_64/bin/clang++ CGO_CFLAGS=""-target armv7a-none-linux-androideabi --sysroot $ANDROID_HOME/ndk-bundle/platforms/android-15/arch-arm -gcc-toolchain $ANDROID_HOME/ndk-bundle/toolchains/arm-linux-androideabi-4.9/prebuilt/linux-x86_64 -I$GOMOBILE/include"" CGO_CPPFLAGS=""-target armv7a-none-linux-androideabi --sysroot $ANDROID_HOME/ndk-bundle/platforms/android-15/arch-arm -gcc-toolchain $ANDROID_HOME/ndk-bundle/toolchains/arm-linux-androideabi-4.9/prebuilt/linux-x86_64 -I$GOMOBILE/include"" CGO_LDFLAGS=""-target armv7a-none-linux-androideabi --sysroot $ANDROID_HOME/ndk-bundle/platforms/android-15/arch-arm -gcc-toolchain $ANDROID_HOME/ndk-bundle/toolchains/arm-linux-androideabi-4.9/prebuilt/linux-x86_64 -L$ANDROID_HOME/ndk-bundle/platforms/android-15/arch-arm/usr/lib -L$GOMOBILE/lib/arm"" CGO_ENABLED=1 GOARM=7 go build -pkgdir=$GOMOBILE/pkg_android_arm -buildmode=c-shared
",44424331
1057,44481041,"If in a map you want to store multiple values associated with the same key, the value type must be suitable for that. A struct isn't, but a slice is a perfect choice.

So change your value type to []A:

letSee := map[X][]A{}
letSee[X{1}] = []A{A{""T"", B{""T1"", C{""T11"", ""T12""}}}}
letSee[X{1}] = append(letSee[X{1}], A{""L"", B{""L1"", C{""L11"", ""L12""}}})

fmt.Printf(""%+v"", letSee)


Output (try it on the Go Playground):

map[{key:1}:[{value1:T value2:{value3:T1 value4:{value5:T11 value6:T12}}}
    {value1:L value2:{value3:L1 value4:{value5:L11 value6:L12}}}]]

",44480989
1058,44482304,"You should remove the default clauses from the select statements. 

Since your select statement is within a for loop and the default clause prevents it from blocking, the loop has to go through a lot of cycles before any message will be received. 

Looks like Playground detects it and stops the program.
",44481659
1059,44482565,"As @dev.bmax already mentioned, you use default in a wrong way.
Check this small article about using default keyword.

Also, try to add runtime.GOMAXPROCS(4) on the beginning of your program, run few times and check output to see, how it's working:

https://play.golang.org/p/TLDHNg6urB

Here's correct example for you:

https://play.golang.org/p/bc0TGdmx1Y

Note, that in this case you should use different channels for stopping additional and main goroutines.
",44481659
1060,44524824,"Your call to Math.Float64frombits occurs at runtime, not compile time, and thus, is not constant. From the effective Go page (which will explain it better than I can):


  Constants in Go are just that—constant. They are created at compile
  time, even when defined as locals in functions, and can only be
  numbers, strings or booleans. Because of the compile-time restriction,
  the expressions that define them must be constant expressions,
  evaluatable by the compiler. For instance, 1<<3 is a constant
  expression, while math.Sin(math.Pi/4) is not because the function call
  to math.Sin needs to happen at run time.


Link: https://golang.org/doc/effective_go.html#constants
",44524774
1061,44524941,"You can't call a function like Float64frombits in a constant declaration; the function call means it can't be evaluated fully at compile time, so it can't be used as a constant. You can, however, just dump bits into a float value:

const myFloat float64 = 0x7ff8c0c0ac0ffee1

func main() {
    fmt.Println(myFloat)
}

",44524774
1062,44525986,"If you want to store the bit value (which is essentially a uint64), and have it available as a float64 to external packages, you can provide a ""constant"" function, which you guarantee to only return the constant value. This is precisely how functions like math.NaN work.

const uintFoo = 0x7ff8c0c0ac0ffee1

func ConstFoo() float64 {
    return math.Float64frombits(uintFoo)
}

",44524774
1063,44528288,"You're code looks alright. However it can be simplified-

var b bytes.Buffer // you could use buffer pool here
err := jsonapi.MarshalManyPayload(&b, albumList())
if err != nil {
    return err
}
return c.JSONBlob(http.StatusOK, b.Bytes())




Following approaches for your thoughts:

Approach 1 -

c.Response().Header().Set(echo.HeaderContentType, jsonapi.MediaType)
c.Response().WriteHeader(http.StatusOK)
return jsonapi.MarshalManyPayload(c.Response(), albumList())




Approach 2 -

var b bytes.Buffer // you could use buffer pool here
err := jsonapi.MarshalManyPayload(&b, albumList())
if err != nil {
    return err
}
c.Response().Header().Set(echo.HeaderContentType, jsonapi.MediaType)
c.Response().WriteHeader(http.StatusOK)
_, err := b.WriteTo(c.Response())
return err

",44515677
1064,44594347,"You're looking at two separate data structures, so to unmarshal them with a single struct type, you'd need to account for both:

type Owner struct {
    Name string
    Pet
    Pets []Pet `json:""Pet""`
}


Then, if you want the slice to be authoritative, after you unmarshall, move the embedded to the slice:

// owner := unmarshall blah blah
if owner.Pet != Pet{} {
    owner.Pets = append(owner.Pets, owner.Pet)
}

",44594289
1065,44594408,"Yes it's possible. 


Suppose that the GOPATH is C:\Work\golang
Revel project name is myapp, thus the location of the project (workspace) will be C:\Work\golang\src\myapp. 
Make some changes to the controllers etc...
Run the application with revel run myapp, then press CTRL+C to exit. This step is necessary to generate corresponding go files. The generated file, i.e. the main package will be available under ${workspaceRoot}/app/tmp/main.go 
Configure launch.json as follows:

{
    ""version"": ""0.2.0"",
    ""configurations"": [
        {
            ""name"": ""Launch"",
            ""type"": ""go"",
            ""request"": ""launch"",
            ""mode"": ""debug"",
            ""remotePath"": """",
            ""port"": 2345,
            ""host"": ""127.0.0.1"",
            ""env"": {},
            ""showLog"": true,
            ""program"": ""${workspaceRoot}/app/tmp/"",
            ""args"": [""-importPath"", ""myapp"", ""-srcPath"", ""c:\\work\\golang\\src"",  ""-runMode"", ""dev""]
        }
    ]
}

The important parts are program and args parameters, while the other parameters are unmodified. 
Set breakpoint and start the delve debugger...




EDIT:


Setting args parameter to [""-importPath"", ""myapp"", ""-srcPath"", ""${workspaceRoot}/.."",  ""-runMode"", ""dev""] also work, and I think this should work in other platforms (Mac, Linux) too. 
The error message is related to delve issue. See https://github.com/Microsoft/vscode-go/issues/986

",44589854
1066,44631925,"You should not set $GOROOT.

Type export GOROOT="""" to fix your problem. 
",25499670
1067,44631949,"Your $GOROOT should not be set up. 
You $GOPATH should be set to $HOME/go by typing export $GOPATH=$HOME/go

Please type export GOROOT="""" to fix your problem. 
",20628918
1068,44651270,"package main

import (
    ""bytes""
    ""encoding/json""
    ""errors""
    ""fmt""
)

type StreamMessage struct {
    Data []*Data `json:""data""`
    Ts   float64 `json:""ts""`
}

type Data struct {
    Type    string
    XRate   *XRateData
    Balance *BalanceData
    Event   *EventData
    Sync    *SyncData
}

func (d *Data) UnmarshalJSON(b []byte) error {
    dec := json.NewDecoder(bytes.NewReader(b))
    t, _ := dec.Token()
    if delim, ok := t.(json.Delim); !ok || delim != '[' {
        return errors.New(""expecting data to be an array"")
    }

    if err := dec.Decode(&d.Type); err != nil {
        return err
    }

    var err error
    switch d.Type {
    case ""xrate"":
        err = dec.Decode(&d.XRate)
    case ""sync"":
        err = dec.Decode(&d.Sync)
    case ""balance"":
        err = dec.Decode(&d.Balance)
    case ""event"":
        err = dec.Decode(&d.Event)
    default:
        return errors.New(""unknown data type "" + d.Type)
    }

    if err != nil {
        return err
    }

    t, _ = dec.Token()
    if delim, ok := t.(json.Delim); !ok || delim != ']' {
        return errors.New(""expecting array to be two elements"")
    }

    return nil
}

type XRateData struct {
    Rate json.Number `json:""rate""`
    CCY  string      `json:""ccy""`
}

type BalanceData struct {
    // TODO
}

type EventData struct {
    // TODO
}

type SyncData struct {
    Token string `json:""Token""`
}

var streamSnapshot = []byte(

    `{ 
   ""ts"": 1496244373.04,
   ""data"":[
      [""xrate"", {""rate"":1.2916,""ccy"":""USD""}],
      [""balance"", 
         {
            ""open_stake"":[""GBP"", 0.0],
            ""balance"":[""GBP"", 0.0]
         }
      ],
      [""event"", 
         {
            ""competition_id"":""545"",
            ""ir_status"":""pre_event"",
            ""start_time"":""2017-09-10T17:00:00+00:00"",
            ""competition_name"":""USA NFL"",
            ""event_id"":""2017-09-10,21617,21635"",
            ""home"":""Buffalo Bills"",
            ""away"":""New York Jets"",
            ""sport"":""af"",
            ""competition_country"":""US""
         }
      ],
      [""sync"", {""Token"":""eb1c57132d004f8d8fb967c076921fac""}]
   ]
}`)

func main() {
    var sm StreamMessage
    if err := json.Unmarshal(streamSnapshot, &sm); err != nil {
        panic(err)
    }
    fmt.Println(sm)
}


https://play.golang.org/p/ktABS6z40m
",44650198
1069,44671438,"If you want to Switch Bar to lowercase, you have to set :  

// swagger:parameters updateBar
type BarParam struct {
    Bar string `json:""bar""`
}

",35432369
1070,44675798,"If you don't send data containing a variable to the template but you use {{ if .Variable }} you will get the error: 


  executing ""templatename"" at : can't evaluate field Variable in type handler.Data


My solution was to send the ""Email"" variable as a boolean (false) in order to pass the {{ if .Email }} function check. But this is a short term solution that I don't like.

I was inspired by: https://stackoverflow.com/a/31527618/1564840. In that example they show different HTML for authenticated and non-authenticated users. You will see that in both cases they send the ""Logged"" variable. Try removing that variable from the struct and execute the function. You will receive the error that I mentioned above.
",44675087
1071,44676179,"The recommended way

First, the recommended way is not to rely on whether a struct field exists. Of course there might be optional parts of the template, but the condition to decide whether to render a part should rely on fields that exist in all cases.

The issue, and avoiding it using a map

If the type of the template data is a struct (or a pointer to a struct) and there is no field or method with the given name, the template engine returns an error for that.

You could easily get rid of this error if you were to use a map, as maps can be indexed with keys they don't contain, and the result of that index expression is the zero value of the value type (and not an error).

To demonstrate, see this example:

s := `{{if .Email}}Email is: {{.Email}}{{else}}Email is NOT set.{{end}}`

t := template.Must(template.New("""").Parse(s))
exec := func(name string, param interface{}) {
    fmt.Printf(""\n%s:\n  "", name)
    if err := t.Execute(os.Stdout, param); err != nil {
        fmt.Println(""Error:"", err)
    }
}

exec(""Filled map"", map[string]interface{}{""Email"": ""as@as""})
exec(""Empty map"", map[string]interface{}{})

exec(""Filled struct"", struct {
    Email string
}{Email: ""as@as.com""})
exec(""Empty struct"", struct{}{})


Output (try it on the Go Playground):

Filled map:
  Email is: as@as
Empty map:
  Email is NOT set.
Filled struct:
  Email is: as@as.com
Empty struct:
  Error: template: :1:5: executing """" at : can't evaluate field Email in type struct {}


Sticking to struct and providing ""isset""

If you must or want to stick to a struct, this ""isset"" can be implemented and provided, I'll call it avail().

This implementation uses reflection, and in order to check if the field given by its name exists (is available), the (wrapper) data must also be passed to it:

func avail(name string, data interface{}) bool {
    v := reflect.ValueOf(data)
    if v.Kind() == reflect.Ptr {
        v = v.Elem()
    }
    if v.Kind() != reflect.Struct {
        return false
    }
    return v.FieldByName(name).IsValid()
}


Example using it:

s := `{{if (avail ""Email"" .)}}Email is: {{.Email}}{{else}}Email is unavailable.{{end}}`

t := template.Must(template.New("""").Funcs(template.FuncMap{
    ""avail"": avail,
}).Parse(s))
exec := func(name string, param interface{}) {
    fmt.Printf(""\n%s:\n  "", name)
    if err := t.Execute(os.Stdout, param); err != nil {
        fmt.Println(""Error:"", err)
    }
}

exec(""Filled struct"", struct {
    Email string
}{Email: ""as@as.com""})
exec(""Empty struct"", struct{}{})


Output (try it on the Go Playground):

Filled struct:
  Email is: as@as.com
Empty struct:
  Email is unavailable.

",44675087
1072,44687510,"In newer API-versions, there is an option to discard all ""old"" messages and always deliver just the ""newest"" one.

If that meets your expectations, and if all peers meet API v.4.0+, you are done.


  ZMQ_CONFLATE: Keep only last message 
  If set, a socket shall keep only one message in its inbound/outbound queue, this message being the last message received/the last message to be sent. Ignores ZMQ_RCVHWM and ZMQ_SNDHWM options. Does not support multi-part messages, in particular, only one part of it is kept in the socket internal queue.
  Option value type int
  Option value unit boolean
  Default value 0 (false)
  Applicable socket types   ZMQ_PULL, ZMQ_PUSH, ZMQ_SUB, ZMQ_PUB, ZMQ_DEALER

",44687426
1073,44690546,"What you're trying to do is use communication as an execution rendezvous. The sender wants to know something about when the receiver gets messages.

ZMQ implements the Actor model. What you need is a modification of the Communicating Sequential Processes model (one where sends timeout). Basically you need to add control message flows to/from the workers, the idea being that the server asks the worker to receive a message and the server waits for the reply. The reply means that the worker is ready to receive a message right now, and that the server and worker have both rendezvoused at a send/receive in their program flows. If that reply fails to arrive within timeout seconds, then the server doesn't send the actual message. 

Or you could cheat by having everything going to the workers regardless, wrapped in a message that carries a ""sent at time X"" field, and have the worker decide to discard old messages.
",44687426
1074,44700761,"The server requires a token string without added strings in my case I have added Bearer string to the token string in the header when sending request to the web server i.e. 

'Authorization':'Bearer' + localStorage.getItem('id_token')


At the web server we need to split only the valid token without the Bearer string

reqToken := r.Header.Get(""Authorization"")
splitToken := strings.Split(reqToken, ""Bearer"")
reqToken = splitToken[1]


As a result it becomes valid token without nil. 
",39518237
1075,44716385,"More robust solution that Garrett's one is:

 func init() {
    if v := flag.Lookup(""test.v""); v == nil || v.Value.String() != ""true"" {
        fmt.Println(""normal run"")
    } else {
        fmt.Println(""run under go test"")
    }
 }

",14249217
1076,44757772,"Here a solution to make cross-compile super easy even with CGO.

I stumbled upon it recently after wasting a lot of time getting a new windows build server to build my Go app.
Now I just compile it on my Mac and will create a Linux build server with it:

https://github.com/karalabe/xgo

Many thanks to Péter Szilágyi alias karalabe for this really great package!

How to use:


have Docker running
go get github.com/karalabe/xgo
xgo --targets=windows/amd64 ./


There are lots more options!
",35997995
1077,44759792,"This is not possible with Go. As a statically compiled language you can only compile a binary if all its dependencies exist.
Can you give us some more details on why you need this in the first place? Maybe there is a simpler or more idiomatic way to achieve your idea.
",44759016
1078,44812828,"You could use a map[string]command similar to how the net/http package registers handlers. Something akin to this:

https://play.golang.org/p/9YzHyLodAQ

package main

import (
    ""fmt""
    ""errors""
)

type BotFunc func(string) (string, error)

type BotMap map[string]BotFunc

var Bot = BotMap{}

func (b BotMap) RegisterCommand(command string, f BotFunc) error {
    if _, exists := b[command]; exists {
        return errors.New(""command already exists"")
    }
    b[command] = f
    return nil
}

func (b BotMap) Execute(statement string) (string, error) {
    // parse out command and query however you choose (not this way obviously)
    command := statement[:9]
    query := statement[10:]

    return b.ExecuteQuery(command, query)
}

func (b BotMap) ExecuteQuery(command, query string) (string, error) {
    if com, exists := b[command]; exists {
        return com(query)
    }
    return """", errors.New(""command doesn't exist"")

}

func main() {
    err := Bot.RegisterCommand(""search me"", func(query string) (string, error) {
        fmt.Println(""search"", query)
        return ""searched"", nil
    })
    if err != nil {
        fmt.Println(err)
        return
    }
    err = Bot.RegisterCommand(""thesaurus me"", func(query string) (string, error) {
        fmt.Println(""thesaurus"", query)
        return ""thesaurused"", nil
    })
    if err != nil {
        fmt.Println(err)
        return
    }

    result, err := Bot.Execute(""search me please"")
    if err != nil {
        fmt.Println(err)
        return
    }
    fmt.Println(result)
}


Obviously there's a lot of checks missing here, but this is the basic idea.
",44812324
1079,44833099,"del is not an executable, it's a built-in command. exec.Command allows you to fork out to another executable. To use shell commands, you would have to call the shell executable, and pass in the built-in command (and parameters) you want executed:

cmd := exec.Command(""cmd.exe"", ""/C"", ""del C:\\trial\\now.txt"")


Note that you also have to escape backslashes in strings as above, or use backtick-quoted strings:

cmd := exec.Command(""cmd.exe"", ""/C"", `del C:\trial\now.txt`)


However, if you just want to delete a file, you're probably better off using os.Remove to directly delete a file rather than forking out to the shell to do so.
",44833044
1080,44833287,"In addition to the problem with the executable, your path string is not what you think it is.

cmd := exec.Command(""del"", ""C:\trial\now.txt"")


The \t will be interpreted as a tab, and the \n as a newline.

To avoid this, use `` which has no special characters and no escape, not even \. A great relief for Windows users!

cmd := exec.Command(""del"", `C:\trial\now.txt`)


See String Literals in the Go Language Spec for more.
",44833044
1081,44847651,"Per the documentation, they're strings. Just type cast to string:

asStr := string(myTplJsObj)

",44847607
1082,44852377,"I think there is a bit of a misunderstanding here. openssl rsautl -sign does not encrypt the data. It produces a signature. The contents in your secret file is not ""secret"", encrypted. Rather, it is a signature of the text ""secret"" that is signed with the private key.

Using the public key, you can -verify the signature, but this isn't really what you are trying to do. It sounds like you want encrypt/decrypt, not sign/verify.

Use the -encrypt and -decrypt options of rsautl. Encryption happens with the public key, and decryption happens with the private key.

Keep in mind there are limits to the amount of data you can encrypt with RSA. Typically, you would protect a symmetric key with RSA, and use the symmetric key to do bulk encryption and decryption.
",44852289
1083,44853488,"I fully understood my question, it was about RSA_public_decrypt method of openssl: https://www.openssl.org/docs/man1.1.0/crypto/RSA_public_decrypt.html

I did not found any pure-golang realization. Realization with cgo: https://github.com/dgkang/rsa/blob/master/rsa/rsa.go

UPD, work for me:

func RSA_public_decrypt(pubKey *rsa.PublicKey, data []byte) []byte {
    c := new(big.Int)
    m := new(big.Int)
    m.SetBytes(data)
    e := big.NewInt(int64(pubKey.E))
    c.Exp(m, e, pubKey.N)
    out := c.Bytes()
    skip := 0
    for i := 2; i < len(out); i++ {
        if i+1 >= len(out) {
            break
        }
        if out[i] == 0xff && out[i+1] == 0 {
            skip = i + 2
            break
        }
    }
    return out[skip:]
}

",44852289
1084,44890804,"
The client ACKs (responds to server) that it has also updated local state to be synchronous with the server.


If 4. doesn't happen, then the server rolls back the transaction done in 1. and the entire operation of 1 - 4 is atomic.
",44889128
1085,44895648,"You have to define slice of Weather struct in WeatherData. 

Uncomment Weather struct and update WeatherData struct to following.

// WeatherData struct to collect data from the API call
type WeatherData struct {
    Wind    Wind      `json:""wind""`
    Sys     Sys       `json:""sys""`
    Weather []Weather `json:""weather""`
    Name    string    `json:""name""`
}


Please have a look on example code: https://play.golang.org/p/4KFqRuxcx2
",44895535
1086,44950870,"Realizing that we are calculating an integral and remembering that integrals are usually calculated using primitive functions, which can be taken to be the integral from some fixed time, we can write the following code.

The function primitive() gives the number of workdays since 3 January 2000, chosen to be a Monday to simplify the formula. The number of workdays between two dates is then given by the difference of primitive() for the two days.

package main

import (
    ""fmt""
    ""time""
)

type Date struct {
    year int
    month time.Month
    day int
}

func date2unix(d Date, loc *time.Location) int64 {
    return time.Date(d.year, d.month, d.day, 0, 0, 0, 0, loc).Unix()
}

func primitive(d Date, loc *time.Location) int64 {
    // 3 January 2000 was a Monday
    base := Date{2000, time.January, 3}
    seconds := date2unix(d, loc) - date2unix(base, loc)
    weeks := seconds / (7*24*60*60)
    seconds_into_week := seconds % (7*24*60*60)
    workdays := seconds_into_week / (24*60*60)
    if workdays > 5 {
        workdays = 5
    }

    return 5*weeks + workdays
}

func DayCountExcludingWeekends(from, to Date, loc *time.Location) int {
    return int(primitive(to, loc) - primitive(from, loc))
}

func main() {
    loc, err := time.LoadLocation(""Europe/Stockholm"")
    if err != nil {
        panic(err)
    }

    f := Date{2017, 6, 28}
    t := Date{2017, 7,  6}

    fmt.Println(DayCountExcludingWeekends(f, t, loc))
}



https://play.golang.org/p/_wxw8-PyMO
https://goplay.space/#wWU0Stv5zO

",31327124
1087,44960239,"In the end, the solution was to add an expires-at property like @colini and @bazza mentioned, and to drop timed out messages from the queue after each heartbeat. However, doing so and satisfying all requirements of my application was proving to be more difficult than first glance, so I ended up using RabbitMQ, whose ttl-expires argument provided the desired functionality.
",44687426
1088,44987214,"You've got two options:


The simplest is load the data in main before any other processing starts. If probability that you will read the data is very high and there is no other reason to avoid doing it immediately, why not?
Load the data with sync.Once. Something like:

var dataLoaded sync.Once
var data DataType = nil

func LookupPostCode(some_args) {
    once.Do(func() {
        data = LoadData(some_subset_of_some_args)
    })
    // and here I know, that data are loaded
}


",44986977
1089,44992313,"In net/rpc godoc example it just shows how to use global defaults. Instead create your own rpc and http server instances.

import ""net/rpc""
import ""net/http""

rpcServer := rpc.NewServer()
// rpc stuff
httpServer := &http.Server{
    Handler: rpcServer,
}
// graceful shutdown stuff


For graceful shutdown, there's a few packages. I know of this one. 


https://github.com/tylerb/graceful

",44979398
1090,44993440,"You can use init() function in your package to do this.

Or, if it does not change frequently, you can convert your CSV into a Go Map definition in a separate .go file and it will be 'loaded' at the compile time.
",44986977
1091,45024418,"Let's start with using interface{}, when you define interface don't use pointer definition, good read here.

type DockerUtil struct{
    Client        DockerClient
}


And moby Client implements lot of methods and you would like to do interface for selective methods.


  Right way to do is via Type assertion. Good read Effective Go - Type assertions and Spec - Type assertion.


Note: try this code, I don't have docker env in my machine to test.

func NewDockerUtil() (*DockerUtil, error) {
    dockerClient, err := client.NewEnvClient()
    if err != nil {
        return nil, err
    }
    return &DockerUtil{
        Client:        dockerClient.(DockerClient),
    }, nil
}


Note:

Using DockerUtil.Client, you can call only Ping method since your interface DockerClient has definition of Ping method.



If you would like to call all the methods supported by client.Client later on then you have to do type assertion-

dockerClient := DockerUtil.Client.(*client.Client)

",45024152
1092,45088878,"I had a look on your sample code and its errors. To learn more about interface slice is to refer this Go wiki and SliceTricks.



Generic implementation is bit complex instead you can go with type based implementation. However Type based implementation brings more code on boilerplate/repetitive.

You need to use reflect package for your purpose as @stephen-weinberg mentioned in the comment.

So best starting point would be; try this library github.com/anzhihun/generic and go through library codebase, implement on your own. This library uses reflection. 
",45088229
1093,45089928,"Trying to make Go generic is one of the great pitfalls for new Go devs. Stop. You're saving five of lines of code:

for i := len(foos) - 1; i >= 0; i-- {
    if foos[i] == foo1 {
        foos = append(foos[:i], foos[i+1:]...)
    }
}


Yes, in generic languages, you would wrap those five lines up in to a nice stdlib method, but Go is not a generic language. Trying to do this with reflection is slow, but that's not the reason to avoid it. Reflection is very complicated. It's hard to get it right. You'll spend much more time figuring out Value and chasing weird corner cases than you'll spend rewriting those five lines of code 12 times (including fixing the time you accidentally cut/paste it wrong, and the one time you mess up i--). Just write them.

Just writing the code lets you decide what equality means. It lets you decide whether to stop searching at the first match, or keep going through the whole list. It lets you do what this program needs rather than focusing on what some generic program might someday need.

I love generic programming. Few things make me happier than creating an elegant fold in Haskell. But that's not the way of Go. In Go you generally just write the code, keep it simple and obvious, and move on.

Andy makes a good point that if you have to do this a lot, list may be a better data structure. And I often find that when I have three types that all seem to have parallel methods, it turns out that they should all have been part of a single struct (do you really need separate lists here at all?) But in any case, stay away from reflection unless you have a very specialized problem where you really mean ""anything"" rather than ""one of these short list of things.""

(It's noteworthy that you call out append(). I don't think it's possible to write append() in Go. That's why it had to be part of the language rather than a stdlib function. When I started working in Go, I took that as a significant flaw in the language. The longer I've worked in Go, the more I've found it not to matter so much. You just write the code and move on.)
",45088229
1094,45098675,"It seems that mongo wire protocol does not support the feature of indexing policy change. As @DavidMakogon said, please refer to the document How does Azure Cosmos DB index data? to change the settings of indexing policy on Azure portal as the figure below, or using REST API Replace a Collection.



Hope it helps.
",45075598
1095,45108529,"Find the answer: just need client instead of conn:

client, err := ssh.Dial(""tcp"", addr, config)

sftp, err := sftp.NewClient(client)
",45108286
1096,45180310,"The current accepted answer (as of July 2017) fails for JSON arrays and hasn't been updated: https://repl.it/J8H0/10

Try this:

func isJSON(s string) bool {
  var js interface{}
  return json.Unmarshal([]byte(s), &js) == nil
}


Or William King's solution, which is better.
",22128282
1097,45209033,"It's called conversion in Go (not casting), and this is covered in Spec: Conversions:


  Specific rules apply to (non-constant) conversions between numeric types or to and from a string type. These conversions may change the representation of x and incur a run-time cost. All other conversions only change the type but not the representation of x.


So generally converting does not make a copy, only changes the type. Converting to / from string usually does, as string values are immutable, and for example if converting a string to []byte would not make a copy, you could change the content of the string by changing elements of the resulting byte slice.

See related question: Does convertion between alias types in Go create copies?

There are some exceptions (compiler optimizations) when converting to / from string does not make a copy, for details see golang: []byte(string) vs []byte(*string).

If you already have your JSON content as a string value which you want to unmarshal, you should not convert it to []byte just for the sake of unmarshaling. Instead use strings.NewReader() to obtain an io.Reader which reads from the passed string value, and pass this reader to json.NewDecoder(), so you can unmarshal without having to make a copy of your big input JSON string.

This is how it could look like:

input := ""BIG JSON INPUT""
dec := json.NewDecoder(strings.NewReader(input))

var result YourResultType
if err := dec.Decode(&result); err != nil {
    // Handle error
}


Also note that this solution can further be optimized if the big JSON string is read from an io.Reader, in which case you can completely omit reading it first, just pass that to json.NewDecoder() directly, e.g.:

dec := json.NewDecoder(jsonSource)

var result YourResultType
if err := dec.Decode(&result); err != nil {
    // Handle error
}

",45207920
1098,45299316,"You can use the map[string]interface{} result and typecast the relevant parts, e.g.:

o[""ret""].([]interface{})


would get the array and continue so on. However, this is tedious and you need to check for values being set etc as well.

Instead, I'd recommend you use the handy JSON to Go tool that can automatically generate a struct definition for you to paste into your Go code when given some input JSON. 

Obviously you might need to amend this to suit your needs as you know what valid formats the input can take. However, this tool saves a lot of tedious boilerplate code writing!

For example, for the JSON above, it generates:

type AutoGenerated struct {
    Profile struct {
        ExecutionTime int `json:""execution_time""`
        ServerName string `json:""server_name""`
    } `json:""profile""`
    Result string `json:""result""`
    Ret []struct {
        Alias string `json:""alias""`
        AllParents []int `json:""all_parents""`
        Bankrupt bool `json:""bankrupt""`
        Block bool `json:""block""`
        Card interface{} `json:""card""`
    } `json:""ret""`
}

",45299133
1099,45308172,"From the caddy docs


  to is the destination endpoint to proxy to. At least one is required,
  but multiple may be specified. If a scheme (http/https) is not
  specified, http is used. Unix sockets may also be used by prefixing
  ""unix:"".


So maybe it is sending http requests to the proxied https endpoint.

Does 

mysite.com {
    proxy / https://localhost:9000 {
        max_fails 1
    }
    log logfile
}


fix it?

If that is the case, you may not strictly need your app on :9000 to listen https. It may simplify your deployment or cert management to just have it listen http and have caddy manage all the certs.
",45308108
1100,45315040,"Using ../css on the web should be avoided and likely is your error source. Your go server likely cannot resolve the file (because you don't have a handler for the ../css URI).
So you should change the ../css part to /css and tell your server (you didn't provide details, so I cannot show you code) to handle /css URIs by serving the files. 

Assuming that you are using the default net/http mux, your code should look something like:

mux := http.NewServeMux()
mux.Handle(""/css/"", http.StripPrefix(""/css/"", http.FileServer(http.Dir(""css""))))
http.ListenAndServe("":8080"", mux)

",45309657
1101,45317241,"First, it's a slice not an array. Arrays and slices in Go are very different, arrays have a fixed size that is part of the type. I had trouble with this at first too :)


Not really. Any if the three is correct, and any difference should be too small to worry about. In my own code I generally use whatever is easiest in a particular case.
0
Nothing, until you need to add an item, then whatever it costs to allocate the storage needed.

",45317074
1102,45318222,"
  Is there any difference between the 3 ways to make an empty array?


if empty array means len(array)==0, the answer is no, but actually only myArr3==nil is true.


  What is the default capacity of an array when unspecified?


the default capacity will be same with the len you specify.


  What is the performance cost of using arrays with unspecified capacity?


none
",45317074
1103,45331396,"
  What is the performance cost of using arrays with unspecified capacity?


There is certainly a cost when you start populating the slice. If you know how big the slice should grow, you can allocate capacity of the underlying array from the very begging as opposed to reallocating every time the underlying array fills up.

Here is a simple example with timing:

package main

import ""fmt""

func main() {

    limit := 500 * 1000 * 1000
    mySlice := make([]int, 0, limit) //vs mySlice := make([]int, 0)

    for i := 0; i < limit; i++ {
        mySlice = append(mySlice, i)
    }

    fmt.Println(len(mySlice))
}


On my machine:

time go run my_file.go


With preallocation:

real    0m2.129s
user    0m2.073s
sys     0m1.357s


Without preallocation

real    0m7.673s
user    0m9.095s
sys     0m3.462s

",45317074
1104,45333669,"Its important to check the returned error always. 

if err := xml.Unmarshal([]byte(xmlRawData), &xmlData); err != nil {
    fmt.Println(err)
}


The error you're getting is

cannot unmarshal into interface {}


Empty interface cannot be unmarshalled since the empty interface doesn't have any exported fields to map the xml keys/values to.

However there is way to get around. Implementing xml.Unmarshaler interface on your VendorMapInfo struct.

Example: Your updated code

type VendorMapInfo struct {
    MapHierarchyString string      `xml:""mapHierarchyString,attr""`
    FloorRefID         interface{} `xml:""floorRefId,attr""`
    Image              Image       `xml:""Image""`
    FloorDimension     VendorFloorDimension
}

type Image struct {
    Name string `xml:""imageName,attr""`
}

func (mf *VendorMapInfo) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
    // Attributes
    for _, attr := range start.Attr {
        switch attr.Name.Local {
        case ""mapHierarchyString"":
            mf.MapHierarchyString = attr.Value
        case ""floorRefId"":
            mf.FloorRefID = findFloorRefIDType(attr.Value)
        }
    }

    for {
        token, err := d.Token()
        if err != nil {
            return err
        }

        switch el := token.(type) {
        case xml.StartElement:
            if el.Name.Local == ""Image"" {
                item := new(Image)
                if err = d.DecodeElement(item, &el); err != nil {
                    return err
                }
                mf.Image = *item
            }
        case xml.EndElement:
            if el == start.End() {
                return nil
            }
        }
    }

    return nil
}


Complete code, play link: https://play.golang.org/p/wZQOsQv0Nq

Output:

{Locations:{Space: Local:} WirelessClientLocation:[{MacAddress:00:00:00:00:00:00 MapInfo:{MapHierarchyString:Head office>Ground floor>Store FloorRefID:-1122334455667789 Image:{Name:floorPlan1.png} FloorDimension:{Length:0 Width:0 Height:0 OffsetX:0 OffsetY:0 Unit:}}} {MacAddress:11:11:11:11:11:11 MapInfo:{MapHierarchyString:Head office>Ground floor>Store FloorRefID:-1122334455667789 Image:{Name:floorPlan1.png} FloorDimension:{Length:0 Width:0 Height:0 OffsetX:0 OffsetY:0 Unit:}}} {MacAddress:26:cd:96:46:0b:2b MapInfo:{MapHierarchyString: FloorRefID:0 Image:{Name:} FloorDimension:{Length:0 Width:0 Height:0 OffsetX:0 OffsetY:0 Unit:}}}]}

",45333364
1105,45368604,"Monitoring process exits because p.Wait() does not block.

From the docs:


  On most operating systems, the Process must be a child of the current
  process or an error will be returned.


You can perhaps poll the process pool to check if the process still exists.
",45368284
1106,45379942,"This is maybe related to some docker-compose bug.

Try cleaning containers

docker-compose down


Alternatively this (you will lose your container data):

docker rm -f $(docker ps -a -q)

",45361846
1107,45388909,"I think that the best answer would be an example.

Look at Client.CheckRedirect in the documentation.

type Client struct {
    // (...)
    CheckRedirect func(req *Request, via []*Request) error
}


This is a function that is being invoked whenever a http.Client has a redirect response. By the fact, that this function is a public property, you can set this when creating the Client object or afterwards and thus you can define custom behaviour on such case.

client := &http.Client{
    CheckRedirect: func(req *http.Request, via []*http.Request) error {
        return http.ErrUseLastResponse
    }
}


Function properties are just a delegates of custom behaviour (and not only!).

Another example would be creating an object which has an event.

type Example struct {
    EventHandler func(params []interface{})
}


You can specify a behaviour on that event by setting the Example.EventHandler property.
",45388814
1108,45395478,"It allows you to customize the function for a type without making it be from that type. 
",45388814
1109,45428021,"Yes, you can do that.

It does not need to go anywhere.

Purpose of the Done channel usually is just to signal the done event, so the value is not relevant and can be ignored.

It is the same as when you call a function and don't assign the return values to variables.

Consider this:

func getInt() int {
    return 1
}

func main() {
    getInt()  // does not ""go anywhere""
}


See this playground showing those examples:

https://play.golang.org/p/CA8P7gYpok
",45427963
1110,45443981,"You probably want to limit active concurrent requests to a more sensible number than 5000. Possibly spin up 10/20 workers and send individual files to them over a channel.

The http client should reuse connections for requests, assuming you always read the entire request body, and close it.

Something like this:

func main() {
    http.DefaultTransport.(*http.Transport).MaxIdleConnsPerHost = 100
    for i := 0; i < 10; i++ {
        wg.Add(1)
        go worker()
    }
    var csvs = []string{""http://example.com/a.csv"", ""http://example.com/b.csv""}
    for _, u := range csvs {
        ch <- u
    }
    close(ch)
    wg.Wait()
}

var ch = make(chan string)
var wg sync.WaitGroup

func worker() {
    defer wg.Done()
    for u := range ch {
        get(u)
    }
}

func get(u string) {
    resp, err := http.Get(u)
    //check err here

    // make sure we always read rest of body, and close
    defer resp.Body.Close()
    defer io.Copy(ioutil.Discard, resp.Body)

    //read and decode / handle it. Make sure to read all of body.
}

",45443848
1111,45444981,"
  I understand that sleep will cause the new goroutine to start the other thread for the specified amount of time


This is partly incorrect!

This would be correct on a machine with only one core where only one thread can be executed at a time.

On a machine with multiple cores go can execute as many goroutines parallel as there are cores. With parallel executed goroutines there is no guarantee at all, what will be executed before or after.
",45444880
1112,45444985,"You cannot say with any certainty what order concurrent operations will ""always"" execute in. That's how concurrency works. If you want to control the order of execution, either don't execute concurrently, or use synchronization constructs (e.g. mutex, channel) to control the order of operations.
",45444880
1113,45445211,"As others have said, there are no guarantees you can assume about the order of execution.

The Go scheduler has an internal algorithm that decides how to allocate the processor and there is little you can do to control this without resorting to synchronization (which would be the right approach to take here).

If you are interested in learning how to control synchronization between tasks, take a look at the sync package, and also at how channels work:

https://golang.org/pkg/sync/

https://tour.golang.org/concurrency/2

However, I want to add something that others have not mentioned, and while it does not allow you to control execution order, it might be worth commenting due to the nature of the question.

There is a runtime.Gosched function that you can use to hint the scheduler. It would yield the processor so it is likely that other threads will execute.

https://golang.org/pkg/runtime/#Gosched

If you add a call to Gosched instead of sleeping, in my tests it is much more likely that ""hello"" and ""world"" would output in order (though again, there is no guarantee and they will appear in random order at times).

Try it like this:

package main

import (
    ""fmt""
    ""runtime""
)

func say(s string) {
    for i := 0; i < 5; i++ {
        fmt.Println(s, i)
        runtime.Gosched()
    }
}

func main() {
    go say(""world"")
    say(""hello"")
}


Lastly, take a look at this article which you might find interesting as well:

http://container-solutions.com/surprise-golang-thread-scheduling/
",45444880
1114,45512527,"The only way I've been able to make working DLLs is to use buildmode=c-archive and write C stubs for all the go functions I want to export.  But I was working on Windows for this, I haven't had to mess with this on Linux.  It is a path to investigate.
",39616236
1115,45597771,"In your sample code you're creating arrays, not slices, hence the error. To create a slice of a specific length, use make, which does not require the length to be a constant. When you create an array, the length must be a constant, because you're creating an unnamed type which must be resolvable at compile time.
",45596789
1116,45604492,"So this is what I ended up doing (posting it as an answer to my question):

import ""unsafe""
import ""reflect""   

mySliceR := *(*reflect.SliceHeader)(unsafe.Pointer(&mySlice))
mySliceR.Len *= mySliceElemSize
mySliceR.Cap *= mySliceElemSize

byteSlice := *(*[]byte)(unsafe.Pointer(&mySliceR))


I tested it for different array sizes, and it is better than looping through individual elements (using only unsafe.Pointer) only when arrays are large enough.
",45596789
1117,45619883,"If you're using the same version of the same Go-based tool to compile the proto, you should get the same output. I would double-check that both are identical versions.
",45618300
1118,45653717,"The explanation lies in the fact that when dealing with the concrete struct itself, it has the proper information to handle this automatically. You can read in the tour here that:


  Go automatically handles conversion between values and pointers for
  method calls.


But when you are dealing with an interface{} type, it has less information on what is actually contained in the variable. It just knows there is a foo() method. But there is a subtlety here that requires extra explanation so here is an example.

https://play.golang.org/p/Y0fJcAISw1

type Foo interface {
    foo()
}
type Bar struct {}
func (b *Bar) foo() {}

type Baz struct {}
func (b Baz) foo() {}

func main() {
    b := Bar{}
    b.foo()

    var v Foo = &Bar{}
    // v = Bar{} // fails
    v.foo()

    v = Baz{}
    v.foo()
    v = &Baz{} // works too
    v.foo()
}


Notice that &Baz{} works even though it has a value receiver, but not the reverse. The reason being that a *Baz points to exactly one Baz, both of which exist (the pointer and the value), so the value is easily obtained. When you try to do v = Bar{}, the value exists, but the pointer does not, and Go will not automatically create one for an interface{} value.

This is all explained in detail under the Pointers and interfaces heading in this blog post
",45652560
1119,45653986,"Short answer var foo Foo = Bar{} is not working because the concrete value stored in an interface is not addressable.

Longer Version

Please read https://github.com/golang/go/wiki/MethodSets


  It is legal to call a pointer-valued method on anything that is
  already a pointer or whose address can be taken. It is legal to call a
  value method on anything which is a value or whose value can be
  dereferenced.


With respect to the above explanation, your code

b := Bar{}
b.foo()


works because b is addressable.


  The concrete value stored in an interface is not addressable.
  Therefore, when you call a method on an interface, it must either have
  an identical receiver type or it must be directly discernible from the
  concrete type: pointer- and value-receiver methods can be called with
  pointers and values respectively, as you would expect. Value-receiver
  methods can be called with pointer values because they can be
  dereferenced first. Pointer-receiver methods cannot be called with
  values, however, because the value stored inside an interface has no
  address. When assigning a value to an interface, the compiler ensures
  that all possible interface methods can actually be called on that
  value, and thus trying to make an improper assignment will fail on
  compilation.


According to the above explanation the concrete value stored in an interface is not addressable and hence the code,

var foo Foo = Bar{}


will not work because the concrete value stored in an interface, in this case Bar{}, is not addressable. 
",45652560
1120,45654151,"Half of your question depends on whether your value is addressable or not:


  For an operand x of type T, the address operation &x generates a
  pointer of type *T to x. The operand must be addressable, that is,
  either:
  
  
  a variable,
  pointer indirection, or
  slice indexing operation; or
  a field selector of an addressable struct operand; or
  an array indexing operation of an addressable array.
  
  
  As an exception to the addressability requirement, x may also be a
  (possibly parenthesized) composite literal.
  
  — Address operators


Bar{} is a composite literal, thus it is not addressable. You may type &Bar{} to create an object of type *Bar, but that is listed as ""an exception to the addressability requirement"", reinforcing the idea that Bar{} is not addressable in itself.

Variable b of type Bar can invoke b.foo() despite Bar.foo() requiring a pointer receiver for a good reason:


  A method call x.m() is valid if the method set of (the type of) x
  contains m and the argument list can be assigned to the parameter
  list of m. If x is addressable and &x's method set contains m,
  x.m() is shorthand for (&x).m()
  
  — Calls


However, that does not mean Bar.foo() is in the method set of b. This is because b has type Bar while Bar.foo() receives a value of type *Bar:


  A type may have a method set associated with it. The method set of an
  interface type is its interface. The method set of any other type T
  consists of all methods declared with receiver type T. The method
  set of the corresponding pointer type *T is the set of all methods
  declared with receiver *T or T (that is, it also contains the
  method set of T).
  
  — from Method sets


Because the method sets of b and the Foo interface differ, you cannot use  var foo Foo = b, despite b.foo() being converted to (&b).foo() by the compiler. Otherwise, var foo Foo = Bar{} would work. You may, however, use either of the following since Bar.foo() receives a *Bar:

var foo Foo = &b
var foo Foo = &Bar{}

",45652560
1121,45713197,"This question is impossibly broad. Entire books have been written on the topic.

But since you asked specifically about global variables, the simplest answer is:  Don't use global variables.

We're always taught that global variables are an anti-pattern. Testing is one of the main reasons that global variables and singletons is an anti-pattern.

If possible, refactor your global state to at least allow an instance variable, rather than a global.  Then you can pass that instance into your functions for testing.

As a simplified example, suppose you have the following global variable, and a function which uses it:

var globalFoo = 123

func doFoo() string {
    return fmt.Sprintf(""foo = %d"", globalFoo)
}


Modify your function to take your variable as an argument:

func doFoo(foo int) string {
    return fmt.Sprintf(""foo = %d"", foo)
}


This can be more complicated if your global state is a database connection, or a large number of variables, but the principle is the same: Don't use globals; pass variables instead.

In a legacy codebase, one method to allow testing, without changing your function signatures, is to create simple wrapping functions:

func doFoo() string {
    return realDoFoo(globalFoo)
}

func realDoFoo(foo int) string {
    fmt.Sprintf(""foo = %s"", foo)
}

",45711053
1122,45732044,"To answer the ""My Real Question: How can I customize the behaviour of mgo before upsert?"" - you can customise bson marshalling by defining bson Getter to the model. 

To illustrate how it works, lets simplify the model to avoid nested documents:

type Game struct {
    ID int `bson:""_id""`
    Name string
    Stats [] float64
}


With newGame as following:

newGame := Game{
    ID: 1,
    Name: ""foo"",
    Stats: []{5.0}
}


The update col.UpsertId(newGame.ID, newGame) by default marshals newGame into JSON, producing mongo query like:

update({_id:1}, {name: ""foo"", stats: [5]}, {upsert: true});


To make use of $set, $push etc, you can define a custom bson getter. E.g.

func (g Game) GetBSON() (interface{}, error) {
    return bson.M{
        ""$set"": bson.M{""name"": g.Name}, 
        ""$push"": bson.M{""stats"": bson.M{""$each"": g.Stats}},
    }, nil
}


So the update col.UpsertId(newGame.ID, newGame) will produce a mongodb query 

update({_id:1}, {$set: {name: ""foo""}, $push: {stats: {$each: [5]}}}, {upsert: true});


To make it crystal clear - the custom marshaler will be used in all mgo queries, so you probably don't want to define it directly to the model, but to its derivative to use in upsert operations only:

type UpdatedGame struct {
    Game
}

func (g UpdatedGame) GetBSON() (interface{}, error) {
    return bson.M{....}
}

.....

newGame := Game{
    ID: 1,
    Name: ""foo"",
    Stats: []{5.0}
}

col.UpsertId(newGame.ID, UpdatedGame{newGame})

",45718580
1123,45741268,"This:

for range <-md{


is not the same as:

for range md{


The latter ranges over the channel (what you want), while the former ranges over the value received from the channel when the loop starts, which happens to be a two-element array, hence the two executions. You're also ignoring the value received from the channel in the for statement, and reading from it again in the loop body, ignoring every other message on the channel (though this makes no difference in the example, since every value is identical, it would make a significant difference in practice). What you really want is:

for foo := range md{
    fmt.Println(foo)
}


Here's a working version of your playground example, slightly modified to avoid ""program took too long"" errors because in its current form it never stops: https://play.golang.org/p/RSUJFvluU5
",45741209
1124,45754815,"This is a known issue, see this thread:

https://github.com/golang/go/issues/20239

Hopefully they will fix it soon but for now it sounds like adding a short delay in your test is the simplest solution - it probably doesn't come up in real world use much because you won't trigger a shutdown so soon after starting. 
",45751869
1125,45836832,"In Go int is a predefined identifier, therefore it cannot be used as a variable name. So rename the first variable to anything else. Such as num1 and it will compile!

package main
import ""fmt""

func main() {
    var num1 int = 8
    fmt.Println(num1)

    var number int = 10
    fmt.Println(number)
}


Hope this helps!
",45836683
1126,45837752,"Unfortunately there is no ready solution for an in-memory io.WriteSeeker implementation in the standard lib.

But as always, you can always implement your own. It's not that hard.

An io.WriteSeeker is an io.Writer and an io.Seeker, so basically you only need to implement 2 methods:

Write(p []byte) (n int, err error)
Seek(offset int64, whence int) (int64, error)


Read the general contract of these methods in their documentation how they should behave.

Here's a simple implementation which uses an in-memory byte slice ([]byte). It's not optimized for speed, this is just a ""demo"" implementation.

type mywriter struct {
    buf []byte
    pos int
}

func (m *mywriter) Write(p []byte) (n int, err error) {
    minCap := m.pos + len(p)
    if minCap > cap(m.buf) { // Make sure buf has enough capacity:
        buf2 := make([]byte, len(m.buf), minCap+len(p)) // add some extra
        copy(buf2, m.buf)
        m.buf = buf2
    }
    if minCap > len(m.buf) {
        m.buf = m.buf[:minCap]
    }
    copy(m.buf[m.pos:], p)
    m.pos += len(p)
    return len(p), nil
}

func (m *mywriter) Seek(offset int64, whence int) (int64, error) {
    newPos, offs := 0, int(offset)
    switch whence {
    case io.SeekStart:
        newPos = offs
    case io.SeekCurrent:
        newPos = m.pos + offs
    case io.SeekEnd:
        newPos = len(m.buf) + offs
    }
    if newPos < 0 {
        return 0, errors.New(""negative result pos"")
    }
    m.pos = newPos
    return int64(newPos), nil
}


Yes, and that's it.

Testing it:

my := &mywriter{}
var ws io.WriteSeeker = my

ws.Write([]byte(""hello""))
fmt.Println(string(my.buf))

ws.Write([]byte("" world""))
fmt.Println(string(my.buf))

ws.Seek(-2, io.SeekEnd)
ws.Write([]byte(""k!""))
fmt.Println(string(my.buf))

ws.Seek(6, io.SeekStart)
ws.Write([]byte(""gopher""))
fmt.Println(string(my.buf))


Output (try it on the Go Playground):

hello
hello world
hello work!
hello gopher


Things that can be improved:


Create a mywriter value with an initial empty buf slice, but with a capacity that will most likely cover the size of the result PDF document. E.g. if you estimate the result PDFs are around 1 MB, create a buffer with capacity for 2 MB like this:
my := &mywriter{buf: make([]byte, 0, 2
Inside mywriter.Write() when capacity needs to be increased (and existing content copied over), it may be profitable to use bigger increment, e.g. double the current capacity to a certain extent, which reserves space for future appends and minimizes the reallocations.

",45836767
1127,45837791,"package main

import ""fmt""

func main() {
    // int is a predeclared type identifier
    var int int = 8
    // int is a variable identifier
    fmt.Println(int)

    // error: int is not a type
    var number int = 10
    fmt.Println(number)
}


You are shadowing the int identifier.

See The Go Programming Language Specification.

Go is a block structured programming language: 

Blocks

Declarations and scope

int is a predeclared identifier and is implicitly declared in the universe block.

The scope of a variable identifier declared inside a function begins at the end of the declaration and ends at the end of the innermost containing block.

The statement

var int int = 8


uses the predeclared int type to declare a variable identifier int, shadowing the predeclared identifier: Variable shadowing.
",45836683
1128,45855822,"The JSON package can only process exported struct fields (e.g. start with a capital letter). That's why you use the JSON tag so you can change the tag name/case to use. 

Otherwise, this works as you would expect. See example:

https://play.golang.org/p/pRVKNrekWe
",45855530
