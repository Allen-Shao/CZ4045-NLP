,PostId,Body,ParentId
0,36094230,"You could embed sort.IntSlice in your custom type:

type MySlice struct {
    sort.IntSlice
}

func (ms MySlice) ReverseSort() {
    sort.Sort(sort.Reverse(ms))
}

func main() {
    t2 := MySlice{sort.IntSlice{5, 4, 3, 1}}
    t2.ReverseSort()
    fmt.Println(t2)
}


(On the Go Playgroud.)

Of course, that makes constructing objects more difficult.



A post on golang-nuts discusses this:


  You ""cannot define new methods on non-local type[s],"" by design.
  
  The best practice is to embed the non-local type into your own own
  local type, and extend it. Type-aliasing (type MyFoo Foo) creates a
  type that is (more-or-less) completely distinct from the original. I'm
  not aware of a straightforward/best-practice way to use type
  assertions to get around that.
  
  
  Peter Bourgon
  


And:


  
    A type's methods are in the package that defines it. 
  
  
  This is a logical coherence. It is a compilation virtue. It is seen as
  an important benefit for large-scale maintenance and multi-person
  development projects.
  
  The power you speak of is not lost, though, because you can embed the
  base type in a new type as described above and add whatever you want
  to it, in the kind of functional ""is a"" that you seek, with the only
  caveat that your new type must have a new name, and all of its fields
  and methods must be in its new package.
  
  
  Michael Jones
  

",36094060
1,1736012,"I haven't written a large enough project yet to require a build system, so a simple build.sh is sufficient.

You can use $GOROOT, $GOARCH and $GOOS to determine what you need:

jurily@jurily ~ $ env | grep GO
GOARCH=amd64
GOROOT=/home/jurily/go
GOOS=linux


If it's enough for Go, it's enough for me.
",1735993
2,1736202,"I've been using scons; this is an example SConstruct file:

archs = {'amd64': '6', '386': '8', 'arm': '5',}

def gc(source, target, env, for_signature):
    targets = target[0]
    sources = ' '.join(str(s) for s in source)
    flags = ''
    for include in env.get('GOINCLUDE', []):
        flags += '-I %s ' % (include)
    return '%s -o %s %s %s' % (env['GOCOMPILER'], targets, flags, sources)

def ld(source, target, env, for_signature):
    targets = target[0]
    sources = ' '.join(str(s) for s in source)
    return '%s -o %s %s' % (env['GOLINKER'], targets, sources)

def _go_object_suffix(env, sources):
    return ""."" + archs[env['ENV']['GOARCH']]

def _go_program_prefix(env, sources):
    return env['PROGPREFIX']

def _go_program_suffix(env, sources):
    return env['PROGSUFFIX']

go_compiler = Builder(generator=gc,
                      suffix=_go_object_suffix,
                      src_suffix='.go',)
go_linker = Builder(generator=ld,
                    prefix=_go_program_prefix,
                    suffix=_go_program_suffix,)

# Create environment
import os
env = Environment(BUILDERS={'Go': go_compiler, 'GoProgram': go_linker},
                  ENV=os.environ,)
arch_prefix = archs[os.environ['GOARCH']]
env.SetDefault(GOCOMPILER=os.path.join(os.environ['GOBIN'], arch_prefix + 'g'))
env.SetDefault(GOLINKER=os.path.join(os.environ['GOBIN'], arch_prefix + 'l'))
# Build programs
# Modify this to suit your program
main_package = env.Go(target='main', source='main.go')
program = env.GoProgram(target='program', source=[main_package])

",1735993
3,1989788,"I've built my own little tool called gobuild for that, and am still working on it. It should be able to compile most programs/libs that don't interfacing with C code without having to write any build-scripts/makefiles.
",1735993
4,11753827,"You can find in Go Utils and Tools all the available build tools for Go.

But more of them are superseded by the ""go build"" command and the lack of Makefile with Go 1.
See ""The go tool"" blog post.


  Go packages don't have any build configuration at all. There's no makefiles, no descriptions of dependencies etc.
  How it works then? Everything is retrieved from the source code. To let the magic happen one thing has to be done first.


Even if Makefile can still be used, for pure Go source code, they can be removed (like in this code review for instance)
",1735993
5,40142237,"First, the bitmap field is a *image.Image, so it's of the same type and you don't need to convert it when you could just dereference it.

(*img.Bitmap).Bounds()


However, image.Image is an interface. A pointer to an interface is almost always a programming error.

Change your struct definition to

type Image struct {
    Src    string
    Title  string
    Width  int
    Height int
    Index  int
    Bitmap image.Image
}


and you can then just call img.Bitmap.Bounds() directly
",40142146
6,25025558,"Go is not python, you should properly check for args before you use it:

func main() {
    if len(os.Args) != 2 {
         fmt.Printf(""usage: %s [filename]\n"", os.Args[0])
         os.Exit(1)
    }
    file, err := os.Open(os.Args[1])
    if err != nil {
        log.Fatal(err)
    }
    fmt.Printf(""%s"", file)
}

",25025467
7,25025559,"First: You wouldn't want to do this. Try-catch-style error handling is no error handling. In Go you would check len(os.Args) first and access element 1 only if present.

For the rare cases you need to catch panics (and your case is not one of them!) use defer in combination with recover. See http://golang.org/doc/effective_go.html#recover
",25025467
8,25025563,"A panicking program can recover with the builtin recover() function:


  The recover function allows a program to manage behavior of a panicking goroutine. Suppose a function G defers a function D that calls recover and a panic occurs in a function on the same goroutine in which G is executing. When the running of deferred functions reaches D, the return value of D's call to recover will be the value passed to the call of panic. If D returns normally, without starting a new panic, the panicking sequence stops. In that case, the state of functions called between G and the call to panic is discarded, and normal execution resumes. Any functions deferred by G before D are then run and G's execution terminates by returning to its caller.
  
  The return value of recover is nil if any of the following conditions holds:
  
  
  panic's argument was nil;
  the goroutine is not panicking;
  recover was not called directly by a deferred function.
  


Here is an example of how to use this:

// access buf[i] and return an error if that fails.
func PanicExample(buf []int, i int) (x int, err error) {
    defer func() {
        // recover from panic if one occured. Set err to nil otherwise.
        if (recover() != nil) {
            err = errors.New(""array index out of bounds"")
        }
    }()

    x = buf[i]
}


Notice that more often than not, panicking is not the right solution. The Go paradigm is to check for errors explicitly. A program should only panic if the circumstances under which it panics do not happen during ordinary program executing. For instance, not being able to open a file is something that can happen and should not cause a panic while running out of memory is worth a panic. Nevertheless, this mechanism exists to be able to catch even these cases and perhaps shut down gracefully.
",25025467
9,28444392,"Some Golang official packages use panic/defer+recover as throw/catch, but only when they need to unwind a large call stack. In Golang's json package using panic/defer+recover as throw/catch is the most elegant solution.

from http://blog.golang.org/defer-panic-and-recover


  For a real-world example of panic and recover, see the json package from the Go standard library. It decodes JSON-encoded data with a set of recursive functions. When malformed JSON is encountered, the parser calls panic to unwind the stack to the top-level function call, which recovers from the panic and returns an appropriate error value (see the 'error' and 'unmarshal' methods of the decodeState type in decode.go).


Search for d.error(
at http://golang.org/src/encoding/json/decode.go

In your example the ""idiomatic"" solution is to check the parameters before using them, as other solutions have pointed.

But, if you want/need to catch anything you can do:

package main

import (
    ""fmt""
    ""os""
)

func main() {

    defer func() { //catch or finally
        if err := recover(); err != nil { //catch
            fmt.Fprintf(os.Stderr, ""Exception: %v\n"", err)
            os.Exit(1)
        }
    }()

    file, err := os.Open(os.Args[1])
    if err != nil {
        fmt.Println(""Could not open file"")
    }

    fmt.Printf(""%s"", file)
}

",25025467
10,36609099,"Note that the recover treatment of a panic Execution error (such as attempting to index an array out of bounds trigger) might change with go 1.7 after issue 14965

See CL 21214 and its test:


  runtime: make execution error panic values implement the Error interface
  
  Make execution panics implement Error as mandated by Run-time panics (specs), instead of panics with strings.


When you recover a panic error, you would be able to do:

if _, ok := recovered.(runtime.Error); !ok {




This is still being evaluated, and as Dave Cheney. mentions:


  I don't know what people are currently doing but from my POV this has been broken for a long time and nobody has complained so they are either explicitly relying on the broken behaviour, or nobody cares. Either way I think it's a good idea to avoid making this change.

",25025467
11,41631702,"I had to catch panics in a test case. I got redirected here.


  func.go


var errUnexpectedClose = errors.New(""Unexpected Close"")
func closeTransaction(a bool) {
    if a == true {
        panic(errUnexpectedClose)
    }
}



  func_test.go


func TestExpectedPanic() {
    got := panicValue(func() { closeTransaction(true) })
    a, ok := got.(error)
    if a != errUnexpectedClose || !ok {
        t.Error(""Expected "", errUnexpectedClose.Error())
    }
}

func panicValue(fn func()) (recovered interface{}) {
    defer func() {
        recovered = recover()
    }()
    fn()
    return
}


Used from https://github.com/golang/go/commit/e4f1d9cf2e948eb0f0bb91d7c253ab61dfff3a59 (ref from VonC)
",25025467
12,43386645,"Have you tried to test it with HTTP testing tools like ab, httperf, jmeter or alike? 
* Try to run them with different number of requests and simultaneous requests. 


First put static file to the webserver and try to fetch it in the same manner. Do you see such problems? If yes, there can problems with network configuration, few buffers, sockets maxfiles and so on. 
If not - try to feed this static file with golang app. If you see problems investigate them in golang settings. 
If no, check your app with db config. If there are problems check DB connections. May be they're not properly closed and got exhausted.

",43385437
13,42121891,"You have to insert your metadata into the client's context before calling the server.

For an unary RPC the client side looks like:

conn, _ := grpc.Dial(address, opts...)
client := NewMyClient(conn) // generated from your proto with the grpc protoc option

header := metadata.New(map[string]string{""authorization"": """", ""space"":  """", ""org"": """", ""limit"": """", ""offset"": """"})
// this is the critical step that includes your headers
ctx := metadata.NewContext(context.Background(), header)

request := // construct a request for your service
response, err := client.MyMethod(ctx, request)


For a stream, it looks almost the same:

conn, _ := grpc.Dial(address, opts...)
client := NewMyClient(conn) // generated from your proto with the grpc protoc option

header := metadata.New(map[string]string{""authorization"": """", ""space"":  """", ""org"": """", ""limit"": """", ""offset"": """"})
// this is the critical step that includes your headers
ctx := metadata.NewContext(context.Background(), header)
stream, err := client.MyMethodStream(ctx)

for {
    request :=  // construct a request for your service
    err := stream.Send(request)
    response := new(Response)
    err = stream.RecvMsg(response)
}




On the server side for an unary RPC:

func (s myServer) MyMethod(context.Context, *Request) (*Response, error) {
    headers, ok := metadata.FromContext(ctx)
    token := headers[""authorization""]
}


and for a streaming RPC:

func (s myServer) MyMethodStream(stream MyMethod_MyServiceStreamServer) error {
    headers, ok := metadata.FromContext(stream.Context())
    token := headers[""authorization""]
    for {
        request := new(Request)
        err := stream.RecvMsg(request)
        // do work
        err := stream.SendMsg(response)
    }
}




Note that for a stream there are only three times that headers can be sent: in the context used to open the initial stream, via grpc.SendHeader, and grpc.SetTrailer. It is not possible to set headers on arbitrary messages in a stream. For an unary RPC header are sent with every message and can be set in the initial context, with grpc.SendHeader and grpc.SetHeader, and grpc.SetTrailer.
",42116642
14,39353435,"Are you sure that the host in question as an eth0 device (and bosun has indexed that metadata)? nil means it couldn't find the entry.

The following works for me:

template test {
    subject = {{ .GetMeta """" ""addresses"" (printf ""host=%s,iface=eth0"" .Group.host) }}
}

",39352921
15,36380170,"In Go you can run all tests of a given project with a single command regardless of where your test files are located. In a terminal, change to your project base directory and run:

$ go test ./...


In my Go projects I usually have a separate Bash script that will do this for me. You can can place it, for instance, in bin/run_tests.sh with the following contents:

#!/bin/bash -e
time go test ./... | grep -v '^?'


Make this file executable and then run it:

$ ./bin/run_tests.sh


I don't have a separate test folder. Judging by most Go projects I see around what developers are going for is having the test file in the same directory where the file being tested is located.
",32396372
16,24966872,"Because once searchAndLog receives something on the channel, it will do its stuff and exit. Therefore after 5 directories, all of your goroutines that were running searchAndLog are now gone. Try this:

// Create 5 threads of searchAndLog()
for i := 0; i < numThreads; i++ {
  go func(i int) {
     for {
        searchAndLog(dir[i], i)
     }
  }(i)
}

",24966675
17,29663370,"H5T_NATIVE_UINT64 is NOT a constant but a #define that ultimately evaluates to (H5Open(), H5T_NATIVE_UINT64_g), which cgo does not understand.

It's easy to check by turning on debug output on gcc's preprocessor:

gcc -E -dM your_test_c_file.c | grep H5T_NATIVE_UINT64


Result:

#define H5T_NATIVE_UINT64 (H5OPEN H5T_NATIVE_UINT64_g)


Now the same for H5OPEN:

gcc -E -dM test_go.c | grep '#define H5OPEN'


gives:

#define H5OPEN H5open(),


Right now, cgo does understand simple integer constant defines like #define VALUE  1234, or anything that the gcc preprocessor will turn into an integer constant. See the function func (p *Package) guessKinds(f *File) in $GOROOT/src/cmd/cgo/gcc.go. 
",28442524
18,43322359,"What happens in your code is very correct and behaves as expected.

You create a context with 5 seconds timeout. You pass it to the request and make that request. Let's say that request returns in 2 seconds. You then do a select and either wait 10 seconds or wait for the context to finish. Context will always finish in the initial 5 seconds from when it was created and will also give that error every time it reaches the end.

The context is independent of the request and it will reach it's deadline unless, cancelled previously. You cancel the request when the function finishes using defer.

In your code the request takes your timeout in consideration. But the ctx.Err() will return deadline exceeded everytime it reaches the timeout. Since that's what happens inside the context. calling ctx.Err() multiple times will return the same error.

ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
defer cancel()

go func () {
    select {
    case <-time.After(10 * time.Second):
        fmt.Println(""overslept"")
    case <-ctx.Done():
        fmt.Println(ctx.Err()) // prints ""context deadline exceeded""
    }
}()
req, _ := http.NewRequest(""GET"", authorizationServer, nil)
req.Header = r.Header
req = req.WithContext(ctx)
res, error := client.Do(req)


From the context documentation:

// Err returns a non-nil error value after Done is closed. Err returns
// Canceled if the context was canceled or DeadlineExceeded if the
// context's deadline passed. No other values for Err are defined.
// After Done is closed, successive calls to Err return the same value.


In your code, the timeout will always be reached and not cancelled, that is why you receive DeadlineExceeeded. Your code is correct except the select part which will block until either 10 seconds pass or context timeout is reached. In your case always the context timeout is reached.

You should check the error returned by the client.Do call and not worry about the context error in here. You are the one controlling the context. If the request timeouts, a case you should test of course, then a proper error would be returned for you to verify. 
",43321894
19,42986840,"Usually we do a RECORD that has two columns (id,name)

-country
 |id
 |name


this way in our query we can use country.id to query by integer, or country.name to display the value for quick inspection.

Since nowadays storage is cheap, we can afford storing the literal representation in every column. Since BQ is append-only by design, and we usually read most recent row, that already contains the fresh value if the name meanwhile suffered a change. Using LAST_VALUE function we can always pick the last record that holds the last name.
",42986325
20,33162487,"If you want to iterate over a multiline string literal as shown in the question, then use this code:

for _, line := range strings.Split(strings.TrimSuffix(x, ""\n""), ""\n"") {
    fmt.Println(line)
}


Run the code on the playground

If you want to iterate over data read from a file, use bufio.Scanner. The documentation has an example showing how to iterate over lines:

scanner := bufio.NewScanner(f) // f is the *os.File
for scanner.Scan() {
    fmt.Println(scanner.Text()) // Println will add back the final '\n'
}
if err := scanner.Err(); err != nil {
   // handle error
}

",33162449
21,33162587,"You can use bufio.Scanner in Go which iterates over lines from an io.Reader. The following example creates a reader from the given multiline string and passes it to the scanner factory function. Each invocation of scanner.Scan() splits the reader on the next line and buffers the line. If there is no more lines it returns false. Calling scanner.Text() returns the buffered split. 

var x string = `this is
my multiline
string`

scanner := bufio.NewScanner(strings.NewReader(x))
for scanner.Scan() {
    fmt.Println(scanner.Text())
}


In the example, the for loop will continue until Scan() returns false at the end of the multiline string. In each loop we print the line returned by the scan. 

https://play.golang.org/p/U9_B4TsH6M
",33162449
22,28671574,"Omni completion (which the Go plugin offers) is triggered via , that is Ctrl + X followed by Ctrl-O. The prompt (-- mode ^X (^]^D^E^F^I^K^L^N^O^Ps^U^V^Y)) you've described hints at that.

If that is too cumbersome for you, you can define an insert mode mapping to shorten that; here's a (global) example to be put into your ~/.vimrc:

:inoremap  


If you use GVIM, you can also use the IDE-like  instead of the example  trigger.
",28671272
23,37330422,"Yes it's built in, I can't seem to find the implementation document (it's a relatively new feature in 1.5 or 1.6) however the syntax is:

package name // import ""your-custom-path""


Example: https://github.com/golang/crypto/blob/master/bcrypt/bcrypt.go#L7

// edit

The design document for this feature is https://docs.google.com/document/d/1jVFkZTcYbNLaTxXD9OcGfn7vYv5hWtPx9--lTx1gPMs/edit

// edit

@JimB pointed out to https://golang.org/cmd/go/#hdr-Import_path_checking, and in the go1.4 release notes: https://golang.org/doc/go1.4#canonicalimports
",37330303
24,33831574,"The Go Programming Language Specification

Keywords

The following keywords are reserved and may not be used as identifiers.

break        default      func         interface    select
case         defer        go           map          struct
chan         else         goto         package      switch
const        fallthrough  if           range        type
continue     for          import       return       var


.

func (p *Project) OmitUsername() *struct {
}


struct is a reserved keyword.

Without more information about what you are trying to do, it's hard to know what you want, pehaps something like this?

package main

import (
    ""encoding/json""
)

type Scheme struct{}

type Project struct {
    Id     uint
    Alias  string
    Data   *json.RawMessage
    Scheme Scheme
}

type UserProject struct {
    Username string
    Project
}

func (u *UserProject) GetProject() *Project {
    return &u.Project
}

func main() {}

",33831454
25,33831833,"With ""truly"" anonymous struct return value

If you want to use an anonymous struct return value, that's gonna look really ugly.

Why? Because when you define the return type, you have to describe the anonymous struct. And when you write a return statement, you have to provide the return value which will be a struct literal. A struct literal for an anonymous struct also has to describe the struct!

When you attempt to write this:

func (p *Project) OmitUsername() *struct {
    // return somethig
}


This syntax is not what you think: it doesn't contain the struct definition. Basically in your example the first { is the opening bracket of the anonymous struct definition, and not the opening bracket of the function body. And as such, the subsequent return is interpreted as being inside the anonymous struct definition which is invalid syntax, this is exactly what the error message states too (""syntax error: unexpected return"").

It should look like this:

func (p *Project) OmitUsername() *struct {
    Id     uint
    Alias  string
    Data   *json.RawMessage
    Scheme Scheme
} {
    // And now here comes the return statement
}


And if you also add the return statement which has to repeat the anonymous struct definition:

func (p *Project) OmitUsername() *struct {
    Id     uint
    Alias  string
    Data   *json.RawMessage
    Scheme Scheme
} {
    return &struct {
        Id     uint
        Alias  string
        Data   *json.RawMessage
        Scheme Scheme
    }{p.Id, p.Alias, p.Data, p.Scheme}
}


Yes, it's ugly. You can make it a little simpler by using named return value, and not returning a pointer, because zero value of pointers is nil, and to return something, you'd have to initialize it which would also involve repeating the anonymous struct! If you use a non-pointer, named return value, you will have a value of the anonymous struct right away, and you don't have to repeat the anonymous struct definition again, just assign values to its fields:

func (p *Project) OmitUsername2() (ret struct {
    Id     uint
    Alias  string
    Data   *json.RawMessage
    Scheme Scheme
}) {
    ret.Id = p.Id
    ret.Alias = p.Alias
    ret.Data = p.Data
    ret.Scheme = p.Scheme
    return
}


Using them:

p := Project{""Bob"", 1, ""bobie"", nil, nil}
fmt.Println(p.OmitUsername())
fmt.Println(p.OmitUsername2())


Output (try these on the Go Playground):

&{1 bobie  }
{1 bobie  }


Still ugly...

With another named type, using embedding

...Best would be to provide another named type to return and not an anonymous struct. You may utilize embedding to make this solution practical and short:

type BaseProject struct {
    Id     uint
    Alias  string
    Data   *json.RawMessage
    Scheme Scheme
}

type Project struct {
    BaseProject
    Username string
}

func (p *Project) OmitUsername() BaseProject {
    return p.BaseProject
}


Using it:

p := Project{BaseProject{1, ""bobie"", nil, nil}, ""Bob""}
fmt.Println(p.OmitUsername())


Output (try this on the Go Playground):

{1 bobie  }


Note:

Embedding is not really necessary, but this way the fields of the embedded type (BaseProject) will be promoted and so you can refer to them like p.Id as if they were defined in Project. Defining it as a regular field would also work.
",33831454
26,23954469,"Revel is simply a set of libraries on top of the standard Go libraries, plus some wrappers creating a nice structure for you.

You can debug it like any other go applications using GDB.

More specifically, you can build it first and then debug the corresponding executable (this assumes my GOPATH is ~/workspace):

[user@host ~]$ workspace/bin/revel new app
~
~ revel! http://revel.github.io
~
Your application is ready:
    /home/user/workspace/src/app

You can run it with:
   revel run app
[user@host ~]$ workspace/bin/revel build app app
~
~ revel! http://revel.github.io
~
INFO  2014/05/30 12:21:25 revel.go:320: Loaded module static
TRACE 2014/05/30 12:21:25 build.go:128: Exec: [/usr/bin/git --git-dir=/home/user/workspace/src/app/.git describe --always --dirty]
WARN  2014/05/30 12:21:25 build.go:132: Cannot determine git repository version: exit status 128
TRACE 2014/05/30 12:21:25 build.go:77: Exec: [/home/user/go/bin/go build -ldflags -X app/app.APP_VERSION """" -tags  -o /home/user/workspace/bin/app app/app/tmp]


You then have an self-contained executable app at /home/user/workspace/bin/app, which you can run independently from revel like so (note that cmd line arguments are mandatory, otherwise the program will crash):

[user@host ~]$ workspace/bin/app -importPath app revel -srcPath ""workspace/src"" -runMode dev
INFO  2014/05/30 12:51:40 revel.go:320: Loaded module static
INFO  2014/05/30 12:51:40 revel.go:320: Loaded module testrunner
INFO  2014/05/30 12:51:40 main.go:26: Running revel server
Listening on :9000...


You can then debug this executable using GDB as you would do any other program:

[user@host ~]$ gdb -silent --args workspace/bin/app -importPath app revel -srcPath ""workspace/src"" -runMode dev
Reading symbols from workspace/bin/app...done.
Loading Go Runtime support.


Then using the GDB commands to start the program and set breakpoints:

(gdb) start
Temporary breakpoint 1 at 0x400c00: file /home/user/workspace/src/app/app/tmp/main.go, line 23.
Starting program: /home/user/workspace/bin/app -importPath app revel -srcPath workspace/src -runMode dev
warning: Could not load shared library symbols for linux-vdso.so.1.
Do you need ""set solib-search-path"" or ""set sysroot""?
[Thread debugging using libthread_db enabled]
Using host libthread_db library ""/usr/lib/libthread_db.so.1"".
[New Thread 0x7fffe7804700 (LWP 5742)]

Temporary breakpoint 1, main.main () at /home/user/workspace/src/app/app/tmp/main.go:23
23      func main() {
(gdb) b workspace/src/app/app/controllers/app.go:9
Breakpoint 2 at 0x465610: file /home/user/workspace/src/app/app/controllers/app.go, line 9.
(gdb) cont
Continuing.
INFO  2014/05/30 13:12:31 revel.go:320: Loaded module static
INFO  2014/05/30 13:12:31 main.go:26: Running revel server
TRACE 2014/05/30 13:12:31 controller.go:375: Registered controller: App
TRACE 2014/05/30 13:12:31 controller.go:375: Registered controller: Static
TRACE 2014/05/30 13:12:31 watcher.go:94: Watching: /home/user/workspace/src/app/app/views
TRACE 2014/05/30 13:12:31 watcher.go:94: Watching: /home/user/workspace/src/app/app/views/App
TRACE 2014/05/30 13:12:31 watcher.go:94: Watching: /home/user/workspace/src/app/app/views/errors
TRACE 2014/05/30 13:12:31 watcher.go:94: Watching: /home/user/workspace/src/github.com/revel/revel/templates
TRACE 2014/05/30 13:12:31 watcher.go:94: Watching: /home/user/workspace/src/github.com/revel/revel/templates/errors
TRACE 2014/05/30 13:12:31 i18n.go:119: Successfully loaded messages from file sample.en
TRACE 2014/05/30 13:12:31 watcher.go:72: Watching: /home/user/workspace/src/app/conf/routes
[New Thread 0x7fffe6ea3700 (LWP 5743)]
[New Thread 0x7fffe66a2700 (LWP 5744)]
[New Thread 0x7fffe5ea1700 (LWP 5745)]
[New Thread 0x7fffe56a0700 (LWP 5746)]
Listening on :9000...


At this point, your program is running, but your controllers are not (yet) called: the code will only be executed when a query comes in, so go to your browser and access: ""localhost:9000"" (or whatever port you configured in app.conf) to trigger the response:

TRACE 2014/05/30 13:12:36 template.go:174: Refreshing templates from [/home/user/workspace/src/app/app/views /home/user/workspace/src/github.com/revel/revel/templates]
INFO  2014/05/30 13:12:36 router.go:293: Skipping routes for inactive module testrunner
TRACE 2014/05/30 13:12:36 i18n.go:183: Unable to read locale cookie with name 'REVEL_LANG': http: named cookie not present
TRACE 2014/05/30 13:12:36 i18n.go:149: Found Accept-Language header value: en-GB
[Switching to Thread 0x7fffe56a0700 (LWP 5746)]

Breakpoint 2, app/app/controllers.App.Index (c=..., ~anon0=...) at /home/user/workspace/src/app/app/controllers/app.go:9
9       func (c App) Index() revel.Result {
(gdb) 


And you are now at your breakpoint in your controller.

And then proceed using GDB. (There are plenty of interface to GDB, from command line (like CGDB) to graphical ones, or ones included in IDEs (like in GoClipse), but it all boils down to the same process eventually.

Good luck with your code !
",23952886
27,31685550,"Characters that have special meaning in the shell need to be quoted or escaped. You can find complete list in the shell's man pages (under ""Quoting"" in man 1 bash). 

In this case, you can either quote or escape the baskslash

-string=hello\\Bob
// or
-string='hello\Bob'

",31684942
28,40280192,"You can set the destinationTable property and even place in a separate dataset where you set a default expiration time eg 1 hour, 2days or whatever for the entire dataset. This way whatever table you create under that dataset automatically expires.

This way you control the name of the name of the table you created, and this way it will automatically expire and you don't need to build a script to delete it and won't incure costs.
",40279985
29,19472694,"As you're dealing with interface{} values you either need type assertions or reflection.

If you know which types you will deal with, type assertions are probably the way to go
(Code on play):

func GetItem(key Key) interface{} {
    return &Item{key, ""Value from GetFromMemory""}
}

func Get(key Key, item interface{}) {
    switch v := item.(type) {
        case **Item:
            *v = GetItem(key).(*Item)
    }
}

// Usage:
var item *Item
Get(""Key1"", &item)


The code in Get is laid out so that you can easily add more conditions for several more 
types. The type switch checks the underlying type of item. In this case it is a
pointer to a pointer to an Item (it was *Item in main, then we gave Get the address of &item, making it a **Item).

In the section that matches when the type matches, we can then call GetItem, assert that the resulted object is of type *Item and copy it to *v.

Note that I changed the item variable to *Item as you're producing a pointer value in GetItem, so it makes more sense to get the pointer instead of a copy of an Item object.

Also note that you need to check the result of type assertions like the one used to 
retrieve the value from GetItem. If you don't and the type does not match, say, *Item,
your code will blow up with a runtime panic.

Checked type assertions:

v, ok := someInterfaceValue.(SomeType)
// ok will be true if the assertion succeeded


For the sake of completeness, you can solve your problem with reflection as well.
Define Get as follows (Example on play):

func Get(key Key, item interface{}) {
    itemp := reflect.ValueOf(item).Elem()
    itemp.Set(reflect.ValueOf(GetItem(key)))
}


What happens is that at first the reflected value of item (type **Item) is dereferenced,
assuming that it is a pointer value, giving us a reflected value with type *Item. Said
value is then set with the reflected value of GetItem by using the Set method.

Of course you will need to check whether the kind of item is actually a pointer. 
Not doing this and passing a non-pointer value to Get will result in panics.
",19472506
30,26929991,"A good article to refer to is ""Middlewares in Go: Best practices and examples""


  The first code smell we encounter when writing a web application in Go is code duplication.
  Before processing the request, we will often need to log the request, convert app errors into HTTP 500 errors, authenticate users, etc. And we need to do most of these things for each handler.
  
  We could create a function with a closure. But if we have multiple functions like that, it will become as bad as callback spaghetti in Javascript. We don't want that.
  
  So we can write a handler and pass another handler to it.


loggingHandler(recoverHandler(indexHandler))



  So a middleware would be something like func (http.Handler) http.Handler
  This way we pass a handler and returns a handler. At the end we have one handler and can be called with http.Handle(pattern, handler)




Alice


  Alice is a small package to chain handlers more elegantly. Furthermore, we can create a common list of handlers and reuse them for each route like this:


func main() {
  commonHandlers := alice.New(loggingHandler, recoverHandler)
  http.Handle(""/about"", commonHandlers.ThenFunc(aboutHandler))
  http.Handle(""/"", alice.New(commonHandlers, bodyParserHandler).ThenFunc(indexHandler))
  http.ListenAndServe("":8080"", nil)
}



  Problem solved. We now have a middleware system that is idiomatic and use standard interfaces. Alice is 50 lines of code, so it is a very small dependency.

",26926488
31,31194663,"Let's break down the example:

The variable a is set before the function setup() returns because reads and writes within a single goroutine must behave as if they executed in the order specified by the program [1].

The single call to setup() from once.Do() happens before any call of once.Do() returns [2].

Therefore, the variable a is set before any call to once.Do() returns. No further synchronization is required to establish this before relationship.

The question asks about struct fields, not a single variable as in the example. As far as the memory model is concerned, struct fields are variables. All of the logic that applies to  the variable in the example applies to fields in a struct.
",31193406
32,35689967,"Well the error is pretty self explanatory:


  cannot use (*term, variable name) (type elastic.AggregationBucketKeyItem 


Whatever your *term value

Generated by: for _, term := range terms.Buckets {

is not the right type for the function

extractBucket(parts []string, aggs elastic.Aggregations)


Takes a type of elastic.Aggregations
",35689930
33,35690322,"It is a common misunderstanding that embedding a type makes you ""inherit"" that type. Even though AggregationBucketSignificantTerms embeds an Aggregations, it is not one to the compiler. It merely has a field of type Aggregations, and it provides methods from that type at it's top level. It feels a bit like inheritance, but is probably not what you are used to with things like Java subclasses.

To solve it you can try ""Value"": extractBucket(parts[1:], *term.Aggregations),, but I am not clear if that will solve your problem or not.
",35689930
34,19115627,"You seem to have selected the GOPATH, but the tool wants the GOROOT! Look at this test that you fail:

https://github.com/mtoader/google-go-lang-idea-plugin/blob/master/src/ro/redeul/google/go/sdk/GoSdkUtil.java#L84

I can only see linux_amd64 barely under your popup which indicates a GOPATH to me.

In general, the trend nowadays is to install packages/tools (especially when they're so young like GO) as non-root users and in your home directory and adjust $PATH and $GOPATH in your environment instead of installing it globally. This will make it much easier to upgrade and change versions. I'd recommend to place go in ~/usr/local/go and your GOPATH into ~/gopath. Then point IntelliJ to ~/usr/local/go
",19108421
35,20533130,"It turns out that google-go-lang-idea-plugin requires a slightly different folder structure than the default apt install produces. To fix it:

# mkdir /usr/lib/go/bin
# ln -s /usr/bin/go    /usr/lib/go/bin/go
# ln -s /usr/bin/godoc /usr/lib/go/bin/godoc
# ln -s /usr/bin/gofmt /usr/lib/go/bin/gofmt

",19108421
36,38720289,"So I just had this exact problem on IntelliJ 2016.1.3 with Go 1.5.

I had installed the IntelliJ Go Plugin a while ago and installed GO 1.5 a while back, and it all worked fine. Now i checked and suddenly, I'm sure I didn't remove it, GO 1.5 was gone from my system. But who knows, I haven't worked with go for a bit, so I might have removed it. 

Anyway, after a bit of debugging, the following steps helped me: 


Install the most current Go version (currently for me 1.6.3). Follow the instructions on https://golang.org/doc/install
Update the Plugin for Go in IntelliJ !!!
Set the SDK in IntelliJ for the project:File -> Project Structure -> Project -> under Project SDK add a New SDK and navigate to your go installation.
Click Apply and then Ok

",19108421
37,34791077,"
  Why does pprof think the heap is 14 MB, but Windows says the memory use is 70 MB? Is the rest the stack?


Besides the heap, there's also the Go runtime, the stack, the code segment. Also the OS might allocate more than it's actually needed. Also, is the amount reported by Windows the resident memory or the total allocated by the OS memory?
",34785048
38,32135428,"No there is not.

If you want to 'know' your types you'll have to register them.
",32132064
39,32135558,"Unfortunately, I don't think this is possible. Packages are not ""actionable"" in Go, you can't ""call a function"" on it. You can't call a function on a type either, but you can call reflect.TypeOf on an instance of the type and get reflect.Type which is a runtime abstraction of a type. There just isn't such mechanism for packages, there isn't a reflect.Package.

With that said, you could file an issue about the absence of (and practicality of adding) reflect.PackageOf etc.
",32132064
40,32135975,"Warning: untested and hacky. Can break whenever a new version of Go is released.

It is possible to get all types the runtime knows of by hacking around Go's runtime a little. Include a small assembly file in your own package, containing:

TEXT yourpackage·typelinks(SB), NOSPLIT, $0-0
    JMP reflect·typelinks(SB)


In yourpackage, declare the function prototype (without body):

func typelinks() []*typeDefDummy


Alongside a type definition:

type typeDefDummy struct {
    _      uintptr           // padding
    _      uint64            // padding
    _      [3]uintptr        // padding
    StrPtr *string           
}


Then just call typelinks, iterate over the slice and read each StrPtr for the name. Seek those starting with yourpackage. Note that if there are two packages called yourpackage in different paths, this method won't work unambiguously.


  can I somehow hook into the reflect package to instantiate new instances of those names?


Yeah, assuming d is a value of type *typeDefDummy (note the asterisk, very important):

t := reflect.TypeOf(*(*interface{})(unsafe.Pointer(&d)))


Now t is a reflect.Type value which you can use to instantiate reflect.Values.



Edit: I tested and executed this code successfully and have uploaded it as a gist.

Adjust package names and include paths as necessary.
",32132064
41,32142080,"In Go 1.5, you can use the new package types and importer to inspect binary and source packages. For example:

package main

import (
    ""fmt""
    ""go/importer""
)

func main() {
    pkg, err := importer.Default().Import(""time"")
    if err != nil {
        fmt.Printf(""error: %s\n"", err.Error())
        return
    }
    for _, declName := range pkg.Scope().Names() {
        fmt.Println(declName)
    }
}


You can use the package go/build to extract all the packages installed. Or you can configure the Lookup importer to inspect binaries outside the environment.

Before 1.5, the only no-hacky way is to use the package ast to compile the source code.
",32132064
42,25567077,"There are a couple of issues at play here:


The structures defined by JSON are not all representable in CSV, for example:


Objects e.g. {""name"":""john""}
Arrays e.g. [""john"", ""mike"", ""sam""]

There is no CSV standard. Well, there is RFC-4180, but most CSV encoders/decoders don't adhere to it because Microsoft.
The package you are using is very poorly coded.


One of the main differences among CSV implementation is the quote-handling. Consider the JSON string: ""\""Hello, world!\"""".

Depending on our marshaller we could end up with any of the following CSV representations for the string:


""""""Hello, world!""""""
""\""Hello, world!\""""
'""Hello, world!""'


Some encoders will even escape the comma inside of the string. The package you describe circumvents this issue by skipping the commas altogether. Which is a very poor design decision if you ask me.

Everything you need is in Go's standard library:


encoding/json
encoding/csv

",25566411
43,25567183,"Using this code you will be able to read your json data in a Go struct really easily:

package main

import (
    ""encoding/json""
    ""fmt""
)

// define the User type 
type User struct {
    Name     []string
    Password string
}

type DataStruct struct {
    User      User
    Remote_ip string
    Dt        string
}

func main() {
     var jsonBlob = []byte(`{""user"": {""name"":[""jehiah, mike, semo""], ""password"": ""root""},
  ""remote_ip"": ""127.0.0.1"", ""dt"" : ""[20/Aug/2010:01:12:44 -0400]""}`)

     var data DataStruct
     err := json.Unmarshal(jsonBlob, &data)
     if err != nil {
          fmt.Println(""error:"", err)
     } else {
          fmt.Printf(""%+v"", data)
     }

}


If you have never used the encoding/json package you should read the official Golang json article.

When you have correctly read the data in the DataStruct structure, you will be able to serialize it using the proper Golang csv package.
",25566411
44,41992654,"I would make 'Baskets' a struct within 'Response', create a 'BasketsData' struct,  and give it all some labels. 

type Fruit struct {
    Name   string `json:""Name""`
    Season string `json:""Season""`
}

type BasketData struct {
    Count  int     `json:""Count""`
    Fruits []Fruit `json:""Fruits""`
}

type Response struct {
    Basket BasketData `json:""Basket""`
}


This way you will get a top level JSON response when you marshall it.

fruitmania := []Fruit{{Name: ""Mango"", Season: ""Summer""},
                       {Name: ""Fig"", Season: ""Winter""}}
basket := Response{BasketData{Count: 100, Fruits: fruitmania}}

b, _ := json.Marshal(basket)
fmt.Println(string(b))


checkit-checkit out:
https://play.golang.org/p/TuUwBLs_Ql
",41992035
45,42005122,"Your model is totally correct and valid, but the JSON object is not. ""Fruits"" doesn't have name if it should be key value pair or it should be wrapped in [] not {}.

JSON obj should be formatted like this:

{
  ""Basket"" : {
    ""Count"": 1,
    ""Fruits"": [
      {
        ""Name"":""Mango"", 
        ""Season"":""Summer""
      },
      {
        ""Name"":""Fig"", 
        ""Season"":""Winter""
      }
    ]
  }
}


And actually invalid json shouldn't work https://play.golang.org/p/yoW7t4NfI7
",41992035
46,24393816,"I ran into this same issue and after looking at if for a long time I read the doc on Scan and it says


  If an argument has type *[]byte, Scan saves in that argument a copy of the corresponding data. The copy is owned by the caller and can be modified and held indefinitely. The copy can be avoided by using an argument of type *RawBytes instead; see the documentation for RawBytes for restrictions on its use.


What I think is happening if you use *json.RawMessage then Scan does not see it as a *[]byte and does not copy into it. So you get in internal slice on the next loop Scan overwrites. 

Change your Scan to cast the *json.RawMessage to a *[]byte so Scan will copy the values to it.

    err := rows.Scan(
        &a.Id,
        (*[]byte)(a.Doc),
    )

",24069459
47,28130630,"In case that helps anyone : 

I used masebase anwser to INSERT a json.RawMessage property of my struct in a postgresql db column having jsonb column type.

All you need to do is cast : ([]byte)(a.Doc) in the insert binding method (without the * in my case).
",24069459
48,44784809,"When doing this:

now := MysqlTime(time.Now())


It tries to convert a Time to your MysqlTime type (which throws an error).

Did you mean to actually initialize the inner Time attribute, like so?

now := MysqlTime{time.Now()}

",44784676
49,34929843,"for without any additional statements is basically the same as while (true) in other languages, an infinite loop.
",34929803
50,34930016,"
  The Go Programming Language Specification
  
  For statements
  
  A ""for"" statement specifies repeated execution of a block. The
  iteration is controlled by a condition, a ""for"" clause, or a ""range""
  clause.

ForStmt = ""for"" [ Condition | ForClause | RangeClause ] Block .
Condition = Expression .

  
  In its simplest form, a ""for"" statement specifies the repeated
  execution of a block as long as a boolean condition evaluates to true.
  The condition is evaluated before each iteration. If the condition is
  absent, it is equivalent to the boolean value true.


If the condition is absent, for example, for { ... }, it is equivalent to the boolean value true, for example for true { ... }. It is sometimes referred to as an infinite loop. Therefore, you will need another mechanism, such as break or return, to terminate the loop.

The documentation for the for statement is the The Go Programming Language Specification.
",34929803
51,17564467,"Here are the structure definitions :

// A Word represents a single digit of a multi-precision unsigned integer.
type Word uintptr

type nat []Word

type Int struct {
    neg bool // sign
    abs nat  // absolute value of the integer
}

type Rat struct {
    // To make zero values for Rat work w/o initialization,
    // a zero value of b (len(b) == 0) acts like b == 1.
    // a.neg determines the sign of the Rat, b.neg is ignored.
    a, b Int
}


There is no explicit limit. The limit will be your memory or, theoretically, the max array size (2^31 or 2^63, depending on your platform).



If you have practical concerns, you might be interested by the tests made in http://golang.org/src/pkg/math/big/nat_test.go, for example the one where 10^100000 is benchmarked.

And you can easily run this kind of program :

package main

import (
    ""fmt""
    ""math/big""
)

func main() {
    verybig := big.NewInt(1)
    ten := big.NewInt(10)
    for i:=0; i<100000; i++ {
       temp := new(big.Int)
       temp.Mul(verybig, ten)
       verybig = temp
    }
    fmt.Println(verybig)
}


(if you want it to run fast enough for Go Playground, use a smaller exponent than 100000)

The problem won't be the max size but the used memory and the time such computations take.
",17564335
52,11321996,"Compiling a Go package on Windows is like compiling a Go package on Linux or Mac OS X. Use the go build command. There is no make file.

Here are some instructions.

Getting Started

How to Write Go Code

Compile packages and dependencies
",11321668
53,11322515,"There are no more Makefiles needed in Go, so the make tool isn't necessary. You also do not need cygwin.

If you do not seem to have a valid go command in your windows shell, then try following the official docs on installing Go for windows


  Zip archive
  
  Extract the zip file to the directory of your choice (we suggest
  c:\Go).
  
  If you chose a directory other than c:\Go, you must set the GOROOT
  environment variable to your chosen path.
  
  Add the bin subdirectory of your Go root (for example, c:\Go\bin) to
  to your PATH environment variable.
  
  MSI installer (experimental)
  
  Open the MSI file and follow the prompts to install the Go tools. By
  default, the installer puts the Go distribution in c:\Go.
  
  The installer should put the c:\Go\bin directory in your PATH
  environment variable. You may need to restart any open command prompts
  for the change to take effect.
  
  Setting environment variables under Windows
  
  Under Windows, you may set environment variables through the
  ""Environment Variables"" button on the ""Advanced"" tab of the ""System""
  control panel. Some versions of Windows provide this control panel
  through the ""Advanced System Settings"" option inside the ""System""
  control panel.


The last section is important. Your windows PATH environment variable needs to have C:\Go\bin, so that you will have go in your path.
",11321668
54,24731788,"from: Golang windows, a complete setup guide, http://noypi-linux.blogspot.com/2014/07/golang-windows-complete-setup-guide.html

1) download ZIP


  Get the latest code from: http://golang.org/dl/


2) extract ZIP


  Extract zip to example C:\local\dev\go


3) create a gopath directory,


  Gopath is where third parties will be stored. Example if you will
  execute a ""go get github.com/somelib"", this library will be stored in
  gopath. Create a c:\local\dev\gopath


4) set the environmental variables


  open System Properties->Advanced->Environmental Variables


GOROOT=C:\local\dev\go
GOBIN=%GOROOT%\bin
GOPATH=c:\local\dev\gopath


5) add your gobin to PATH


  append C:\local\dev\go\bin to PATH


6) test

6.1) create the path ""C:\local\dev\gopath\src\myfirstproject""

6.2) create the main.go file ""C:\local\dev\gopath\src\myfirstproject\main.go""

package main

import ""fmt""

func main() {
    fmt.Println(""Hi foobar"")
}


6.2) you can now build the project anywhere example,

6.2.1) open cmd.exe

6.2.2) cd c:\temp

6.2.3) go build myfirstproject

6.2.4) run myfirstproject.exe

7) get a few libraries

7.1) you can download some free git, svn, and hg for windows

7.2) once you have them you can now do ""go get -u github.com/somelib""

8) get an IDE


  download liteide


congrats!
",11321668
55,36755088,"Ideally (at least in my opinion), you would essentially just pipe stdout to Fluentd.

If you happen to be also using Docker for your application you can do this easily using the built in logging drivers: 

https://docs.docker.com/engine/admin/logging/overview/

Otherwise, there seem to be a few options to help get stdout to Fluentd:

12Factor App: Capturing stdout/stderr logs with Fluentd
",36744360
56,15103151,"Effectively, you are running:

package main

import (
    ""fmt""
    ""time""
)

func main() {
    returnCurrentTime := func() string {
        return time.Now().String()
    }

    c := make(chan string, 2)

    asyncReturnCurrentTime := func(c chan string) {
        time.Sleep(2001 * time.Millisecond)
        c <- returnCurrentTime()
    }

    go asyncReturnCurrentTime(c)
    go asyncReturnCurrentTime(c)
    go asyncReturnCurrentTime(c)
    fmt.Println(<-c)
    fmt.Println(<-c)
    fmt.Println(<-c)
    fmt.Println()
    go asyncReturnCurrentTime(c)
    go asyncReturnCurrentTime(c)
    go asyncReturnCurrentTime(c)
    fmt.Println(<-c)
    fmt.Println(<-c)
    fmt.Println(<-c)
    fmt.Println()
}


Output:

2013-02-26 21:28:22.069581655 -0500 EST
2013-02-26 21:28:22.069688722 -0500 EST
2013-02-26 21:28:22.069695217 -0500 EST

2013-02-26 21:28:24.070985411 -0500 EST
2013-02-26 21:28:24.070999309 -0500 EST
2013-02-26 21:28:24.071002661 -0500 EST



  Send statements
  
  Both the channel and the value expression are evaluated before
  communication begins. Communication blocks until the send can proceed.


The returnCurrentTime() expression (the timestamp) is evaluated immediately, before an attempt is made to send. It's not a timestamp for the send. The send may happen later if the buffer is full.

Also, measuring actual send and receive times, the buffering delay for chan c is going to be inconsequential: send, send, block, receive, unblock, send.  For example, 

c <-;  2013-02-26 23:29:34.505456624 -0500 EST
c <-;  2013-02-26 23:29:34.505467030 -0500 EST
<- c;  2013-02-26 23:29:34.505468497 -0500 EST
c <-;  2013-02-26 23:29:34.505518015 -0500 EST

c <-;  2013-02-26 23:31:36.506659943 -0500 EST
c <-;  2013-02-26 23:31:36.506664832 -0500 EST
<- c;  2013-02-26 23:31:36.506669302 -0500 EST
c <-;  2013-02-26 23:31:36.506696540 -0500 EST

",15102643
57,37813566,"Your default case is first, so nothing else can ever match. Put that at the end. You can't scan into a value, you need a pointer, so change the type switch cases to their pointer equivalents.

switch t := input.(type) {
case *int:
    _, err = fmt.Scanf(""%d"", input)
case *string:
    _, err = fmt.Scanf(""%s"", input)
default:
    fmt.Printf(""unexpected type %T"", t)
}


You have to pass in a pointer to the interface argument, so use the use & operator there.

var firstName string
getUserInput(&firstName)

var age int
getUserInput(&age)



You lose the input, or only read part of it if you try to scan the wrong type. If you want to scan for multiple types, it's often better to read the token from stdin, and check that against the types you want. Not only do you then have the input for comparison, but you also have it to produce useful error messages.

",37813173
58,28355924,"Add $GOPATH/bin to your PATH variable in your shell, 

for bash:

export PATH=$GOPATH/bin:$PATH

",28353111
59,10499051,"Assuming the question is about Go, e.g.

var _ foo.RequiredInterface = myType{} // or &myType{} or [&]myType if scalar


as a TLD will check that for you at compile time.

EDIT: s/[*]/&/

EDIT2: s/dummy/_/, thanks Atom
",10498547
60,10499906,"Like this:

http://play.golang.org/p/57Vq0z1hq0

package main

import(
    ""fmt""
)

type Test int

func(t *Test) SayHello() {
    fmt.Println(""Hello"");   
}

type Saluter interface{
    SayHello()
    SayBye()
}

func main() {
    t := Saluter(new(Test))
    t.SayHello()
}


Will yield:

prog.go:19: cannot convert new(Test) (type *Test) to type Saluter:
    *Test does not implement Saluter (missing SayBye method)

",10498547
61,10562921,"I don't like the idea of making compiler throw errors by putting dummy lines in the main code. That's a smart solution that works, but I prefer to write a test for this purpose.

Assuming that we have:

type Intfc interface { Func() }
type Typ int
func (t Typ) Func() {}


This test makes sure Typ implements Intfc:

package main

import (
    ""reflect""
    ""testing""
)

func TestTypes(t *testing.T) {
    var interfaces struct {
        intfc Intfc
    }
    var typ Typ
    v := reflect.ValueOf(interfaces)
    testType(t, reflect.TypeOf(typ), v.Field(0).Type())
}

// testType checks if type t1 implements interface t2
func testType(t *testing.T, t1, t2 reflect.Type) {
    if !t1.Implements(t2) {
        t.Errorf(""%v does not implement %v"", t1, t2)
    }
}


You can check all of your types and interfaces by adding them to TestTypes function. Writing tests for Go is introduced here.
",10498547
62,25324011,"package main

import (
    ""fmt""
)

type Sayer interface {
    Say()
}

type Person struct {
    Name string
}

func(this *Person) Say() {
    fmt.Println(""I am"", this.Name)
}

func main() {
    person := &Person{""polaris""}

    Test(person)
}

func Test(i interface{}) {
    //!!here ,judge i implement Sayer
    if sayer, ok := i.(Sayer); ok {
        sayer.Say()
    }
}


The code example is here:http://play.golang.org/p/22bgbYVV6q
",10498547
63,34619122,"In Go language there is no ""implements"" declaration by design. The only way to ask the compiler to check that the type T implements the interface I by attempting an assignment (yes, a dummy one :). Note, Go lang differentiates methods declared on structure and pointer, use the right one in the assignment check!

type T struct{}
var _ I = T{}       // Verify that T implements I.
var _ I = (*T)(nil) // Verify that *T implements I.


Read FAQ for details Why doesn't Go have ""implements"" declarations?
",10498547
64,39822180,"Use the read deadline to implement the timeouts:

ws, err := upgrader.Upgrade(w, r, nil)
if err != nil {
    // handle error
}

// Read the initial message with deadline of 30 seconds
ws.SetReadDeadline(time.Now().Add(30 * time.Second))
mt, message, err := c.ReadMessage()
if err != nil {
   // Handle the error which might be a deadline exceeded error.
}
// process the initial message
// ...

for {
    // Read next message with deadline of 45 minutes
    ws.SetReadDeadline(time.Now().Add(45 * time.Minute))
    mt, message, err = c.ReadMessage()
    if err != nil {
        // Handle the error which might be a deadline exceeded error.
    }
    // process message
     // ....
}

",39821084
65,19683613,"You can use this helper function which wraps SplitN:

import ""strings""

func Partition(s string, sep string) (string, string, string) {
    parts := strings.SplitN(s, sep, 2)
    if len(parts) == 1 {
        return parts[0], """", """"
    }
    return parts[0], sep, parts[1]
}

",19683612
66,19703339,"Indeed SplitN allows you to parse at most n strings. If you need something simpler for e-mail check, you can try something like the code below. Don't forget to check the error.

package main

import (
    ""fmt""
    ""strings""
    ""errors""
)

func Separate(str, separator string) (string, string, error){
    sepIndex := strings.Index(str, separator)
    if sepIndex >= 0 {
        return str[0 : (sepIndex)], str[sepIndex+len(separator) : len(str)], nil
    } else {
        return """", """", errors.New(""Separator now found!"")
    }
}

func main(){
    str := ""@xmyname@xample.com""

    fmt.Println(""Initial string: "", str)

    p1, p2, err := Separate(str, ""@x"")
    if err != nil{
        fmt.Println(err)
    } else {
        fmt.Println(""Slice 1:"", p1, ""\nSlice 2:"",p2)
    }
}

",19683612
67,44279015,"Depending on the OS and how your program is started, stdin can be a whole lot of different things, not all of which can be written to. So writing to stdin isn't generally supported.

For example: If you start your program on linux in a terminal, stdin, stdout and stderr are all the same endpoint, that is your terminal. Writing to any of these will produce output on the screen, which you won't get served back, when reading from stdin. (Where you will only see stuff, the terminal hands you through its slave device.)

If you want to read back, what you write to stdin, you could create a simple wrapper, which starts your program and puts everything it gets from the program back into its input, like so

package main

import (
        ""bufio""
        ""flag""
        ""fmt""
        ""io""
        ""log""
        ""os/exec""
)

func main() {
        cmd := flag.String(""cmd"", ""none"", ""command to run and loop output back to input"")
        flag.Parse()
        process := exec.Command(*cmd)
        input, err := process.StdinPipe()
        if err != nil {
                log.Fatalln(err)
        }
        output, err := process.StdoutPipe()
        if err != nil {
                log.Fatalln(err)
        }
        errors, err := process.StderrPipe()
        if err != nil {
                log.Fatalln(err)
        }
        err = process.Start()
        if err != nil {
                log.Fatalln(err)
        }
        _, err = io.Copy(input, output)
        if err != nil {
                log.Println(err)
        }
        err = input.Close()
        if err != nil {
                log.Fatalln(err)
        }
        errorsScanner := bufio.NewScanner(errors)
        for errorsScanner.Scan() {
                fmt.Println(errorsScanner.Text())
        }
        err = process.Wait()
        if err != nil {
                log.Fatalln(err)
        }
        fmt.Println(""all done"")
}


I called that tool outinloop and called it like outinloop -cmd=""testprog""

A suitable test program would be

package main

import (
        ""bufio""
        ""fmt""
        ""log""
        ""os""
)

func main() {
        fmt.Println(""vim-go"")
        err := os.Stdout.Close()
        if err != nil {
                log.Fatalln(err)
        }
        in := bufio.NewScanner(os.Stdin)
        if !in.Scan() {
                fmt.Fprintf(os.Stderr, ""no input?\n"")
                os.Exit(1)
        }
        if in.Text() == ""vim-go"" {
                fmt.Fprint(os.Stderr, ""all is well\n"")
                return
        }
        fmt.Fprintf(os.Stderr, ""wrong input: %s\n"", in.Text())
        os.Exit(1)
}

",44272125
68,39789420,"The net/http server does not allow the application to control the transfer encoding.

The net/http server automatically uses chunked encoding when the application does not set the Content-Length response header and the connection can be reused (http/1 client requested keep-alive or http/1.1 client did not request connection close).
",39789273
69,33755152,"Would go with the Select method as the doc states that this enables selecting which fields should be retrieved for the results found, thus the projection using $elemMatch operator can be applied here in conjuction with Select, with your final query looking something like: 

c.Find(bson.M{
    ""_id"": bson.ObjectIdHex(p.ByName(""id""))
}).Select(bson.M{
    ""races"": bson.M{
        ""$elemMatch"": bson.M{
            ""_id"": bson.ObjectIdHex(p.ByName(""raceId""))
        }
    }
}).One(&result)

",33751451
70,27243620,"You would still need a library to add color escape code like:


for Windows: mattn/go-colorable or shiena/ansicolor
for Unix or Windows: fatih/color or kortschak/ct
for Unix or Windows: logrusorgru/aurora (mentioned by Ivan Black in the comments)


From there, you specify what you want to color (StdOut or StdErr, like in this example)
",27242652
71,27245610,"You can create a wrapper shell script for this and color it using color escape sequence. Here's a simple example on Linux (I'm not sure how this would look on windows, but I guess there is a way.. :) )

go test -v . | sed ''/PASS/s//$(printf ""\033[32mPASS\033[0m"")/'' | sed ''/FAIL/s//$(printf ""\033[31mFAIL\033[0m"")/''

",27242652
72,33711559,"BoltDB has some test methods that look like this:

func assert(tb testing.TB, condition bool, msg string, v ...interface{}) {
    if !condition {
        _, file, line, _ := runtime.Caller(1)
        fmt.Printf(""\033[31m%s:%d: ""+msg+""\033[39m\n\n"", append([]interface{}{filepath.Base(file), line}, v...)...)
        tb.FailNow()
    }
}


Here are the rest.  I added the green dots here.
",27242652
73,40160711,"You can use grc, a generic colourizer, to colourize anything.

On Debian/Ubuntu, install with apt-get install grc. On a Mac with , brew install grc.

Create a config directory in your home directory:

mkdir ~/.grc


Then create your personal grc config in ~/.grc/grc.conf:

# Go
\bgo.* test\b
conf.gotest


Then create a Go test colourization config in ~/.grc/conf.gotest, such as:

regexp==== RUN .*
colour=blue
-
regexp=--- PASS: .*
colour=green
-
regexp=^PASS$
colour=green
-
regexp=^(ok|\?) .*
colour=magenta
-
regexp=--- FAIL: .*
colour=red
-
regexp=[^\s]+\.go(:\d+)?
colour=cyan


Now you can run Go tests with:

grc go test -v ./..


Sample output:



To avoid typing grc all the time, add an alias to your shell (if using Bash, either ~/.bashrc or ~/.bash_profile or both, depending on your OS):

alias go=grc go


Now you get colourization simply by running:

go test -v ./..

",27242652
74,41709728,"There's also a tool called richgo that does exactly this, in a user-friendly way.


",27242652
75,21622188,"First of all, there is a difference between a slice and an array.

var a [3]int // Array of 3 ints
var s []int // Slice of ints


In your case, the map can store slices, but the data is stored in different types of arrays.

The size of an array is part of its type. And because of Go's strict typing, you cannot set a value of one array type/size to a value of a different array type/size.

Instead we have slices. Slices uses an underlying array, but may differ in length and capacity.

You can solve your problem by changing your code:

var THREE_C_THREE = [][]uint32 { // Changed type from [1][3]int to [][]uint32
    {0, 1, 2},
}

var FOUR_C_THREE = [][]uint32 { // Changed type from [4][3]int to [][]uint32
    {0, 1, 2}, {0, 1, 3}, {0, 3, 2}, {3, 1, 2},
}

var FIVE_C_THREE = [][]uint32 { // Changed type from [5][3]int to [][]uint32
    // ... etc
}


This official blog-post will give you more info: http://blog.golang.org/slices
And this post as well: http://blog.golang.org/go-slices-usage-and-internals
",21621547
76,42739715,"form json pkg you can encoding and decoding JSON format

package main

import (
    ""encoding/json""
    ""fmt""
)

type Species struct {
    Human  []Info `json:""human""`
    Animal []Info `json:""animal""`
}

type Info struct {
    Name   string `json:""name""`
    Number string `json:""number""`
}

func main() {
    data := Species{
        Human: []Info{
            Info{Name: ""dave"", Number: ""00001""},
            Info{Name: ""jack"", Number: ""00002""},
        },
        Animal: []Info{
            Info{Name: ""ko"", Number: ""00004""},
            Info{Name: ""na"", Number: ""00005""},
        },
    }

    b, err := json.MarshalIndent(data, """", ""  "")
    if err != nil {
        fmt.Println(""error:"", err)
    }

    fmt.Println(string(b))
}


https://play.golang.org/p/evQto70Z8y
",42739268
77,37691095,"Check the documentation for the go build command

go build [-o output] [-i] [build flags] [packages]



  When compiling a single main package, build writes the resulting
  executable to an output file named after the first source file ('go
  build ed.go rx.go' writes 'ed' or 'ed.exe') or the source code
  directory ('go build unix/sam' writes 'sam' or 'sam.exe'). The '.exe'
  suffix is added when writing a Windows executable.
  
  When compiling multiple packages or a single non-main package, build
  compiles the packages but discards the resulting object, serving only
  as a check that the packages can be built.
  
  The -o flag, only allowed when compiling a single package, forces
  build to write the resulting executable or object to the named output
  file, instead of the default behavior described in the last two
  paragraphs.


Try building it like this go build -o greet and do not forget to add the resulting executable to your $PATH if you want it to be accessible from everywhere.   



Alternatively, you can just 1) create an alias; or 2) symlink to the actual executable:


alias greet='myproject'
ln -s $GOPATH/bin/myproject greet (the link will be created in the current dir)

",37691028
78,18938332,"The difference is between creating a reference object (with the ampersand) vs. a value object (without the ampersand).

There's a nice explanation of the general concept of value vs. reference type passing here... What's the difference between passing by reference vs. passing by value?

There is some discussion of these concepts with regards to Go here... http://www.goinggo.net/2013/07/understanding-pointers-and-memory.html
",18938138
79,18942359,"bb := &BigBox{} creates a struct, but sets the variable to be a pointer to it. It's the same as bb := new(BigBox). On the other hand, bb := BigBox{} makes bb a variable of type BigBox directly. If you want a pointer (because perhaps because you're going to use the data via a pointer), then it's better to make bb a pointer, otherwise you're going to be writing &bb a lot. If you're going to use the data as a struct directly, then you want bb to be a struct, otherwise you're going to be dereferencing with *bb.

It's off the point of the question, but it's usually better to create data in one go, rather than incrementally by creating the object and subsequently updating it.

bb := &BigBox{
    BubbleGumsCount: 4,
    SmallBox: {
        AnyMagicItem: true,
    },
}

",18938138
80,19002191,"I figured out one motivation for this kind of code: avoidance of ""struct copying by accident"".



If you use a struct variable to hold the newly created struct:

bigBox := BigBox{}


you may copy the struct by accident like this

myBox := bigBox // Where you just want a refence of bigBox.
myBox.BubbleGumsCount = 4


or like this

changeBoxColorToRed(bigBox)


where changeBoxColorToRed is

// It makes a copy of entire struct as parameter. 
func changeBoxColorToRed(box bigBox){
    // !!!! This function is buggy. It won't work as expected !!!
    // Please see the fix at the end.
    box.Color=red
}




But if you use a struct pointer:

bigBox := &BigBox{}


there will be no copying in

myBox := bigBox


and

changeBoxColorToRed(bigBox)


will fail to compile, giving you a chance to rethink the design of changeBoxColorToRed. The fix is obvious:

func changeBoxColorToRed(box *bigBox){
    box.Color=red
}


The new version of changeBoxColorToRed does not copy the entire struct and works correctly.
",18938138
81,19015140,"In general there is no difference between a &BigBox{} and BigBox{}. The Go compiler is free to do whatever it likes as long as the semantics are correct.

func StructToStruct() {
    s := Foo{}
    StructFunction(&s)
}

func PointerToStruct() {
    p := &Foo{}
    StructFunction(p)
}

func StructToPointer() {
    s := Foo{}
    PointerFunction(&s)
}

func PointerToPointer() {
    p := &Foo{}
    PointerFunction(p)
}

//passed as a pointer, but used as struct
func StructFunction(f *Foo) {
    fmt.Println(*f)
}

func PointerFunction(f *Foo) {
    fmt.Println(f)
}


Summary of the assembly:


StructToStruct: 13 lines, no allocation
PointerToStruct: 16 lines, no allocation
StructToPointer: 20 lines, heap allocated
PointerToPointer: 12 lines, heap allocated


With a perfect compiler the *ToStruct functions would be the identical as would the *ToPointer functions. Go's escape analysis is good enough to tell if a pointer escapes even across module boundries. Which ever way is most efficient is the way the compiler will do it.

If you're really into micro-optimization note that Go is most efficient when the syntax lines up with the semantics (struct used as a struct, pointer used as a pointer). Or you can just forget about it and declare the variable the way it will be used and you will be right most of the time.

Note: if Foo is really big PointerToStruct will heap allocate it. The spec threatens to that even StructToStruct is allowed to do this but I couldn't make it happen. The lesson here is that the compiler will do whatever it wants. Just as the details of the registers is shielded from the code, so is the state of the heap/stack. Don't change your code because you think you know how the compiler is going to use the heap.
",18938138
82,19034216,"The & takes an address of something. So it means ""I want a pointer to"" rather than ""I want an instance of"". The size of a variable containing a value depends on the size of the value, which could be large or small. The size of a variable containing a pointer is 8 bytes.

Here are examples and their meanings:

bigBox0 := &BigBox{} // bigBox0 is a pointer to an instance of BigBox{}
bigBox1 := BigBox{} // bigBox1 contains an instance of BigBox{}
bigBox2 := bigBox // bigBox2 is a copy of bigBox
bigBox3 := &bigBox // bigBox3 is a pointer to bigBox
bigBox4 := *bigBox3 // bigBox4 is a copy of bigBox, dereferenced from bigBox3 (a pointer)


Why would you want a pointer?


To prevent copying a large object when passing it as an argument to a function.
You want to modify the value by passing it as an argument.
To keep a slice, backed by an array, small. [10]BigBox would take up ""the size of BigBox"" * 10 bytes. [10]*BigBox would take up 8 bytes * 10. A slice when resized has to create a larger array when it reaches its capacity. This means the memory of the old array has to be copied to the new array.


Why do you not what to use a pointer?


If an object is small, it's better just to make a copy. Especially if it's 
Using pointers can create garbage. This garbage has to be collected by the garbage collector. The garbage collector is a mark-and-sweep stop-the-world implementation. This means that it has to freeze your application to collect the garbage. The more garbage it has to collect, the longer that pause is. This individual, for example. experienced a pause up to 10 seconds.
Copying an object uses the stack rather than the heap. The stack is usually always faster than the heap. You really don't have to think about stack vs heap in Go as it decides what should go where, but you shouldn't ignore it either. It really depends on the compiler implementation, but pointers can result in memory going on the heap, resulting in the need for garbage collection.
Direct memory access is faster. If you have a slice []BigBox and it doesn't change size it can be faster to access. []BigBox is faster to read, whereas []*BigBox is faster to resize.


My general advice is use pointers sparingly. Unless you're dealing with a very large object that needs to be passed around, it's often better to  pass around a copy on the stack. Reducing garbage is a big deal. The garbage collector will get better, but you're better off by keeping it as low as possible.

As always test your application and profile it.
",18938138
83,37362313,"As per your code function mytest can be called on receiver which pointer to Base.

Struct Derived inherits/embeds Base and Derived2 inherits/embeds *Base i.e. pointer to base.

For   


var _MyInt = &Derived2{}: Here pointer of Derived2 is created and since Dervied2 inherits from *Base calling mytest on _MyInt will work
var _MyInt = Derived2{}: Instance of Derived2 is created and since Dervied2 inherits from *Base calling mytest on _MyInt will work
var _MyInt = &Derived{}: Here pointer of Derived is created and since Dervied inherits from Base calling mytest on _MyInt will work
var _MyInt = Derived{}: Instance of Derived is created and since Dervied inherits from Base calling mytest on _MyInt will not work has pointer to Base is expected.


You rightly pointed out that changing receiver from *Base to Base will work because Go will be able recognize Object from pointer and will be able to call mytest.

As per golang specification
A type may have a method set associated with it. The method set of an interface type is its interface. The method set of any other type T consists of all methods declared with receiver type T. The method set of the corresponding pointer type *T is the set of all methods declared with receiver *T or T (that is, it also contains the method set of T). 

Hope this helps
",37362131
84,37363643,"From the Go language specification:


  Given a struct type S and a type named T, promoted methods are
  included in the method set of the struct as follows:
  
  
  If S contains an anonymous field T, the method sets of S and *S both
  include promoted methods with receiver T.
  The method set of *S also
  includes promoted methods with receiver *T.
  If S contains an anonymous
  field *T, the method sets of S and *S both include promoted methods
  with receiver T or *T.
  


The case that doesn't work in your code:

var _ MyInt = Derived{}


Here the method set of Derived (which contains an anonymous field Base) includes methods of Base by rule 1. Since mytest is a method of *Base and not Base, it's promoted to a method of *Derived (by the second rule), but not of Derived.

Why is it like that? Well, it's similar to the rule for method sets of structs: methods of T are also methods of T*, but not vice-versa. That's because a method of a pointer receiver can expect to be able to mutate its receiver, but a method of a non-pointer receiver can't.
",37362131
85,39154131,"I use the first approach. Here its a gulp task the build go code. If the production flag is set, it runs GOOS=linux CGO_ENABLED=0 go build instead  go build. So the binary will work inside a docker container

gulp.task('server:build', function () {
    var build;

    let options = {
        env: {
            'PATH': process.env.PATH,
            'GOPATH': process.env.GOPATH
        }
    }

    if (argv.prod) {
        options.env['GOOS'] = 'linux'
        options.env['CGO_ENABLED'] = '0'
        console.log(""Compiling go binarie to run inside Docker container"")
    }

    var output = argv.prod ? conf.paths.build + '/prod/bin' : conf.paths.build + '/dev/bin';
    build = child.spawnSync('go', ['build', '-o', output, ""src/backend/main.go""], options);
    if (build.stderr.length) {
        var lines = build.stderr.toString()
            .split('\n').filter(function(line) {
                return line.length
            });
        for (var l in lines)
            util.log(util.colors.red(
                'Error (go install): ' + lines[l]
            ));
        notifier.notify({
            title: 'Error (go install)',
            message: lines
        });
    }
    return build;
});

",35997995
86,40000860,"You could create a Docker container from the distinct OS you need for your executable, and map a volume to your src directory. Run the container and make the executable from within the container.  You end up with a binary that you can run on the distinct OS.
",35997995
87,44757772,"Here a solution to make cross-compile super easy even with CGO.

I stumbled upon it recently after wasting a lot of time getting a new windows build server to build my Go app.
Now I just compile it on my Mac and will create a Linux build server with it:

https://github.com/karalabe/xgo

Many thanks to Péter Szilágyi alias karalabe for this really great package!

How to use:


have Docker running
go get github.com/karalabe/xgo
xgo --targets=windows/amd64 ./


There are lots more options!
",35997995
88,35320463,"You can simply use type assertion to obtain the value stored in an interface, e.g.

if isPointerToSlice(val) {
    var result []interface{}
    result = *val.(*[]interface{})
    fmt.Println(result)
} else {
    fmt.Println(""Not *[]interface{}"")
}


The type of the value stored in the interface as you claim is pointer to []interface{}, which is *[]interface{}. The result of the type assertion will be a pointer, just dereference it to get the slice []interface{}.

Using short variable declaration:

result := *val.(*[]interface{}) // type of result is []interface{}


Try it on the Go Playground.



Also your attempt also works:

slice, worked := reflect.ValueOf(val).Elem().Interface().([]interface{})
fmt.Println(slice, worked)


Here's the edited the Playground example which proves your solution works.

But using reflection is unnecessary (as it can be done with type assertion).

Also note that *[]interface{} and *[]someOtherType are 2 different types and you can't obtain a value of *[]interface{} if there is something else in val.
",35320357
89,35321504,"If you just want to convert a slice to []interface{} you can use something like this:

func sliceToIfaceSlice(val interface{}) []interface{} {
    rf := reflect.Indirect(reflect.ValueOf(val)) // skip the pointer
    if k := rf.Kind(); k != reflect.Slice && k != reflect.Array {
        // panic(""expected a slice or array"")
        return nil
    }
    out := make([]interface{}, rf.Len())
    for i := range out {
        out[i] = rf.Index(i).Interface()
    }
    return out
}


playground
",35320357
90,35321977,"Icza's answer is great and will work especially if you can't know for sure you are getting an interface slice, however if you don't want to bother with the reflect package at all and want to keep imported code low, you can use type switching to obtain the same functionality using only built-in methods.

Using this method, you can shorten your code to just:

package main

import (
    ""fmt""
)

func main() {
    s := []interface{}{""one"", 2}
    p := &s

    do(p)
}

func do(val interface{}) {
    switch val.(type){
    case *[]interface{}:
        var result []interface{}
        result = *val.(*[]interface{})
        fmt.Println(result)
    }
}


Playground:  http://play.golang.org/p/DT_hb8JcVt

The downside is if you don't know the exact type of slice you are receiving beforehand, then this will not work unless you list all possible types for handling and assertion.
",35320357
91,37602873,"
  func Sprintf(format string, a ...interface{}) string
  
  Sprintf formats according to a format specifier and returns the resulting string.


mt.Println(fmt.Sprintf(""SELECT * FROM mytable WHERE mycolumn LIKE 'camel%'""))

//Output:
//SELECT * FROM mytable WHERE mycolumn LIKE 'camel%!'(MISSING)
//Ofc postgres will complain


You do not need fmt.Sprintf in this case.

rows, err := db.Query(""SELECT * FROM mytable WHERE mycolumn LIKE 'camel.%'"")


works fine.

But if you really need to use fmt.Sprintf you must escape '%' with '%%'

rows, err := db.Query(fmt.Sprintf(""SELECT * FROM mytable WHERE mycolumn LIKE 'camel.%%'""))

",37602726
92,29317411,"I suspect this is a bug with the Go playground. When I compile and run this program on my machine, it yields the expected output. A bug report pertaining this issue has been filed.
",29316958
93,29318406,"You are being inconsistent in your print destination.

stdout: fmt.Println

stderr: println


Write to the same print destination.

package main

import ""fmt""

var z = 1

func main() {

    defer increaseZ(10)
    defer fmt.Println(""z ="", increaseZ(20), ""Deferred Value 1"")
    defer fmt.Println(""z ="", increaseZ(30), ""Deferred Value 2"")

    fmt.Println(""z ="", z, ""Main Value"")
}

func increaseZ(y int) int {
    z += y
    fmt.Println(""z ="", z, ""Inside Increase Function"")
    return z
}


Output:

z = 21 Inside Increase Function
z = 51 Inside Increase Function
z = 51 Main Value
z = 51 Deferred Value 2
z = 21 Deferred Value 1
z = 61 Inside Increase Function


or,

package main

import (
    ""fmt""
    ""os""
)

var z = 1

func main() {

    defer increaseZ(10)
    defer fmt.Fprintln(os.Stderr, ""z ="", increaseZ(20), ""Deferred Value 1"")
    defer fmt.Fprintln(os.Stderr, ""z ="", increaseZ(30), ""Deferred Value 2"")

    fmt.Fprintln(os.Stderr, ""z ="", z, ""Main Value"")
}

func increaseZ(y int) int {
    z += y
    println(""z ="", z, ""Inside Increase Function"")
    return z
}


Output:

z = 21 Inside Increase Function
z = 51 Inside Increase Function
z = 51 Main Value
z = 51 Deferred Value 2
z = 21 Deferred Value 1
z = 61 Inside Increase Function

",29316958
94,29318417,"It's not about deferred evaluations. It's about printing. println function documented for completeness but are not guaranteed to stay in the language at all. Also Stdout and Stderr merged in one stream on Playground by design.
If you use fmt.Println(...) everywhere http://play.golang.org/p/PU3hxHCazA
or explicitly define  fmt.Fprintln(os.Stdout, ... http://play.golang.org/p/OQpOQR2vm0 things would work as expected.
",29316958
95,15774060,"You have to surround the right side of the == with parenthesis. Otherwise go will think that the '{' is the beginning of the 'if' block. The following code works fine:

package main

import ""fmt""

type Auth struct {
    Username    string
    Password    string
}

func main() {
    auth := Auth { Username : ""abc"", Password : ""123"" }
    if auth == (Auth {Username: ""abc"", Password: ""123""}) {
        fmt.Println(auth)
    }
}

// Output: {abc 123}

",15773969
96,33373720,"This is due to a bug in Go 1.4.  Fixed in 1.5.

https://golang.org/issue/10303
",31926976
97,34477118,"The problem is that you're embedding both CreatedBy and UpdatedBy into Event, so calls to Event.By are ambiguous and not allowed (you'd have to be able to specify Event.CreatedBy.By and Event.UpdatedBy.By explicitly to disambiguate the two fields).

The solution, most likely, would be to not embed the types, but actually create a struct with explicit fields:

type Event struct {
    CreatedBy CreatedBy
    UpdatedBy UpdatedBy
}


gorm should now know how to disambiguate the two columns.

Of course if you're only going to embed By into CreatedBy and UpdatedBy for the purposes of column mapping then you shouldn't need to declare new structs:

type By struct {
    ByID sql.NullInt64
    By *User
}

type Event struct {
    CreatedBy By
    UpdatedBy By
}

",34462118
98,45872626,"Instead of doing a range over the channel, your first select case should be from that channel, with the whole thing inside an infinite loop.

func BatchEvents(inChan <-chan *Event) <-chan *Event {
    batchSize := 10
    comboEvent := Event{}
    go func() {
        defer close(out)
        i = 0
        for {
            select {
            case event, ok := <-inChan:
                if !ok {
                    return
                }
                comboEvent.data = append(comboEvent.data, event.data)
                i++
                if i == batchSize {
                    out <- &comboEvent
                    // reset for next batch
                    comboEvent = Event{}
                    i = 0
                }
            case <-time.After(5 * time.Second):
                // process whatever we have seen so far if the batch size isn't filled in 5 secs
                if i > 0 {
                    out <- &comboEvent
                }
                // stop after
                return
            }
        }
    }()
    return out
}

",45872441
99,19757754,"You can use t.Log() to log information about the test case -- go will show that output if the test case fails or if you run go test -v

You can also assert certain state within the test using panics -- if a test panics, you will see the trace in your console. 
",19757462
100,19758842,"I don't know if you'd want to check in code with this in it, but for one-off debugging, PrintStack might help. http://golang.org/pkg/runtime/debug/#PrintStack
",19757462
101,39260108,"Oddly enough, you have to double-click the selected file, so that the go code is visible in the code editor. Only after doing this do commands such as ""build"" and ""install"" operate on the expected file. So although the file may be appear to be selected on the left hand navigation, unless it is actually loaded in the code editor it is not selected.
",39260088
102,35931797,"It is for the timeout based on SetWriteDeadline. If it times out and had written some bytes you know how many were written.
",35931691
103,35932130,"
  Package io

import ""io"" 

  
  type Writer

type Writer interface {
        Write(p []byte) (n int, err error)
}

  
  Writer is the interface that wraps the basic Write method.
  
  Write writes len(p) bytes from p to the underlying data stream. It
  returns the number of bytes written from p (0 <= n <= len(p)) and any
  error encountered that caused the write to stop early. Write must
  return a non-nil error if it returns n < len(p). Write must not modify
  the slice data, even temporarily.
  
  Implementations must not retain p.
  
  Package net
  
  import ""net""
  
  type Conn

type Conn interface {
        // Read reads data from the connection.
        // Read can be made to time out and return a Error with Timeout() == true
        // after a fixed time limit; see SetDeadline and SetReadDeadline.
        Read(b []byte) (n int, err error)

        // Write writes data to the connection.
        // Write can be made to time out and return a Error with Timeout() == true
        // after a fixed time limit; see SetDeadline and SetWriteDeadline.
        Write(b []byte) (n int, err error)

        // Close closes the connection.
        // Any blocked Read or Write operations will be unblocked and return errors.
        Close() error

        // LocalAddr returns the local network address.
        LocalAddr() Addr

        // RemoteAddr returns the remote network address.
        RemoteAddr() Addr

        // SetDeadline sets the read and write deadlines associated
        // with the connection. It is equivalent to calling both
        // SetReadDeadline and SetWriteDeadline.
        //
        // A deadline is an absolute time after which I/O operations
        // fail with a timeout (see type Error) instead of
        // blocking. The deadline applies to all future I/O, not just
        // the immediately following call to Read or Write.
        //
        // An idle timeout can be implemented by repeatedly extending
        // the deadline after successful Read or Write calls.
        //
        // A zero value for t means I/O operations will not time out.
        SetDeadline(t time.Time) error

        // SetReadDeadline sets the deadline for future Read calls.
        // A zero value for t means Read will not time out.
        SetReadDeadline(t time.Time) error

        // SetWriteDeadline sets the deadline for future Write calls.
        // Even if write times out, it may return n > 0, indicating that
        // some of the data was successfully written.
        // A zero value for t means Write will not time out.
        SetWriteDeadline(t time.Time) error
}

  
  Conn is a generic stream-oriented network connection.
  
  Multiple goroutines may invoke methods on a Conn simultaneously.
  
  func (*IPConn) Write

func (c *IPConn) Write(b []byte) (int, error)

  
  Write implements the Conn Write method.


It's an implementation of the io.Writer interface. Write writes len(p) bytes from p to the underlying data stream. It returns the number of bytes (n) written from p (0  error (err) encountered that caused the write to stop early.

In particular, for the net.Conn interface, func (*IPConn) Write writes data to the connection. Write can be made to time out and return a Error with Timeout() == true after a fixed time limit; see SetDeadline and SetWriteDeadline.
",35931691
104,29997262,"Rule #1 of fightclub, err Go, check your errors.

That being said, the format for time parsing is defined in the documentation (scroll down to constants).

For your specific question, the format is 1/_2/2006, 15:04:05.

playground
",29997234
105,27166526,"Create structs with bson tags and use mgo's Find().All().
And if you need an JSON output, use encoding/json package and MarshalIndent() function:

package main

import (
    ""encoding/json""
    ""fmt""
    ""gopkg.in/mgo.v2""
    ""gopkg.in/mgo.v2/bson""
    ""log""
)

type City struct {
    ID     bson.ObjectId `bson:""_id,omitempty"" json:""-""`
    Name   string        `bson:""City""`
    Region []Place       `bson:""region""`
}

type Place struct {
    RegionID  string `bson:""regionid""`
    HistPlace string `bson:""historical_place""`
}

func main() {
    session, err := mgo.Dial(""127.0.0.1"")
    if err != nil {
        panic(err)
    }
    defer session.Close()

    c := session.DB(""db"").C(""myplaces"")

    var cities []City
    err = c.Find(nil).All(&cities)
    if err != nil {
        log.Fatal(err)
    }

    out, err := json.MarshalIndent(cities, "" "", "" "")
    if err != nil {
        log.Fatal(err)
    }
    fmt.Println(""Result:"", string(out))
}

",27165692
106,40118881,"It shouldn't be a driver for any language rather than Go because as you say it's embedded e.i. it works like a Go library that just do data manipulation over a file.

What I know for sure there's HTTP or other network protocols wrappers on top of BoltDB, for example: https://github.com/skyec/boltdb-server and even with Raft: https://github.com/hashicorp/raft-boltdb. As you may see it's pretty easy create your own network layer, I've been thinking in do my own.

Maybe this's not your answer, but it's too big for a comment :)
",40104463
107,8601792,"You can use Key as a property in the entity: http://code.google.com/appengine/docs/go/datastore/reference.html

Something like this (I don't know Go so bear with me):

type Employee struct {
    Name     string
    Boss     *Key
}

employee := Employee{
    Name:     ""John Doe"",
    Boss:     key    // a key to some other entity
}

",8596084
108,8620918,"Peter, you were definitely on the right track.  I think I've figured this out.  I haven't really tested this, but it appears to be right in the datastore viewer. What I have right now looks like this (ignoring error checking for the example): 

type Boss struct {
    Name, Uuid string
}

type Employee struct {
    Name, Uuid string,
    Boss *datastore.Key
}

boss := &Boss {
    Name:  ""Pointy Haired Boss"",
    Uuid:  >,
}

dilbert := &Employee {
    Name: ""Dilbert"",
    Uuid: >,
    boss: nil,
}

datastore.Put(context, datastore.NewIncompleteKey(context, ""Boss"", nil), bossman)
query := datastore.NewQuery(""Boss"").Filter(""Uuid ="", bossMan)
for t := query.Run(ctx); ; {
    var employee Employee
    key, err := t.Next(&employee)
    if err == datastore.Done {
        break
    }
    if err != nil {
        fmt.Fprintf(w, ""Error %s"", err)
    }
    dilbert.Boss = key
}
datastore.Put(context, datastore.NewIncompleteKey(context, ""Employee"", nil), dilbert)

",8596084
109,23068455,"I am trying to do the same but the only projects that gave me a good performance to cache data was the binary tree https://github.com/stathat/treap m which supported more than 1 millons of nodes on memory in one machine Ubuntu 12.0.4 LTS with 8 GB memory. Furthermore,  it was fast loading and searching data.

Other projects that I tested was LMDB but not support many nodes on memory, kv, go-cache and goleveldb but no one was as faster to recovery data from memory that treap. 
",23067500
110,25945832,"Maybe using a custom http.HandlerFunc would be easier:

Except in your case, your func would be the http.ServeFile one, for serving just one file.

See for instance ""Go Web Applications: Serving Static Files"":


  Add the following below your home handler (see below):


http.HandleFunc(""/static/"", func(w http.ResponseWriter, r *http.Request) {
    http.ServeFile(w, r, r.URL.Path[1:])
})



  This is using the net/http package’s ServeFile function to serve our content.
  Effectively anything that makes a request starting with the /static/ path will be handled by this function.
  One thing I found I had to do in order for the request to be handled correctly was trim the leading ‘/’ using:


r.URL.Path[1:]


Actually, do not do that.
This won't be possible in Go 1.6, as sztanpet comments, with commit 9b67a5d:


  If the provided file or directory name is a relative path, it is
  interpreted relative to the current directory and may ascend to parent
  directories.
  If the provided name is constructed from user input, it should be sanitized before calling ServeFile.
  As a precaution, ServeFile will reject requests where r.URL.Path contains a "".."" path element.


That will protect against the following ""url"":

/../file
/..
/../
/../foo
/..\\foo
/file/a
/file/a..
/file/a/..
/file/a\\..

",25945538
111,37256393,"Maybe I missed something here, but after a lot of confused searching, I put this together:

...

func downloadHandler(w http.ResponseWriter, r *http.Request) {
        r.ParseForm()
        StoredAs := r.Form.Get(""StoredAs"") // file name
        data, err := ioutil.ReadFile(""files/""+StoredAs)
        if err != nil { fmt.Fprint(w, err) }
        http.ServeContent(w, r, StoredAs, time.Now(),   bytes.NewReader(data))
}


...

Where downloadHandler is invoked as part of a simple upload and download server:

func main() {
              http.HandleFunc(""/upload"", uploadHandler)
              http.HandleFunc(""/download"", downloadHandler)
              http.ListenAndServe("":3001"", nil)
}   


Works fine with Firefox and Chrome. Doesn't even need a file type.
",25945538
112,43114407,"You could use http.StripPrefix

Like this: 

http.Handle(""/hello/"", http.StripPrefix(""/hello/"",http.FileServer(http.Dir(""static""))))

",25945538
113,30213864,"Use the special ""comma, ok"" form which tells if the key was found in the map. Go Spec: Index Expressions:


  An index expression on a map a of type map[K]V used in an assignment or initialization of the special form

v, ok = a[x]
v, ok := a[x]
var v, ok = a[x]

  
  yields an additional untyped boolean value. The value of ok is true if the key x is present in the map, and false otherwise.


So in your code:

type Hello struct{}
structMap := map[string]Hello{}
if j, ok := structMap[""example""]; !ok {
    // ""example"" is not in the map
}

",30213739
114,28262843,"package main

import (
    ""bufio""
    ""fmt""
    ""net/http""
    ""strings""
)

func main() {
    rawCookies := ""cookie1=value1;cookie2=value2""
    rawRequest := fmt.Sprintf(""GET / HTTP/1.0\r\nCookie: %s\r\n\r\n"", rawCookies)

    req, err := http.ReadRequest(bufio.NewReader(strings.NewReader(rawRequest)))

    if err == nil {
        cookies := req.Cookies()
        fmt.Println(cookies)
    }
}


Playground
",28262376
115,33926065,"A bit shorter version

package main

import (
    ""fmt""
    ""net/http""
)

func main() {
    rawCookies := ""cookie1=value1;cookie2=value2""

    header := http.Header{}
    header.Add(""Cookie"", rawCookies)
    request := http.Request{Header: header}

    fmt.Println(request.Cookies()) // [cookie1=value1 cookie2=value2]
}


http://play.golang.org/p/PLVwT6Kzr9
",28262376
116,12334902,"Variadic functions receive the arguments as a slice of the type. In this case your function receives a []interface{} named args. When you pass that argument to fmt.Sprintf, you are passing it as a single argument of type []interface{}. What you really want is to pass each value in args as a separate argument (the same way you received them). To do this you must use the ... syntax.

str := fmt.Sprintf(format, args...)


This is also explained in the Go specification here.
",12334697
117,25084057,"As you've mentioned in the comments, you'll need to use the = operator in order to assign to a variable you've already declared. The := operator is used to simultaneously declare and assign a variable. The two are the same:

var x int
x = 5
//is the same as
x := 5


This solution will at least compile:

package main

func myfunc() (int, int) {
    return 1, 1
}

func main() {
    var b int
    a := make([]int, 1)
    a[0], b = myfunc()
    a[0] = b
}


To answer your question, I don't think there is a way to simultaneously use an undeclared and a declared variable when returning multiple values. That would be trying to use two different operators simultaneously.

Edit: just saw your example from the code that compiles, so it appears you're already familiar with go's assignment operators. I'll leave the example up anyway.
",25083235
118,42949912,"If you want two identical servers connecting to their local MySQL instances, you need a way of deciding which one is the production server. There are a number of solutions for that, including


Setting up a reverse proxy, as you mention, but then, your proxy
itself becomes a SPOF,
Using a floating IP, also known as a failover
IP, but this only works if your host supports it. Cloud providers
typically support them, as well as some bare metal server providers.


There is nothing specific to Go as far as I know.
",42946855
119,39659996,"Declare field Data in struct Sample as interface{}:

type Sample struct {
    Temppath string
    Data     interface{}
}


The type Sample then can also be used in other controllers as placeholder of any data which is going to be passed to template.
",39655389
120,18953917,"Unmarshal unmarshals XML to a struct. It is not called XPath because you cannot do what you want with Unmarshal.

Either unmarshal into a larger struct and iterate until id==3 as you suggested. (Not sure why you say this is inefficient. And I doubt that you measured the cost of doing before claiming inefficiency).

Or: Parse the XML manually with xml.Decoder and processing the Tokens yourself.
",18949564
121,37498813,"To change the type of an interface into its rightful type, you can use type assertions:

package main

import r ""reflect""

type A struct {
    Name string
}

func main() {
    // No pointer
    aa := A{""name""}
    var ii interface{} = aa

    bb := ii.(A)
    // main.A

    // Pointer
    a := &A{""name""}
    var i interface{} = a

    b := *i.(*A)
    // main.A

    c := i.(*A)
    // *main.A

    d := r.Indirect(r.ValueOf(i)).Interface().(A)
    // main.A
}


Playground 1

When using type assertions, you have to know the underlying type of your interface. In Go, there is no way to use type assertion with a dynamic type. reflect.Type is not a type, it's an interface representing a type. So no, you can't use it this way.

If you have several type possibilities, the solution is the type switch:

package main

import ""fmt""

type TypeA struct {
    A string
}

type TypeB struct {
    B string
}

func doSomethingA(t TypeA) {
    fmt.Println(t.A)
}

func doSomethingB(t TypeB) {
    fmt.Println(t.B)
}

func doSomething(t interface{}) {
    switch t := t.(type) {
    case TypeA:
        doSomethingA(t)
    case TypeB:
        doSomethingB(t)
    default:
        panic(""Unrecognized type"")
    }
}

func main() {
    a := TypeA{""I am A""}
    b := TypeB{""I am B""}

    doSomething(a)
    // I am A
    doSomething(b)
    // I am B
}


Playground 2
",37498781
122,37500585,"It turns out that using JSON instead of Gob for serialization avoids the error that I was encountering entirely. Other functions can handle passing into interfaces, etc.
",37498781
123,16455320,"No, calling StreamWriter's close method and calling the underlying writer's close method is exactly the same. It is only there so StreamWriter will implement the io.WriteCloser interface.

It is only because this method exists that the type can be used as an io.WriteCloser.
",16455200
124,26707708,"You are missing a \r\n between headers and the body. You are also missing a date and a message-ID header. Lots of spam filters will take missing those as a good sign of sloppy spam/virus mail. The same for not having a text-only alternate.

Sendgrid or mandrill might help get these things right by default.
",26706258
125,26709592,"You need to add a newline (\r\n) between the header and the body.

Also if you want an easy way to send emails in Go you can use Gomail (I'm the author):

package main

import (
    ""gopkg.in/gomail.v2""
)

func main() {
    m := gomail.NewMessage()
    m.SetHeader(""From"", ""test@withheld.com"")
    m.SetHeader(""To"", ""me@gmail.com"")
    m.SetHeader(""Subject"", ""Testing"")
    m.SetBody(""text/html"", `
      Testing 
`)

    d := gomail.NewPlainDialer(""smtp.example.com"", 587, ""user"", ""123456"")
    if err := d.DialAndSend(m); err != nil {
        panic(err)
    }
}

",26706258
126,38239471,"Have you included this line in the main function?

http.Handle(""/view/"", http.StripPrefix(""/view/"", http.FileServer(http.Dir(""view""))))


view is the name of the directory that has to be specified in FileServer function to allow read/write.(view directory has to be kept in the same directory where your binary is present)
",38238764
127,38240913,"I have solved the issue by giving absolute path of the html. For that I created a class in which the html are parsed

package htmltemplates

import (
""html/template""
""path/filepath""
)


And in the NewHandler method I removed 
     //Templates is used to store all Templates
    var Templates *template.Template

func init() {
filePrefix, _ := filepath.Abs(""./work/src/Project/view/html/"")       // path from the working directory
Templates = template.Must(template.ParseFiles(filePrefix + ""/first.html"")) 
...
//htmls must be specified here to parse it
}


And in the NewHandler I removed first 5 lines and instead gave

err := htmltemplates.Templates.ExecuteTemplate(w, ""first.html"", nil)


It is now working .But need a better solution if any
",38238764
128,18688962,"It's a struct tag. Libraries use these to annotate struct fields with extra information; in this case, the module encoding/xml uses these struct tags to denote which tags correspond to the struct fields.
",18688578
129,18340593,"From the docs, that is a type assertion:


  For an expression x of interface type and a type T, the primary expression


 x.(T)



  asserts that x is not nil and that the value stored in x is of type T. The notation x.(T) is called a type assertion. 

",18340411
130,18341047,"os.Create returns an error as second return value. The error itself is an interface type error interface { Error() string }. Any data type that happens to have a Error method will implement that interface and can be assigned.

In most cases, just printing the error is enough, but in this example, you would like to handle ENOSPC (no space left on device) explicitly. The os package returns an *os.PathError as error implementation in that case and if you want to access additional information about the error, i.e. everything beside the Error() string, method, you would have to convert it.

The statement e, ok := err.(*os.PathError) is a type assertion. It will check if the interface value err contains a *os.PathError as concrete type and will return that. If another type was stored in the interface (there might be other types that implement the error interface) then it will simply return the zero value and false, i.e. nil, false in that case.
",18340411
131,33848513,"While str1+str2 does return new (unrelated in terms of memory) string, append doesn't behave this way. For example append(str[0:i], str[i+1:]...) will destroy original content of str, overwriting str[i:] with str[i+1:]. This is because str[0:i] will have capacity to append str[i+1:] without allocating new buffer.

The solution would be to create a completely new array in every iteration. At least for str, as append(prefix, str[i]) is immune to this problem. For example:

for i := 0; i < n; i++ {
    var s []int
    s = append(s, str[0:i]...)
    s = append(s, str[i+1:]...)
    permutation(append(prefix, str[i]), s)
}


https://play.golang.org/p/lXwu39AA0V

More about slices and mechanism of append:

http://blog.golang.org/go-slices-usage-and-internals

https://blog.golang.org/slices
",33848258
132,17384108,"Apparently, it now is possible, but only under very precise set of circumstances.  More precisely, if you're writing for the Android platform.

The ""goandroid"" project on GitHub provides a set of patches that allows Go to build a shared library for specific use with the Android NDK.  See https://github.com/eliasnaur/goandroid
",1757090
133,32192400,"Go Execution Modes describes Building Go Packages as a shared library:

""In this mode a Go package, or set of packages, may be built as a shared library. A Go program that imports one or more of those Go packages may be linked against this shared library.  The shared library may be changed between the time the Go program is linked and the time it is run; the shared library that is available when the program starts is the one that will be used...

In the Go 1.5 release this is implemented for the linux-amd64 target only.  When using gccgo it is implemented for any supported target.""
",1757090
134,35060357,"This is possible now using -linkshared flag

What you need to do is to first run this command:

go install -buildmode=shared -linkshared  std


(Above code makes all common packages shareable!)
then 

go install  -buildmode=shared -linkshared userownpackage


finally when compiling your code you need to run:

go build -linkshared yourprogram


What the above those is now it rather than statically linking everything only dynamically links them and you will end up with much smaller compiled files. Just to give you an idea my ""hello.go"" file with static linking is 2.3MB while the same code using dynamic linking is just 12KB!
",1757090
135,38548852,"Possible now! I built a .so file using Go and then imported into python quite easily! Here is an articles that I liked: http://www.darkcoding.net/software/building-shared-libraries-in-go-part-1/
",1757090
136,33552288,"The only way to insert raw XML is to write it directly to the stream, os.Stdout in this case.

myxml := `foo`
enc := xml.NewEncoder(os.Stdout)
root := xml.StartElement{Name: xml.Name{Local: ""root""}}
enc.EncodeToken(root)
enc.Flush()
os.Stdout.WriteString(myxml)
enc.EncodeToken(root.End())
enc.Flush()


This is essentialy what happens if you use the innerxml struct tag, but that can only be done through a struct, and would give you one more set of tags representing the struct around your raw xml.
",33551110
137,43087472,"You need to install Cluster module of nodejs in order to take full advantage of CPU cores when running cpu-intensive code. 
",43087315
138,43087568,"Multiple processes will do. For 4 cpus/threads you need 4 Node.js processes to make use of them. That requires a workload that can be split between processes though. 

Node.js provides the Cluster module to distribute socket connections between multiple worker processes which may help in some workloads, but I doubt this would help any of the benchmark workloads. 
",43087315
139,43088966,"Node.js is indeed a single threaded process. However, you can make use of clustering to spawn multiple workers on multiple cores.

If you are not using PM2 for spawning the app, please consider using it. PM2 makes spawning workers on multiple cores super easy.


  pm2 start app.js -i max


This command will spawn workers on each available core.

Also, note that if you are using session/sockets then you might face some problems because of clustering.
",43087315
140,20789057,"go get already gets all the dependencies:


  Get downloads and installs the packages named by the import paths, along with their dependencies.


If you need more control consider vendoring your dependencies using a tool like godep.
",20788732
141,21719744,"An interface value packages up two pieces of data: (1) a type and (2) a value of that type.  On the subject of comparison, the spec says:


  Interface values are comparable. Two interface values are equal if they have identical dynamic types and equal dynamic values or if both have value nil.


So both pieces of data need to be equal for the interface values to be considered equal.

In your final example, interface{}(a) has a dynamic type of *int and a dynamic value of nil, while interface{}(nil) has a dynamic type of nil (i.e. no type set) and a dynamic value of nil.  Since the types do not match, the two values are not considered equal.
",21719484
142,13417405,"Check some ""is it time to stop"" flag in your loop right after the accept() call, then flip it from your main, then connect to your listening port to get server socket ""un-stuck"". This is very similar to the old ""self-pipe trick"".
",13417095
143,13417413,"Something among these lines might work in this case, I hope:

// Listen for incoming connections
func (es *EchoServer) serve() {
        for {
                conn, err := es.listen.Accept()
                if err != nil {
                    if x, ok := err.(*net.OpError); ok && x.Op == ""accept"" { // We're done
                            log.Print(""Stoping"")
                            break
                    }

                    log.Printf(""Accept failed: %v"", err)
                    continue
                }
                go es.respond(conn.(*net.TCPConn))
        }
        es.done <- true
}

",13417095
144,13419724,"I would handle this by using es.done to send a signal before it closes the connection.  In addition to the following code you'd need to create es.done with make(chan bool, 1) so that we can put a single value in it without blocking.

// Listen for incoming connections
func (es *EchoServer) serve() {
  for {
    conn, err := es.listen.Accept()
    if err != nil {
      select {
      case <-es.done:
        // If we called stop() then there will be a value in es.done, so
        // we'll get here and we can exit without showing the error.
      default:
        log.Printf(""Accept failed: %v"", err)
      }
      return
    }
    go es.respond(conn.(*net.TCPConn))
  }
}

// Stop the server by closing the listening listen
func (es *EchoServer) stop() {
  es.done <- true   // We can advance past this because we gave it buffer of 1
  es.listen.Close() // Now it the Accept will have an error above
}

",13417095
145,24225691,"Here's a simple way that's good enough for local development.

http://www.sergiotapia.me/how-to-stop-your-go-http-server/



package main

import (  
    ""net/http""
    ""os""

    ""github.com/bmizerany/pat""
)

var mux = pat.New()

func main() {  
    mux.Get(""/kill"", http.HandlerFunc(kill))
    http.Handle(""/"", mux)
    http.ListenAndServe("":8080"", nil)
}

func kill(w http.ResponseWriter, r *http.Request) {  
    os.Exit(0)
}

",13417095
146,26080002,"Your first assertion to *MyCar works fine

Here is a playground example to illustrate

Your second assertion to MyCar will fail since it's not a pointer.
",26079892
147,26080234,"To be able to modify the car you need to use a pointer to it (like you already did), however to make it more clear to others (and yourself)  you should define the interface method on the pointer:

type Drivable interface {
    Drive() string
}

type Car struct {
    name string
}

func (*Car) Drive() string {
    return ""rum rum""
}

type SpaceShip struct {
    name string
}

func (*SpaceShip) Drive() string {
    return ""sound spaceships makes when you drive / fly them""
}

func Drive(d Drivable) {
    switch d := d.(type) { // d now is the actual type
    case *Car:
        fmt.Println(""Got a car named"", d.name)
    case *SpaceShip:
        fmt.Println(""Got a spaceship named"", d.name)
    }
}


playground

I recommend going through Effective Go, and pay extra attention to the Interfaces And Methods section.
",26079892
148,37442619,"This is a classic cross-cutting concerns example.

You are using a 3rd party to magically handle input params for your unit under test.  By that very definition, you are going to have to do some extra setup to prep the context for the state you want.

When it comes to Go http handlers (which the convention is to KISS it), you shouldn't need to ""reach out of context"" of your func to get extra data: keep all the data you need within your single func.

Personally, I try to avoid corrupting my handlers like this.  I think I've only used gorilla's context once out of the dozens of big sites I've built.  And that was basically to get around a cached response, just to keep the data refesh to the end user.  Of which I simply ignored in my unit tests, as it was out-of-scrope of what I was testing.

Instead, I use middle-ware wrappers to setup the basics I want in my handles and modify the handler's signature accordingly.


caching
logging
authentication and authorization
json marshaling
context (e.g. expected User{} object loaded from DB)


...etc.  I would create a middle-ware that wraps your handler when you register it with mux that uses gorilla/context to lookup your cookie or userid or something, hidrates that user object from cache, DB, redis, etc, and then calls your handler that would have a signature like:

func MyHandler(u User, p Page, w http.ResponseWriter, r *http.Request) {
    // u is the User object loaded from middle-ware

    // p is your global Page object... etc
}


That way, your unit tests inject only the items you need under test.

And you can integration test your middle-ware on a QA server with expected User and Page objects in a datastore.
",37442010
149,37443609,"The way my team does it is to add a name to the route handler and then in the tests we call that route by name.

This is how to add a route:

r.HandleFunc(""/"", MyHandler).Methods(""GET"").Name(""MyHandlerByName"")

Then this is how to test it

r.Get(""MyHandlerByName"")
",37442010
150,37446207,"One way to test handles is modify the way in which they are created. for example, Creating a function that return a http.HandlerFunc, this function can have parameters. You can mock the values that you send to the function

Without parameters

 func State() http.HandlerFunc {
        return http.HandlerFunc(func(pResponse http.ResponseWriter, r *http.Request)    {
            // your code
        })
    }


With Parameters

   func State(pParam1,pParam2,pParam3 ...) http.HandlerFunc {
        return http.HandlerFunc(func(pResponse http.ResponseWriter, r *http.Request)    {
            // your code using pParam1,pParam2,pParam3 
        })
    }


The mapping will be 

http.HandleFunc(""/State"", State())


or 

http.HandleFunc(""/State"", State(value1,value2,value3 ....))

",37442010
151,37334984,"this is my piping sample, file a calls file b via OS Std Pipe, you can edit this and add timer to do what you need.

// a
package main

import (
    ""fmt""
    ""log""
    ""os/exec""
    ""runtime""
    ""time""
)

var cout chan []byte = make(chan []byte)
var cin chan []byte = make(chan []byte)
var exit chan bool = make(chan bool)

func Foo(x byte) byte { return call_port([]byte{1, x}) }
func Bar(y byte) byte { return call_port([]byte{2, y}) }
func Exit() byte      { return call_port([]byte{0, 0}) }
func call_port(s []byte) byte {
    cout <- s
    s = <-cin
    return s[1]
}

func start() {
    fmt.Println(""start"")
    cmd := exec.Command(""../b/b"")
    stdin, err := cmd.StdinPipe()
    if err != nil {
        log.Fatal(err)
    }
    stdout, err2 := cmd.StdoutPipe()
    if err2 != nil {
        log.Fatal(err2)
    }
    if err := cmd.Start(); err != nil {
        log.Fatal(err)
    }
    defer stdin.Close()
    defer stdout.Close()
    for {
        select {
        case s := <-cout:
            stdin.Write(s)
            buf := make([]byte, 2)
            runtime.Gosched()
            time.Sleep(100 * time.Millisecond)
            stdout.Read(buf)
            cin <- buf
        case b := <-exit:
            if b {
                fmt.Printf(""Exit"")
                return //os.Exit(0)
            }
        }
    }
}
func main() {
    go start()
    runtime.Gosched()
    fmt.Println(""30+1="", Foo(30)) //30+1= 31
    fmt.Println(""2*40="", Bar(40)) //2*40= 80
    Exit()
    exit <- true
}


file b:

// b
package main

import (
    ""log""
    ""os""
)

func foo(x byte) byte { return x + 1 }
func bar(y byte) byte { return y * 2 }

func ReadByte() byte {
    b1 := make([]byte, 1)
    for {
        n, _ := os.Stdin.Read(b1)
        if n == 1 {
            return b1[0]
        }
    }
}
func WriteByte(b byte) {
    b1 := []byte{b}
    for {
        n, _ := os.Stdout.Write(b1)
        if n == 1 {
            return
        }
    }
}
func main() {
    var res byte
    for {
        fn := ReadByte()
        log.Println(""fn="", fn)
        arg := ReadByte()
        log.Println(""arg="", arg)
        if fn == 1 {
            res = foo(arg)
        } else if fn == 2 {
            res = bar(arg)
        } else if fn == 0 {
            return //exit
        } else {
            res = fn //echo
        }
        WriteByte(1)
        WriteByte(res)
    }
}

",37330211
152,17065954,"I don't like the code bellow, but it seems to do what you seem to want it to do:

package main

import (
        ""fmt""
        ""regexp""
)

func main() {
        input := `bla bla b:foo=""hop"" blablabla b:bar=""hu?""`
        r := regexp.MustCompile(`\bb:\w+=""([^""]+)""`)
        r2 := regexp.MustCompile(`""([^""]+)""`)
        fmt.Println(r.ReplaceAllStringFunc(input, func(m string) string {
                return r2.ReplaceAllString(m, `""${2}whatever""`)
        }))
}


Playground



Output

bla bla b:foo=""whatever"" blablabla b:bar=""whatever""




EDIT: Take II.



package main

import (
        ""fmt""
        ""regexp""
)

func computedFrom(s string) string {
        return fmt.Sprintf(""computedFrom(%s)"", s)
}

func main() {
        input := `bla bla b:foo=""hop"" blablabla b:bar=""hu?""`
        r := regexp.MustCompile(`\bb:\w+=""([^""]+)""`)
        r2 := regexp.MustCompile(`""([^""]+)""`)
        fmt.Println(r.ReplaceAllStringFunc(input, func(m string) string {
                match := string(r2.Find([]byte(m)))
                return r2.ReplaceAllString(m, computedFrom(match))
        }))
}


Playground



Output:

bla bla b:foo=computedFrom(""hop"") blablabla b:bar=computedFrom(""hu?"")

",17065465
153,33465126,"I don't know about Go, but in Java you can simply delete local_db.bin from WEB-INF/appengine-generated folder. An empty file will be created next time you run the app.
",33465099
154,33465590,"Simply provide the --clear_datastore command line parameter when starting:

goapp serve --clear-datastore


Documented at: The Go Development Server: Using the Datastore.


  To clear the local datastore for an application, use the --clear_datastore=yes option when you start the web server:


Note that the documentation was ""copied"" from the Python section, you need to use it as presented above (you get an error if you try to execute goapp serve --clear_datastore=yes).
",33465099
155,24775103,"It is ultimately up to you, but nginx's SSL configuration is extremely configurable, battle-tested and performant. 


nginx can provide an SSL session cache to boost performance - ssl_session_cache
Good cipher compatibility
I believe that nginx's SSL implementation is faster (more req/s and less CPU) than Go's, but have not tested this myself. This would not be surprising given maturity of the nginx project. 
Other benefits like response caching for both proxied and static content. 


The downside, of course, is that it's another moving part that requires configuration. If you are already planning to use nginx as a reverse proxy however I would use it for SSL as well. 
",24774833
156,33063846,"Your code is fine for in-place modification.

Don't clearly understand what you mean by bitwise operations. Maybe this

package main

    import ""fmt""

    func main() {
        a := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
        fmt.Println(a)
        rotateR(&a, 4)
        fmt.Println(a)
        rotateL(&a, 4)
        fmt.Println(a)
    }

    func rotateL(a *[]int, i int) {
        x, b := (*a)[:i], (*a)[i:]
        *a = append(b, x...)
    }

    func rotateR(a *[]int, i int) {
        x, b := (*a)[:(len(*a)-i)], (*a)[(len(*a)-i):]
        *a = append(b, x...)
    }


Code works https://play.golang.org/p/0VtiRFQVl7

It's called reslicing in Go vocabulary. Tradeoff is coping and looping in your snippet vs dynamic allocation in this. It's your choice, but in case of shifting 10000 elements array by one position reslicing looks much cheaper. 
",33059420
157,33067435,"Rotating the slice one position at a time, and repeating to get the total desired rotation means it will take time proportional to rotation distance × length of slice. By moving each element directly into its final position you can do this in time proportional to just the length of the slice.

The code for this is a little more tricky than you have, and you’ll need a GCD function to determine how many times to go through the slice:

func gcd(a, b int) int {
    for b != 0 {
        a, b = b, a % b
    }

    return a
}

func rotateL(a []int, i int) {

    for c := 0; c < gcd(i, len(a)); c++ {

        t := a[c]

        j := c

        for {
            k := j + i
            // loop around if we go past the end of the slice
            if k >= len(a) {
                k -= len(a)
            }
            // end when we get to where we started
            if k == c {
                break
            }
            // move the element directly into its final position
            a[j] = a[k]
            j = k
        }

        a[j] = t
    }
}


Rotating a slice of size l right by p positions is equivalent to rotating it left by l − p positions, so you can simplify your rotateR function by using rotateL:

func rotateR(a []int, i int) {
    rotateL(a, len(a) - i)
}

",33059420
158,28949235,"You can use encoding/binary.Read to fill an []int16 directly from your reader, although technically the answer to your first question is still no (check the source of binary.Read, it reads the data to a []byte first).
",28949063
159,28949296,"When working with IO, you always work with []bytes, there's no way to substitute that with []int16, or pre-format that as int16s, it's always a stream of bytes.

You can look at the encoding/binary package to decode this stream.

// to get the first uint16 as i
i := binary.LittleEndian.Uint16(buf[:2])


You can then iterate through the buf as needed. 

You can also use binary.Read to read directly from the io.Reader. 

var i uint16
for {
    err := binary.Read(r, binary.LittleEndian, &i)
    if err != nil {
        log.Println(err)
        break
    }
    fmt.Println(i)
}


It may worth noting the simplicity of what needs to be done. Each uint16 is created via:

func (littleEndian) Uint16(b []byte) uint16 {
    return uint16(b[0]) | uint16(b[1])<<8
}

",28949063
160,30257496,"If you are using visual studio and want to add dependency to your project then just install it using NuGet Package Manager it's easiest method.
Install command: Install-Package libxml2 
",29901728
161,30967521,"You are struggling because it is hard to combine packages that were built by different people for different purposes and get your environment set up correctly.  I think it is best to use MSYS2, an environment for Windows that provides a consistent set of packages for things like gcc, go, libxml2, and iconv.  MSYS2 has a package manager (pacman) that helps you easily install them and keep them updated.

I don't do much programming with Go, but I am familiar with MSYS2 and it seems like I was able to get gokogiri installed using MSYS2.  You should open MSYS2's ""MinGW-w64 Win64 Shell"" from the Start menu (mingw64_shell.bat), and try running these commands:

pacman -S mingw-w64-x86_64-{gcc,go,libxml2,iconv}
export GOROOT=/mingw64/
export GOPATH=/c/Users/David/Documents/goproj/
mkdir -p $GOPATH
go git github.com/moovweb/gokogiri


I think GOPATH should be set to the directory of your project.  If you run into an error, it might be because some pacman package is required that I didn't list here.

The string mingw-w64-x86_64-{gcc,go,libxml2,iconv} gets expanded by Bash into the following list of packages:

mingw-w64-x86_64-gcc
mingw-w64-x86_64-go
mingw-w64-x86_64-libxml2
mingw-w64-x86_64-iconv


If you are actually using 32-bit Windows, replace x86_64 with i686 in the instructions above.

If you are curious, the scripts for building those packages are here: https://github.com/Alexpux/MINGW-packages

As a disclaimer, I haven't actually compiled any go programs in MSYS2, so there could be big problems I am unaware of.

Also, one of the main developers of MSYS2 (alexpux) said this in the #msys2 IRC chat on 2015-06-21:


  We not build go for a long time.
  This package in very WIP state
  Also see
  https://github.com/Alexpux/MINGW-packages/issues/421


So you might need to fix some issues with the MSYS2 Go package and recompile it yourself to really make this work.  But you have the PKGBUILD script that was used to build it, so maybe that will be less hard than what you are trying to do right now, which involves compiling/collecting every dependency of gokogiri.

MSYS2 would make your other installation of go, libxml2, and iconv obsolete.  You can delete those things once you get your MSYS2 environment working.
",29901728
162,41248359,"Write an interface that describes your usage. This won't be very pretty if you use the V method, but you have a wrapper so you've already done the hard work that fixing that would entail.

For each package you need to test, define

type Logger interface {
    Infoln(...interface{}) // the methods you actually use in this package
}


And then you can easily swap it out by not referring to glog types directly in your code.
",41247206
163,41310246,"Test which captures stderr:

package main

import (
    ""bytes""
    ""io""
    ""os""
    ""testing""

    ""github.com/golang/glog""
    ""strings""
)

func captureStderr(f func()) (string, error) {
    old := os.Stderr // keep backup of the real stderr
    r, w, err := os.Pipe()
    if err != nil {
        return """", err
    }
    os.Stderr = w

    outC := make(chan string)
    // copy the output in a separate goroutine so printing can't block indefinitely
    go func() {
        var buf bytes.Buffer
        io.Copy(&buf, r)
        outC <- buf.String()
    }()

    // calling function which stderr we are going to capture:
    f()

    // back to normal state
    w.Close()
    os.Stderr = old // restoring the real stderr
    return <-outC, nil
}

func TestGlogError(t *testing.T) {
    stdErr, err := captureStderr(func() {
        glog.Error(""Test error"")
    })
    if err != nil {
        t.Errorf(""should not be error, instead: %+v"", err)
    }
    if !strings.HasSuffix(strings.TrimSpace(stdErr), ""Test error"") {
        t.Errorf(""stderr should end by 'Test error' but it doesn't: %s"", stdErr)
    }
}


running test:

go test -v
=== RUN   TestGlogError
--- PASS: TestGlogError (0.00s)
PASS
ok      command-line-arguments  0.007s

",41247206
164,42201984,"ind1 is a slice (the type is []bool).

ind2 is an array (the type is [10]bool).

They are not of the same type.

The result of unsafe.Sizeof(ind1) probably has nothing to do with the arguments passed to make.
",42201804
165,42202087,"Arrays and slices in Go are different things.

Your ind1 is a slice, and ind2 is an array. The length of an array is part of the type, so for example [2]bool and [3]bool are 2 different array types.

A slice in Go is a descriptor for a contiguous segment of an underlying array and provides access to a numbered sequence of elements from that array. This slice header is a struct-like data structure represented by the type reflect.SliceHeader:

type SliceHeader struct {
        Data uintptr
        Len  int
        Cap  int
}


It contains a data pointer (to the first element of the represented segment), a length and a capacity.

The unsafe.SizeOf() function returns the size in bytes of the hypothetical variable as if it would hold the passed value. It does not include any memory possibly referenced by it.

So if you pass a slice value (ind1), it will tell you the size of the above mentioned slice header. Note that the size of the fields of SliceHeader are architecture dependent, e.g. int may be 4 bytes on one platform and it may be 8 bytes on another. The size 24 applies to 64-bit architectures.

The Go Playground runs on a 32-bit architecture. Let's see this example:

fmt.Println(unsafe.Sizeof(make([]bool, 10)))
fmt.Println(unsafe.Sizeof(make([]bool, 20)))

fmt.Println(unsafe.Sizeof([10]bool{}))
fmt.Println(unsafe.Sizeof([20]bool{}))


Output (try it on the Go Playground):

12
12
10
20


As you can see, no matter the length of the slice you pass to unsafe.SizeOf(), it always returns 12 on the Go Playground (and 24 on 64-bit architectures).

On the other hand, an array value includes all its elements, and as such, its size depends on its length. Size of [10]bool is 10, and size of [20]bool is 20.

See related questions+answers to learn more about slices, arrays and the difference and relation between them:

How do I find the size of the array in go

Why have arrays in Go?

Why use arrays instead of slices?

Must read blog posts:

Go Slices: usage and internals

Arrays, slices (and strings): The mechanics of 'append'
",42201804
166,22394667,"I have answered my own question about this subject. It contains the Python code for reading and writing files (blobs) using Google Cloud storage and creating serving urls. 

This codes works for images and other files like js, css and pdf's. in both the SDK and GAE production.

The code is here: How to serve cloudstorage files using app engine SDK 
",22394264
167,31328676,"The short answer is no. The code is compiled leaving no information about what language/compiler produced it. You can look for symptoms of a go-program, like references to your GOPATH or sub directories of it, but not much more.
",31328213
168,31331002,"In addition to @evanmcdonnal's answer, here's a (very, very) hacky solution:

strings /path/to/binary/from/ps/output | grep 'runtime.gogc' 


Output:


runtime.gogc                                                                                            runtime.gogc   
runtime.gogc   



This of course relies on the binary format not changing or otherwise being obfuscated, which is not a good assumption to make long-term. I'm also assuming that runtime.gogc exists across all Go binaries (it may not).

Note that it would be very rare for this to be useful information from an operational point of view.
",31328213
169,42691737,"It means perform the action on all packages under a directory. So for example go test ./... runs go test on the current dir + all subdirectories.

The Go tool documentation is here:

https://golang.org/doc/cmd
",42691705
170,42692762,"./... means a recursive action ( ... ) from your current directory ( ./ )
",42691705
171,30488660,"syscall.Syscall don't do what you think.

It make a System Call, a call to OS kernel function, not an arbitrary jump to a location

Moreover the shellcode expect the C calling conventions, for example the stack pointer to be to a C stack etc. this conditions are not fulfilled in go runtime
",30468532
172,36799526,"Try to qualify identifiers with import prefix to make them defined

d := gorpc.NewDispatcher()

",36798854
173,42852592,"It's because goroutine is cooperative (not fully preemptive) task, and the context switch only happen when there's some IO, system call, time.Sleep(), or calling large function which have to extend the stack.

Reference:


Go Routine Blocking the Other One
Preemption since Go 1.2


Your atomic.AddUint64(&ops, 1) is small function which does not have to extend stack. so the context switch never occurs.

Since main thread is also a goroutine, it does not acquire context switch, and sleeps forever.

There's an open issue to make golang preemptive in tight loop, but not yet solved.

More useful references:


A pitfall of golang scheduler
golang scheduler is not preemptive - it's cooperative?

",42852429
174,23256113,"json.RawMessage is really just a slice of bytes. You should be able to feed it directly into json.Unmarshal directly, like so:

json.Unmarshal(out.Hits.Hits[0].Source, &mySyncInfo)


Also, somewhat unrelated, but json.Unmarshal can return an error and you want to handle that.

err := json.Unmarshal(*out.Hits.Hits[0].Source, &mySyncInfo)
if err != nil {
    // Handle
}

",23255456
175,23256630,"As said, the underlying type of json.RawMessage is []byte, so you can use a json.RawMessage as the data parameter to json.Unmarshal.

However, your problem is that you have a pointer (*json.RawMessage) and not a value. All you have to do is to dereference it:

err := json.Unmarshal(*out.Hits.Hits[0].Source, &mySyncInfo)


Working example:

package main

import (
    ""encoding/json""
    ""fmt""
)

type SyncInfo struct {
    Target string
}

func main() {
    data := []byte(`{""target"": ""localhost""}`)
    Source := (*json.RawMessage)(&data)

    var mySyncInfo SyncInfo
    // Notice the dereferencing asterisk *
    err := json.Unmarshal(*Source, &mySyncInfo)
    if err != nil {
        panic(err)
    }

    fmt.Printf(""%+v\n"", mySyncInfo)
}


Output:

{Target:localhost}


Playground: http://play.golang.org/p/J8R3Qrjrzx
",23255456
176,44774651,"If I understand correctly, the issue you're having is that the random number appears to always have the same number of digits as the maximum allowed value, right? When I run the code, this is not the case. Here's an output I just observed:

3859736307910539847452366166956263595094585475969163479420172104717272049811
65719900872761032562423535702578352960653752260368991759410130265294153783


In the playground, I believe the random seed and clock time are fixed, so you'll see the same result repeatedly. But running locally, I see the expected variation in the length of the output.

UPDATE

You may wonder why you can run this code a bunch of times and observe that the length of the random number is very often close to the length of the maximum value.

A little math explains this. Let's imagine we're picking a number between 0 and 999. How many numbers in that range have:


3 digits? 900 (100-999)
2 digits? 90 (10-99)
1 digit? 10 (0-9)


Similarly, with your very large maximum value, most of the numbers that can be picked will be very close to that maximum length. It will be rare to see a number two digits short of that length. (You should see them on the order of 1% of the time.)
",44774514
177,29683321,"You can't refer to promoted fields in a struct literal. You have to create the embedded type, and refer to it by the type's name.

&authHandler{
    sidHandler: sidHandler{section: ""bar""},
    handler:    ""foo"",
}

",29683047
178,29683330,"Embedding doesn't work with literals like that.

func registerAuthHandler(handler authFuncHandler, section string) http.Handler {
    return &authHandler{
        handler: handler,
        sidHandler: sidHandler{section: section},
    }
}

",29683047
179,39474991,"It works as expected, you're just using wrong syntax. The element type of the slice is interface{}, so a composite literal to initialize it should look like []interface{}{ ... }, like in this example:

featureVector := []interface{}{[]int{1, 2}, []float64{1.2, 2.2}, []string{""a"", ""b""}}


And you can treat it like any other slice:

featureVector = append(featureVector, []byte{'x', 'y'})
fmt.Printf(""%#v"", featureVector)


Output (try it on the Go Playground):

[]interface{}{[]int{1, 2}, []float64{1.2, 2.2}, []string{""a"", ""b""}, []uint8{0x78, 0x79}}


But know that since the element type is interface{}, nothing prevents anybody to append a non-slice:

featureVector = append(featureVector, ""abc"") // OK


This also applies with the map solution.
",39474715
180,27244777,"You need to use str, not temp

see: https://play.golang.org/p/t9Aur98KS6

package main

func equalStringArray(a, b []string) bool {
    if len(a) != len(b) {
        return false
    }
    for i := 0; i < len(a); i++ {
        if a[i] != b[i] {
            return false
        }
    }
    return true
}

func main() {
    someotherStringArray := []string{""A"", ""B""}
    var temp interface{}
    temp = []string{""A"", ""B""}
    if strArray, ok := temp.([]string); ok {
        if !equalStringArray(strArray, someotherStringArray) {
            // do something 1
        } else {
            // do something else
        }
    }
}

",27244663
181,41761798,"You may use StaticFile to serve a single file

router.StaticFile(""/favicon.ico"", ""./resources/favicon.ico"")


If you want to serve static image given its path,you may use it just like js and css

router.Static(""/img"", ""./img"")


or

import ""github.com/gin-gonic/contrib/static""
.
.
.
router.Use(static.Serve(""/img"", static.LocalFile(""./img"", true)))

",41759296
182,42758241,"multipart.File implements io.Reader interface so you could copy its content into a bytes.Buffer like this:

file, header, err := ctx.Request.FormFile(""file"")    
defer file.Close()
if err != nil {
    return nil, err
}

buf := bytes.NewBuffer(nil)
if _, err := io.Copy(buf, file); err != nil {
    return nil, err
}


and then add to your app

app.SetFile(buf.Bytes())

",42758054
183,10095809,"There's currently no way to build Android apps with Go, and some hypothetical future version of Android isn't a good reason to invest time in Go today.

That said, Go is a great language, you can do a lot with it like write webservers, command line apps, and even AppEngine apps.  So there's lots of good reasons to learn Go!  But Android isn't one of them.

Edit:
As of Go 1.5 it is possible to write Android apps completely in Go or as a Java app calling a Go JNI library. iOS is also expected to arrive in time for the final 1.5 release. Go to https://github.com/golang/mobile for more details.
",10095698
184,35563136,"You can use dbg.vim.

Once the plugin installed, you can setup your breakpoints and use shortcuts to show value of variable under the cursor, etc.
",26560723
185,22135850,"bound := func(xx,yy int) { return func(){fmt.Println(xx,yy)} }(x,y)


Untested.

Please have a look (or two) at http://golang.org/doc/effective_go.html
",22135486
186,22137690,"For example,

package main

func callbackXY(x, y string) func() {
    return func() { print(""callbackXY: "", x, y, ""\n"") }
}

func main() {
    x, y := ""old x "", ""old y""
    callback := callbackXY(x, y)
    x, y = ""new x "", ""new y""
    callback()
}


Output:

callbackXY: old x old y


Or

package main

func main() {
    x, y := ""old x "", ""old y""
    callback := func() {}
    {
        x, y := x, y
        callback = func() { print(""callbackXY: "", x, y, ""\n"") }
    }
    x, y = ""new x "", ""new y""
    callback()
}


Output:

callbackXY: old x old y

",22135486
187,25387687,"An XPath search from any node can still search the entire tree.

If you want to search just the subtree, you can start the expression with a . (assuming you still want descendant-or-self), otherwise use a exact path.

xps := xpath.Compile(""//div[@class='head']/div[@class='area']"")
xpw := xpath.Compile("".//div[@class='value']"")

// this works in your example case
// xpw := xpath.Compile(""div[@class='value']"")
// as does this
// xpw := xpath.Compile(""./div[@class='value']"")

ss, _ := doc.Root().Search(xps)
for _, s := range ss {
    ww, _ := s.Search(xpw)
    for _, w := range ww {
        fmt.Println(w.InnerHtml())
    }
}


Prints:

10
20
30

",25386761
188,25387699,"Your second query, //div[@class='value'], will select divs anywhere in the document regardless of the parent element. Instead, try div[@class='value'].
",25386761
189,31113429,"The builtin append() function is for appending elements to a slice. If you want to append a string to a string, simply use the concatenation +. And if you want to store the result at the 0th index, simply assign the result to it:

s[0] = s[0] + ""dd""


Or short:

s[0] += ""dd""


Note also that you don't have to (can't) use := which is a short variable declaration, since your s slice already exists.

fmt.Println(s) output:

[filenamedd]


If you want to append to the slice and not to the first element, then write:

s = append(s, ""dd"")


fmt.Println(s) output (continuing the previous example):

[filenamedd dd]


Try these on the Go Playground.
",31113299
190,26281943,"Go has full support for calling into arbitrary Win32 API's via its core syscall package.  

While calling out to raw Win32 via syscall is not exactly pretty to write (mostly because you're crossing the managed/unmanaged boundary, and back) and has no support from the compiler (akin to, say, that of Delphi), this works just OK, and generation of wrapper functions for such API calls can be automated—the Go core packages use this facility for themselves, other popular examples include the odbc package.

Note that there already exists winsvc—a library which interfaces Go with the Windows SCM and event log.

Also look at service which provides unified API for turning your program into a daemon/service using platform-native tools (it uses winsvc on Windows, IIRC).
",26280024
191,24051370,"In Go, these fields from embedded structs are called promoted fields.

The Go Specification states (my emphasis):


  Promoted fields act like ordinary fields of a struct except that they cannot be used as field names in composite literals of the struct.


This is how you can solve it:

p := &Article{
    Page: Page{""Welcome!""},
    Id:   2,
}

",24051325
192,24051398,"You have to init like this:

p := &Article{
    Page: Page{
        Title: ""Welcome!"",
    },
    Id: 2,
}


PlayGround: http://play.golang.org/p/CEUahBLwCT

package main

import ""fmt""

type Page struct {
    Title string
}

type Article struct {
    Page
    Id int
}

func main() {

    // this generates a build error:
    // ""invalid field name Title in struct initializer""
    //
    p := &Article{
        Page: Page{
            Title: ""Welcome!"",
        },
        Id: 2,
    }
    fmt.Printf(""%#v \n"", p)
}

",24051325
193,21204391,"The ""f"" stands for ""file"" - it's a C/Unix-ism. Of course Fprint can write to arbitrary Writers, but in the Unix world file is a pretty generic concept and can refer to pretty much anything from ""normal"" files to socket (streams) or data generated by programs (before any downvotes - yes, I know I'm a bit oversimplifying things, but the question wasn't about the Unix concept of a file so...)

The fmt function names are similar to the C names to ease C programmers already familiar with them in.
",21204318
194,27366319,"It's not in the documentation, but you can still read the source code. The categories you're talking about are defined in this file: http://golang.org/src/pkg/unicode/tables.go

For example, the P category is defined this way:

2029    var _P = &RangeTable{
2030        R16: []Range16{
2031            {0x0021, 0x0023, 1},
2032            {0x0025, 0x002a, 1},
2033            {0x002c, 0x002f, 1},
2034            {0x003a, 0x003b, 1},
2035            {0x003f, 0x0040, 1},
2036            {0x005b, 0x005d, 1},
2037            {0x005f, 0x007b, 28},
                ...
2141            {0xff5d, 0xff5f, 2},
2142            {0xff60, 0xff65, 1},
2143        },
2144        R32: []Range32{
2145            {0x10100, 0x10102, 1},
2146            {0x1039f, 0x103d0, 49},
2147            {0x10857, 0x1091f, 200},
                ...
2157            {0x12470, 0x12473, 1},
2158        },
2159        LatinOffset: 11,
2160    }


And here is a simple way to print all of them:

var p = unicode.Punct.R16
for _, r := range p {
    for c := r.Lo; c <= r.Hi; c += r.Stride {
        fmt.Print(string(c))
    }
}

",27366196
195,27368243,"There are a number of web sites that present an interface to the Unicode character database. For example see the “Punctuation, ...” categories at http://www.fileformat.info/info/unicode/category/.
",27366196
196,25056378,"You could use mail.Header and simply call .Date() on it.

Another option is to read the code starting from line 70 and write your own function.
",25056227
197,8344775,"For example,

package main

import (
    ""fmt""
    ""strconv""
    ""time""
)

func main() {
    t := strconv.FormatInt(time.Nanoseconds(), 10)
    fmt.Println(t)
}


Output:

1322756865962046000

",8344210
198,10512619,"if you got an error like this, just cast it the way the compiler told it.
i.e.:

strconv.Itoa(int(time.Nanoseconds()))

",8344210
199,26553747,"Brackets and dollar signs are significant in regular expressions and should be escaped.

This would make your first boolean evaluate to true:

`SELECT count\(\\\*\) FROM video_resource WHERE key = \$1`


or this for the second:

`SELECT count\(\*\) FROM video_resource WHERE key = \$1`


See here: http://play.golang.org/p/apkker73wr
",26553554
200,26553750,"Your regular expression contains metacharacters that need to be escaped.

regexp.MustCompile(`SELECT count\(\*\) FROM video_resource WHERE key = \$1`)


Play
",26553554
201,30577326,"It can refer to fields in embedded or non embedded structs, recursively:

type Foo struct {
    Bar string
}

type Baz struct {
    Zoo Foo
}

func main() {

    b := Baz{Zoo:Foo{""foo""}}
    v := reflect.ValueOf(b)

    fmt.Println(v.FieldByIndex([]int{0})) //output: 

    fmt.Println(v.FieldByIndex([]int{0, 0})) //output: foo

}

",30576874
202,26548256,"What is (probably) happening is that sendmail is waiting for the input to finish.

Either close the pipe after having written or (depending on sendmail versions and stuff) try finishing sending through "".\n"" as the very last piece of the message (some versions will accept that in addition to the input being closed).
",26548066
203,40080402,"NEVER NEVER NEVER use the ""-t"" command-line option here. It will mis-deliver mail, like sending messages from a mailing list back to the mailing list.
",26548066
204,35791105,"In your example you pass a value of pointer type (*Ab), not a struct type.

Sticking to Type.Name()

If it is not a pointer, Type.Name() will properly return Ab. In case of pointer if you still want the struct's name, you can use Type.Elem() to get the element's type:

func getType(myvar interface{}) string {
    if t := reflect.TypeOf(myvar); t.Kind() == reflect.Ptr {
        return ""*"" + t.Elem().Name()
    } else {
        return t.Name()
    }
}


Testing it:

tst4 := Ab{}
tst5 := new(Ab)
fmt.Println(getType(tst4))
fmt.Println(getType(tst5))


Output (try your modified example on the Go Playground):

Ab
*Ab


Note:

Note that as Type.Name() does not resolve pointers, it would not work if the value passed is a pointer to pointer, e.g. **Ab, while as Type.String() automatically resolves pointers, would work in this case too.

We can easily make our getType() function to work with **Ab too (or with any depth of pointers):

func getType(myvar interface{}) (res string) {
    t := reflect.TypeOf(myvar)
    for t.Kind() == reflect.Ptr {
        t = t.Elem()
        res += ""*""
    }
    return res + t.Name()
}


Calling it with values:

tst4 := Ab{}
tst5 := new(Ab)
tst6 := &tst5 // type of **Ab
tst7 := &tst6 // type of ***Ab


Output (try it on the Go Playground):

Ab
*Ab
**Ab
***Ab


Using Type.String()

A simpler and better approach would be to use Type.String() instead of Type.Name() which automatically handles pointers and also includes package name. E.g.:

func getType(myvar interface{}) string {
    return reflect.TypeOf(myvar).String()
}


For the modified example it outputs:

string
int
float64
main.Ab
*main.Ab


Try this variant on the Go Playground.
",35790935
205,35791322,"The problem is new returns pointer, following should get the desired result.

package main

import (
    ""fmt""
    ""reflect""
)

type Ab struct {
}

func getType(myvar interface{}) {
    valueOf := reflect.ValueOf(myvar)

    if valueOf.Type().Kind() == reflect.Ptr {
        fmt.Println(reflect.Indirect(valueOf).Type().Name())
    } else {
        fmt.Println(valueOf.Type().Name())
    }
}

func main() {
    fmt.Println(""Hello, playground"")

    tst := ""string""
    tst2 := 10
    tst3 := 1.2
    tst4 := new(Ab)

    getType(tst)
    getType(tst2)
    getType(tst3)
    getType(tst4)

}


Output is

Hello, playground
string
int
float64
Ab

",35790935
206,44199875,"fmt has a cool %T tag as well

package main

import (
    ""fmt""
    ""net/http""
)

type Potato struct {
}

func main() {
    fmt.Printf(""I have a %T, an %T and a %T"", Potato{}, http.StatusMultipleChoices, &http.Response{})
}


outputs I have a main.Potato, an int and a *http.Response
https://play.golang.org/p/6z7_0BSitm
",35790935
207,31053543,"Before each rewrite, truncate the file and seek to the beginning.
Example:

package main

import (
    ""fmt""
    ""os""
)

func main() {
    if f, err := os.Create(""test.csv""); err == nil {
        defer f.Close()
        for n := 10; n > 0; n-- {
            f.Truncate(0) // comment or uncomment
            f.Seek(0, 0)  // these lines to see the difference
            for i := 0; i < n; i++ {
                f.WriteString(fmt.Sprintf(""%d\n"", i))
            }
        }
    } else {
        fmt.Println(err)
    }
}

",31050656
208,31074504,"opening file in read and write(os.RDWR) mode appends to the file.

Sol:
open the file in read only mode(os.RDONLY) for reading and close it after reading.

csvfile ,_:= os.OpenFile(""output.csv"", os.O_RDONLY|os.O_CREATE, 0777)
csvfile.Close()


For writing, open the file in write only mode(os.WRONLY) and close it after writing, this overwrites the file rather than appending.

csvfile ,_:= os.OpenFile(""output.csv"", os.O_WRONLY|os.O_CREATE, 0777)
csvfile.Close()


for appending you could use os.APPEND
",31050656
209,29721505,"If you don't want timestamps, just create a new log.Logger with flag set to 0:

l := log.New(os.Stderr, """", 0)
l.Println(""log msg"")


EDIT:


  Is the following good Go?

os.Stderr.WriteString(""Message"")



This is acceptable, and you can also use fmt.Fprintf and friends to get formatted output:

fmt.Fprintf(os.Stderr, ""number of foo: %d"", nFoo)

",29721449
210,29721532,"Using the fmt package, you can choose to write to stderr this way:

import ""fmt""
import ""os""

func main() {
    fmt.Fprintln(os.Stderr, ""hello world"")
}

",29721449
211,29722621,"os.Stderr is an io.Writer, so you can use it in any function which accepts an io.Writer. Here are a few examples:

str := ""Message""
fmt.Fprintln(os.Stderr, str)
io.WriteString(os.Stderr, str)
io.Copy(os.Stderr, bytes.NewBufferString(str))
os.Stderr.Write([]byte(str))


It all depends on how exactly you have the string you want to print (i.e. if you want to format it first, if you have it as an io.Reader, if you have it as a byte slice...). And there can be a lot more ways.
",29721449
212,33875186,"By default the logger flags are set to Ldate | Ltime. You can change the logger format to any of the following (from the golang log documentation):

Ldate         = 1 << iota     // the date in the local time zone: 2009/01/23
Ltime                         // the time in the local time zone: 01:23:23
Lmicroseconds                 // microsecond resolution: 01:23:23.123123.  assumes Ltime.
Llongfile                     // full file name and line number: /a/b/c/d.go:23
Lshortfile                    // final file name element and line number: d.go:23. overrides Llongfile
LUTC                          // if Ldate or Ltime is set, use UTC rather than the local time zone
LstdFlags     = Ldate | Ltime // initial values for the standard logger


For example, flags Ldate | Ltime (or LstdFlags) produce,

2009/01/23 01:23:23 message


While flags Ldate | Ltime | Lmicroseconds | Llongfile produce,

2009/01/23 01:23:23.123123 /a/b/c/d.go:23: message


You can also set the default logger to not print anything by setting the flag to 0:

log.SetFlags(0)

",29721449
213,33261484,"The process runs in a container, and port 8080 is mapped to a random port each time the app start. So, it's a different port each time. However, the same internal port - as the app runs in a Docker container.

Can you elaborate and give more details?
",33260236
214,43370261,"It gives those errors because github.com/go-xorm/dbweb has dependencies on those other two packages which it cannot update because you have them locally but they have no remote so go get does not know from where to pull the code. 

Try removing them:

$ rm -rf $GOPATH\src\github.com\lunny\nodb
$ rm -rf $GOPATH\src\golang.org\x\crypto


Then try to go get your package again:

$ go get -u github.com/go-xorm/dbweb


Or go get them separately and then go get dbweb: 

$ go get -u golang.org\x\crypto
$ go get -u github.com\lunny\nodb
$ go get -u github.com/go-xorm/dbweb

",43367802
215,36988882,"The simple way to do this is to create new Time using the previous one and only assigning the year month and day. It would look like this;

rounded := time.Date(toRound.Year(), toRound.Month(), toRound.Day(), 0, 0, 0, 0, toRound.Location())


here's a play example; https://play.golang.org/p/jnFuZxruKm
",36988681
216,38516536,"You can simply use duration 24 * time.Hour to truncate time.

t := time.Date(2015, 4, 2, 0, 15, 30, 918273645, time.UTC)
d := 24 * time.Hour
t.Truncate(d)


https://play.golang.org/p/BTz7wjLTWX
",36988681
217,39193188,"The panic is on this line:

value = reflect.AppendSlice(value, reflect.ValueOf(s.Elem()))


The value s.Elem() is a reflect.Value. Use this value directly in the call to AppendSlice:

value = reflect.AppendSlice(value, s.Elem())


The expression reflect.ValueOf(s.Elem()) returns the reflect.Value for a reflect.Value, not for the underlying []int.

playground example
",39192373
218,39193350,"Error in line 21:

value = reflect.AppendSlice(value, reflect.ValueOf(s.Elem()))


See doc:

func AppendSlice(s, t Value) Value
The slices s and t must have the same element type.


When you dump values, you see:

Var dump s.Elem(): []int(nil) 
Var dump reflect.ValueOf(s.Elem()): {typ:0xfa840 ptr:0x1040e160 flag:407} 
Var dump value: []int(nil) 


So you only need s.Elem() 
See: https://play.golang.org/p/KwXRxGyswg
",39192373
219,39194309,"Try this working sample ( The Go Playground ):

package main

import (
    ""fmt""
    ""reflect""
)

func main() {
    s := reflect.New(reflect.TypeOf([]interface{}{})).Elem()
    s = reflect.Append(s, reflect.ValueOf(1))
    s = reflect.AppendSlice(s, reflect.ValueOf([]interface{}{2, 3, 4, 5, 6, 7, 8, 9}))
    fmt.Println(s)
}


output:

[1 2 3 4 5 6 7 8 9]


And see: https://github.com/golang/go/wiki/InterfaceSlice :


  The question then, ""Why can't I assign any slice to an []interface{},
  when I can assign any type to an interface{}?""
  
  Why?
  
  There are two main reasons for this.
  
  The first is that a variable with type []interface{} is not an
  interface! It is a slice whose element type happens to be interface{}.
  But even given this, one might say that the meaning is clear.
  
  Well, is it? A variable with type []interface{} has a specific memory
  layout, known at compile time.
  
  Each interface{} takes up two words (one word for the type of what is
  contained, the other word for either the contained data or a pointer
  to it). As a consequence, a slice with length N and with type
  []interface{} is backed by a chunk of data that is N*2 words long.
  
  This is different than the chunk of data backing a slice with type
  []MyType and the same length. Its chunk of data will be
  N*sizeof(MyType) words long.
  
  The result is that you cannot quickly assign something of type
  []MyType to something of type []interface{}; the data behind them just
  look different.

",39192373
220,38821032,"By the time the goroutines are running the variable i has already incremented. Pass it as a function parameter instead.

In fact, never rely on variables from a function closure in goroutines. It's too unreliable.
",38820997
221,38821129,"There are some problems:
What is the value of i when chan_array[i-1] runs:

for i := 0; i < 2; i++ {
    go func() {
        select {
        case x := <- chan_array[i-1]:
            if x == 0 {
                return
            }
            fmt.Println(x)
        }
    }()
}


try this:  

for i := 0; i < 2; i++ {
    go func(i int) { 
        select {
        case x := <-chan_array[i]:
            if x == 0 {
                return
            }
            fmt.Println(x)
        }
    }(i)
}


Let's simplify your code (with some corrections):  

package main

import ""fmt""

func main() {
    chan1 := make(chan int)
    chan2 := make(chan int)

    go routine(chan1)
    go routine(chan2)

    chan1 <- 1
    chan2 <- 2
    chan1 <- 0
    chan2 <- 0
}

func routine(ch chan int) {
    select {
    case x := <-ch:
        if x == 0 {
            return
        }
        fmt.Println(x)
    }
}


With these:

chan1 <- 1
chan2 <- 2


fatal error: 

all goroutines are asleep - deadlock!


your goroutines finished and no goroutines listening to chan1 and chan1 here:

chan1 <- 0
chan2 <- 0


Your corrected working sample code is:

package main

import ""fmt""

func main() {
    chan1 := make(chan int)
    chan2 := make(chan int)

    go routine(chan1)
    go routine(chan2)

    chan1 <- 1
    chan2 <- 2
    chan1 <- 0
    chan2 <- 0
}

func routine(ch chan int) {
    for {
        select {
        case x := <-ch:
            if x == 0 {
                return
            }
            fmt.Println(x)
        }
    }
}


output:

1
2

",38820997
222,36448282,"You can do,

p := result.(*Bar)
*p = data


The first line is a type assertion.

The second assigns data to the dereferenced pointer. Assigning a value to a dereferenced pointer changes the value at the referenced address. 

Since you don't know the underlying types of result or data the best you can do is using a type assertion switch.

switch v := data.(type) {
case Bar:
    // If 'data' is of type 'Bar'
    p, ok := result.(*Bar)
    if(!ok){
        // This means inputs were bad.
        // 'result' and 'data' should both have the same underlying type.
        fmt.Println(""underlying types mismatch"")
        break;
    }

    *p = v

case Baz:
    // If 'data' is of type 'Baz'
    // Equivalent of above for 'Baz'
}


See Type Switches from switch statement
",36446675
223,40986705,"syscall.Stat_t.Dev represents the ID of device on which the given file resides. So it's not internal to Go. You can find it using stat command like,

stat --format=%d 


See this thread for more about device numbers.
",40985556
224,42701856,"since you have full control on the writer, you could use a waitgroup
to wait in your main for all goroutines to finish.
",42701207
225,42738490,"Problem was solved by implementing a more robust Close() function. I also used defer Close() to make sure that Golang handled all the Goroutines internally.
",42701207
226,26972636,"A use case is when what you want is only the init function doing some initialization (for example registering themselves so that you don't have to explictely call them).

An exemple is the registring of some database drivers :

import (
    ""database/sql""
    _ ""github.com/ziutek/mymysql/godrv""
)

",26972615
227,26972661,"This is because of the init function


  each source file can define its own niladic init function to set up whatever state is required. (Actually each file can have multiple init functions.) 
  
  And finally means finally: init is called after all the variable declarations in the package have evaluated their initializers, and those are evaluated only after all the imported packages have been initialized. 


That is how the go-sqlite3 mentioned in ""What does an underscore in front of an import statement mean in Go"" works.

func init() {
    sql.Register(""sqlite3"", &SQLiteDriver{})
}


You have another example in ""Understanding Golang Packagese"":


  In some contexts, we may need to import a package only for invoking it’s init method, where we don’t need to call forth other methods of the package.
  If we imported a package and are not using the package identifier in the program, Go compiler will show an error.
  In such a situation, we can use a blank identifier ( _ ) as the package alias name, so the compiler ignores the error of not using the package identifier, but will still invoke the init function.

",26972615
228,26972898,"I was writing an image scaler. I wanted it to be able to read images in different formats like JPEG, PNG & GIF and output them in JPEG.

So in addition to the image and image/jpeg packages, I also had to import image/png and image/gif only to register their respective decoders.

Had I not imported those, the scaler would only be able to read JPEG images.

package main

import(
  ""image""
  ""image/jpeg"" // I wanted to export the images as JPEG
  _ ""image/png""
  _ ""image/gif""
)

// ...


The relevant documentation from the image package:


  Decoding any particular image format requires the prior registration of a decoder function. Registration is typically automatic as a side effect of initializing that format's package so that, to decode a PNG image, it suffices to have:

import _ ""image/png""


",26972615
229,39318297,"In Go, the character _ is a placeholder indicating that you don't care about the value. Therefore, you can do

var _, hasElement = myMap[key]


which will ignore the first return value.

This extends to functions with any number of return values:

var a, _, _, d, e, _ = bigFunction()

",39318255
230,43283541,"This is a common producer-consumer problem. Use channels to wait on the input from another routine. Does something like this help?

In this particular example, you would have to call go b(c) again after collecting the inputs as it terminates, but you could easily wrap whatever b does in an infinite for loop. Or whatever needs to happen.

Please note that in this example, and unbuffered channel is used, which forces both routines to meet at the same time to ""hand off"" the *Thing. If you want the producer (a's process) to not have to wait, you can use a buffered channel, which is created like so:

c := make(chan(*Thing, n))


Where n is the number of items the channel can store. This allows several to be queued by the producer.

https://play.golang.org/p/X14_QsSSU4

package main

import (
    ""fmt""
    ""time""
)

type Thing struct {
    N int
}

func a(t *Thing, c chan (*Thing)) {
    // stuff happens. whee
    c <- t
}

func b(c chan (*Thing)) {
    things := []*Thing{}
    for i := 0; i < 10; i++ {
        t := <-c
        things = append(things, t)
        fmt.Printf(""I have %d things\n"", i+1)
    }
    fmt.Println(""I now have 10 things! Let's roll!"")
    // do stuff with your ten things
}

func main() {
    fmt.Println(""Hello, playground"")
    c := make(chan (*Thing))

    go b(c)

    // this would probably be done producer-consumer like in a go-routine
    for i := 0; i < 10; i++ {
        a(&Thing{i}, c)
        time.Sleep(time.Second)
    }
    time.Sleep(time.Second)
    fmt.Println(""Program finished"")
}

",43283349
231,31728730,"For an interface value (like an error value) to compare equal to nil, both the actual contained value and the actual contained type have to be nil. In your case you have an interface value, which holds a nil pointer, but a *TestError (i.e. non-nil) type.

PS. Just in case it's not clear what are these ""interface values"", you can check this http://research.swtch.com/interfaces
",31728656
232,31728755,"In the second case you're printing the interface instances information which is the type and the value, type being (*main.TestError) value being (nil). In the first case what you're actually comparing isn't nil because it's also the interface.
",31728656
233,29842344,"For files with x at the end are relatively easy to detect. Just unzip it and read .rels/_rels file. It contains path to the main file in document. It denoted by namespace http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument. Just check its name. It's document.xml for docx, workbook.xml for xlsx and presentation.xml for pptx.

More info here can be found here ECMA-376.

Binary formats harder to detect. Basically you need to read MS-CFB filesystem and check for entries:


WordDocument for doc
Workbook or Book for xls
PowerPoint Document for ppt
EncryptedPackage means file is encrypted.

",29838185
234,29842508,"There's currently no way to extend http.DetectContentType as it uses a fixed, unexported slice of ""sniffers"": https://golang.org/src/net/http/sniff.go (sniffSignatures on line 49 at the time of writing).

Also, I looked quickly through godoc.org in search of a better package but didn't find any that is extensible and content-oriented as you require.

My advice would be: build your own package, guided by Go's content sniffer implementation (which follows https://mimesniff.spec.whatwg.org/).

Edit: If you're willing to use CGO and you're on nix, you could use libmagic bindings like for example https://github.com/jteeuwen/magic.
",29838185
235,30299131,"I found mimemagic, which I find preferable to magicmime since it doesn't use cgo. But magicmime is better at differentiating between application/zip and office file types.
",29838185
236,42648911,"The problem is that the C# code is using the Encoding.Unicode. In Go it should be:

package main

import (
    ""crypto/sha1""
    ""encoding/base64""
    ""encoding/binary""
    ""fmt""
    ""unicode/utf16""
)

func main() {
    s := ""fish123""
    salt := ""227EA7ABD26E40608A6EDEB209058D93A632D1D1A52246D0A27F6E447B16AEBF""

    h1 := sha1.New()
    h1.Write(convertUTF16ToLittleEndianBytes(salt))
    h1.Write(convertUTF16ToLittleEndianBytes(s))

    b64 := base64.StdEncoding.EncodeToString(h1.Sum(nil))
    fmt.Println(b64)
}

func convertUTF16ToLittleEndianBytes(s string) []byte {
    u := utf16.Encode([]rune(s))
    b := make([]byte, 2*len(u))
    for index, value := range u {
        binary.LittleEndian.PutUint16(b[index*2:], value)
    }
    return b
}


The convertUTF16ToLittleEndianBytes was taken from another response on SO.
",42647857
237,13214133,"Edit: since you meant GOPATH, see fasmat's answer (upvoted)

As mentioned in ""How do I make go find my package?"", you need to put a package xxx in a directory xxx.

See the Go language spec:

package math



  A set of files sharing the same PackageName form the implementation of a package.
  An implementation may require that all source files for a package inhabit the same directory.


The Code organization mentions:


  When building a program that imports the package ""widget"" the go command looks for src/pkg/widget inside the Go root, and then—if the package source isn't found there—it searches for src/widget inside each workspace in order.


(a ""workspace"" is a path entry in your GOPATH: that variable can reference multiple paths for your 'src, bin, pkg' to be)



(Original answer)

You also should set GOPATH to ~/go, not GOROOT, as illustrated in ""How to Write Go Code"".


  The Go path is used to resolve import statements. It is implemented by and documented in the go/build package.
  
  The GOPATH environment variable lists places to look for Go code.
  On Unix, the value is a colon-separated string.
  On Windows, the value is a semicolon-separated string.
  On Plan 9, the value is a list. 


That is different from GOROOT:


  The Go binary distributions assume they will be installed in /usr/local/go (or c:\Go under Windows), but it is possible to install them in a different location.
  If you do this, you will need to set the GOROOT environment variable to that directory when using the Go tools. 

",13214029
238,13217263,"Have you tried adding the absolute directory of go to your 'path'?

export PATH=$PATH:/directory/to/go/

",13214029
239,13223578,"It does not work because your foobar.go source file is not in a directory called foobar. go build and go install try to match directories, not source files.


Set $GOPATH to a valid directory, e.g. export GOPATH=""$HOME/go""
Move foobar.go to $GOPATH/src/foobar/foobar.go and building should work just fine.


Additional recommended steps:


Add $GOPATH/bin to your $PATH by: PATH=""$GOPATH/bin:$PATH""
Move main.go to a subfolder of $GOPATH/src, e.g. $GOPATH/src/test
go install test should now create an executable in $GOPATH/bin that can be called by typing test into your terminal.

",13214029
240,31753324,"You cannot. In Go all interface implementations are implicit. You can check if a type implements and interface (the most explicit it gets). If I recall correctly in a project I worked in it just did some type asserts at the top of the package against the interfaces which the type implemented, as close to explicit as it gets. 
",31753282
241,31753338,"Method 2 is the correct one, method 1 you're just embedding a type and overriding its function. If you forget to override it, you will end up with a nil pointer dereference.
",31753282
242,31757646,"I have rarely needed to declare this, because there is almost always somewhere in my package where I am using the struct as the interface. I tend to follow the pattern of keeping my structs unexposed where possible, and providing them only through ""constructor"" functions.

type Foo interface{
  Foo()
}

type bar struct {}
func (b *bar)Foo() {}

func NewBar() Foo{
  return &bar{}
}


If bar does not satisfy Foo, this will not compile. Rather than add constructs to declare that the type implements the interface, I just make sure that my code uses it as the interface at some point.
",31753282
243,15825149,"To the best of my knowledge there is no such verb (as the format specifiers are called in the fmt package) for this task. What you can do however, is specifying some verb and ignoring its value. This is not particularly memory friendly, though. Ideally this would work:

fmt.Scan(&a, _, &b)


Sadly, it doesn't. So your next best option would be to declare the variables and ignore the one
you don't want:

var a,b,c int
fmt.Scanf(""%d %v %d"", &a, &b, &c)
fmt.Println(a,c)


%v would read a space separated token. Depending on what you're scanning on, you may fast forward the
stream to the position you need to scan on. See this answer 
for details on seeking in buffers. If you're using stdio or you don't know which length your input may
have, you seem to be out of luck here.


  It doesn't indicate that %* is not implemented, so... Am I doing it
  wrong? Or has it just been quietly omitted? ...but then, why does it
  compile?


It compiles because for the compiler a format string is just a string like any other. The content of that string is evaluated at run time by functions of the fmt package. Some C compilers may check format strings
for correctness, but this is a feature, not the norm. With go, the go vet command will try to warn you about format string errors with mismatched arguments.

Edit:

For the special case of needing to parse a row of integers and just caring for some of them, you
can use fmt.Scan in combination with a slice of integers. The following example reads 3 integers 
from stdin and stores them in the slice named vals:

ints := make([]interface{}, 3)
vals := make([]int, len(ints))

for i, _ := range ints {
    ints[i] = interface{}(&vals[i])
}

fmt.Scan(ints...)
fmt.Println(vals)


This is probably shorter than the conventional split/trim/strconv chain. It makes a slice of pointers
which each points to a value in vals. fmt.Scan then fills these pointers. With this you can even
ignore most of the values by assigning the same pointer over and over for the values you don't want:

ignored := 0

for i, _ := range ints {
    if(i == 0 || i == 2) {
        ints[i] = interface{}(&vals[i])
    } else {
        ints[i] = interface{}(&ignored)
    }
}


The example above would assign the address of ignore to all values except the first and the second, thus
effectively ignoring them by overwriting.
",15825007
244,12369689,"Reading from stdin using os.Stdin should work as expected:

package main

import ""os""
import ""log""
import ""io/ioutil""

func main() {
    bytes, err := ioutil.ReadAll(os.Stdin)

    log.Println(err, string(bytes))
}


Executing echo test stdin | go run stdin.go should print 'test stdin' just fine.

It would help if you'd attach the code you used to identify the problem you encountered.

For line based reading you can use bufio.Scanner:

import ""os""
import ""log""
import ""bufio""

func main() {
    s := bufio.NewScanner(os.Stdin)
    for s.Scan() {
        log.Println(""line"", s.Text())
    }
}

",12363030
245,12384207,"I think your question per se has no sensible answer because there's just no such thing as ""initial stdin"".  Unix-like OSs, and Windows implement the concept of ""standard streams"", which works like this (simplified): when a process is created, it automagically has three file descriptors (handles in Windows) open — stdin, stdout and stderr.  No doubts, you're familiar with this concept, but I'd like to stress the meaning of the word ""stream"" there — in your example, when you call

$ echo 'test stdin' | ./stdin


the shell creates a pipe, spawns two processes (one for echo and one for your binary) and makes use of the pipe it created: the pipe's write FD is attached to the echo's stdout and the pipe's read FD is attached to your binary's stdin.  Then whatever the echo process pleases to write to its stdout is piped (sic!) to the stdin of your process.
(In reality most today's shells implement echo as a built-in primitive but this does not in any way change the semantics; your could as well have tried /bin/echo instead, which is a real program.  Also note that I just used ./stdin to refer to your program — this is for clarity, as go run stdin.go would do exactly this, in the end.)

Note several crucial things here:


The writing process (echo in your case) is not oblidged to write anything to its stdout (for instance, echo -n would not write anything to its stdout and exit successfully).
It's also able to make arbitrary delays writing its data (either because it wants to make such delays or because it has been preempted by the OS or sleeps in some syscall waiting on some busy system resource etc).
The OS buffers transfers over pipes.  This means what the writing process sends to a pipe, might come out in arbitrary chunks on the reading side.1
There are only two ways to know the writing side has no more data to send over the pipe:


Somehow encode this in the data itself (this means using an agreed upon data transfer protocol between the writer and the reader).
The writer might close its side of the pipe which would result in the ""end of file"" condition on the reader side (but only after the buffer is drained and one another call to read is attempted, which fails).



Let's wrap this up: the behaviour you're observing is correct and normal.  If you expect to get any data from stdin, you must not expect it to be readily available.  If you also don't want to block on stdin, then create a goroutine which would do blocking reads from stdin in an endless loop (but checking for the EOF condition) and pass collected data up over a channel (possibly after certain processing, if needed).

1 This is why certain tools which usually occur between two pipes in a pipeline, such as grep, might have special options to make them flush their stdout after writing each line — read about the --line-buffered option in the grep manual page for one example.  People who are not aware of this ""full buffering by default"" semantics are puzzled why tail -f /path/to/some/file.log | grep whatever | sed ... seems to stall and not display anything when it's obvious the monitored file gets updated.



As a side note: if you were to run your binary ""as is"", like in

$ ./stdin


that would not meant the spawned process would not have stdin (or ""initial stdin"" or whaveter), instead, its stdin would be connected to the same stream your shell receives your keyboard import from (so you could directly type something to your process's stdin).

The only sure way to have a process's stdin connected to nowhere is to use

$ ./stdin </dev/null


on Unix-like OSes and

C:\> stdin <NUL


on Windows.  This ""null device"" makes the process see EOF on the first read from its stdin.
",12363030
246,16753808,"You can't check stdin for content, but you can check if stdin is associated with a terminal or a pipe. IsTerminal just takes the standard unix fd numbers (0,1,2). The syscall package has variables assigned so you can do syscall.Stdin if you prefer naming them.

package main

import (
    ""code.google.com/p/go.crypto/ssh/terminal""
    ""fmt""
    ""io/ioutil""
    ""os""
)

func main() {
    if ! terminal.IsTerminal(0) {
        b, _ := ioutil.ReadAll(os.Stdin)
        fmt.Print(string(b))
    } else {
        fmt.Println(""no piped data"")
    }
}

",12363030
247,37980397,"There's no way to shut down idle HTTP/1.1 or HTTP2 connections. There is a an open issue at https://golang.org/issue/9478, but no immediate plans for it. Note that once you close your listener, your server will not accept new connections; you're reusing the same connection.

If you want to forcefully close all connections, you would need to do the bookkeeping yourself using the http.Server ConnState to track the TCP connections that are active.

You could also have your handlers set Connection: close on each response, but that would make your http server much less efficient if clients ever need to make more than 1 request. 
",37979111
248,37501333,"If you are dealing with binary files like docx and pdf, you're best off storing the metadata in seperate files or in a sqlite file.

Metadata is usually stored seperate from files, in data structures called inodes (at least in Unix systems, Windows probably has something similar). But you probably don't want to get that deep into the rabbit hole.

If your goal is to query the system based on metadata, then it would be easier and more efficient to use something SQLite. Having the meta data in the file would mean that you would need to open the file, read it into memory from disk, and then check the meta data - i.e slower queries.

If you don't need to query based on metadata, then storing metadata in the file might make sense. It would reduce the dependencies in your application, but in order to access the contents of the file through Word or Adobe Reader, you'd need to strip the metadata before handing it off to the application. Not worth the hassle, usually
",37500810
249,37502101,"Metadata you wish to add is best kept in a separate file or database for all files.

Or in another file with same name and different extension or prefix, that you can make hidden.

Relying on a file system is very tricky and your data will be bound by the restrictions and capabilities of the file system your file is stored on.
And, you cannot count on your data remaining intact as any application may wish to change these flags.

And some of those have very specific, clearly defined use, such as creation time, modification time, access time...

See, if you need only flagging the document, you may wish to use creation time, which will stay unchanged through out the live of this document (until is copied) to store your flags. :D

Very dirty business, unprofessional, unreliable and all that.

But it's a solution. Poor one, but exists.

I do not know that FAT32 or NTFS file systems support any extra bits for flagging except those already used by the OS.
Unixes EXT family FS's do support some extra bits. And even than you should be careful in case some other important application makes use of them for something.

Mac OS may support some metadata by itself, but I am not 100% sure.

On Windows, you have one more option to associate more data with a file, but I wouldn't use that as well.

Well, NTFS file system (FAT doesn't support that) has a feature called streams.

In essential, same file can have multiple data streams under itself. I.e. You have more than one file contents under same file node.


To be more clear. Same file contains two different files.

When you open the file normally only main stream is visible to the application. Applications must check whether the other streams are present and choose the one they want to follow.

So, you may choose to store metadata under the second stream of the file.

But, what if all streams are taken?

Even more, anti-virus programs may prevent you access to the metadata out of paranoya, or at least ask for a permission.
I don't know why MS included that option, probably for file duplication or something, but bad hackers made use of the fact that you can store some data, under existing regular file, that nobody is aware of.

Imagine a virus writing it's copy into another stream of one of programs already there.

All that is needed for it to start, instead of your old program next time you run it is a batch script added to task scheduler that flips two streams making the virus data the main one.

Nasty trick! So when this feature started to be abused, anti-virus software started restricting files with multiple streams, so it's like this feature doesn't exist.

If you want to add some metadata using OS's technology, use Windows registry,
but even that is unwise.

What to tell you?
Don't add metadata to files, organize a separate file, or index your data in special files with same name as the file you are refering to and in same folder.
",37500810
250,34684299,"The Group function  of IRouter is a variadic function. It means it can be called with any number of trailing arguments, of type HandlerFunc. 

Another example of this type of function in go is fmt.Println:

Its signature is:


func Println(a ...interface{}) (n int, err error)


so you can invoke it with a variable number of arguments:


fmt.Println(1, 2)
fmt.Println(""a"" , ""b"" , ""C"")

",34684265
251,34684432,"The block you see in { ... } is just that, a code block, not an argument to anything. The Group method is variadic, and could accept any number of HandlerFunc arguments, but nothing is passed in here. 

Since Go is block scoped, you can use blocks to create a limited variable scope. Since there are no declarations within the blocks, I see no use for this pattern here other than to cause the HandlerFunc assignments to be indented as a group for style reasons. 

An example showing the scope of a code block:

http://play.golang.org/p/Kgpw1zCC7X

x := 42

{
    x := 3
    y := 4
    fmt.Println(""x inside block:"", x) // prints 3
}

fmt.Println(""x outside block:"", x) // prints 42
// fmt.Println(y) // undefined: y

",34684265
252,38477962,"Your map initialization is correct.
You just need to explicitly declare the type of your map element:

m:= make(map [string][2]int)
m[""test""] = [2]int{1,3}
fmt.Println(m)


This approach work if you don't need to access underlying elements.

If you need this, you have to use pointers:

package main

import (
    ""fmt""
)

func main() {
    fmt.Println(""Hello, playground"")
    m := make(map[string]*[2]int)
    m[""hi""] = &[2]int{2, 3}
    m[""heello""] = &[2]int{0, 1}
    m[""hi""][0] = m[""hi""][0] + 1
    // commented out. Initialize it first
    //m[""h""][1]=m[""h""][1]+1
    fmt.Println(m) // 2 address
    fmt.Println(m[""hi""], m[""heello""])
}

",38477567
253,38478089,"You need to have a map of pointers to array if you want to be able to assign values to array indices. Check out this code (you need to initiate all map keys before using them as array though).

package main

import (
    ""fmt""
)

func Assign(m map[string]*[2]int, key string, index int, value int) {
    if _, ok := m[key]; !ok {
        m[key] = &[2]int{}
    }

    m[key][index] = value
}

func main() {
    fmt.Println(""Hello, playground"")

    m := make(map[string]*[2]int)

    m[""hi""] = &[2]int{2, 3}
    m[""h""] = &[2]int{4, 5}

    //existing key
    Assign(m, ""h"", 1, 4)
    //new key
    Assign(m, ""howdy"", 1, 3)

    fmt.Println(m[""hi""])
    fmt.Println(m[""h""])
    fmt.Println(m[""howdy""])

}

",38477567
254,38478120,"See this issue: https://github.com/golang/go/issues/3117

package main

import (
    ""fmt""
)

func main() {
    fmt.Println(""Hello, playground"")
    m := make(map[string][2]int)

    m[""hi""] = [2]int{2, 3}

    m[""heello""] = [2]int{}

    var tmp = m[""heello""]
    tmp[1] = 1
    m[""heello""] = tmp

    fmt.Println(m)
}

",38477567
255,23466699,"You can define a function. Take a look http://golang.org/pkg/text/template/#example_Template_func.

Edit:
See it at the playground: http://play.golang.org/p/OP2x5vDCtn
",23466497
256,23466932,"Update: Now the code below is unicode compliant for those who are working with international programs. 

One thing to note is that bytes.Runes(""string"") below is an O(N) operation, as is the converstion from runes to a string, so this code loops over the string twice. It is likely to be more efficient to do the code below for PreviewContent()

func (c ContentHolder) PreviewContent() string {
    var numRunes = 0
    for index, _ := range c.Content {
         numRunes++
         if numRunes > 25 {
              return c.Content[:index]
         }
    }
    return c.Content
}


You have a couple options for where this function can go. Assuming that you have some type of content holder, the below can be used:

type ContentHolder struct {
    Content string
    //other fields here
}

func (c ContentHolder) PreviewContent() string {
    // This cast is O(N)
    runes := bytes.Runes([]byte(c.Content))
    if len(runes) > 25 {
         return string(runes[:25])
    }
    return string(runes)
}


Then your template will look like this:

{{ range .SomeContent }}
....
{{ .PreviewContent }}
....
{{ end }}


The other option is to create a function that will take then first 25 characters of a string. The code for that looks like this (revision of code by @Martin DrLík, link to code)

package main
import (
    ""html/template""
    ""log""
    ""os""
)

func main() {

    funcMap := template.FuncMap{

        // Now unicode compliant
        ""truncate"": func(s string) string {
             var numRunes = 0
             for index, _ := range s {
                 numRunes++
                 if numRunes > 25 {
                      return s[:index]
                 }
            }
            return s
       },
    }

    const templateText = `
    Start of text
    {{ range .}}
    Entry: {{.}}
    Truncated entry: {{truncate .}}
    {{end}}
    End of Text
    `
    infoForTemplate := []string{
        ""Stackoverflow is incredibly awesome"",
        ""Lorem ipsum dolor imet"",
        ""Some more example text to prove a point about truncation"",
        ""ПриветМирПриветМирПриветМирПриветМирПриветМирПриветМир"",
    }

    tmpl, err := template.New("""").Funcs(funcMap).Parse(templateText)
    if err != nil {
        log.Fatalf(""parsing: %s"", err)
    }

    err = tmpl.Execute(os.Stdout, infoForTemplate)
    if err != nil {
        log.Fatalf(""execution: %s"", err)
    }

}


This outputs:

Start of text

Entry: Stackoverflow is incredibly awesome
Truncated entry: Stackoverflow is incredib

Entry: Lorem ipsum dolor imet
Truncated entry: Lorem ipsum dolor imet

Entry: Some more example text to prove a point about truncation
Truncated entry: Some more example text to

Entry: ПриветМирПриветМирПриветМирПриветМирПриветМирПриветМир
Truncated entry: ПриветМирПриветМирПриветМ

End of Text

",23466497
257,26108865,"Needs more magic for Unicode strings

This is not correct, see below

import ""unicode/utf8""

func Short( s string, i int) string {
    if len( s ) < i {
        return s
    }
    if utf8.ValidString( s[:i] ) {
        return s[:i]
    }
    // The omission.
    // In reality, a rune can have 1-4 bytes width (not 1 or 2)
    return s[:i+1] // or i-1
}


But i above is not the number of chars. It's the number of bytes. Link to this code on play.golang.org

I hope this helps.



Edit

Updated: check string length. See @geoff comment below

See that answer, and play here. It's another solution.

package main

import ""fmt""

func Short( s string, i int ) string {
    runes := []rune( s )
    if len( runes ) > i {
        return string( runes[:i] )
    }
    return s
}

func main() {
    fmt.Println( Short( ""Hello World"", 5 ) )
    fmt.Println( Short( ""Привет Мир"", 5 ) )
}




But if you are interested in the length in bytes:

func truncateStrings(s string, n int) string {
    if len(s) <= n {
        return s
    }
    for !utf8.ValidString(s[:n]) {
        n--
    }
    return s[:n]
}


play.golang.org. This function never panics (if n >= 0), but you can obtain an empty string play.golang.org



Also, keep in mind this experimental package golang.org/x/exp/utf8string


  Package utf8string provides an efficient way to index strings by rune rather than by byte.

",23466497
258,36093426,"You can use printf in templates, which acts as fmt.Sprintf. In your case truncating a string would be as easy as:

""{{ printf \""%.25s\"" .Content }}""

",23466497
259,33691694,"Using the information provided in the above comments, here is a working example on how to tunnel HTTP requests through a SOCKS proxy:

package main

import (
    ""fmt""
    ""io/ioutil""
    ""net""
    ""net/http""
    ""time""

    ""golang.org/x/net/proxy""
)

func main() {
    url := ""https://example.com""
    socksAddress := ""localhost:9998""

    socks, err := proxy.SOCKS5(""tcp"", socksAddress, nil, &net.Dialer{
        Timeout:   30 * time.Second,
        KeepAlive: 30 * time.Second,
    })
    if err != nil {
        panic(err)
    }

    client := &http.Client{
        Transport: &http.Transport{
            Dial:                socks.Dial,
            TLSHandshakeTimeout: 10 * time.Second,
        },
    }

    res, err := client.Get(url)
    if err != nil {
        panic(err)
    }
    content, err := ioutil.ReadAll(res.Body)
    res.Body.Close()
    if err != nil {
        panic(err)
    }
    fmt.Printf(""%s"", string(content))
}

",33681662
260,38610258,"You are not importing routers package. If you don't import routers in anywhere, the init function will never be executed. You can test it adding a simple fmt.Println('I'm initialized') in routers.init function.

func init() {
     fmt.Println('I'm initialized')
     beego.Router(""/"", &controllers.MainController{})
}


Ok, you must add a new import with _ to say that you won't use, but, the init function will be executed! Then you must write this in main package:

import (
        ""fmt""
        ""github.com/astaxie/beego""

        _ ""example/routers""
)


I hope that it is useful! :-)
",38601959
261,38048643,"There's a bunch of things going on, I can't spot the bug right away but these things will help:


Try to use bufio.Writer as much as possible if you are calling file.WriteString, otherwise every single write will be a syscall, hurting performance.
You don't need to use select in you startAccessLog function:

func startAcessLog() {
  for ctx := <-logCtxCh {
      handleAccessLog(ctx)
  }
}

Change your error checks from:

if err != nil {
  fmt.Errorf(err.Error())
}


to:

if err != nil {
  fmt.Println(err)
}


otherwise you are not printing errors. fmt.Errorf formats a string, like fmt.Sprintf does and returns it as an error. It doesn't print anything at all.
You should guard accessLog with a sync.Mutex or write to it via a channel. Why? Because there's more than one goroutine trying to work with accessLog and you don't want data races to happen.
Doing it via a channel would simplify your writeLog function a log. Currently it's hard to follow the logic. I initially thought you weren't properly closing the file.

",38045375
262,32706023,"Let's review the hierarchy.


At the top level, you map country names to country objects.
Each country object maps area names to area objects.
Each area object maps town names to town objects.


In Go, you can implement each level of the hierarchy as a map[string]*Something, with the last level consisting of Town objects that contain various information about towns:

type Country map[string]*Area

type Area map[string]*Town

type Town struct {
    Name                string
    Population          int
    Latitude, Longitude float64
}


The sample hierarchy that you've given in your question would then look like this:

countries := map[string]*Country{
    ""country1"": &Country{
        ""area1"": &Area{
            ""town1"": &Town{},
            ""town2"": &Town{},
        },
        ""area2"": &Area{
            ""town3"": &Town{},
        },
    },
}


If you don't want to map to concrete types, you can use map[string]interface{}, but then you'll need type assertions to work with the values. Here is a code sample taken from Zack Bloom's article on Go and JSON:

var parsed map[string]interface{}
data := []byte(`
    {
        ""id"": ""k34rAT4"",
        ""age"": 24
    }
`)
err := json.Unmarshal(data, &parsed)
idString := parsed[""id""].(string)

",32705948
263,32706212,"If you're going to have arbitrary depth, then it might be worth it to create a default struct that can be nested:

type area struct {
    Name string
    //Any other area info
    Sections []*area
}


Slices of pointers aren't initialized when creating a new struct object, so it's a valid construct.  Declare a.Sections = new([]*area) and append area pointers to it.  You will have len(a.Sections) or a for range loop for use in the tree traversal.  

Parsing and traversal would be coded recursively, so you would need a type identifier if you treat different areas in different ways.
",32705948
264,11003888,"Having all but an error interface is enough to perform a type assertion or a type switch to reveal the concrete type held by the interface.
",11003692
265,11004221,"The broken pipe error is defined in the syscall package. You can use the equality operator to compare the error to the one in syscall. Check http://golang.org/pkg/syscall/#constants for a complete list of syscall errors. Search ""EPIPE"" on the page and you will find all the defined errors grouped together. 

if err == syscall.EPIPE {
    /* ignore */
}


If you wish to get the actual errno number (although it is pretty useless) you can use a type assertion:

if e, ok := err.(syscall.Errno); ok {
    errno = uintptr(e)
}

",11003692
266,34548166,"What about something like this ?

//main.go
package main

import (
    ""NovAPI/routes""
    ""fmt""
    ""github.com/gorilla/mux""
    ""net/http""
)

func main() {

    router := mux.NewRouter().StrictSlash(true)

    router.HandleFunc(""/hello"", HelloHandler)
    router.HandleFunc(""/user"", UserHandler)
    router.HandleFunc(""/route2"", Route2Handler)
    router.HandleFunc(""/route3"", Route3Handler)
    // route declarations continue like this

    http.ListenAndServe("":1128"", router)

}

func HelloHandler(res http.ResponseWriter, req *http.Request) {
    fmt.Fprintln(res, ""Hello"")
}

func UserHandler(res http.ResponseWriter, req *http.Request) {
    fmt.Fprintln(res, ""User"")
}

func Route2Handler(res http.ResponseWriter, req *http.Request) {
    fmt.Fprintln(res, ""Route2"")
}

func Route3Handler(res http.ResponseWriter, req *http.Request) {
    fmt.Fprintln(res, ""Route3"")
}


That way you can put your handlers in other files, or even other packages.

If you endup with additionnal dependencies like a database, you can even avoid the need of the global var using a constructor trick:

//main.go

func main() {
    db := sql.Open(…)

    //...

    router.HandleFunc(""/hello"", NewHelloHandler(db))

    //...
}

func NewHelloHandler(db *sql.DB) func(http.ResponseWriter, *http.Request) {
    return func(res http.ResponseWriter, req *http.Request) {
        // db is in the local scope, and you can even inject it to test your
        // handler
        fmt.Fprintln(res, ""Hello"")
    }
}

",34548039
267,34548687,"I like checking out other projects in github to grab ideas on how to do stuff, and for these cases I usually take a look first at the Docker repo. This is the way they do it:

For the system's routes, define all handlers in system_routes.go and then initialize those routes on a NewRouter function in system.go.

type systemRouter struct {
    backend Backend
    routes  []router.Route
}

func NewRouter(b Backend) router.Router {
    r := &systemRouter{
        backend: b,
    }

    r.routes = []router.Route{
        local.NewOptionsRoute(""/"", optionsHandler),
        local.NewGetRoute(""/_ping"", pingHandler),
        local.NewGetRoute(""/events"", r.getEvents),
        local.NewGetRoute(""/info"", r.getInfo),
        local.NewGetRoute(""/version"", r.getVersion),
        local.NewPostRoute(""/auth"", r.postAuth),
    }

    return r
}

// Routes return all the API routes dedicated to the docker system.
func (s *systemRouter) Routes() []router.Route {
    return s.routes
}


Notice that systemRouter implements the router.Router interface and the Routes function returns a []router.Route, and their handlers are defined as

func(ctx context.Context, w http.ResponseWriter, r *http.Request, vars map[string]string) error


instead of Go's standard http handler:

func(w http.ResponseWriter, r *http.Request)


So there's extra code of theirs to convert a Docker API Handler to a Go HTTP Handler at the makeHttpHandler function.

And finally, to add those routes to their mux router, on their server.go they implement several other functions to add middleware to their handlers.

If this is something that you think it's what you are looking for, then take your time to analyze the Docker code for their routes, and if you need me to elaborate more or if I missed anything, post a comment. 
",34548039
268,44256618,"The json you have posted in your example looks like it is missing F1 in the body?

https://play.golang.org/p/Fl-lhH2y3X


b := []byte(`{""F1"":{""Val"":13}}`)

",44256484
269,19951928,"A friend wrote a simple Compile Daemon for go, worked like a charm for my own small net/http-projects.

You can find the repository here: https://github.com/githubnemo/CompileDaemon
",19605076
270,28629255,"You can also try out Gin by Codegangsta. It's fire and forget.

https://github.com/codegangsta/gin

EDIT:
I prefer CompileDaemon nowadays. Gin sometimes won't accept requests
",19605076
271,35906676,"All function arguments are passed by value in Go. A function cannot change the caller's value.

The slice (length, capacity, pointer) is passed by value to the append function. Because append cannot change the caller's slice, the append function returns the new slice.

The append function could be written to take a pointer to a slice, but that would make append awkward to use in the many situations where slice values are not addressable.
",35906405
272,18939646,"No, you cannot use your proposed syntax (though it would be nice).

One way is to line up column names and values:

INSERT INTO `table` 
(`column`, `column2`,...) 
VALUES
('value1', 'value2'...);


Update in response to your comment ""the statements contain variables from outside the string"": if you parameterise your SQL statements then matching up column names to variables is easy to check if the parameters are named for their respective columns: @ColumnName.

This is actually how I do it in my TSQL scripts:

INSERT INTO `table` 
(
    `column`, 
    `column2`,
    ...
) 
VALUES
(
    'value1', 
    'value2',
    ...
);


(It's also common to put the commas at the start of the lines)

but to be honest, once you get enough columns it is easy to mix up the position of columns. And if they have the same type (and similar range of values) you might not notice straight away....
",18939631
273,18951854,"When you use Golang database/sql package, the work connecting to the database is carry out by your chosen SQL driver such as http://github.com/ziutek/mymysql or https://github.com/Go-SQL-Driver/MySQL/. 

When you use an SQL statement in function such as Query() or Exec(), almost all driver will pass your SQL statement as it is to the database engine. MySQL implements the standard SQL INSERT syntax, and does not support your proposed syntax. Thus you can not use your proposed syntax with existing Golang MySQL drivers and MySQL database.

Thus your solution if you want to use your syntax is to:


find an SQL database that supports your proposed non-standard syntax, and there is none that I'm aware.
or write your own Golang MySQL driver to parse and convert your proposed syntax to the standard INSERT syntax before sending it to MySQL database.
or write a database/sql extension (similar to https://github.com/jmoiron/sqlx) that supports your proposed syntax.

",18939631
274,27281673,"I solved my issue like this - 

{
    {{ $temp := .schema.Id }}
    {{if .Input}} func (c *Container) {{$key }}(input *{{.Input}}) *{{$temp}}{} {{else}} func (c *Container) {{$key}}() *{{$temp}}{}{{end}}
}


This works fine in GO templates. 
",27280158
275,38892450,"Firstly, you're dividing by the wrong number. If you want the numbers only up to 8, you need to divide by 8.

Secondly, you don't need to subtract one in the second string, but you do need to decrease the n.

func ToString(n int8) string {
    n--
    return string((n/8)+65) + string((n%8)+49)
}

func main() {
    var i int8
    for i = 1; i <= 64; i++ {
        fmt.Println(ToString(i))
    }
}


https://play.golang.org/p/BdAce3C5JL
",38892197
276,38893496,"Let's see different approaches and performance improvements.

All the solutions and the benchmarking code can be found on the Go Playground. The code on the Playground is a test file, not an executable. You have to save it into a file named XX_test.go and run it with go test -bench ..

String concatenation

Ainar-G's answer is cool (+1):

func ToStringConcat(n byte) string {
    n--
    return string((n/8)+65) + string((n%8)+49)
}


Byte slice

But note that the previous solution concatenates 2 string values which is ""costly"" especially if we want to call this ToString() many times.

One might think that we could spare the string concatenation if we would try to convert a single integer number containing the 2 codes (the first shifted left by 8 bits), but that wouldn't work as converting integer numbers to string results in a string value with a single rune (a string containing the UTF-8 representation of the integer).

But we may use a []byte with 2 values (the letter code and the digit code), and then we only need to convert this single slice value to string:

func ToStringSlice(n byte) string {
    n--
    return string([]byte{(n / 8) + 65, (n % 8) + 49})
}


String constant and slicing

string values are slicable in Go which results in a new string (new string header). So we may use a string constant of all the values, and do a simple slicing to get the part we need:

const values = ""  A1A2A3A4A5A6A7A8B1B2B3B4B5B6B7B8C1C2C3C4C5C6C7C8D1D2D3D4D5D6D7D8E1E2E3E4E5E6E7E8F1F2F3F4F5F6F7F8G1G2G3G4G5G6G7G8H1H2H3H4H5H6H7H8""

func ToStringConst(n byte) string {
    n *= 2
    return values[n : n+2]
}


Dictionary

Even though slicing a string results in a substring which shares the underlying array, it sill needs to create a new string header.

Since we don't have a lot of possible values, best (fastest) solution is to prepare all the possible values, and just do a simple lookup. Since input is a number, we don't even need a map, we can use a simple []string slice:

var dict = []string{"""",
    ""A1"", ""A2"", ""A3"", ""A4"", ""A5"", ""A6"", ""A7"", ""A8"",
    ""B1"", ""B2"", ""B3"", ""B4"", ""B5"", ""B6"", ""B7"", ""B8"",
    ""C1"", ""C2"", ""C3"", ""C4"", ""C5"", ""C6"", ""C7"", ""C8"",
    ""D1"", ""D2"", ""D3"", ""D4"", ""D5"", ""D6"", ""D7"", ""D8"",
    ""E1"", ""E2"", ""E3"", ""E4"", ""E5"", ""E6"", ""E7"", ""E8"",
    ""F1"", ""F2"", ""F3"", ""F4"", ""F5"", ""F6"", ""F7"", ""F8"",
    ""G1"", ""G2"", ""G3"", ""G4"", ""G5"", ""G6"", ""G7"", ""G8"",
    ""H1"", ""H2"", ""H3"", ""H4"", ""H5"", ""H6"", ""H7"", ""H8"",
}

func ToStringDict(n byte) string {
    return dict[n]
}


Speed analysis (benchmark)

Let's benchmark speed of the above solutions:

func BenchmarkConcat(b *testing.B) {
    for i := 0; i < b.N; i++ { ToStringConcat(1) }
}

func BenchmarkSlice(b *testing.B) {
    for i := 0; i < b.N; i++ { ToStringSlice(1) }
}

func BenchmarkConst(b *testing.B) {
    for i := 0; i < b.N; i++ { ToStringConst(1) }
}

func BenchmarkDict(b *testing.B) {
    for i := 0; i < b.N; i++ { ToStringDict(1) }
}


Result:

BenchmarkConcat-4       20000000               106 ns/op
BenchmarkSlice-4        100000000               17.0 ns/op
BenchmarkConst-4        2000000000               1.34 ns/op
BenchmarkDict-4         2000000000               1.04 ns/op


Just by jumping from concatenation to slice conversion, it immediately becomes 6 times faster.

Utilizing string slicing, we again make it 12 times faster.

And pre-building all possible values and just doing a simple lookup, we further gain 22%.

Comparing the final to the initial: the dictionary lookup is a hundred times faster than the original concatenation.

Using fmt

For completeness, here's a solution using the fmt package:

func ToStringFmt(n byte) string {
    n--
    return fmt.Sprintf(""%c%c"", (n/8)+65, (n%8)+49)
}


But this one is slower by almost 2.5 times even than our slowest String concatenation solution, as this has to wrap arguments into interface{} values, create and put them into a slice (for the vararg), has to parse and analyze a format string, use reflection to process arguments, build the string representation in a buffer which finally is used to produce the returned string value. A lot of things happen which are for the ""general"" case and are not required for our ""special"" case.
",38892197
277,31409281,"When making connections at a high rate over the internet, it's very likely you're going to encounter some connection problems. You can't mitigate them completely, so you may want to add retry logic around the request. The actual error type at this point probably doesn't matter, but matching the error string for use of closed network connection or connection reset by peer is about the best you can do if you want to be specific. Make sure to limit the retries with a backoff, as some systems will drop or reset connections as a way to limit request rates, and you may get more errors the faster you reconnect.

Depending on the number of remote hosts you're communicating with, you will want to increase Transport.MaxIdleConnsPerHost (the default is only 2). The fewer hosts you talk to, the higher you can set this. This will decrease the number of new connections made, and speed up the requests overall.

If you can, try the go1.5 beta. There have been a couple changes around keep-alive connections that may help reduce the number of errors you see.
",31385487
278,31411754,"I recommend implementing an exponential back off or some other rate limiting mechanism on your side of the wire. There's not really anything you can do about those error, and using exponential back off won't necessarily make you get the data any faster either. But it can ensure that you get all the data and the API you're pulling from will surely appreciate the reduced traffic. Here's a link to one I found on GitHub; https://github.com/cenkalti/backoff

There was another popular option as well though I haven't used either. Implementing one yourself isn't terribly difficult either and I could provide some sample of that on request. One thing I do recommend based off my experience is make sure you're using a retry function that has an abort channel. If you get to really long back off times then you'll want some way for the caller to kill it.
",31385487
279,42379118,"Use omitempty flag for when your ""anleitung"" is empty in JSON to be consumed. Beware though, when that is the case, your Jailbreak struct won't have an ""anleitung"" field.

Change your map's json flag to to;

Anleitung   map[string]struct {
    Name string `json:""blog""`
    Link string `json:""link""`
} `json:""anleitung,omitempty""`


Option 2;

I guess you could also use Anleitung   map[string]interface{} but that is better for ""holding a map of strings to arbitrary data types"". In your case the data is not arbitrary but rather, empty I guess. And looks like that is just temporary. 

I'd go for option 1, then I'd check if my struct contains any Anleitung data or not before accessing it.
",42378878
280,42383863,"The json provided is not valid (as the array does not have a closing ] and the top level json object lacks another closing }) so let's assume it's like:

{
  ""jailbreaks"": [
    {
      ""jailbroken"": false,
      ""name"": """",
      ""version"": """",
      ""url"": """",
      ""anleitung"": [],
      ""ios"": {
        ""start"": ""10.2.1"",
        ""end"": """"
      },
      ""platforms"": [],
      ""caveats"": """"
    },
    {
      ""jailbroken"": true,
      ""name"": ""Yalu102"",
      ""version"": ""beta 6"",
      ""url"": ""https://domain-dl.tld"",
      ""anleitung"": [
        {
          ""blog"": ""title"",
          ""link"": ""http://domain.tld/""
        },
        {
          ""blog"": ""Test"",
          ""link"": ""http://google.at""
        }
      ],
      ""ios"": {
        ""start"": ""10.2"",
        ""end"": """"
      },
      ""platforms"": [
        ""Windows"",
        ""OS X"",
        ""Linux""
      ],
      ""caveats"": ""some text here""
    }
  ]
}


The data structure Jailbreaks (first one), marshals-to/unmarshals-from this json properly:

type Jailbreaks struct {
    List []Jailbreak `json:""jailbreaks""`
}

type Jailbreak struct {
    Jailbroken bool   `json:""jailbroken""`
    Name       string `json:""name""`
    Version    string `json:""version""`
    URL        string `json:""url""`
    Anleitung  []struct {
        Name string `json:""blog""`
        Link string `json:""link""`
    } `json:""anleitung""`

    Firmwares struct {
        Start string `json:""start""`
        End   string `json:""end""`
    } `json:""ios""`

    Platforms []string `json:""platforms""`
    Caveats   string   `json:""caveats""`
}


As you see Anleitung is declared as a slice (not a map).
",42378878
281,23957533,"The size of an array is part if its type.

If there's a set of sizes you know you are going to accept, you could take a buf interface{} with a type switch on the sizes you want. I would assume you know the array sizes, since they must be constant at compile time.

Other than that you would need to use reflection to actually find the array size, and store elements within the array.

It's very infrequent you need to use an array instead of a slice. You may want to reconsider why you have to pass arrays of varying sizes around.
",23956929
282,23958738,"You almost certainly want to use a slice instead of an array. A slice has three things: an underlying backing array, a capacity, and a length. The capacity ""cap"" tells you the size of the underlying backing array.

So, you can use append after checking that len(s)  to avoid any reallocation. Or if you want to make a function, perhaps something like this:

func pushByte(s []byte, b byte) ([]byte, error) {
    if len(s) == cap(s) {
        return s, errors.New(""capacity reached"")
    }
    return append(s, b), nil
}


You'd use it something like this:

s := make([]byte, 0, 10)
var err error
if s, err = pushByte(s, 10); err != nil {
    ... handle error
}

",23956929
283,44207153,"Credit: Jon Calhoun

Resource: https://www.usegolang.com/


  ""...the short answer is that automigrate fails to run because when it adds the column and says it can't have null values this contradicts the fact that any existing records will have a null value by default. The simplest fix since you are still in a dev env is to delete all the users from your table either by dripping the entire table or by running some SQL."" 


Many thanks to Jon Calhoun for this simple and effective solution.
",44188272
284,24729087,"Good Question, let's see the code of udpconn.Close

http://golang.org/src/pkg/net/net.go?s=3725:3753#L124

   func (c *conn) Close() error {
        if !c.ok() {
            return syscall.EINVAL
        }
        return c.fd.Close()
   }


Closes c.fd but what is c.fd ?

type conn struct {
    fd *netFD
}


ok is a netFD net File Descriptor. Let's look at the Close method.

func (fd *netFD) Close() error {
    fd.pd.Lock() // needed for both fd.incref(true) and pollDesc.Evict
    if !fd.fdmu.IncrefAndClose() {
        fd.pd.Unlock()
        return errClosing
    }
    // Unblock any I/O.  Once it all unblocks and returns,
    // so that it cannot be referring to fd.sysfd anymore,
    // the final decref will close fd.sysfd.  This should happen
    // fairly quickly, since all the I/O is non-blocking, and any
    // attempts to block in the pollDesc will return errClosing.
    doWakeup := fd.pd.Evict()
    fd.pd.Unlock()
    fd.decref()
    if doWakeup {
        fd.pd.Wakeup()
    }
    return nil


}

Notice all the decref
So to answer your question. Yes. Is good practice or you will leave hanging around in memory network file descriptors.
",24728805
285,42375272,"Okay, confession time...

I was so caught up in trying to understand deflate that I completely overlooked the fact that Vim wasn't saving the stream contents correctly into new files. So I spent quite a bit of time reading the RFC's, and digging through the internals of the Go compress/... packages, assuming the problem was with my code.

Shortly after I posted my question I tried reading the PDF as a whole, finding the stream/endstream locations, and pushing that through deflate. As soon as I saw the content scroll through the screen I realized my dumb mistake.

+1 @icza, that was exactly my issue.

It was good in then end, as I have a much better understanding of the whole process than if it would have just worked the first go around.
",42355485
286,42377224,"Binary data should never be copied out of / saved from text editors. There might be cases when this succeeds, and it just adds oil to the flame.

Your data that you eventually ""mined out"" from the PDF is most likely not identical to the actual data that is in the PDF. You should take the data from a hex editor (e.g. try hecate for something new), or write a simple app that saves it (which strictly handles the file as binary).

Hint #1:

The binary data displayed spread across multiple lines. Binary data does not contain carriage returns, that's a textual control. If it does, that means the editor did interpret it as text, and so some codes / characters where ""consumed"" to start a new line. Multiple sequences may be interpreted as the same newline (e.g. \n, \r\n). By excluding them, you're already at data loss, by including them, you might already have a different sequence. And if the data was  interpreted and displayed as text, more problems may arise as there are more control characters, and some characters may not appear when displayed.

Hint #2:

When flateReaderFn is used, decoding the 2nd example succeeds (completes without an error). This means ""you were barking up the right tree"", but the success depends on what the actual data is and to what extent was it ""distorted"" by the text editor.
",42355485
287,23192263,"Here's a function to set a bit. First, shift the number 1 the specified number of spaces in the integer (so it becomes 0010, 0100, etc). Then OR it with the original input. This leaves the other bits unaffected but will always set the target bit to 1.

// Sets the bit at pos in the integer n.
func setBit(n int, pos uint) int {
    n |= (1 << pos)
    return n
}


Here's a function to clear a bit. First shift the number 1 the specified number of spaces in the integer (so it becomes 0010, 0100, etc). Then flip every bit in the mask with the ^ operator (so 0010 becomes 1101). Then use a bitwise AND, which doesn't touch the numbers AND'ed with 1, but which will unset the value in the mask which is set to 0.

// Clears the bit at pos in n.
func clearBit(n int, pos uint) int {
    mask := ^(1 << pos)
    n &= mask
    return n
}


Finally here's a function to check whether a bit is set. Shift the number 1 the specified number of spaces (so it becomes 0010, 0100, etc) and then AND it with the target number. If the resulting number is greater than 0 (it'll be 1, 2, 4, 8, etc) then the bit is set.

func hasBit(n int, pos uint) bool {
    val := n & (1 << pos)
    return (val > 0)
}

",23192262
288,35297872,"There is also a compact notation to clear a bit. The operator for that is &^ and called ""and not"".

Using this operator the clearBit function can be written like this:

// Clears the bit at pos in n.
func clearBit(n int, pos uint) int {
    n &^= (1 << pos)
    return n
}


Or like this:

// Clears the bit at pos in n.
func clearBit(n int, pos uint) int {
    return n &^ (1 << pos)
}

",23192262
289,23872527,"It's ""possible"" only in the extremely pedantic sense that you could theoretically write some sort of JVM environment in Go that can run JVM bytecode that happens to interact with memory allocated by Go.

In any practical sense, Java (and Scala etc) compile in completely different ways to Go and it's not feasible to do this. This is especially complicated by Go having its own runtime which complicates the inverse as well (running Go functions from Java).

If you need to communicate with Java code from Go, I advise looking into RPC, you can launch a Java program as a separate process and cooperatively call methods over your local network. This takes a little effort, but not very much. It's certainly easier than writing the framework to truly invoke Java methods from Go would be.

The other option is to invoke Java programs by using os/exec, having them output to a file or command line, and then reading in that output and parsing it, but that's a lot more fragile than RPC and prone to errors and security holes.

As Evan mentions in the comments, you can use the JNI (Java Native Interface) with a C entrypoint. So using Cgo you can launch the JVM and call Java code. This site seems to have a tutorial on how to set it up in C and C++. I'm not very familiar with using JNI from this direction so I can't really recommend it nor dissuade you from using it. It does introduce a C dependency into your build process though, so be aware of that.
",23872323
290,31015006,"This is not valid json:

tweet := `
""media_ids"": 612877656984416256,
""status"": ""hello""
`


Try using this to generate your json:

type Tweet struct {
    MediaIds uint64 `json:""media_ids""`
    Status   string `json:""status""`
}
tweet := Tweet{612877656984416256, ""hello""}
b, err := json.Marshal(tweet)


This results in :

{""media_ids"":612877656984416256,""status"":""hello""}


This has a few benefits over using a raw string. 


It is more go centric. The struct can be passed around with values set and read with proper type checking caught at compile time.
The generated json string is more likely to be semantically correct. e.g. Go will also escape certain characters to help ensure they will be parsed properly by the receiver.

",30992532
291,31066920,"Thanks everyone. I see that the json was invalid but the issue was an error passing the media_ids parameter. The response was: ""errors"":[{""code"":44,""message"":""media_ids parameter is invalid.""}] which i though erroring out on the formatting but it had to do with not converting the media_ids type int64 to a string correctly. Here is the fixed code:

data, err := ioutil.ReadFile(fileName)
if err != nil {
    fmt.Println(err)
}

mediaResponse, err := api.UploadMedia(base64.StdEncoding.EncodeToString(data))
if err != nil {
    fmt.Println(err)
}

v := url.Values{}
v.Set(""media_ids"", strconv.FormatInt(mediaResponse.MediaID, 10))

result, err := api.PostTweet(posttitle, v)
if err != nil {
    fmt.Println(err)
} else {
    fmt.Println(result)
}

",30992532
292,33926716,"You have to initialize each layer on its own. Example (on play):

tiles = make([][][]*tile, x)

for i := range tiles {
    tiles[i] = make([][]*tile, y)
    for j := range tiles[i] {
        tiles[i][j] = make([]*tile, z)
    }
}

",33926629
293,33926775,"It works like this, but to me this feels very inefficient. Using the append-operation this many times. And it feels bloated, this should be possible in a simpler way.

func generateTiles(x int, y int, z int) [][][]*tile {
    var tiles [][][]*tile

    for i := 0; i < z; i++ {
        var layer [][]*tile
        for j := 0; j < y; j++ {
            var row []*tile
            for k := 0; k < x; k++ {
                var t *tile
                t = &tile{}
                row = append(row, t)
                count++
            }
            layer = append(layer, row)
        }
        tiles = append(tiles, layer)
    }

    return tiles
}

",33926629
294,33926783,"There is an example for creating a two dimensional array on GoByExample: https://gobyexample.com/arrays.  You should be able to expand that into a three dimensional case.

Here is what I came up with.

CODE

package main

import (
    ""fmt""
)

type Tile struct {
    value int
}

func create3D( x, y, z int) [][][]*Tile {
    result := make([][][]*Tile,x)
    for i := 0 ; i < x ; i++ {
        result[i] = make([][]*Tile,y);
        for j := 0; j < y; j++ {
            result[i][j] = make([]*Tile,z);
            for k := 0 ; k < z; k++ {
                result[i][j][k] = new(Tile)
                result[i][j][k].value = i + j + k;
            }
        }
    }
    return result
}

func main() {
    X := 3
    Y := 4
    Z := 5

    mat := create3D( X , Y , Z);
    for i := 0; i < X; i++ {
        for j := 0 ; j < Y; j++ {
            for k := 0 ; k < Z; k++ {
                fmt.Printf(""%d "",mat[i][j][k].value)
            }
            fmt.Println();
        }
        fmt.Println();
    }

}

",33926629
295,33929271,"I'd personally use a 1D slice for performance reasons, I'm adding this as an alternative:

type Tile struct {
    x, y, z int
}

type Tiles struct {
    t       []*Tile
    w, h, d int
}

func New(w, h, d int) *Tiles {
    return &Tiles{
        t: make([]*Tile, w*h*d),
        w: w,
        h: h,
        d: d,
    }
}

// indexing based on http://stackoverflow.com/a/20266350/145587
func (t *Tiles) At(x, y, z int) *Tile {
    idx := t.h*t.w*z + t.w*y
    return t.t[idx+x]
}

func (t *Tiles) Set(x, y, z int, val *Tile) {
    idx := t.h*t.w*z + t.w*y
    t.t[idx+x] = val
}

func fillTiles(w int, h int, d int) *Tiles {
    tiles := New(w, h, d)

    for x := 0; x < w; x++ {
        for y := 0; y < h; y++ {
            for z := 0; z < d; z++ {
                tiles.Set(x, y, z, &Tile{x, y, z})
            }
        }
    }

    return tiles
}


playground
",33926629
296,23713214,"The Hash interface embeds the Writer interface. Therefore, any type that wants to implement the Hash interface, also needs to implement the Writer interface containing the Write method.

The reason for the Write Method is that you can calculate hashes of anything that can be written. For example, you can calculate the hash of the formatted representation of an object (by using the fmt package), or you can calculate the hash of the json representation (by using the json package), etc.

h := fnv.New32a()
fmt.Fprint(h, myobject)
// alternatively:
// json.NewEncoder(h).Encode(myobject)
// etc.
return h.Sum32()

",23713146
297,38179313,"d.exec is not a part of struct declaration (it is not a struct field). It is a method defined on dialog type. Hence it is not addressable and cannot be assigned to.

You can try embedding Dialog in a new type and redefine exec on that type.

type TestDialog struct {
    Dialog
}

func (d *TestDialog) exec(dType string, allowLabel bool) (string, error) {
    return """", fmt.Errorf(DIALOG_ERR_CANCEL)
}

",38178920
298,8032562,"For example,

package main

import ""fmt""

func main() {
    s := ""abc""
    var a [20]byte
    copy(a[:], s)
    fmt.Println(""s:"", []byte(s), ""a:"", a)
}


Output:

s: [97 98 99] a: [97 98 99 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]

",8032170
299,17605026,"I think it's better..

package main

import ""fmt""

func main() {
    str := ""abc""
    mySlice := []byte(str)
    fmt.Printf(""%v -> '%s'"",mySlice,mySlice )
}


Check here: http://play.golang.org/p/vpnAWHZZk7
",8032170
300,28261008,"Safe and simple:

[]byte(""Here is a string...."")

",8032170
301,31513540,"Besides the methods mentioned above, you can also do a trick as

s := ""hello""
b := *(*[]byte)(unsafe.Pointer((*reflect.SliceHeader)(unsafe.Pointer(&s))))


Go Play: http://play.golang.org/p/xASsiSpQmC

You should never use this :-)
",8032170
302,35012258,"Piece of cake:

arr := []byte(""That's all folks!!"")

",8032170
303,35377171,"Ended up creating array specific methods to do this. Much like the encoding/binary package with specific methods for each int type. For example binary.BigEndian.PutUint16([]byte, uint16).

func byte16PutString(s string) [16]byte {
    var a [16]byte
    if len(s) > 16 {
        copy(a[:], s)
    } else {
        copy(a[16-len(s):], s)
    }
    return a
}

var b [16]byte
b = byte16PutString(""abc"")
fmt.Printf(""%v\n"", b)


Output:

[0 0 0 0 0 0 0 0 0 0 0 0 0 97 98 99]


Notice how I wanted padding on the left, not the right.

http://play.golang.org/p/7tNumnJaiN
",8032170
304,39294665,"For converting from a string to a byte slice, string -> []byte:

[]byte(str)


For converting an array to a slice, [20]byte -> []byte:

arr[:]


For copying a string to an array, string -> [20]byte:

copy(arr[:], str)


Same as above, but explicitly converting the string to a slice first:

copy(arr[:], []byte(str))





The built-in copy function only copies from a slice to a slice.
Arrays are ""the underlying data"", while slices are ""a viewport into underlying data"".
Using [:] makes an array qualify as a slice.
A string qualifies as a slice.
If the string is too long, copy will only copy the part of the string that fits.




This code:

var arr [20]byte
copy(arr[:], ""abc"")
fmt.Printf(""array: %v (%T)\n"", arr, arr)


...gives the following output:

array: [97 98 99 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] ([20]uint8)


I also made it available at the Go Playground
",8032170
305,43265761,"If you want to use a byte array [20]byte rather than the preferred slice of bytes []byte, use the built-in copy function to assign the string to the array. Here's an example based on original question.

package main

import ""fmt""

func main() {
    var arr [20]byte
    str := ""abc""
    copy(arr[:], str)
    fmt.Println(arr) // [97 98 99 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]
}


I still recommend using slices over arrays, as does Rob Pike (one of the original creators of the Go language).  I just want to share a relatively easy alternative if slices are not an option.
",8032170
306,29213654,"You're not missing anything, look at the source:

// HasPrefix exists for historical compatibility and should not be used.
func HasPrefix(p, prefix string) bool {
    return strings.HasPrefix(p, prefix)
}


Just use strings.HasPrefix(p, prefix) directly.
",29213429
307,29213688,"In Go 1.4 method filepath.HasPrefix actually calls strings.HasPrefix so the answer is yes.
",29213429
308,41480652,"You need to make the field exported,ie you may declare the struct as

type MyStruct struct {
    Field MyEnum
}


Here is a sample program with exported and unexported fields

Code

package main

import (
    ""fmt""
)

type MyEnum int

const (
    Foo MyEnum = 1
    Bar MyEnum = 2
)

func (e MyEnum) String() string {
    switch e {
    case Foo:
        return ""Foo""
    case Bar:
        return ""Bar""
    default:
        return fmt.Sprintf(""%d"", int(e))
    }
}

type MyStruct struct {
    Field1 MyEnum
    field2 MyEnum
}

func main() {
    info := &MyStruct{
        Field1: MyEnum(1),
        field2: MyEnum(2),
    }
    fmt.Printf(""%v\n"", MyEnum(1))
    fmt.Printf(""%v\n"", info)
    fmt.Printf(""%+v\n"", info)
    fmt.Printf(""%#v\n"", info)
}


Output

Foo
&{Foo 2}
&{Field1:Foo field2:2}
&main.MyStruct{Field1:1, field2:2}


Here is play link : https://play.golang.org/p/7knxM4KbLh
",41480543
309,43474444,"When using an embedded struct, the key is usually the type name without the package. You can declare your TypeMeta like this:

test := v1beta1.Deployment{
  TypeMeta: metav1.TypeMeta{
    APIVersion: ""apps/v1beta1"",
    Kind: ""Deployment"",
  },
}


However, manually setting the TypeMeta on any Kubernetes API object is usually only necessary if you plan to persist these objects yourself (for example, to generate YAML files).

When using the Kubernetes client API (for example, using the k8s.io/client-go package) to talk to an API server, you will not need the TypeMeta property, since all API operations are strongly typed anyway and all metadata can safely be inferred. After all, the API version and kind of a v1beta1.Deployment struct should be (and are, to the client library) obvious.
",43462908
310,30171872,"The only way to do it is to encapsulate all your tests into one test function, that calls sub-functions in the right order and with the right context, and pass the testing.T pointer to each so they can fail. The down-side is that they will all appear as one test. But in fact that is the case - tests are stateless as far as the testing framework is concerned, and each function is a separate test case. 

Note that although the tests may run in the order they are written in, I found no documentation stating that this is actually a contract of some sort. So even though you can write them in order and keep the state as external global variables - that's not recommended.

The only flexibility the framework gives you since go 1.4 is the TestMain method that lets you run before/after steps, or setup/teardown: 

func TestMain(m *testing.M) {

    if err := setUp(); err != nil {
        panic(err)
    }
    rc := m.Run()
    tearDown()
    os.Exit(rc)
}


But that won't give you what you want. The only way to do that safely is to do something like:

// this is the whole stateful sequence of tests - to the testing framework it's just one case
func TestWrapper(t *testing.T) {

   // let's say you pass context as some containing struct
   ctx := new(context)
   test1(t, ctx)
   test2(t, ctx)
   ...
}

// this holds context between methods
type context struct {   
    eventId string
}

func test1(t *testing.T, c *context) {
   // do your thing, and you can manipulate the context
   c.eventId = ""something""
} 

func test2(t *testing.T, c *context) {
   // do your thing, and you can manipulate the context
   doSomethingWith(c.eventId)
} 

",30171693
311,33560897,"First  of all your code doesn't work because you should use exported fields for marshalling/unmarshalling (see https://golang.org/pkg/encoding/xml/).
You should use 

type pv struct {
    XMLName    xml.Name  `xml:""series""`
    Unit       string    `xml:""unit""`
    Datevalues datevalue `xml:""values>dateValue""`
}


instead of 

type pv struct {
    XMLName    xml.Name  `xml:""series""`
    Unit       string    `xml:""unit""`
    datevalues datevalue `xml:""values>dateValue""`
}


Look at DateValues field name. If first symbol is uppercased it's will be exported. Otherwise that field will be ignored while Unmarshal

Second:

After it I noticed that you are ignoring your errors. Please don't ignore them, they are critically useful.

Check it out on the go playgroung

As you can see you use int datatype for Date field of datatype.
If you change type to string, your code will work.

Third:

I think you really want to unmarshall your date value into time.Time.
To do so you can check this related question 

The complete working code you can try on the go playground
",33557401
312,36826936,"I just port your node.js code (in your former version) to golang :

  session, err := r.Connect(r.ConnectOpts{
    Address: ""localhost:28015"",
  })
  if err != nil {
    return
  }

  res, err := table.ConcatMap(func(customer r.Term) interface{} {
    return customer.Field(""purchases"").Map(func(purchase r.Term) interface{} {
      return map[string]interface{}{
        ""zip"":     customer.Field(""address"").Field(""zip""),
        ""product"": purchase.Field(""name""),
      }
    })
  }).Run(session)

  if err != nil {
    return
  }

  defer res.Close()

  var response interface{}
  for res.Next(&response) {
    fmt.Println(response)
  }

",36734721
313,42086642,"I think problem is here:

var queue []Queue


Here queue is a slice of Queue or slice of slice of Job. So it's impossible to assign first its element value of Job. 

Try:

var queue Queue

",42086547
314,42086976,"You don't need a slice of queues, and you should not index an empty slice.

package main

import ""fmt""

type Job struct {
    Type string
    Url string
}

type Queue []Job

func main() {
    var q Queue
    job := Job{""test"", ""http://google.com""}
    q = append(q, job)
    fmt.Println(q)
}

",42086547
315,42087766,"[]TypeName is definition of slice of TypeName type.

Just as it said:

var queue []Queue is a slice of instances of type Queue.

q := Queue{Job{""test"", ""http://google.com""}, Job{""test"", ""http://google.com""}}


Definitely it is not what you want. Instead of it you should declare var queue Queue:

var queue Queue
q := append(queue, Job{""test"", ""http://google.com""}, Job{""test"", ""http://google.com""})

",42086547
316,31176148,"simple answer: you don't. Not at that place at least

the variables rw and req make first sense if the function fn is called. (or a function that calls fn, which probably will have rw and req variables)

In your case it is probably where appContainer uses the routes configured

To better understand how middleware concept works a simple example can be found here: https://golang.org/doc/articles/wiki/

you might want to scroll down to ""Introducing Function Literals and Closures""
",31175233
317,30129325,"You may save a couple of key strokes by using named returns:

func FindUserInfo(id string) (i Info, ok bool) {
    i, ok = all[id]
    return
}


But apart from that, I don't think what you want is possible.
",30129206
318,30130594,"I'm no Go expert but I believe you are getting compile time error when you are trying to return the array i.e. return all[id]. The reason could be because the functions return type is specially mentioned as (Info, bool) and when you are doing return all[id] it can't map the return type of all[id] to (Info, bool).

However the solution mentioned above, the variables being returned i and ok are the same that are mentioned in the return type of the function (i Info, ok bool) and hence the compiler knows what it's returning as opposed to just doing (i Info, ok bool).
",30129206
319,30134516,"By default, maps in golang return a single value when accessing a key

https://blog.golang.org/go-maps-in-action

Hence, return all[id] won't compile for a function that expects 2 return values.
",30129206
320,30135334,"To elaborate on my comment, the Effective Go mentions that the multi-value assignment from accessing a map key is called the ""comma ok"" pattern.


  Sometimes you need to distinguish a missing entry from a zero value. Is there an entry for ""UTC"" or is that the empty string because it's not in the map at all? You can discriminate with a form of multiple assignment.


var seconds int
var ok bool
seconds, ok = timeZone[tz]



  For obvious reasons this is called the “comma ok” idiom. In this example, if tz is present, seconds will be set appropriately and ok will be true; if not, seconds will be set to zero and ok will be false.


Playground demonstrating this

We can see that this differs from calling a regular function where the compiler would tell you that something is wrong:

package main

import ""fmt""

func multiValueReturn() (int, int) {
    return 0, 0
}

func main() {
    fmt.Println(multiValueReturn)

    asgn1, _ := multiValueReturn()

    asgn2 := multiValueReturn()
}


On the playground this will output

# command-line-arguments
/tmp/sandbox592492597/main.go:14: multiple-value multiValueReturn() in single-value context


This gives us a hint that it may be something the compiler is doing. Searching the source code for ""commaOk"" gives us a few places to look, including types.unpack

At the time of writing this it this the method's godoc reads:

// unpack takes a getter get and a number of operands n. If n == 1, unpack
// calls the incoming getter for the first operand. If that operand is
// invalid, unpack returns (nil, 0, false). Otherwise, if that operand is a
// function call, or a comma-ok expression and allowCommaOk is set, the result
// is a new getter and operand count providing access to the function results,
// or comma-ok values, respectively. The third result value reports if it
// is indeed the comma-ok case. In all other cases, the incoming getter and
// operand count are returned unchanged, and the third result value is false.
//
// In other words, if there's exactly one operand that - after type-checking
// by calling get - stands for multiple operands, the resulting getter provides
// access to those operands instead.
//
// If the returned getter is called at most once for a given operand index i
// (including i == 0), that operand is guaranteed to cause only one call of
// the incoming getter with that i.
//


The key bits of this being that this method appears to determine whether or not something is actually a ""comma ok"" case.

Digging into that method tells us that it will check to see if the mode of the operands is indexing a map or if the mode is set to commaok (where this is defined does give us many hints on when it's used, but searching the source for assignments to commaok we can see it's used when getting a value from a channel and type assertions). Remember the bolded bit for later!

if x0.mode == mapindex || x0.mode == commaok {
    // comma-ok value
    if allowCommaOk {
        a := [2]Type{x0.typ, Typ[UntypedBool]}
        return func(x *operand, i int) {
            x.mode = value
            x.expr = x0.expr
            x.typ = a[i]
        }, 2, true
    }
    x0.mode = value
}


allowCommaOk is a parameter to the function. Checking out where unpack is called in that file we can see that all callers pass false as an argument. Searching the rest of the repository leads us to assignments.go in the Checker.initVars() method.

l := len(lhs)
get, r, commaOk := unpack(func(x *operand, i int) { check.expr(x, rhs[i]) }, len(rhs), l == 2 && !returnPos.IsValid())


Since it seems that we can only use the ""comma ok"" pattern to get two return values when doing a multi-value assignment this seems like the right place to look! In the above code the length of the left hand side is checked, and when unpack is called the allowCommaOk parameter is the result of l == 2 && !returnPos.IsValid(). The !returnPos.IsValid() is somewhat confusing here as that would mean that the position has no file or line information associated with it, but we'll just ignore that.

Further down in that method we've got:

var x operand
if commaOk {
    var a [2]Type
    for i := range a {
        get(&x, i)
        a[i] = check.initVar(lhs[i], &x, returnPos.IsValid())
    }
    check.recordCommaOkTypes(rhs[0], a)
    return
}


So what does all of this tell us?


Since the unpack method takes an allowCommaOk parameter that's hardcoded to false everywhere except in assignment.go's Checker.initVars() method, we can probably assume that you will only ever get two values when doing an assignment and have two variables on the left-hand side.
The unpack method will determine whether or not you actually do get an ok value in return by checking if you are indexing a slice, grabbing a value from a channel, or doing a type assertion
Since you can only get the ok value when doing an assignment it looks like in your specific case you will always need to use variables 

",30129206
321,30137980,"Simply put: the reason why your second example isn't valid Go code is because the language specification says so. ;)

Indexing a map only yields a secondary value in an assignment to two variables. Return statement is not an assignment.


  An index expression on a map a of type map[K]V used in an assignment or initialization of the special form
  
  v, ok = a[x]
  v, ok := a[x]
  var v, ok = a[x]  
  
  yields an additional untyped boolean value. The value of ok is true if the key x is present in the map, and false otherwise. 


Furthermore, indexing a map is not a ""single call to a multi-valued function"", which is one of the three ways to return values from a function (the second one, the other two not being relevant here):


  There are three ways to return values from a function with a result type:  
  
  
  The return value or values may be explicitly listed in the ""return"" statement. Each expression must be single-valued and assignable to the corresponding element of the function's result type.
  The expression list in the ""return"" statement may be a single call to a multi-valued function. The effect is as if each value returned from that function were assigned to a temporary variable with the type of the respective value, followed by a ""return"" statement listing these variables, at which point the rules of the previous case apply.
  The expression list may be empty if the function's result type specifies names for its result parameters. The result parameters act as ordinary local variables and the function may assign values to them as necessary. The ""return"" statement returns the values of these variables.
  


As for your actual question: the only way to avoid temporary variables would be using non-temporary variables, but usually that would be quite unwise - and probably not much of an optimization even when safe.

So, why doesn't the language specification allow this kind of special use of map indexing (or type assertion or channel receive, both of which can also utilize the ""comma ok"" idiom) in return statements? That's a good question. My guess: to keep the language specification simple.
",30129206
322,41941085,"The problem here is that fields having struct types (including embedded structs) appear as embedded documents in MongoDB. If you don't want this, you have to specify the ""inline"" bson flag when embedding a struct:

User struct {
    Id           `bson:"",inline""`
    Email string `json:""email"" bson:""email""`
}


What the ""inline"" tag does is in MongoDB it ""flattens"" the fields of the embedded struct as if they were part of the embedder struct.

Similarly:

type UserModel struct {
    SoftDelete `bson:"",inline""`
}

type BlogPost struct {
    SoftDelete `bson:"",inline""`
}


Edit: the following section applies to the original Id type which embedded bson.ObjectId. The asker later clarified that this was just a typo (and edited the question since), and it is a named, non-anonymous field. Still think the info below is useful.

One thing to note about your Id type: Your Id type also embeds bson.ObjectId:

Id struct {
    bson.ObjectId `json:""id"" bson:""_id""`
}


Id not just has a field of bson.ObjectId, but it embeds it. This matters because this way you Id type will have a String() method promoted from bson.ObjectId, and so will User which embeds Id. Having said that, it will be hard trying to print or debug values of type User, because you will always see it printed just as a single ObjectId.

Instead you can make it a regular field in Id, embedding Id in User will still work as expected:

Id struct {
    ID bson.ObjectId `json:""id"" bson:""_id""`
}


See related question+asnwer: Enforce a type mapping with mgo
",41939080
323,28032713,"len(array) returns an int convert it to an int32 int32(len(array)) or convert perPage to an int 
",28032648
324,24382679,"IMHO, starting the timer on the init() function is a bad idea, for the single reason that the user of your API should be the one to decide if and when to do the fetching/caching/updating.

I would advise to make optionnal the caching and auto-updating of the data using either options in the NewRT() function or a package-wide boolean (api.AutoUpdate, api.Caching).

On the call of your accessors, you can then make the proper action:


Retrieve the data if caching isn't enabled
Check for data freshness if caching is enabled but auto-update isn't, and refresh if needed
Nothing if caching and auto-updating is enabled, as your timer (started in the NewRT() function) will take care of the data for you


This way you don't start retrieving anything before your user need it, but have the flexibility to let your user decide if they need additionnal functionnalities.

Note that you should ensure that unnecessary timers aren't kept after the corresponding struct have been removed.
",24375671
325,24482742,"Like Elwinar said, starting the timer in init is a bad idea, however you have a constructor, so any ""object construction"" should happen in it, here's a short example :

(check the playground for the full code)

func NewRT(interval int) (rt *realTime) {
    rt = &realTime{
        tk: time.NewTicker(time.Second * time.Duration(interval)),
    }
    go func() {
        rt.fetch()
        for _ = range rt.tk.C {
            rt.fetch()
        }
    }()

    return
}

func (rt *realTime) fetch() {
    rt.Lock()
    defer rt.Unlock()
    rt.fetchLatest()
    rt.fetchHistory()
}


......

func (rt *realTime) GetLatest() error {
    rt.RLock()
    defer rt.RUnlock()
    if rt.cached == nil || len(rt.cached) == 0 {
        return ErrNoCachedResponse
    }

    return nil
}

func (rt *realTime) Stop() {
    rt.Lock()
    defer rt.Unlock()
    rt.tk.Stop()
}

",24375671
326,33090986,"I don't think you can because the value is a primitive and attempting to do it in one shot like the below would be a syntax error. Its attempting to get an address of a value so it wouldn't be possible. At least I am not aware of a way where its possible.

someInt := &int64(10) // would not compile 


The other alternative you have is to write a function to return a pointer to the primitive like the following:

func NewIntPointer(value int) *int {
  return &value
}

",33090833
327,31558468,"The main difference is the the array bounds checking.  In the disassembly dump for the Go program, there is:

400c89:       48 83 fb 02             cmp    $0x2,%rbx
400c8d:       73 2d                   jae    400cbc 
...
400cbc:       e8 6f e0 00 00          callq  40ed30 
400cc1:       0f 0b                   ud2    


So if %rbx is greater than or equal to 2, then it jumps down to a call to runtime.panicindex.  Given you're working with an array of size 2, that is clearly the bounds check.  You could make the argument that the compiler should be smart enough to skip the bounds check in this particular case where the range of the index can be determined statically, but it seems that it isn't smart enough to do so yet.

While you're seeing a noticeable performance difference for this micro-benchmark, it might be worth considering whether this is actually representative of your actual code.  If you're doing other stuff in your loop, the difference is likely to be less noticeable.

And while bounds checking does have a cost, in many cases it is better than the alternative of the program continuing with undefined behaviour.
",31555672
328,40373000,"The examples on the docs would be sufficient to get started. However, if you are not familiar with golang, the $cond part could be a bit tricky. See below example code:



    collection := session.DB(""dbName"").C(""devices"")

    stage_match := bson.M{""$match"":bson.M{""userId"":""v73TuQqZykbxFXsWo"", ""state"": true}}

    condition_weight := []interface{}{bson.M{""$or"": []bson.M{
                       bson.M{""$eq"": []string{""$categorySlug"", ""air_fryer""}},
                       bson.M{""$eq"": []string{""$categorySlug"", ""iron""}},
    }}, 0, 1}

    stage_project:= bson.M{""$project"": bson.M{""userId"":1, ""categorySlug"":1, ""weight"": condition_weight}}

    stage_sort := bson.M{""$sort"": bson.M{""weight"":1}}

    stage_limit := bson.M{""$limit"": 10}

    pipe := collection.Pipe([]bson.M{stage_match, stage_project, stage_sort, stage_limit})


See also mgo: type Pipe
",40259171
329,43347179,"Use ctx_with_deadline also when creating a new instance of the bigquery client:

client, err := bigquery.NewClient(ctx_with_deadline, PROJECT_ID, option.WithServiceAccountFile(SERVICE_ACCOUNT_JSON_FILE_PATH‌​), option.WithHTTPClient(httpClient))

",43339181
330,8417164,"You can view the size of all entities in the admin console under Data > Datastore Statistics.

These stats can be queried programmatically from Python or Java; I couldn't find a documented equivalent for Go.
",8415000
331,8454969,"    c := appengine.NewContext(r)
    var result struct {
        Bytes int64 `datastore:""bytes""`
        Count int64 `datastore:""count""`
        Timestamp datastore.Time `datastore:""timestamp""`
    }
    datastore.NewQuery(""__Stat_Total__"").Run(c).Next(&result)
    c.Infof(""count: %d"", result.Count)

",8415000
332,43746955,"You are accessing the same key ""i"" twice - once as a string when calling SET, and then as a hash when calling HMSET. 

The error you are getting is just redis denying HMSET on a string, which is an invalid operation. 

BTW the other way around will work - calling SET on any type in redis will just write a string instead of that value, so be careful.
",43746853
333,31072203,"File names returned by filepath.Glob() are already absolute (but read below).

See this example:

fs, err := filepath.Glob(""/dev/../dev/*"")
if err != nil {
    panic(err)
}
for _, f := range fs {
    fmt.Println(f, filepath.IsAbs(f))
}


Output:

/dev/null true
/dev/random true
/dev/urandom true
/dev/zero true


Try it on the Go Playground.

Edit:

The returned file names are only absolute if the glob pattern is absolute. So the easiest way is to make the glob pattern absolute.
",31071382
334,35211509,"Unfortunately, that will not work in Go.  Your best option would be to create some import and export methods, so that you can cast your PythonTime to a time.Time and vice versa.  That will give you flexibility you desire along with compatibility with other libraries.

package main

import (

    ""fmt""
    ""reflect""
    ""time""

)

func main() {

    p, e := NewFromTime(time.Now())
    if e != nil {
        panic(e)
    }

    v, e := p.MarshalJSON()
    if e != nil {
         panic(e)
    }

    fmt.Println(string(v), reflect.TypeOf(p))

    t, e := p.GetTime()
    if e != nil {
        panic(e)
    }

    fmt.Println(t.String(), reflect.TypeOf(t))

}

type PythonTime struct {
    time.Time
}

var pythonTimeFormatStr = ""2006-01-02 15:04:05-0700""

func NewFromTime(t time.Time) (*PythonTime, error) {

b, e := t.GobEncode()
if e != nil {
    return nil, e
}

p := new(PythonTime)
e = p.GobDecode(b)
if e != nil {
    return nil, e
}

    return p, nil
}

func (self *PythonTime) GetTime() (time.Time, error) {
    return time.Parse(pythonTimeFormatStr, self.Format(pythonTimeFormatStr))
}

func (self *PythonTime) UnmarshalJSON(b []byte) (err error) {
    // removes prepending/trailing "" in the string
    if b[0] == '""' && b[len(b)-1] == '""' {
        b = b[1 : len(b)-1]
    }
    self.Time, err = time.Parse(pythonTimeFormatStr, string(b))
    return
}

func (self *PythonTime) MarshalJSON() ([]byte, error) {
    return []byte(self.Time.Format(pythonTimeFormatStr)), nil
}


That should give output like this:

2016-02-04 14:32:17-0700 *main.PythonTime

2016-02-04 14:32:17 -0700 MST time.Time
",35211363
335,35211746,"Don't do this. You're checking for a time.Time object when you should be checking that it satisfies an interface.

type TimeLike interface {
    Day() int
    Format(string) string
    ...  // whatever makes a ""time"" object to your code!
    // looks like in this case it's
    UTC() time.Time
    IsZero() bool
}


then any code that expects a time.Time that can be substituted with a PythonTime, expect a TimeLike instead.

function Foo(value interface{}) int {
    switch v := value.(type) {
    case TimeLike:
        return v.Day()  // works for either time.Time or models.PythonTime
    }
    return 0
}

",35211363
336,35228113,"Just like you have done with the json.Marshaler and json.Unamrshaler, you can also implement the gocql.Marshaler gocql.Unamrshaler interfaces.

func (t *PythonTime) MarshalCQL(info gocql.TypeInfo) ([]byte, error) {
    b := make([]byte, 8)
    x := t.UnixNano() / int64(time.Millisecond)
    binary.BigEndian.PutUint64(b, uint64(x))
    return b, nil
}

func (t *PythonTime) UnmarshalCQL(info gocql.TypeInfo, data []byte) error {
    x := int64(binary.BigEndian.Uint64(data)) * int64(time.Millisecond)
    t.Time = time.Unix(0, x)
    return nil
}


(note, untested in the context of CQL, but this does round-trip with itself)
",35211363
337,43739798,"fmt.Println accepts any number of arguments, so is ok accepting the results of half.

In the first one, you need to provide places for both variables. Either:

i,b := half(2)

or 

i, _ := half(2)

if you don't need the second return.
",43739732
338,43739816,"If a function has 2 return values, you have to ""expect"" both of them or none at all. More on this: Return map like 'ok' in Golang on normal functions

Your half() function has 2 return values, so when using a short variable declaration to store the returned values in variables, you have to provide 2 variables:

O, even := half(I)
fmt.Println(""Returned:"", O, even)


In the second case, you're not storing the returned values, you are passing them to fmt.Println() which has the signature:

func Println(a ...interface{}) (n int, err error)


fmt.Println() has a variadic parameter, so you can pass any number of arguments to it. What happens here is that all the multiple return values of half() are passed as the value of the variadic parameter of Println(). This is allowed and detailed in Spec: Calls:


  As a special case, if the return values of a function or method g are equal in number and individually assignable to the parameters of another function or method f, then the call f(g(parameters_of_g)) will invoke f after binding the return values of g to the parameters of f in order. The call of f must contain no parameters other than the call of g, and g must have at least one return value. If f has a final ... parameter, it is assigned the return values of g that remain after assignment of regular parameters.


Note that when doing so, you are not allowed to pass / provide extra parameters, so for example the following is also a compile-time error:

fmt.Println(""Returned:"", half(10))
// Error: multiple-value half() in single-value context


Check out these similar questions: 

Go: multiple value in single-value context

Avoid nesting from conjunction with function that returns 2 values in go?
",43739732
339,17372055,"based on how you which to query you could do the following:

in your struct A add a field: 

BIds []int64


in your struct B add a field:

AIds []int64


now any time you add a relation between A and B you just need to add the corresponding ids to your two variables

when you need to query now for all B which are related to this A1 you do your query like this:

SELECT * FROM B where AIds = 'A1'


for all A wich are related to this B1 your do it similar:

SELECT * FROM A where BIds = 'B1'


update:
altered querys on suggestion from dragonx
",17371244
340,17372295,"A python ReferenceProperty essentially stores a key to another entity.  It's similar to using a Key field in Go.

There's at least two ways to solve your problem.  A cheap way to store a limited number of references, and an expensive way for larger data sets.

fmt.Println.MKO provided the answer for the cheap way, except the query is simpler than what he suggests, it should actually be:

SELECT * FROM B where AIds = 'A1'


This method is limited to the number of indexed entries per entity, as well as the entity size.  So the list of AIds or BIds will limit the number of entities to 20000 or less.

If you have an insane amount of data, you would want a mapping entity to represent the M2M relationship between a given A & B entity.  It would simply contain a key to an A and a key to a B.  You would then query for map entities, and then fetch the corresponding A or B entities you need.  This would be much more expensive, but breaks past the entity size limit.
",17371244
341,28636712,"A slice has three parts. A pointer to an underlying array, a length, and a capacity. The length is the length of the array according to program logic and capacity is the true length of the underlying array.

The capacity is fixed without reallocating. The length can be changed whenever you want as long as the final length doesn't exceed the capacity. In this case you can do arr[:7] and your array will be length 7 but still capacity 10. If you do arr[:11], you will get an error because you can't grow the slice that large without reallocating.

You may want to read this for a more in depth discussion of slices:
http://blog.golang.org/go-slices-usage-and-internals
",28636235
342,29251811,"URLs may only contain characters of the ASCII character set, but it is often intended to include/transfer characters outside of this ASCII set. In such cases the URL has to be converted into a valid ASCII format.

If the raw URL contains characters outside of the allowed set, they are escaped: they are replaced with a '%' followed by two hexadecimal digits. Therefore the character '%' is special and also has to be escaped (and its escaped form will start with '%' as well, and its hexadecimal code is 25).

Since your raw URL contains the character '%', it will be replaced by ""%25"".

Back to your example: in the printed form you see ""%2525"". You could ask why not just ""%25""?

This is because your original url contains a '%' in its escaped form which means its raw form contains the escape sequence ""%25"". If you use/interpret this as raw input, the '%' will be replaced by ""%25"" which will be followed by the ""25"" from the input hence resulting in ""%2525"".

See: HTML URL Encoding Reference

Also: RFC 1738 - Uniform Resource Locators (URL)

And also: RFC 3986 - Uniform Resource Identifier (URI): Generic Syntax
",29249900
343,45397828,"If you take a look at this page https://golang.org/doc/articles/wiki/ there are examples of what I think you are after.  

You want a handler with name person and then extract (any_name) and handle it accordingly to each person. One of the examples shows how to do it with title which is the same principle.

func viewHandler(w http.ResponseWriter, r *http.Request) {
    title := r.URL.Path[len(""/view/""):]
    p, _ := loadPage(title)
    t, _ := template.ParseFiles(""view.html"")
    t.Execute(w, p)
}


Instead of /view/ you got /person/ and title is what (any_name) is in your case.

r.URL.Path[len(""/view/""):] will take everything from r.URL.Path but start len(""/view/"") bytes into the slice.
",45397625
344,45402602,"You should look into using gorilla/mux package for what you are trying to do.
An excerpt from the package github shows https://github.com/gorilla/mux 

r := mux.NewRouter()
r.HandleFunc(""/products/{key}"", ProductHandler)
r.HandleFunc(""/articles/{category}/"", ArticlesCategoryHandler)
r.HandleFunc(""/articles/{category}/{id:[0-9]+}"", ArticleHandler)

",45397625
345,28542464,"Use reflect.MakeSlice for that:

type := reflect.ValueOf(obj)
reflectSlice := reflect.MakeSlice(type, sliceLength, sliceCapacity)

",28542330
346,45044580,"If activeFilters is a map, you don't need to iterate it to find a key - that's the whole point of a map. You can just:

if v,ok := activeFilters[event.Msg.Namepace]; ok {
    // range over v as you are now
} else {
    // event.Msg.Namepace does not exist in the map
}


This eliminates one loop, and thus one break. The last break (BREAK 3) works but isn't particularly clear what it's doing; I'd make it a conditional to make it more readable:

if matches {
    if err := sendEvent(event); err != nil {
        sendErr(err)
        return
    }
}


return would not close the channel (assuming there's another reference to it somewhere else, which there would have to be for this to work at all), but it would exit your loop, so no further messages would be processed. I'd also double-check that the return in the error case is really what you want; typically in these situations you'd log the error but keep handling future messages that come over the channel.
",45044434
347,31832899,"Try this regex:

https?:[^:]*$


Regex live here.
",31832852
348,31833520,"The lookaheads exist for a reason.

However, if you insist on a supposedly equivalent alternative, a general strategy you can use is:

(?!xyz)


is somewhat equivalent to:

$|[^x]|x(?:[^y]|$)|xy(?:[^z]|$)


With that said, hopefully I didn't make any mistakes:

https?:\/\/(?:$|(?:[^h]|$)|(?:h(?:[^t]|$))|(?:ht(?:[^t]|$))|(?:htt(?:[^p]|$))|(?:http(?:[^s:]|$))|(?:https?(?:[^:]|$))|(?:https?:(?:[^\/]|$))|(?:https?:\/(?:[^\/]|$)))*$

",31832852
349,34915947,"Because the client streams the response body from the network, it's not possible to read the body twice.

Read the response to a []byte as you are already doing. Create a io.Reader on the bytes for the HTML parser using bytes.NewReader.

resp, err := http.Get(url)
...
b, err := ioutil.ReadAll(resp.Body)  
doc, err := html.Parse(bytes.NewReader(b))

",34915873
350,7707193,"Go programs are compiled to binaries; I don't think there is an option to run them directly from source.

This is similar to other compiled languages such as C++ or Java. Some languages (such as Haskell) offer both a fully compiled mode and a ""script"" mode which you can run directly from source with a shebang line. 
",7707178
351,7707313,"There isn't one by default. There is a third-party tool called gorun that will allow you to do it, though. https://wiki.ubuntu.com/gorun

Unfortunately the compilers don't like the shebang line. You can't compile the same code you run with gorun.
",7707178
352,17900932,"//usr/bin/go run $0 $@ ; exit

example:

//usr/bin/go run $0 $@ ; exit
package main

import ""fmt""

func main() {
    fmt.Println(""Hello World!"")
}


go treat // as a single line comment
and shell ignore extra /
",7707178
353,30082862,"I prefer this:

///bin/true; exec /usr/bin/env go run ""$0"" ""$@""


This has several advantages compared to the answer by هومن جاویدپور:


Uses 'exec' to replace the new shell process instead of launching a grandchild process.  As a result, your Go program will be a direct child process.  This is more efficient and it's also important for some advanced situations, such as debugging and monitoring.
Proper quoting of arguments.  Spaces and special characters won't cause problems.
The leading ""///"" is more standards compliant than just ""//"".  If you only use ""//"", you run the risk of bumping into implementation-defined behaviour.  Here's a quote from http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap04.html:



  If a pathname begins with two successive  characters, the first
  component following the leading  characters may be interpreted
  in an implementation-defined manner, although more than two leading
   characters shall be treated as a single  character.


I have tested this answer with bash, dash, zsh, and ksh.

Example:

///bin/true; exec /usr/bin/env go run ""$0"" ""$@""
package main
import ""fmt""
func main() {
    fmt.Println(""你好！"")
}

",7707178
354,31735179,"The short answer is that intercepting syscalls with Go is going to be very difficult, and anything ptrace will probably not work.

Go has a runtime which multiplexes go-routines onto OS threads. A syscall is a scheduling point, so after the syscall returns you could be on a different thread, whereas I think ptrace follows a single thread. 

Say the thread you are ptrace-ing is running your main go-routine. Then you call fmt.Println (which does syscall.Write), so the Go runtime takes your go-routine off that thread, and runs the syscall in a different os thread (syscalls always run in different threads). When the syscall returns, your main go-routine is put back on the schedulers list of runnable routines, and it will continue on whichever os thread is available, which may not be the one you are ptrace-ing.

This is also the reason you cannot step through a Go program with gdb.

If you just wanted to execute an external program (like /bin/ls) you could use os/exec from the standard library.

The program that comes closes to what you are trying to do is probably delve. I think that sets a breakpoint on every thread at each single-step, then tries to find which thread your go-routine is now on based on the go-routine id.
",18502203
355,8070330,"Just use int():

x := float32(3.1)
fmt.Println(int(x))


Which produces 3 as needed, without having to use string conversions or the like.
",8070205
356,27758235,"Consider the way you define your structures.

In the first case:

type chatbetweenusers struct {
    Time string `json:""time""`
    Text string `json:"":""text""`
}


The syntax of the tag associated to Text is wrong. It should be:

    Text string `json:""text""`


In the second case:

type chatbetweenusers struct {
    Text string `json:"":""text""`
    User1 string `json:"":""user1""`
}


The syntax associated to both tags is wrong. They should be:

    Text string `json:""text""`
    User1 string `json:""user1""`


Here is a playground example: https://play.golang.org/p/rirtTsTVWT
",27756856
357,36243165,"My trace ID generation was incorrect. 

package main

import (
    ""io/ioutil""
    ""log""
    ""os""
    ""time""
    ""encoding/hex""
    ""rand""

    ""golang.org/x/oauth2""
    goog ""golang.org/x/oauth2/google""
    cloudtrace ""google.golang.org/api/cloudtrace/v1""
)

func run() error {
    blob, err := ioutil.ReadFile(""jwt.json"")
    if err != nil {
        return err
    }
    conf, err := goog.JWTConfigFromJSON(blob, cloudtrace.CloudPlatformScope)
    if err != nil {
        return err
    }

    client := conf.Client(oauth2.NoContext)

    srv, err := cloudtrace.New(client)
    if err != nil {
        return err
    }

    tracer := cloudtrace.NewProjectsService(srv)
    now := time.Now()
    format := ""2006-01-02T15:04:05.999999999Z""

    p := make([]byte, 16)
    rand.Read(p)

    call := tracer.PatchTraces(""foo-1262"", &cloudtrace.Traces{
        Traces: []*cloudtrace.Trace{
            {
                TraceId:   hex.EncodeToString(p),
                ProjectId: ""foo-1262"",
                Spans: []*cloudtrace.TraceSpan{
                    {
                        StartTime: now.Format(format),
                        EndTime:   now.Add(5 * time.Second).Format(format),
                        Kind:      ""RPC_SERVER"",
                        Name:      ""bar"",
                        SpanId:    100,
                    },
                },
            },
        },
    })

    _, err = call.Do()
    return err
}

func main() {
    if err := run(); err != nil {
        log.Fatal(err)
    }
}

",36242589
358,21127615,"As you guess, gd (and other commands) is merely text matching, vim don't understand the syntax as it is just a text editor, :h gd will explain how gd works.

Usually, 'go to definition' is brought by using CTRL-] and tag files. A user manual about this topic can be read by :h 29.1.

First you need to generate a tags file for your project, as latest Exuberant Ctags has supported golang (from here), command

cd /path/to/your/project
ctags -f tags -R --fields=+K+a


will do the job.

Second, open vim, by default vim will find tag files under working directory (according to 'tags' option), if the tag file is found successfully, then CTRL-] should works well.

Also check two useful plugins Tagbar and Easytags.
",21125602
359,28678946,"For golang, you can use the application godef to do it. The pluging vim-go helps you on setting everything, so, you just type 'gd' in a definition and it goes to the exact definition.

https://github.com/fatih/vim-go/blob/master/doc/vim-go.txt
",21125602
360,33979484,"Its really just doing powers of 2

so the outputs are

1 2 4 8 16 32 ... 1024

Think of this loop as 

sum = 1
while(sum < x) {
    sum = sum * 2
}

",33979399
361,30626379,"I'm not familar with MongoDB or bson.ObjectId, but can you substitute your own type for your User field and have MongoDB easily fill that in for you from a user's bson.ObjectId?

If so you can just wrap user object id's into their own type that implements the json.Marshaler interface. E.g.:

// Embedded (instead of `type x bson.ObjectId`) so that we
// get all the methods and satisfy all the interfaces that
// bson.ObjectId does. Hopefully that's engough to allow MongoDB
// to fill in fields of this type from a database??
type ownerObjID struct{ bson.ObjectId }

// Here we marshal the results of looking up the user from the id
// rather than just the ID itself.
func (oid ownerObjID) MarshalJSON() ([]byte, error) {
    user, err := LookupUser(oid.ObjectId)
    if err != nil {
        return nil, err
    }
    return json.Marshal(user)
}

type Post struct {
    ID    bson.ObjectId `json:""id,omitempty""`
    Title string        `json:""title,omitempty""`
    Owner ownerObjID    `json:""owner,omitempty""` // <-- is this type wrapping doable/easy with MongoDB?
}

type User struct {
    ID   bson.ObjectId `json:""id,omitempty""`
    Name string        `json:""name,omitempty""`
}

func main() {
    post := LookupPost()
    b, err := json.MarshalIndent(post, """", ""  "")
    if err != nil {
        log.Fatal(err)
    }
    fmt.Printf(""JSON:\n%s\n"", b)
}

// Some stubs for demo:
func LookupPost() Post {
    return Post{
        ID:    ""postID001"",
        Title: ""Ima Test"",
        Owner: ownerObjID{""ownerID002""},
    }
}

func LookupUser(id bson.ObjectId) (User, error) {
    return User{
        ID:   id,
        Name: ""name for "" + string(id),
    }, nil
}


Playground

Gives me:

JSON:
{
  ""id"": ""postID001"",
  ""title"": ""Ima Test"",
  ""owner"": {
    ""id"": ""ownerID002"",
    ""name"": ""name for ownerID002""
  }
}

",30611086
362,30655945,"So I actually discovered a much cleaner solution to this problem:

type Post struct {
    ID bson.ObjectId `bson:""_id,omitempty"" json:""id,omitempty""`
    Title string `bson:""title,omitempty"" json:""title,omitempty""`
    Owner UserRef `bson:""owner,omitempty"" json:""owner,omitempty""`
}

type User struct {
    ID   bson.ObjectId `json:""id,omitempty""`
    Name string        `json:""name,omitempty""`
}

type UserRef bson.ObjectId

func (ref UserRef) GetBSON() (interface{}, error) {
    return bson.ObjectId(ref), nil
}

func (ref UserRef) MarshalJSON() ([]byte, error) {
    u := LookupUserInMongoDB(ref)

    return json.Marshal(u)
}


Here's how it works -- mgo can't store UserRef as an ObjectId when converting a Post to bson, so we can implement the GetBSON method for UserRef to return the underlying ObjectId. This allows us to store Owner as an ObjectId in the database. And, like in @DaveC's answer, we implement the MarshalJSON method for UserRef so that when converting a Post to json, we can replace the ObjectId with an actual embedded user.
",30611086
363,34863211,"You can, as Tim Cooper noted, test UTF-8 validity with utf8.Valid.

But! You might be thinking that converting non-UTF-8 bytes to a Go string is impossible. In fact, ""In Go, a string is in effect a read-only slice of bytes""; it can contain bytes that aren't valid UTF-8 which you can print, access via indexing, or even round-trip back to a []byte (to Write, say).

There are two places in the language that Go does do UTF-8 decoding of strings for you. 


when you do for i, r := range s the r is a Unicode code point as a value of type rune
when you do the conversion []rune(s), Go decodes the whole string to runes


In both these instances invalid UTF-8 is replaced with U+FFFD, the replacement character reserved for uses like this. More is in the spec sections on for statements and conversions between strings and other types. These conversions never crash, so you only need to actively check for UTF-8 validity if it's relevant to your application, like if you want to throw an error on mis-encoded input.

Since that behavior's baked into the language, you can expect it from libraries, too. U+FFFD is utf8.ErrorRune and returned by functions in utf8.

Here's a sample program showing what Go does with a []byte holding invalid UTF-8:

package main

import ""fmt""

func main() {
    a := []byte{0xff}
    s := string(a)
    fmt.Println(s)
    for _, r := range s {
        fmt.Println(r)
    }
    rs := []rune(s)
    fmt.Println(rs)
}


Output will look different in different environments, but in the Playground it looks like

�
65533
[65533]

",34861479
364,22768444,"Cloud SQL works with the latest SDK. The online docs haven't been updated. Pick a MySQL driver of your choosing that can work with appengine/cloudsql package and the databse/sql package will work. Some of the working drivers : mymysql https://github.com/ziutek/mymysql or go-sql-driver : https://github.com/go-sql-driver/mysql
",22622355
365,40265197,"proto3 has type Any

import ""google/protobuf/any.proto"";

message ErrorStatus {
  string message = 1;
  repeated google.protobuf.Any details = 2;
}


but if you look at its implementation, it is simply as

message Any {
  string type_url = 1;
  bytes value = 2;
}


You have to define such a message yourself by possibly using reflection and an intermediate type. 

See example application

https://github.com/golang/protobuf/issues/60
",40259551
366,44894480,"While it gets a little verbose to deal with, the ""struct"" type in protocol buffers is probably closer to golang's map[string]interface{} 

But like interface{}  will take some reflection-style overhead to determine what the actual stored type is.

for example see comment here: https://github.com/golang/protobuf/issues/370
",40259551
367,12756420,"Replacing 

split_line := strings.Fields(line)

with 

split_line := strings.SplitN(line, "" "", 11)

Yielded ~4x speed improvement on a 1M line randomly generated file that mimicked the format you provided above:

strings.Fields version: Completed in 4.232525975s

strings.SplitN version: Completed in 1.111450755s

Some of the efficiency comes from being able to avoid parsing and splitting the input line after the duration has be split, but most of it comes from the simpler splitting logic in SplitN. Even splitting all of the strings doesn't take much longer than stopping after the duration. Using:

split_line := strings.SplitN(line, "" "", -1)

Completed in 1.554971313s

SplitN and Fields are not the same. Fields assumes tokens are bounded by 1 or more whitespace characters, where SplitN treats tokens as anything bounded by the separator string. If your input had multiple spaces between tokens, split_line would contain empty tokens for each pair of spaces.

Sorting and calculating the median does not add much time. I changed the code to use a float64 rather than a float32 as a matter of convenience when sorting. Here's the complete program:

package main

import (
    ""bufio""
    ""fmt""
    ""os""
    ""sort""
    ""strconv""
    ""strings""
    ""time""
)

// SortKeys returns a sorted list of key values from a map[int][]float64.
func sortKeys(items map[int][]float64) []int {
    keys := make([]int, len(items))
    i := 0
    for k, _ := range items {
        keys[i] = k
        i++
    }
    sort.Ints(keys)
    return keys
}

// Median calculates the median value of an unsorted slice of float64.
func median(d []float64) (m float64) {
    sort.Float64s(d)
    length := len(d)
    if length%2 == 1 {
        m = d[length/2]
    } else {
        m = (d[length/2] + d[length/2-1]) / 2
    }
    return m
}

func main() {
    data := make(map[int][]float64)
    infile, err := os.Open(""sample.log"")
    defer infile.Close()
    if err != nil {
        panic(err)
    }
    reader := bufio.NewReaderSize(infile, 256*1024)

    s := time.Now()
    for {
        line, err := reader.ReadString('\n')
        if len(line) == 0 {
            break
        }
        if err != nil {
            panic(err)
        }
        split_line := strings.SplitN(line, "" "", 11)
        num_packets, err := strconv.ParseFloat(split_line[7], 32)
        if err != nil {
            panic(err)
        }
        duration, err := strconv.ParseFloat(split_line[9], 32)
        if err != nil {
            panic(err)
        }
        pkts := int(num_packets)
        data[pkts] = append(data[pkts], duration)
    }

    for _, k := range sortKeys(data) {
        fmt.Printf(""pkts: %d, median: %f\n"", k, median(data[k]))
    }
    fmt.Println(""\nCompleted in "", time.Since(s))
}


And the output:

pkts: 0, median: 0.498146
pkts: 1, median: 0.511023
pkts: 2, median: 0.501408
...
pkts: 99, median: 0.501517
pkts: 100, median: 0.491499

Completed in  1.497052072s

",12755575
368,33672201,"Your OAuth token has no write:public_key scope. Scopes
",33666158
369,33705844,"The GitHub API docs for creating a public key give an example with  a request body that contains lowercase keys:

{
  ""title"": ""octocat@octomac"",
  ""key"": ""ssh-rsa AAA...""
}


while the first character of your request keys is capitalized:

{
  ""Title"": ""octocat@octomac"",
  ""Key"": ""ssh-rsa AAA...""
}


I think the easiest way to fix this is by using json struct tags on your githubBody struct. For example:

type githubBody struct {
    Title string `json:""title""`
    Key string `json:""key""`
}

",33666158
370,34481712,"Your WebSock function need to include a receive loop to receive more than one message. Otherwise, your function will terminate and the websocket connection will be closed.
",34480387
371,34484772,"@Mickaël Rémond is right. Modify your Websock function to something like:

func Websock(ws *websocket.Conn) {
    for {
        msg := <-messages
        log.Println(""only one message arrives, even if I create for two events"", msg)
        if err := websocket.Message.Send(ws, msg); err != nil {
            log.Fatal(err)
        }
    }
}

",34480387
372,19374103,"You cannot do what you want with the current go template package. Templates have no inheritance, and thus no named blocks as you have in your templates. Instead of defining a base template, it is more common to define header and footer templates. Then, in your page templates, explicitly include those where you want them to go.

Another solution, I believe, would be to have a 2-stage template phase. The first would be to compile templates for all of the blocks of the base template. These get added to the map, and then sent off to the base template for inclusion.
",19373586
373,19374187,"This is pretty non-obvious, and I don't know why they do it like this

ParseGlob returns a value that you're throwing away, but you need to keep it; it's the template object that you need to call, so your code should look like:

func init() {
  fmt.Println(""Starting up."")
  t, err := template.ParseGlob(""templates/*.tmpl"")
  if err != nil {
    log.Fatal(""Error loading templates:"" + err.Error())
  }
}


the documentation for the method (as opposed to the library function used above) is a bit unclear, as it says that it associates the templates with the template object that the method is called on, but it also returns a pointer to a template object, which it wouldn't need to do if it worked as advertised. Fun!
",19373586
374,45802941,"If you are using the standard net/http library you can use the following code. Take a look at this answer Showing custom 404 error page with standard http package @Mostafa to which I got this example from 

func homeHandler(w http.ResponseWriter, r *http.Request) {
    if r.URL.Path != ""/"" {
        errorHandler(w, r, http.StatusNotFound)
        return
    }
    fmt.Fprint(w, ""welcome home"")
}

func errorHandler(w http.ResponseWriter, r *http.Request, status int) {
    w.WriteHeader(status)
    if status == http.StatusNotFound {
        // JSON Out here
    }
}

",45802492
375,45802962,"You can't. You can find this in net/http source, it only happens if the request was malformed:

https://github.com/golang/go/blob/master/src/net/http/server.go#L1744

I think your problem might be a new line in the header you're adding in curl?

401, 403, 404, 500 errors you'll be able to respond with json, but bad requests or bad headers (too long, malformed) are handled within server.go. 

There is at present no way to intercept such errors though it is under consideration, so your only solution in go would be to patch the stdlib source (I don't recommend this). However, since this error only presents if the client has made a mistake and the request is malformed, it's probably not a huge problem.  The reason for the text response is so that a browser or similar client (like curl without -v) doesn't just see an empty response. You could put a proxy like nginx in front of your app but then you'd never see the request either as it is a bad request, your proxy would handle it. 

Possibly you'd be able to do it with a proxy like nginx in front though if you set a specific static error page for it to serve for 400 errors and serve a 400.json file that you specify? That's the only solution I can think of. A directive something like this might work for nginx:

error_page 400 /400.json;


If you'd like to be able to customise these errors, perhaps add a comment to the issue linked to let them know you had this specific problem. 
",45802492
376,26618297,"{{index $element ""some field with spaces""}}


playground example
",26617774
377,17667911,"Official documentation about the go tool:


  If DIR is a directory listed in the GOPATH...
  
  If the GOBIN environment variable is set, commands are installed to the directory it names instead of DIR/bin


There has been a discussion about this topic on the mailing list where this is further explained:


  (a) If you don't set your GOBIN env variable, 
  you get the Go compiler binaries going in GOROOT/bin
  whereas the your binaries are going in GOPATH/bin.
  (I personally like this separation of binaries.)
  
  (b) If you set your GOBIN to anything, then 
  both the Go binaries and your binaries are going to GOBIN.


The solution in your case would be to not set your GOBIN.
",17667803
378,28301847,"It's the fact that you're running the middleware within a goroutine that is the problem.

If you want to run your middleware in parallel you will have to set up a mutex around the memory that is written to by any middleware executed within a goroutine. 

In your particular case you are both writing and reading from the ResponseWriter's Header
",28301402
379,44305910,"Observable behavior

nil and empty slices (with 0 capacity) are not the same, but their observable behavior is the same. By this I mean:


You can pass them to the builtin len() and cap() functions
You can for range over them (will be 0 iterations)
You can slice them (by not violating the restrictions outlined at Spec: Slice expressions; so the result will also be an empty slice)
Since their length is 0, you can't change their content (appending a value creates a new slice value)


See this simple example (a nil slice and 2 non-nil empty slices):

var s1 []int         // nil slice
s2 := []int{}        // non-nil, empty slice
s3 := make([]int, 0) // non-nil, empty slice

fmt.Println(""s1"", len(s1), cap(s1), s1 == nil, s1[:], s1[:] == nil)
fmt.Println(""s2"", len(s2), cap(s2), s2 == nil, s2[:], s2[:] == nil)
fmt.Println(""s3"", len(s3), cap(s3), s3 == nil, s3[:], s3[:] == nil)

for _ = range s1 {}
for _ = range s2 {}
for _ = range s3 {}


Output (try it on the Go Playground):

s1 0 0 true [] true
s2 0 0 false [] false
s3 0 0 false [] false


(Note that slicing a nil slice results in a nil slice, slicing a non-nil slice results in a non-nil slice.)

You can only tell the difference by comparing the slice value to the predeclared identifier nil, they behave the same in every other aspect.

To tell if a slice is empty, simply compare its length to 0: len(s) == 0. It doesn't matter if it's the nil slice or a non-nil slice, it also doesn't matter if it has a positive capacity; if it has no elements, it's empty.

s := make([]int, 0, 100)
fmt.Println(""Empty:"", len(s) == 0, "", but capacity:"", cap(s))


Prints (try it on the Go Playground):

Empty: true , but capacity: 100


Under the hood

A slice value is represented by a struct defined in reflect.SliceHeader:

type SliceHeader struct {
    Data uintptr
    Len  int
    Cap  int
}


In case of a nil slice, this struct will have its zero value which is all its fields will be their zero value, that is: 0.

Having a non-nil slice with both capacity and length equal to 0, Len and Cap fields will most certainly be 0, but the Data pointer may not be. It will not be, that is what differentiates it from the nil slice. It will point to a zero-sized underlying array.

Note that the Go spec allows for values of different types having 0 size to have the same memory address. Spec: System considerations: Size and alignment guarantees:


  A struct or array type has size zero if it contains no fields (or elements, respectively) that have a size greater than zero. Two distinct zero-size variables may have the same address in memory.


Let's check this. For this we call the help of the unsafe package, and ""obtain"" the reflect.SliceHeader struct ""view"" of our slice values:

var s1 []int
s2 := []int{}
s3 := make([]int, 0)

fmt.Printf(""s1 (addr: %p): %+8v\n"",
    &s1, *(*reflect.SliceHeader)(unsafe.Pointer(&s1)))
fmt.Printf(""s2 (addr: %p): %+8v\n"",
    &s2, *(*reflect.SliceHeader)(unsafe.Pointer(&s2)))
fmt.Printf(""s3 (addr: %p): %+8v\n"",
    &s3, *(*reflect.SliceHeader)(unsafe.Pointer(&s3)))


Output (try it on the Go Playground):

s1 (addr: 0x1040a130): {Data:       0 Len:       0 Cap:       0}
s2 (addr: 0x1040a140): {Data: 1535812 Len:       0 Cap:       0}
s3 (addr: 0x1040a150): {Data: 1535812 Len:       0 Cap:       0}


What do we see?


All slices (slice headers) have different memory addresses
The nil slice has 0 data pointer
s2 and s3 slices do have the same data pointer, sharing / pointing to the same 0-sized memory value 

",44305170
380,44305916,"A slice can be nil in a very literal sense:

var n []int
n == nil // true


That is the only easy case. The notion of ""empty"" slice is not well defined: A slice s with len(s) == 0 is certainly empty, regardless of its capacity.
The most sensible thing to do is: Ignore the underlying implementation, one never needs to know how a slice is represented internally. All it matters is the defined behaviour of a slice.


  How to test whether a slice is empty or not?


The most sensible definition of "" slice s is empty"" is a slice containing no elements which translates to len(s) == 0. This definition holds for nil as well as for non-nil slices.


  Can anyone please tell whether nil and empty slices are same things? If they both are different, then please tell what is the difference between those two?


Technically a nil slice and a non-nil slice are different (one being == nil, the other being != nil), but this distinction typically does not matter as you can append to a nil slice and len and cap on nil slices return 0

var n []int
len(n) == cap(n) == 0 // true
n = append(n, 123)
len(n) == 1 // true


Read about zero values in Go for further information. A nil slice is like a nil channel or a nil map: It is uninitialised. You initialise by either makeing them or by a literal. As said above, there is no reason to think about the underlying representation.


  Also, what value does the pointer holds in non-nil slices, whose length and capacity are zero?


This is an implementation detail which may vary from compiler to compiler or even from version to version. Nobody needs to know this to write correct and portable Go programs.
",44305170
381,12869641,"You should check out the go.crypto packages particularly the ones in: http://code.google.com/p/go/source/browse/?repo=crypto#hg%2Fopenpgp

It's the most likely to have what you are looking for.
",12867031
382,26692402,"For example,

package main

import ""fmt""

func singleReturn() int {
    s, _ := multiReturn()
    return s
}

func multiReturn() (int, int) {
    return 0, 1
}

func noOp(a int) int {
    return a
}

func main() {

    fmt.Print(noOp(singleReturn()))
    fmt.Print(string(singleReturn()))

    // Too many arguments
    //fmt.Print(noOp(multiReturn()))

    // multiple-value in single-value context
    //fmt.Print(string(multiReturn()))
}

",26692327
383,26694488,"You can have your outer function match the return values of the inner function

func multiReturn() (int, int) {
    return 10, 1
}

func noOp(a, _ int) int {
    return a
}

func main() {
    fmt.Printf(""%v\n"", noOp(multiReturn()))             // output: 10
    fmt.Printf(""%s"", strconv.Itoa(noOp(multiReturn()))) // output: 10
}


On a side note string(int) will not work, you have to use the strconv package.

Go play

Another option would to use a variadic parameter.

func noOp(a ...int) int {
    if len(a) > 0 {
        return a[0]
    }
    return 0
}

",26692327
384,29480363,"you can also return a function that returns multiple values.

func f() (int, int) {
    return 1, 2
}

func g() (int, int) {
    return f()
}

",26692327
385,29199611,"Maybe this way

type Schedule struct {
    Jobs []Job
}
const(
Difference=iota
Ratio=iota
)
type ByDifference Schedule
// ByDifference implements sort.Interface

type ByRatio Schedule
// ByRatio implements sort.Interface

func (s *Schedule) Schedule(order int) { // s.Schedule(Difference) for example
    // Summation variables omitted
    switch order{
        case Difference: ss:= ByDifference(*s);  sort(ss); s=&Schedule(ss)
        case Ratio: ss:= ByRatio(*s);  sort(ss); s=&Schedule(ss)
    }

    for _, v := range s.Jobs {
        // Compute weighted sum omitted
    }

    // Output code omitted

}

",29196323
386,37133267,"For those who encouter the same issue, make sure you call Prepare statement only once and leave it out of any of your loops. I just noticed that it was inside my 'for' loop and therefore it created a new prepare statment everytime.

Also thanks to Apin who mentioned it earlier
",37125537
387,1726206,"This is a common practice nowadays.

Effectively, through the Contributors Agreement you are sharing copyright with Google.

That means, in the end, Google has copyright over the entire codebase. This gives them the right to relicense the codebase however they want should they see fit. (Copyright owner determines license).

The primary goal of the CA is to ensure and assert that the contributor has the rights they are granting to the project (patents, copyright, etc.).

Some projects, for example, would want a patent grant, but are not interested in any copyright, as they have no intention of relicensing the project.

Mind, since the license is BSD, a copyright grant is really just a formality, because of how liberal the BSD license is in the first place.
",1726130
388,1726208,"No, it just means that if you contribute to Google's project, Google can still do whatever they want with it.

You are the copyright holder, of course. If your code gets included into Go, you become part of The Go Authors.
",1726130
389,1726262,"
  To what extent does Google own any Go contributions?


You are not required to transfer copyright to Google.  You still OWN the copyright.

You are not required to transfer ownership of patents to Google.  You still OWN the patents.

In short Google does not OWN any IP that they didn't already own.

But you go grant Google the unlimited right to use and distribute your contributions, and you grant the right to use to downstream folks.  Clause 2 covers copyrights, and clause 3 covers patent rights.  Moreover you grant this as an irrevocable license (i.e. you cannot change your mind) and for free.


  Do they have full rights to profit
  from these contributions?


There is no such a thing as a right to profit in a legal or moral sense.  Hence ""full rights to profit"" is not a valid characterization of the rights that you currently have.

By granting Google non-exclusive, non-revocable copyright and patent licenses, your remaining rights are no longer exclusive.  Google will be able to profit your contributions, but so will you.  You will have reduced your scope for personal profit, but that was not ever a ""right"". 
",1726130
390,1727100,"Disclaimer: I am not a lawyer


  Grant of Patent License.


Means if you have a patent on something in your contribution, you allow Google to use it without worrying about IP crap.

In other words: 

Patent License = Permission to use the ""patented technology"" (if any).

It's irrecoverable: meaning you can't change your mind later.
",1726130
391,31277493,"Not sure if you're trying this on Android or iOS, since it works for me on Android but it doesn't always work on iOS.

Delivery receipts for iOS do not work with the notification parameter in the request. I was able to get it to work for a plain data message i.e. with payload

{
  ""to"" : ,
  ""data"" : {
    ""hello"" : ""world"",
    ""id"" : 123
  }
}


But if I added the notification payload to the above one it didn't work. 

I would assume that since a notification payload message needs to be sent via APNS there is no way for them to know whether the message was delivered or not since APNS does not return any result. 

For a no notification message since it's received only when the app is in the foreground they would be able to verify if the message was delivered or not.
",31212974
392,31306163,"Thanks for trying out GCM on iOS.
Unfortunately, delivery receipts are not available for display notifications on iOS at the moment.
",31212974
393,29779605,"I think it's fair assumption you'd like to use some common methods across your projects. The same way you separate the server, you should then separate the package with the common methods. Although it's probably better to think and organise it in some logical way, rather than calling the package tools, misc etc.

I tend to split things into packages, so they can be used in other places, while the main package would be simply flag parsing and calling the library methods, for example server.Run(). Other people like to put everything into the main project, which might be all right if you think people would use your project as a command line tool, rather than a package.

I would consider:

deamon/
    main.go
    server/server.go
    somelib/somelib.go -- to be included from main and server


If you would like your project to be used mainly as a package, but still include some command line utility, you might consider:

deamon/
   deamon.go -- package deamon
   deamond/
       main.go -- you may include the top level package as anyone else


We need to remember that in Go you include your packages with an absolute path, so you can keep your ""common"" stuff anywhere in the project, or if you decide is useful by itself, just release a separate, standalone project.
",29778778
394,37353033,"Type assertions require the type you want to assert to be of the exact same type of the assertion part.

From your code, flash is a type interface{}, and the underlying type is *gin.H (printed by fmt.Printf(""%T"", flash)). Therefore the assertion should be flash.(*gin.H)

Here are a few examples about of to use type assertions:

package main

import r ""reflect""

type A struct {
    Name string
}

func main() {
    // No pointer
    aa := A{""name""}
    var ii interface{} = aa

    bb := ii.(A)
    // main.A

    // Pointer
    a := &A{""name""}
    var i interface{} = a

    b := *i.(*A)
    // main.A

    c := i.(*A)
    // *main.A

    d := r.Indirect(r.ValueOf(i)).Interface().(A)
    // main.A
}

}

",37352080
395,37353431,"You're putting the * at the wrong place. It should be flash.(*gin.H). 
",37352080
396,25099952,"Here defer close(c) will cause a panic 

func (s *Trick) Save(c chan<- datastore.Property) error {
    defer close(c)
    return datastore.SaveStruct(s, c)
}


The following is ok

func (s *Trick) Save(c chan<- datastore.Property) error {
    return datastore.SaveStruct(s, c)
}


This is also ok

func (s *Trick) Save(c chan<- datastore.Property) error {
    defer close(c)
    c <- datastore.Property{
        Name:  ""Difficulty"",
        Value: int64(s.Difficulty),
    }
    return nil
}


(please edit the documentation to make this more clear https://developers.google.com/appengine/docs/go/datastore/reference#hdr-The_PropertyLoadSaver_Interface)
",25099525
397,1718262,"Goroutines are not the same as a goto - they run in parallel with the main code.  When you state something like (from their example at http://golang.org/doc/effective_go.html)

go list.Sort();  // run list.Sort in parallel; don't wait for it. 


the mainline code continues on - it doesn't wait for the sort to finish.  The sort routine starts up on its own lightweight thread of execution and when it finishes the sort that thread exits.

A goto would cause the mainline code to branch to a separate execution path - so the statements after the goto would never get run.
",1718173
398,1718297,"The key difference is that goto statements in languages that support them allow jumping to any location in the program with little or no restriction. While coroutines may on the surface seem similar they are very different. 

Coroutines allow procedures to be suspended (with all their context) and resumed at certain locations. So while coroutines do pause and yield control to other procedures before they complete and then resume later, the points at which the procedures yield and resume from is known ahead of time.

It is not possible to simply jump to an arbitrary line in a procedure, the procedure in question has to waiting to be resumed at a specific location. While this passing of control is much more structured than with goto it is possible to write confusing code by overusing this powerful mechanism. Then again that is that not the case with every powerful programming language feature? ;-)
",1718173
399,39803151,"A channel provides a concurrent synchronization mechanism you can use to coordinate with. You could use one in coordination with a time.Ticker to periodically dispatch a given number of function calls.

// A PeriodicResource is a channel that is rebuffered periodically.
type PeriodicResource <-chan bool

// The NewPeriodicResourcePool provides a buffered channel that is filled after the
// given duration. The size of the channel is given as count. This provides
// a way of limiting an function to count times per duration.
func NewPeriodicResource(count int, reset time.Duration) PeriodicResource {
    ticker := time.NewTicker(reset)
    c := make(chan bool, count)

    go func() {
        for {
            // Await the periodic timer
            <-ticker.C

            // Fill the buffer
            for i := len(c); i < count; i++ {
                c <- true
            }
        }
    }()

    return c
}


A single go routine waits for each ticker event and attempts to fill a buffered channel to max capacity. If a consumer does not deplete the buffer any successive tick only refills it. You can use the channel to synchronously perform an action at most n times per duration. For example, I may want to call doSomething() no more than five times per second.

r := NewPeriodicResource(5, time.Second)
for {
        // Attempt to deque from the PeriodicResource
        <-r

        // Each call is synchronously drawing from the periodic resource
        doSomething()
}


Naturally, the same channel could be used to call go doSomething() which would fan out at most five processes per second.
",39799684
400,28976385,"The two examples you are using are based on incompatible proto definitions. The problem is that the java example is using the package name grpc.example.helloworld and the go example is using just the helloworld.

And because the package name is part of the URL path (/helloworld.Greeter/SayHello) the call fails (the java server is expecting /grpc.example.helloworld.Greeter/SayHello).

You can see it in the generated code.

Java:

private GreeterServiceDescriptor() {
  sayHello = createMethodDescriptor(
      ""grpc.example.helloworld.Greeter"", METHOD_SAY_HELLO);
}


Go:

var _Greeter_serviceDesc = grpc.ServiceDesc{
        ServiceName: ""helloworld.Greeter"",
        HandlerType: (*GreeterServer)(nil),
        Methods: []grpc.MethodDesc{
            {
                MethodName: ""SayHello"",
                Handler: _Greeter_SayHello_Handler,
            },
        },
        Streams: []grpc.StreamDesc{},
}

",28975841
401,43947140,"The context package exposes this value as a variable.

You can compare err == context.DeadlineExceeded.

However, as argued by Dave Cheney, you should probably use an interface instead.

Specifically net.Error or interface { Timeout() bool } will work as a type.
",43947072
402,17882766,"I would not store logs in a directory to see how the users behave.

Depending on what behaviour you want to keep track of you could use different tools. One of these could be mixpanel or keen.io.

Instead of logging what the user did in a log file you would sent an event to either of those (they are pretty similar, pick the one you think has better docs / lib), then you would graph those events to better understand the behaviour of your users. I've done this a lot recently, to display data in a nice way I've used rickshaw.

The key point why I'm suggesting this is that if you go the file route you will still have to find a way to understand your data, something that graphs will help you a lot at. Also, visualization is something keen.io does by default, you may still want to do your graphs but it's a good start.

Hope this helped.
",17882533
403,17882814,"
  Is this structure correct?


Only you can know that, it depends directly on how the data needs be accessed and used.


  What tool is best suited for this?


You could probably use UNIX tools to achieve this but it may as well be a good exercise to practice your Go skills by writing this. It would also be more extensible.
",17882533
404,29975311,"In the Configuration section of the doc it's stated:


  Optional application-level configuration files (dispatch.yaml,
  cron.yaml, index.yaml, and queue.yaml) are included in the top level
  app directory.


I agree, the paragraph context appears to leave room for interpretation (typically...). But the quoted text also indicates that these files are considered app-level configs. So I'd keep them at the top.

About the update: I noticed, for example, that the index.yaml file was NOT uploaded with the rest of the multi-module app at my first deployment, I had to explicitly use appcfg.py update_indexes. This was not happening with a single module app. Maybe appcfg.py update_cron also needs to be explicit?
",29963881
405,37406355,"The default json encoder/decoder performs a lot of reflection. Check out https://github.com/pquerna/ffjson for a drop in replacement that generates code for greatly improved performance.
",37405162
406,41286475,"As you report, your benchmark has a lot of inter-run variability. This makes it difficult to reason about the problem. What we really want is a benchmark that always gives the same results, no matter what time of the day we run it. 

I revised your benchmark slightly so that it easier to reproduce reliably the results:
1. I serialize the data to memory (as a byte slice[]byte),
2. I avoid overflowing the processor's cache with data (i.e., use little data).

There is a standard way to write benchmarks in Go, to get more reproducible results (https://dave.cheney.net/2013/06/30/how-to-write-benchmarks-in-go) but in this instance, I have not found it necessary.

See my code at https://github.com/lemire/Code-used-on-Daniel-Lemire-s-blog/tree/master/extra/golang/serialization

On my test server (a Skylake processor configured for testing, running at a flat 3.4 GHz, with go 1.7), I get...


2016/12/22 09:55:54 Serialization by JSON elapsed: 599 us
2016/12/22 09:55:54 serialized size in bytes:  18781
2016/12/22 09:55:54 Serialization by GOB elapsed: 230 us
2016/12/22 09:55:54 serialized size in bytes:  9066
2016/12/22 09:55:54 Serialization by XML elapsed: 2404 us
2016/12/22 09:55:54 serialized size in bytes:  25780


As you can see with my results, JSON is just slighly larger (30%) than XML, and GOB is much smaller. This is in agreement with your results. Still in agreement with your results, GOB is much faster than XML and JSON.

However, JSON serialization is much faster than XML serialization (by a factor of 4). GOB is twice as fast as JSON. 

You will get different results on your own hardware, but I suspect you will get fairly consistent numbers (little inter-run variability), especially if you disable CPU features such as TurboBoost.

What would happen if we were to actually serialize to disk or use large blobs of data? It would not change the performance ordering since GOB is faster and smaller, JSON is in the middle with respect to both data size and processing size, and XML is more bloated and slower to process. 

So I think we can safely conclude that we have the following...


GOB is smaller and faster.
JSON is small and fast.
XML is large and slow.

",37405162
407,42027481,"I right click on project (main.go inside) and choose ""Debug ..."" and it work

enter image description here
",41592892
408,42085948,"you can change go file name to ""main.go"" where it has main function.
It might be a bug.
",41592892
409,42732874,"Gogland will not enable the debug action (although run is available) if your code does not reside inside src. There is no warning about this, so it might be really a pain to solve this.

Additionally, depending on your project’s structure it might be possible, that debugging is still not working. In that case, it might help to remove all run configurations and create a new one. There’s is a bug report about this behavior.

PS: Although the OP mentions the first part in an edit of the question, but it think it’s worth mentioning in an answer.
",41592892
410,43167783,"I had this exact problem. 

Deleted and recreated the Debug run configuration. Debugging then worked perfectly.
",41592892
411,45577231,"I was facing this same issue and I solved by using the ""Go Application"" configuration (at the Run/Debug Configurations window), instead of the ""Go Single File"" configuration.

So, go to the upper right corner of the Gogland and ""Edit configurations"". 



Then, add a new configuration using the ""Go Application"" profile.



After saving, you should be able to debug your code. o/

An easy way to enable this configuration is to use the @user1793301 method and right click on the file you want to run and select ""Debug 'go run .go'"".



POSSIBLE EXPLANATION

NOTICE: I did not look any further details about it.

Fact: ""Go Application"" configuration does build the binary executable before running it.

Fact: I could see looking at the console output (inside of the Goglang) is that the IDE uses the DLV as debugging tool.

Fact: I found a dlv debug at the DLV documentation and it seems to compile and debug the code.

Hypothesis: The guys from Jetbrains did not implement it. Or at least not YET.
",41592892
412,33835327,"By now we have to manually add permissions to AndroidManifest.xml, gomobile package is not doing that (feature request is filed). Before they implement this feature we have to do it manually.

For more information please refer to this question:

Golang: Gomobile app cannot generate files
",33818187
413,38058704,"You're not giving c.Decrease() a chance to run.  c.Block() runs an infinite for loop, but it never blocks in that for loop, just calling continue over and over on every iteration.  The main thread spins at 100% usage endlessly.

However, when you add an fmt.Print() call, that makes a syscall, which allows the other goroutine to run.

This post has details on how exactly goroutines yield or are pre-empted.  Note, however, that it's slightly out of date, as entering a function now has a random chance to yield that thread to another goroutine, to prevent similar style flooding of threads.
",38058320
414,38060504,"As others have pointed out, Block() will never yield; a goroutine is not a thread. You could use Gosched() in the runtime package to force a yield -- but note that spinning this way in Block() is a pretty terrible idea.

There are much better ways to do concurrency limiting. See http://jmoiron.net/blog/limiting-concurrency-in-go/ for one example
",38058320
415,38062184,"What you are looking for is called a semaphore. You can apply this pattern using channels

http://www.golangpatterns.info/concurrency/semaphores

The idea is that you create a buffered channel of a desired length. Then you make callers acquire the resource by putting a value into the channel and reading it back out when they want to free the resource. Doing so creates proper synchronization points in your program so that the Go scheduler runs correctly. 

What you are doing now is spinning the cpu and blocking the Go scheduler. It depends on how many cpus you have available, the version of Go, and the value of GOMAXPROCS. Given the right combination, there may not be another available thread to service other goroutines while you infinitely spin that particular thread. 
",38058320
416,38071284,"While other answers pretty much covered the reason (not giving a chance for the goroutine to run) - and I'm not sure what you intend to achieve here - you are mutating a value concurrently without proper synchronization. A rewrite of above code with synchronization considered; would be:

type ConcurrencyLimit struct {
    active int
    Limit  int
    cond   *sync.Cond
}

func (c *ConcurrencyLimit) Block() {
    c.cond.L.Lock()
    for c.active == c.Limit {
        c.cond.Wait()
    }
    c.active++
    c.cond.L.Unlock()

    c.cond.Signal()
}

func (c *ConcurrencyLimit) Decrease() int {
    defer c.cond.Signal()

    c.cond.L.Lock()
    defer c.cond.L.Unlock()

    fmt.Println(""decrease"")
    if c.active > 0 {
        c.active--
    }
    return c.active
}

func main() {
    c := ConcurrencyLimit{
        Limit: 1,
        cond:  &sync.Cond{L: &sync.Mutex{}},
    }

    c.Block()
    go func() {
        c.Decrease()
    }()
    c.Block()
    fmt.Println(c.active, c.Limit)
}


sync.Cond is a synchronization utility designed for times that you want to check if a condition is met, concurrently; while other workers are mutating the data of the condition.

The Lock and Unlock functions work as we expect from a lock. When we are done with checking or mutating, we can call Signal to awake one goroutine (or call Broadcast to awake more than one), so the goroutine knows that is free to act upon the data (or check a condition).

The only part that may seem unusual is the Wait function. It is actually very simple. It is like calling Unlock and instantly call Lock again - with the exception that Wait would not try to lock again, unless triggered by Signal (or Broadcast) in other goroutines; like the workers that are mutating the data (of the condition).
",38058320
417,38898596,"Use this:

""$center"": []interface{}{j.Location.Coordinates, 5000}


This line is probably an error:

 time.Now().Unix() * 1000


Did you want + 1000?
",38892436
418,32021907,"It looks like your database driver returns times in a format that's not in RFC3339. Instead of using 

timeStamp, err := time.Parse(time.RFC3339, sTimeStamp)


try using

timeStamp, err := time.Parse(""2006-01-02 15:04:05"", sTimeStamp)


An important thing to remember is that the database itself is not going to store raw strings at all, RFC3339 or otherwise. It has its own internal representation of time, and when you query for it, the value you get depends on how that db wishes to reperesent it to you. In this case, it's chosen a somewhat different format, which the format string I've pasted above (the one that starts with ""2006-01-02..."") should fix. And yes, in Go, date format strings look like dates themselves.
",32021400
419,44065908,"Found it, I didn't register all the handlers as done in init here
https://golang.org/src/net/http/pprof/pprof.go
",44065511
420,30325711,"You can make a simple middleware for that:

type CORSMiddleware struct {
    http.Handler
}

func (cm CORSMiddleware) ServeHTTP(w http.ResponseWriter, r *http.Request) {
    w.Header().Set(""Access-Control-Allow-Origin"", ""*"")
    cm.Handler.ServeHTTP(w, r)
}


Then, you can use it like that:

var h http.Handler = CORSMiddleware{cont}
r.Handle(""/accounts"", h)
r.Handle(""/accounts/{id}"", h)

",30325483
421,30062694,"There are a few options for how you can do this but I would say your basic problem is that your receiver doesn't do aggregation and if you changed it so it did it would not be thread safe.

The simple choice to modify your receiver to do aggregation would be to allocate an Image array before the loop and pass a pointer to it into the receiver method which would then just use append when it reads of the channel. But then you would have a bunch of different goroutines fighting for access to the same array. So really, you don't want the aggregation to be multithreaded. If it is you need a locking mechanism in order to write to the collection.

Instead you want to block after the loop. The simplest way to do that would just be to put the body of your receiver right there inline after the loop like;

imgs := []image.Image{}
img := <-imgChan
imgs = append(imgs, img)
spew.Dump(img.Bounds())


The problem is in the real world then your software would block on that line and be unresponsive (have no way of dying or exiting or anything) so instead you'd typically use a channel select where you have at least 2 channels/cases, an abort channel that the caller of Partition can use to kill it if it needs to exit and the case that receives from imgChan. That would look a little more like this;

imgs := []image.Image{}

select {
    case img := <-imgChan
         imgs = append(imgs, img)
         spew.Dump(img.Bounds())
    case _ := <-abortChan:
        return MyCustomError();
    }


Which make it so your aggregation is not concurrent, only the work to produce the results which I personally think is the better design. I could explain how to lock in your receiver method as well but I'm sure you can find plenty of examples of mutex's ect.
",30062128
422,32527460,"Thank you @JimB. Working solution:

package main

import (
    ""bytes""
    ""fmt""
    ""github.com/PuerkitoBio/goquery""
    ""io/ioutil""
    ""log""
    ""net""
    ""net/http""
    ""os""
    ""time""
)

func main() {
    ief, err := net.InterfaceByName(""eth0"")
    if err != nil {
        log.Fatal(err)
    }
    addrs, err := ief.Addrs()
    if err != nil {
        log.Fatal(err)
    }
    tcpAddr := &net.TCPAddr{
        IP: addrs[3].(*net.IPNet).IP, // Choosing ip address number 3
    }
    d := net.Dialer{LocalAddr: tcpAddr}
    conn, err2 := d.Dial(""tcp"", ""www.whatismyip.com:80"")
    if err2 != nil {
        log.Fatal(err2)
    }
    fmt.Println(`conn.LocalAddr()`)
    fmt.Println(conn.LocalAddr())
    fmt.Println(`conn.RemoteAddr()`)
    fmt.Println(conn.RemoteAddr())
    defer conn.Close()

    transport := &http.Transport{
        Proxy:               http.ProxyFromEnvironment,
        Dial:                (&net.Dialer{LocalAddr: tcpAddr}).Dial,
        TLSHandshakeTimeout: 10 * time.Second,
    }

    client := &http.Client{
        Transport: transport,
    }

    response, err := client.Get(""https://www.whatismyip.com/"")

    if err != nil {
        fmt.Printf(""%s"", err)
        os.Exit(1)
    } else {
        defer response.Body.Close()
        contents, err := ioutil.ReadAll(response.Body)
        if err != nil {
            fmt.Printf(""%s"", err)
            os.Exit(1)
        }
        var contentsStr = string(contents)
        fmt.Printf(""%s\n"", contentsStr)
        var doc = DocByHtmlString(contentsStr)

        doc.Find(""div"").Each(func(i int, s *goquery.Selection) {
            attr, exists := s.Attr(""class"")
            if exists {
                if attr == ""ip"" {
                    fmt.Println(s.Text())
                }
            }
        })
    }
}

func DocByHtmlString(html string) *goquery.Document {
    doc, err := goquery.NewDocumentFromReader(bytes.NewBufferString(html))
    if err != nil {
        panic(err)
    }
    return doc
}


Prints in the end Your IP Address Is: 111.222.333.213 as expected.
",32518539
423,16636116,"In your server, instead of 

fmt.Fprint(w, buffer.Bytes())


you need to use:

w.Write(buffer.Bytes())


The fmt package will format the Bytes() to some go-syntax-like slice with the bytes represented as decimals, like so:

[123 34 87 104 97 116 ... etc

",16634582
424,16636120,"You don't want to use fmt.Print to write stuff to the response.  Eg

package main

import (
    ""fmt""
    ""os""
)

func main() {
    bs := []byte(""Hello, playground"")
    fmt.Fprint(os.Stdout, bs)
}


(playground link)

Produces

[72 101 108 108 111 44 32 112 108 97 121 103 114 111 117 110 100]


Use the Write() method of the ResponseWriter instead

You could have found this out by telneting to your server as an experiment - always a good idea when you aren't sure what is going on!
",16634582
425,28164356,"
  I also downloaded it from git


The Go repo (github.com/golang/go) wouldn't include the go binary.
Only the msi or the archive at golang.org/dl/ would (like go1.4.1.windows-amd64.zip) would.

You can unzip the archive anywhere, and set GOROOT to it, and %GOROOT%\bin will point the the go binary.
",28162577
426,36365032,"Add under user variables:
GOPATH: C/:go

Add under systems variable:
C:/go
",28162577
427,23667037,"You could use something along the lines of this :

func main() {
    file := strings.NewReader(IPS) //os.Open(fileName)

    var nodes []*Node

    scanner := bufio.NewScanner(file)
    for scanner.Scan() {
        if err := scanner.Err(); err != nil {
            fmt.Fprintln(os.Stderr, ""error reading from file:"", err)
            os.Exit(3)
        }
        ip := net.ParseIP(scanner.Text())
        if ip != nil {
            nodes = append(nodes, &Node{ipaddr: net.ParseIP(scanner.Text())})
        }

    }
    for _, n := range nodes {
        fmt.Printf(""%s, %+v\n"", n.ipaddr, n)
    }
}

",23666085
428,23667119,"The only thing you're missing is the append function to add a new node to the slice.

nodes = append(nodes, &Node{ipaddr: scanner.Text()})


Also, you can have an index on your for loop while still having the scanner.Scan() as the condition.  This lets the EOF be handled elegantly while still allowing you to access that new Node if need be.

for i := 0; scanner.Scan(); i++ {
    if err := scanner.Err(); err != nil {
        fmt.Fprintln(os.Stderr, ""error reading from file:"", err)
        os.Exit(3)
    }

    nodes = append(nodes, &Node{ipaddr: scanner.Text()})
    fmt.Println(nodes[i])
}


Full code: http://play.golang.org/p/RvMQp-jgWF
",23666085
429,40307427,"As a unary operator it means 'bitwise not'
",40307373
430,40307602,"From the ""Arithmetic Operators"" section of the language specification:


  For integer operands, the unary operators +, -, and ^ are defined as
  follows:

+x                          is 0 + x
-x    negation              is 0 - x
^x    bitwise complement    is m ^ x  with m = ""all bits set to 1"" for unsigned x
                                      and  m = -1 for signed x


",40307373
431,35409260,"If you use a file, you could use a Mutex to block concurrent writes.

Otherwise a database would be fine. For example BoltDB could be suitable. It is pure go and runs withing your program.
",35409157
432,35413611,"There are many approaches. You can use file and protect it with Go mutex or system lock. You can memory map the file for performance. You either can use BoltDB which is nice peace of software and provide needed machinery and can work in-process. If you write rare and mostly read, then constant DB https://github.com/colinmarc/cdb also looks interesting.
But, classic SQL DB has some advantages


You can use third party store for data and easely migrate when needed
You can access your data from third party app or just plain SQL
request
You can think about data schema and code logic separately

",35409157
433,38004501,"Check the source code here:

// Acquire permission from NoopControl.
// Permission is granted immediately since it does not perform any rate limit.
func (c *NoopControl) Acquire() {
    log.Debugf(""NoopControl[%s]: Seeking permission."", c.Label)
    log.Debugf(""NoopControl[%s]: Granted permission."", c.Label)
}


There is NO return value of func (c *NoopControl) Acquire().
",38004099
434,21511199,"I've managed to solve this thanks to the help of 'cronos' on #go-nuts.

The solution allows me to use a custom handler type, chain middleware and avoid the repetition of having to wrap handlers (i.e. appHandler(myHandler)), middleware...):

type appHandler func(http.ResponseWriter, *http.Request) *appError

type appError struct {
    Code  int
    Error error
}

func (fn appHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
    if e := fn(w, r); e != nil {

        switch e.Code {

        case http.StatusNotFound:
            notFound(w, r)
        case http.StatusInternalServerError:
            serverError(w, r, e.Error, e.Code)
        default:
            serverError(w, r, e.Error, e.Code)
        }
    }
}

func use(h appHandler, middleware ...func(http.Handler) http.Handler) http.Handler {
    var res http.Handler = h
    for _, m := range middleware {
        res = m(res)
    }

    return res
}

func someMiddleware(h http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {

        w.Header().Set(""Cache-Control"", ""max-age=0, private, must-revalidate"")
        w.Header().Set(""X-Accel-Expires"", ""0"")
        h.ServeHTTP(w, r)
    })
}

func myHandler(w http.ResponseWriter, r *http.Request) *appError {

    err := doSomething()
    if err != nil {
        return &appError{500, err}
    }

    // render your template, etc.
    return nil
}


With routes looking like this: r.Handle(""/route"", use(myHandler, someMiddleware))

You can obviously modify appHandler to return whatever you like, add additional fields to appError and so on. Your middleware is also able to wrap your router if you want to apply it to all routes - i.e. http.Handle(""/"", someMiddleware(r)) 
",21496093
435,29959644,"Yes. sort.Search() is what you want. It takes a length and a comparison function, and returns the first index for which the function returns true. The example in the linked docs includes:

i := sort.Search(len(data), func(i int) bool { return data[i] >= x })


That sets i to the index of the first value >= x (or to len(data) if no items are >= x), so it's like bisect.bisect_left() in Python. Change it to > to get something like bisect_right. 

The Python functions will also search through a range within a list; to do something similar, you could search a subslice of your slice, and add its starting offset to the index Search returns if you need an index into the original slice. There are other ways, but that seems simple and readable.

Though this is also true of Python lists, insertion into a sorted slice is O(n), i.e., it averages twice as slow on twice as much data. That's still fine for many purposes (many times you have a small list or few inserts), but of course you can't scale indefinitely that way. If you're inserting a ton of items, like a significant fraction of the list size, you could append them all, then sort. For general sorted collections with logarithmic-time inserts, deletes, etc., there's always, for example, github.com/cznic/b, or any number of database-y things.
",29959506
436,9466278,"In this particular case, you could use idiomatic Go. Change AStructList *[]Astruct to AStructList []*Astruct. For example,

package main

import ""fmt""

type Astruct struct {
    Number int
    Letter string
}

type Bstruct struct {
    foo         int
    AStructList []*Astruct
}

type Cstruct struct {
    Bstruct
}

func (a *Astruct) String() string {
    return fmt.Sprintf(""Number = %d, Letter = %s"", a.Number, a.Letter)
}

func main() {
    astructlist := make([]*Astruct, 3)            // line 1
    for i := range astructlist {                  // line 2
        astructlist[i] = &Astruct{i, ""a""}         // line 3 
    }                                             // line 4
    c := new(Cstruct)
    c.Bstruct = Bstruct{100, astructlist}         // line 6

    for _, x := range c.Bstruct.AStructList {
        fmt.Printf(""%s\n"", x)
    }
}


In general, it's your responsibility to either assign a non-nil value to a pointer or test for nil before its use. When you allocate memory without explicitly intializing it, it's set to the zero value for the type, which is nil for pointers.


  The zero value
  
  When memory is allocated to store a value, either through a
  declaration or a call of make or new, and no explicit initialization
  is provided, the memory is given a default initialization. Each
  element of such a value is set to the zero value for its type: false
  for booleans, 0 for integers, 0.0 for floats, """" for strings, and nil
  for pointers, functions, interfaces, slices, channels, and maps. This
  initialization is done recursively, so for instance each element of an
  array of structs will have its fields zeroed if no value is specified.

",9464516
437,26374000,"Simply append your marshalled bytes to the header. As seen in the XML Package Source, a generic header is included:

const (
    // A generic XML header suitable for use with the output of Marshal.
    // This is not automatically added to any output of this package,
    // it is provided as a convenience.
    Header = `` + ""\n""
)


So, this would do it:

myString, err := xml.MarshalIndent(...) // abbreviated here
myString = []byte(xml.Header + string(myString))


A working example I'd found (not my code) available at: http://play.golang.org/p/Rbfb717tvh
",26371965
438,27628616,"If you embed a field in a struct, all the methods of that field can be called on the struct, too. So if you write

type EZReader struct {
    *bytes.Reader
}


you don't have to reimplement Read(). Such a field behaves as if it was named Reader. Notice that you can't avoid exposing the field this way.
",27628548
439,13818754,"Installing GoSublime should get this working for you. After installing and restarting ST2: do ctrl-B, type ""run"" and hit enter.
",13817467
440,13841851,"what about:  

{
    ""cmd"": [""go"", ""run"", ""${file}""],
    ""path"": ""/user/local/go/bin""
}  


I like GoSublime, just hate to type run each time when click Command + B
",13817467
441,17541323,"On my mac, I needed the following code in:

/Users/your_user_name/Library/Application Support/Sublime Text 2/Packages/User/go.sublime-build


go.sublime-build

{
    ""cmd"": [""go run '${file}'""],
    ""selector"": ""source.go"",
    ""path"": ""/usr/local/go/bin"",
    ""shell"": true
}  



""cmd"" line quoting is to correctly handle file paths with spaces.
""shell"" line is needed since commenting it out breaks it.
""path"" line is needed because the basic shell, doesn't have access to my .zshrc file include the export GOPATH statement defining the go path.


After that any .go file should build and run with command+B, leaving the stdout message in a console built into sublime text 2.
",13817467
442,19340946,"I got by with

{
    ""cmd"": ""go run $file"",
    ""shell"" : true
}

",13817467
443,25593051,"In ST3: it is changed to be:

{
    ""shell_cmd"": ""go run ${file}""
}

",13817467
444,28270151,"SublimeText 2
build-system for golang, making F4/shift-F4 work (next error/prev error)

1st, create a file: ~/gosublime_build.sh

GOPATH=~/go
export GOPATH 
echo ""GOPATH:$GOPATH""

if [ ""$3."" = ""RUN."" ]
  then 
     EXENAME=${1##*/}
     EXENAME=$GOPATH/bin/$EXENAME
     echo $EXENAME
     $($EXENAME)
     echo ""code: $?""
     exit
fi

echo ""go build $2""
cd /usr/local/go/bin
./go build -o ~/temp.go.compiled $2
if [ $? -eq 0 ]
 then
   cd $1
   echo ""Project: "" $1
   /usr/local/go/bin/go install
   echo ""go install exit code: $?""
 else
   echo ""go build exit code: $?""
fi


2nd: 

chmod 777 ~/gosublime_build.sh


3rd: create a new sublime2 build-system for ""go"" (Tools/Build System/New)

{
""cmd"": [""~/gosublime_build.sh $file_path $file""]
,""shell"": true
,""selector"": ""source.go""
,""file_regex"": ""([\\w/_-]+[.]{1}[\\w./_-]+?):([0-9]+):?([0-9]+)?(.*)?""
}  


4th: select your new build-system (Tools/Build System)

5th: build with Ctrl-B, F4/Shift-F4: next/prev error

If anybody knows how to instruct the go compiler to inform FULL PATH of file and line for each error, this process can be simplified
",13817467
